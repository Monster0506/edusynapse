
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>
/**
 * Model Activity
 * 
 */
export type Activity = $Result.DefaultSelection<Prisma.$ActivityPayload>
/**
 * Model LearningPreferences
 * 
 */
export type LearningPreferences = $Result.DefaultSelection<Prisma.$LearningPreferencesPayload>
/**
 * Model Topic
 * 
 */
export type Topic = $Result.DefaultSelection<Prisma.$TopicPayload>
/**
 * Model Progress
 * 
 */
export type Progress = $Result.DefaultSelection<Prisma.$ProgressPayload>
/**
 * Model Badge
 * 
 */
export type Badge = $Result.DefaultSelection<Prisma.$BadgePayload>
/**
 * Model UpcomingReview
 * 
 */
export type UpcomingReview = $Result.DefaultSelection<Prisma.$UpcomingReviewPayload>
/**
 * Model LearningPath
 * 
 */
export type LearningPath = $Result.DefaultSelection<Prisma.$LearningPathPayload>
/**
 * Model LearningPathItem
 * 
 */
export type LearningPathItem = $Result.DefaultSelection<Prisma.$LearningPathItemPayload>
/**
 * Model ContentItem
 * 
 */
export type ContentItem = $Result.DefaultSelection<Prisma.$ContentItemPayload>
/**
 * Model ContentRating
 * 
 */
export type ContentRating = $Result.DefaultSelection<Prisma.$ContentRatingPayload>
/**
 * Model Bookmark
 * 
 */
export type Bookmark = $Result.DefaultSelection<Prisma.$BookmarkPayload>
/**
 * Model QuizAttempt
 * 
 */
export type QuizAttempt = $Result.DefaultSelection<Prisma.$QuizAttemptPayload>
/**
 * Model KnowledgeNode
 * 
 */
export type KnowledgeNode = $Result.DefaultSelection<Prisma.$KnowledgeNodePayload>
/**
 * Model LeaderboardEntry
 * 
 */
export type LeaderboardEntry = $Result.DefaultSelection<Prisma.$LeaderboardEntryPayload>
/**
 * Model ReviewSession
 * 
 */
export type ReviewSession = $Result.DefaultSelection<Prisma.$ReviewSessionPayload>
/**
 * Model ReviewItem
 * 
 */
export type ReviewItem = $Result.DefaultSelection<Prisma.$ReviewItemPayload>
/**
 * Model Workspace
 * 
 */
export type Workspace = $Result.DefaultSelection<Prisma.$WorkspacePayload>
/**
 * Model WorkspaceMember
 * 
 */
export type WorkspaceMember = $Result.DefaultSelection<Prisma.$WorkspaceMemberPayload>
/**
 * Model Whiteboard
 * 
 */
export type Whiteboard = $Result.DefaultSelection<Prisma.$WhiteboardPayload>
/**
 * Model WhiteboardVersion
 * 
 */
export type WhiteboardVersion = $Result.DefaultSelection<Prisma.$WhiteboardVersionPayload>
/**
 * Model BreakoutRoom
 * 
 */
export type BreakoutRoom = $Result.DefaultSelection<Prisma.$BreakoutRoomPayload>
/**
 * Model LivePoll
 * 
 */
export type LivePoll = $Result.DefaultSelection<Prisma.$LivePollPayload>
/**
 * Model PollVote
 * 
 */
export type PollVote = $Result.DefaultSelection<Prisma.$PollVotePayload>
/**
 * Model SessionSummary
 * 
 */
export type SessionSummary = $Result.DefaultSelection<Prisma.$SessionSummaryPayload>
/**
 * Model Chat
 * 
 */
export type Chat = $Result.DefaultSelection<Prisma.$ChatPayload>
/**
 * Model ChatMessage
 * 
 */
export type ChatMessage = $Result.DefaultSelection<Prisma.$ChatMessagePayload>
/**
 * Model UserSettings
 * 
 */
export type UserSettings = $Result.DefaultSelection<Prisma.$UserSettingsPayload>
/**
 * Model AnalyticsEntry
 * 
 */
export type AnalyticsEntry = $Result.DefaultSelection<Prisma.$AnalyticsEntryPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model PasswordlessToken
 * 
 */
export type PasswordlessToken = $Result.DefaultSelection<Prisma.$PasswordlessTokenPayload>
/**
 * Model DailyChallenge
 * 
 */
export type DailyChallenge = $Result.DefaultSelection<Prisma.$DailyChallengePayload>
/**
 * Model ExternalGoal
 * 
 */
export type ExternalGoal = $Result.DefaultSelection<Prisma.$ExternalGoalPayload>
/**
 * Model Prerequisite
 * 
 */
export type Prerequisite = $Result.DefaultSelection<Prisma.$PrerequisitePayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model AIPlaylist
 * 
 */
export type AIPlaylist = $Result.DefaultSelection<Prisma.$AIPlaylistPayload>
/**
 * Model AIPlaylistItem
 * 
 */
export type AIPlaylistItem = $Result.DefaultSelection<Prisma.$AIPlaylistItemPayload>
/**
 * Model ChallengeScore
 * 
 */
export type ChallengeScore = $Result.DefaultSelection<Prisma.$ChallengeScorePayload>
/**
 * Model AIRecommendation
 * 
 */
export type AIRecommendation = $Result.DefaultSelection<Prisma.$AIRecommendationPayload>
/**
 * Model AIModule
 * 
 */
export type AIModule = $Result.DefaultSelection<Prisma.$AIModulePayload>
/**
 * Model AIModuleLearningPathItem
 * 
 */
export type AIModuleLearningPathItem = $Result.DefaultSelection<Prisma.$AIModuleLearningPathItemPayload>
/**
 * Model AIModuleQuizAttempt
 * 
 */
export type AIModuleQuizAttempt = $Result.DefaultSelection<Prisma.$AIModuleQuizAttemptPayload>
/**
 * Model AIModuleRating
 * 
 */
export type AIModuleRating = $Result.DefaultSelection<Prisma.$AIModuleRatingPayload>
/**
 * Model UserProgress
 * 
 */
export type UserProgress = $Result.DefaultSelection<Prisma.$UserProgressPayload>
/**
 * Model AIChat
 * 
 */
export type AIChat = $Result.DefaultSelection<Prisma.$AIChatPayload>
/**
 * Model AIChatMessage
 * 
 */
export type AIChatMessage = $Result.DefaultSelection<Prisma.$AIChatMessagePayload>
/**
 * Model PracticeAttempt
 * 
 */
export type PracticeAttempt = $Result.DefaultSelection<Prisma.$PracticeAttemptPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs, $Utils.Call<Prisma.TypeMapCb, {
    extArgs: ExtArgs
  }>, ClientOptions>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.activity`: Exposes CRUD operations for the **Activity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Activities
    * const activities = await prisma.activity.findMany()
    * ```
    */
  get activity(): Prisma.ActivityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.learningPreferences`: Exposes CRUD operations for the **LearningPreferences** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LearningPreferences
    * const learningPreferences = await prisma.learningPreferences.findMany()
    * ```
    */
  get learningPreferences(): Prisma.LearningPreferencesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.topic`: Exposes CRUD operations for the **Topic** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Topics
    * const topics = await prisma.topic.findMany()
    * ```
    */
  get topic(): Prisma.TopicDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.progress`: Exposes CRUD operations for the **Progress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Progresses
    * const progresses = await prisma.progress.findMany()
    * ```
    */
  get progress(): Prisma.ProgressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.badge`: Exposes CRUD operations for the **Badge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Badges
    * const badges = await prisma.badge.findMany()
    * ```
    */
  get badge(): Prisma.BadgeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.upcomingReview`: Exposes CRUD operations for the **UpcomingReview** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UpcomingReviews
    * const upcomingReviews = await prisma.upcomingReview.findMany()
    * ```
    */
  get upcomingReview(): Prisma.UpcomingReviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.learningPath`: Exposes CRUD operations for the **LearningPath** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LearningPaths
    * const learningPaths = await prisma.learningPath.findMany()
    * ```
    */
  get learningPath(): Prisma.LearningPathDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.learningPathItem`: Exposes CRUD operations for the **LearningPathItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LearningPathItems
    * const learningPathItems = await prisma.learningPathItem.findMany()
    * ```
    */
  get learningPathItem(): Prisma.LearningPathItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contentItem`: Exposes CRUD operations for the **ContentItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContentItems
    * const contentItems = await prisma.contentItem.findMany()
    * ```
    */
  get contentItem(): Prisma.ContentItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contentRating`: Exposes CRUD operations for the **ContentRating** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContentRatings
    * const contentRatings = await prisma.contentRating.findMany()
    * ```
    */
  get contentRating(): Prisma.ContentRatingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bookmark`: Exposes CRUD operations for the **Bookmark** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bookmarks
    * const bookmarks = await prisma.bookmark.findMany()
    * ```
    */
  get bookmark(): Prisma.BookmarkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quizAttempt`: Exposes CRUD operations for the **QuizAttempt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizAttempts
    * const quizAttempts = await prisma.quizAttempt.findMany()
    * ```
    */
  get quizAttempt(): Prisma.QuizAttemptDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.knowledgeNode`: Exposes CRUD operations for the **KnowledgeNode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KnowledgeNodes
    * const knowledgeNodes = await prisma.knowledgeNode.findMany()
    * ```
    */
  get knowledgeNode(): Prisma.KnowledgeNodeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.leaderboardEntry`: Exposes CRUD operations for the **LeaderboardEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LeaderboardEntries
    * const leaderboardEntries = await prisma.leaderboardEntry.findMany()
    * ```
    */
  get leaderboardEntry(): Prisma.LeaderboardEntryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reviewSession`: Exposes CRUD operations for the **ReviewSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReviewSessions
    * const reviewSessions = await prisma.reviewSession.findMany()
    * ```
    */
  get reviewSession(): Prisma.ReviewSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reviewItem`: Exposes CRUD operations for the **ReviewItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReviewItems
    * const reviewItems = await prisma.reviewItem.findMany()
    * ```
    */
  get reviewItem(): Prisma.ReviewItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workspace`: Exposes CRUD operations for the **Workspace** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Workspaces
    * const workspaces = await prisma.workspace.findMany()
    * ```
    */
  get workspace(): Prisma.WorkspaceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workspaceMember`: Exposes CRUD operations for the **WorkspaceMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkspaceMembers
    * const workspaceMembers = await prisma.workspaceMember.findMany()
    * ```
    */
  get workspaceMember(): Prisma.WorkspaceMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.whiteboard`: Exposes CRUD operations for the **Whiteboard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Whiteboards
    * const whiteboards = await prisma.whiteboard.findMany()
    * ```
    */
  get whiteboard(): Prisma.WhiteboardDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.whiteboardVersion`: Exposes CRUD operations for the **WhiteboardVersion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WhiteboardVersions
    * const whiteboardVersions = await prisma.whiteboardVersion.findMany()
    * ```
    */
  get whiteboardVersion(): Prisma.WhiteboardVersionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.breakoutRoom`: Exposes CRUD operations for the **BreakoutRoom** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BreakoutRooms
    * const breakoutRooms = await prisma.breakoutRoom.findMany()
    * ```
    */
  get breakoutRoom(): Prisma.BreakoutRoomDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.livePoll`: Exposes CRUD operations for the **LivePoll** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LivePolls
    * const livePolls = await prisma.livePoll.findMany()
    * ```
    */
  get livePoll(): Prisma.LivePollDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pollVote`: Exposes CRUD operations for the **PollVote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PollVotes
    * const pollVotes = await prisma.pollVote.findMany()
    * ```
    */
  get pollVote(): Prisma.PollVoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sessionSummary`: Exposes CRUD operations for the **SessionSummary** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SessionSummaries
    * const sessionSummaries = await prisma.sessionSummary.findMany()
    * ```
    */
  get sessionSummary(): Prisma.SessionSummaryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chat`: Exposes CRUD operations for the **Chat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chats
    * const chats = await prisma.chat.findMany()
    * ```
    */
  get chat(): Prisma.ChatDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chatMessage`: Exposes CRUD operations for the **ChatMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChatMessages
    * const chatMessages = await prisma.chatMessage.findMany()
    * ```
    */
  get chatMessage(): Prisma.ChatMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userSettings`: Exposes CRUD operations for the **UserSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSettings
    * const userSettings = await prisma.userSettings.findMany()
    * ```
    */
  get userSettings(): Prisma.UserSettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.analyticsEntry`: Exposes CRUD operations for the **AnalyticsEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AnalyticsEntries
    * const analyticsEntries = await prisma.analyticsEntry.findMany()
    * ```
    */
  get analyticsEntry(): Prisma.AnalyticsEntryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.passwordlessToken`: Exposes CRUD operations for the **PasswordlessToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordlessTokens
    * const passwordlessTokens = await prisma.passwordlessToken.findMany()
    * ```
    */
  get passwordlessToken(): Prisma.PasswordlessTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dailyChallenge`: Exposes CRUD operations for the **DailyChallenge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DailyChallenges
    * const dailyChallenges = await prisma.dailyChallenge.findMany()
    * ```
    */
  get dailyChallenge(): Prisma.DailyChallengeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.externalGoal`: Exposes CRUD operations for the **ExternalGoal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExternalGoals
    * const externalGoals = await prisma.externalGoal.findMany()
    * ```
    */
  get externalGoal(): Prisma.ExternalGoalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.prerequisite`: Exposes CRUD operations for the **Prerequisite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prerequisites
    * const prerequisites = await prisma.prerequisite.findMany()
    * ```
    */
  get prerequisite(): Prisma.PrerequisiteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aIPlaylist`: Exposes CRUD operations for the **AIPlaylist** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AIPlaylists
    * const aIPlaylists = await prisma.aIPlaylist.findMany()
    * ```
    */
  get aIPlaylist(): Prisma.AIPlaylistDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aIPlaylistItem`: Exposes CRUD operations for the **AIPlaylistItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AIPlaylistItems
    * const aIPlaylistItems = await prisma.aIPlaylistItem.findMany()
    * ```
    */
  get aIPlaylistItem(): Prisma.AIPlaylistItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.challengeScore`: Exposes CRUD operations for the **ChallengeScore** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChallengeScores
    * const challengeScores = await prisma.challengeScore.findMany()
    * ```
    */
  get challengeScore(): Prisma.ChallengeScoreDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aIRecommendation`: Exposes CRUD operations for the **AIRecommendation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AIRecommendations
    * const aIRecommendations = await prisma.aIRecommendation.findMany()
    * ```
    */
  get aIRecommendation(): Prisma.AIRecommendationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aIModule`: Exposes CRUD operations for the **AIModule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AIModules
    * const aIModules = await prisma.aIModule.findMany()
    * ```
    */
  get aIModule(): Prisma.AIModuleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aIModuleLearningPathItem`: Exposes CRUD operations for the **AIModuleLearningPathItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AIModuleLearningPathItems
    * const aIModuleLearningPathItems = await prisma.aIModuleLearningPathItem.findMany()
    * ```
    */
  get aIModuleLearningPathItem(): Prisma.AIModuleLearningPathItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aIModuleQuizAttempt`: Exposes CRUD operations for the **AIModuleQuizAttempt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AIModuleQuizAttempts
    * const aIModuleQuizAttempts = await prisma.aIModuleQuizAttempt.findMany()
    * ```
    */
  get aIModuleQuizAttempt(): Prisma.AIModuleQuizAttemptDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aIModuleRating`: Exposes CRUD operations for the **AIModuleRating** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AIModuleRatings
    * const aIModuleRatings = await prisma.aIModuleRating.findMany()
    * ```
    */
  get aIModuleRating(): Prisma.AIModuleRatingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userProgress`: Exposes CRUD operations for the **UserProgress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserProgresses
    * const userProgresses = await prisma.userProgress.findMany()
    * ```
    */
  get userProgress(): Prisma.UserProgressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aIChat`: Exposes CRUD operations for the **AIChat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AIChats
    * const aIChats = await prisma.aIChat.findMany()
    * ```
    */
  get aIChat(): Prisma.AIChatDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aIChatMessage`: Exposes CRUD operations for the **AIChatMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AIChatMessages
    * const aIChatMessages = await prisma.aIChatMessage.findMany()
    * ```
    */
  get aIChatMessage(): Prisma.AIChatMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.practiceAttempt`: Exposes CRUD operations for the **PracticeAttempt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PracticeAttempts
    * const practiceAttempts = await prisma.practiceAttempt.findMany()
    * ```
    */
  get practiceAttempt(): Prisma.PracticeAttemptDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.3.1
   * Query Engine version: acc0b9dd43eb689cbd20c9470515d719db10d0b0
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Account: 'Account',
    Session: 'Session',
    VerificationToken: 'VerificationToken',
    Activity: 'Activity',
    LearningPreferences: 'LearningPreferences',
    Topic: 'Topic',
    Progress: 'Progress',
    Badge: 'Badge',
    UpcomingReview: 'UpcomingReview',
    LearningPath: 'LearningPath',
    LearningPathItem: 'LearningPathItem',
    ContentItem: 'ContentItem',
    ContentRating: 'ContentRating',
    Bookmark: 'Bookmark',
    QuizAttempt: 'QuizAttempt',
    KnowledgeNode: 'KnowledgeNode',
    LeaderboardEntry: 'LeaderboardEntry',
    ReviewSession: 'ReviewSession',
    ReviewItem: 'ReviewItem',
    Workspace: 'Workspace',
    WorkspaceMember: 'WorkspaceMember',
    Whiteboard: 'Whiteboard',
    WhiteboardVersion: 'WhiteboardVersion',
    BreakoutRoom: 'BreakoutRoom',
    LivePoll: 'LivePoll',
    PollVote: 'PollVote',
    SessionSummary: 'SessionSummary',
    Chat: 'Chat',
    ChatMessage: 'ChatMessage',
    UserSettings: 'UserSettings',
    AnalyticsEntry: 'AnalyticsEntry',
    Notification: 'Notification',
    PasswordlessToken: 'PasswordlessToken',
    DailyChallenge: 'DailyChallenge',
    ExternalGoal: 'ExternalGoal',
    Prerequisite: 'Prerequisite',
    Comment: 'Comment',
    AIPlaylist: 'AIPlaylist',
    AIPlaylistItem: 'AIPlaylistItem',
    ChallengeScore: 'ChallengeScore',
    AIRecommendation: 'AIRecommendation',
    AIModule: 'AIModule',
    AIModuleLearningPathItem: 'AIModuleLearningPathItem',
    AIModuleQuizAttempt: 'AIModuleQuizAttempt',
    AIModuleRating: 'AIModuleRating',
    UserProgress: 'UserProgress',
    AIChat: 'AIChat',
    AIChatMessage: 'AIChatMessage',
    PracticeAttempt: 'PracticeAttempt'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "account" | "session" | "verificationToken" | "activity" | "learningPreferences" | "topic" | "progress" | "badge" | "upcomingReview" | "learningPath" | "learningPathItem" | "contentItem" | "contentRating" | "bookmark" | "quizAttempt" | "knowledgeNode" | "leaderboardEntry" | "reviewSession" | "reviewItem" | "workspace" | "workspaceMember" | "whiteboard" | "whiteboardVersion" | "breakoutRoom" | "livePoll" | "pollVote" | "sessionSummary" | "chat" | "chatMessage" | "userSettings" | "analyticsEntry" | "notification" | "passwordlessToken" | "dailyChallenge" | "externalGoal" | "prerequisite" | "comment" | "aIPlaylist" | "aIPlaylistItem" | "challengeScore" | "aIRecommendation" | "aIModule" | "aIModuleLearningPathItem" | "aIModuleQuizAttempt" | "aIModuleRating" | "userProgress" | "aIChat" | "aIChatMessage" | "practiceAttempt"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>
        fields: Prisma.VerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationToken>
          }
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number
          }
        }
      }
      Activity: {
        payload: Prisma.$ActivityPayload<ExtArgs>
        fields: Prisma.ActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          findFirst: {
            args: Prisma.ActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          findMany: {
            args: Prisma.ActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          create: {
            args: Prisma.ActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          createMany: {
            args: Prisma.ActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          delete: {
            args: Prisma.ActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          update: {
            args: Prisma.ActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          deleteMany: {
            args: Prisma.ActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActivityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          upsert: {
            args: Prisma.ActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          aggregate: {
            args: Prisma.ActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivity>
          }
          groupBy: {
            args: Prisma.ActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityCountAggregateOutputType> | number
          }
        }
      }
      LearningPreferences: {
        payload: Prisma.$LearningPreferencesPayload<ExtArgs>
        fields: Prisma.LearningPreferencesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LearningPreferencesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPreferencesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LearningPreferencesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPreferencesPayload>
          }
          findFirst: {
            args: Prisma.LearningPreferencesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPreferencesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LearningPreferencesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPreferencesPayload>
          }
          findMany: {
            args: Prisma.LearningPreferencesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPreferencesPayload>[]
          }
          create: {
            args: Prisma.LearningPreferencesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPreferencesPayload>
          }
          createMany: {
            args: Prisma.LearningPreferencesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LearningPreferencesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPreferencesPayload>[]
          }
          delete: {
            args: Prisma.LearningPreferencesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPreferencesPayload>
          }
          update: {
            args: Prisma.LearningPreferencesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPreferencesPayload>
          }
          deleteMany: {
            args: Prisma.LearningPreferencesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LearningPreferencesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LearningPreferencesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPreferencesPayload>[]
          }
          upsert: {
            args: Prisma.LearningPreferencesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPreferencesPayload>
          }
          aggregate: {
            args: Prisma.LearningPreferencesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLearningPreferences>
          }
          groupBy: {
            args: Prisma.LearningPreferencesGroupByArgs<ExtArgs>
            result: $Utils.Optional<LearningPreferencesGroupByOutputType>[]
          }
          count: {
            args: Prisma.LearningPreferencesCountArgs<ExtArgs>
            result: $Utils.Optional<LearningPreferencesCountAggregateOutputType> | number
          }
        }
      }
      Topic: {
        payload: Prisma.$TopicPayload<ExtArgs>
        fields: Prisma.TopicFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TopicFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TopicFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          findFirst: {
            args: Prisma.TopicFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TopicFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          findMany: {
            args: Prisma.TopicFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>[]
          }
          create: {
            args: Prisma.TopicCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          createMany: {
            args: Prisma.TopicCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TopicCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>[]
          }
          delete: {
            args: Prisma.TopicDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          update: {
            args: Prisma.TopicUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          deleteMany: {
            args: Prisma.TopicDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TopicUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TopicUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>[]
          }
          upsert: {
            args: Prisma.TopicUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          aggregate: {
            args: Prisma.TopicAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTopic>
          }
          groupBy: {
            args: Prisma.TopicGroupByArgs<ExtArgs>
            result: $Utils.Optional<TopicGroupByOutputType>[]
          }
          count: {
            args: Prisma.TopicCountArgs<ExtArgs>
            result: $Utils.Optional<TopicCountAggregateOutputType> | number
          }
        }
      }
      Progress: {
        payload: Prisma.$ProgressPayload<ExtArgs>
        fields: Prisma.ProgressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProgressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProgressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressPayload>
          }
          findFirst: {
            args: Prisma.ProgressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProgressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressPayload>
          }
          findMany: {
            args: Prisma.ProgressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressPayload>[]
          }
          create: {
            args: Prisma.ProgressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressPayload>
          }
          createMany: {
            args: Prisma.ProgressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProgressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressPayload>[]
          }
          delete: {
            args: Prisma.ProgressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressPayload>
          }
          update: {
            args: Prisma.ProgressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressPayload>
          }
          deleteMany: {
            args: Prisma.ProgressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProgressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProgressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressPayload>[]
          }
          upsert: {
            args: Prisma.ProgressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressPayload>
          }
          aggregate: {
            args: Prisma.ProgressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProgress>
          }
          groupBy: {
            args: Prisma.ProgressGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProgressGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProgressCountArgs<ExtArgs>
            result: $Utils.Optional<ProgressCountAggregateOutputType> | number
          }
        }
      }
      Badge: {
        payload: Prisma.$BadgePayload<ExtArgs>
        fields: Prisma.BadgeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BadgeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BadgeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          findFirst: {
            args: Prisma.BadgeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BadgeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          findMany: {
            args: Prisma.BadgeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>[]
          }
          create: {
            args: Prisma.BadgeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          createMany: {
            args: Prisma.BadgeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BadgeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>[]
          }
          delete: {
            args: Prisma.BadgeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          update: {
            args: Prisma.BadgeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          deleteMany: {
            args: Prisma.BadgeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BadgeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BadgeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>[]
          }
          upsert: {
            args: Prisma.BadgeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          aggregate: {
            args: Prisma.BadgeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBadge>
          }
          groupBy: {
            args: Prisma.BadgeGroupByArgs<ExtArgs>
            result: $Utils.Optional<BadgeGroupByOutputType>[]
          }
          count: {
            args: Prisma.BadgeCountArgs<ExtArgs>
            result: $Utils.Optional<BadgeCountAggregateOutputType> | number
          }
        }
      }
      UpcomingReview: {
        payload: Prisma.$UpcomingReviewPayload<ExtArgs>
        fields: Prisma.UpcomingReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UpcomingReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpcomingReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UpcomingReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpcomingReviewPayload>
          }
          findFirst: {
            args: Prisma.UpcomingReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpcomingReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UpcomingReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpcomingReviewPayload>
          }
          findMany: {
            args: Prisma.UpcomingReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpcomingReviewPayload>[]
          }
          create: {
            args: Prisma.UpcomingReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpcomingReviewPayload>
          }
          createMany: {
            args: Prisma.UpcomingReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UpcomingReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpcomingReviewPayload>[]
          }
          delete: {
            args: Prisma.UpcomingReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpcomingReviewPayload>
          }
          update: {
            args: Prisma.UpcomingReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpcomingReviewPayload>
          }
          deleteMany: {
            args: Prisma.UpcomingReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UpcomingReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UpcomingReviewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpcomingReviewPayload>[]
          }
          upsert: {
            args: Prisma.UpcomingReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpcomingReviewPayload>
          }
          aggregate: {
            args: Prisma.UpcomingReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUpcomingReview>
          }
          groupBy: {
            args: Prisma.UpcomingReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<UpcomingReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.UpcomingReviewCountArgs<ExtArgs>
            result: $Utils.Optional<UpcomingReviewCountAggregateOutputType> | number
          }
        }
      }
      LearningPath: {
        payload: Prisma.$LearningPathPayload<ExtArgs>
        fields: Prisma.LearningPathFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LearningPathFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LearningPathFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathPayload>
          }
          findFirst: {
            args: Prisma.LearningPathFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LearningPathFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathPayload>
          }
          findMany: {
            args: Prisma.LearningPathFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathPayload>[]
          }
          create: {
            args: Prisma.LearningPathCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathPayload>
          }
          createMany: {
            args: Prisma.LearningPathCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LearningPathCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathPayload>[]
          }
          delete: {
            args: Prisma.LearningPathDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathPayload>
          }
          update: {
            args: Prisma.LearningPathUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathPayload>
          }
          deleteMany: {
            args: Prisma.LearningPathDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LearningPathUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LearningPathUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathPayload>[]
          }
          upsert: {
            args: Prisma.LearningPathUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathPayload>
          }
          aggregate: {
            args: Prisma.LearningPathAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLearningPath>
          }
          groupBy: {
            args: Prisma.LearningPathGroupByArgs<ExtArgs>
            result: $Utils.Optional<LearningPathGroupByOutputType>[]
          }
          count: {
            args: Prisma.LearningPathCountArgs<ExtArgs>
            result: $Utils.Optional<LearningPathCountAggregateOutputType> | number
          }
        }
      }
      LearningPathItem: {
        payload: Prisma.$LearningPathItemPayload<ExtArgs>
        fields: Prisma.LearningPathItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LearningPathItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LearningPathItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathItemPayload>
          }
          findFirst: {
            args: Prisma.LearningPathItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LearningPathItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathItemPayload>
          }
          findMany: {
            args: Prisma.LearningPathItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathItemPayload>[]
          }
          create: {
            args: Prisma.LearningPathItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathItemPayload>
          }
          createMany: {
            args: Prisma.LearningPathItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LearningPathItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathItemPayload>[]
          }
          delete: {
            args: Prisma.LearningPathItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathItemPayload>
          }
          update: {
            args: Prisma.LearningPathItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathItemPayload>
          }
          deleteMany: {
            args: Prisma.LearningPathItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LearningPathItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LearningPathItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathItemPayload>[]
          }
          upsert: {
            args: Prisma.LearningPathItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPathItemPayload>
          }
          aggregate: {
            args: Prisma.LearningPathItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLearningPathItem>
          }
          groupBy: {
            args: Prisma.LearningPathItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<LearningPathItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.LearningPathItemCountArgs<ExtArgs>
            result: $Utils.Optional<LearningPathItemCountAggregateOutputType> | number
          }
        }
      }
      ContentItem: {
        payload: Prisma.$ContentItemPayload<ExtArgs>
        fields: Prisma.ContentItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContentItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContentItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentItemPayload>
          }
          findFirst: {
            args: Prisma.ContentItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContentItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentItemPayload>
          }
          findMany: {
            args: Prisma.ContentItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentItemPayload>[]
          }
          create: {
            args: Prisma.ContentItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentItemPayload>
          }
          createMany: {
            args: Prisma.ContentItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContentItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentItemPayload>[]
          }
          delete: {
            args: Prisma.ContentItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentItemPayload>
          }
          update: {
            args: Prisma.ContentItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentItemPayload>
          }
          deleteMany: {
            args: Prisma.ContentItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContentItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContentItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentItemPayload>[]
          }
          upsert: {
            args: Prisma.ContentItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentItemPayload>
          }
          aggregate: {
            args: Prisma.ContentItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContentItem>
          }
          groupBy: {
            args: Prisma.ContentItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContentItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContentItemCountArgs<ExtArgs>
            result: $Utils.Optional<ContentItemCountAggregateOutputType> | number
          }
        }
      }
      ContentRating: {
        payload: Prisma.$ContentRatingPayload<ExtArgs>
        fields: Prisma.ContentRatingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContentRatingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentRatingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContentRatingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentRatingPayload>
          }
          findFirst: {
            args: Prisma.ContentRatingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentRatingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContentRatingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentRatingPayload>
          }
          findMany: {
            args: Prisma.ContentRatingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentRatingPayload>[]
          }
          create: {
            args: Prisma.ContentRatingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentRatingPayload>
          }
          createMany: {
            args: Prisma.ContentRatingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContentRatingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentRatingPayload>[]
          }
          delete: {
            args: Prisma.ContentRatingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentRatingPayload>
          }
          update: {
            args: Prisma.ContentRatingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentRatingPayload>
          }
          deleteMany: {
            args: Prisma.ContentRatingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContentRatingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContentRatingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentRatingPayload>[]
          }
          upsert: {
            args: Prisma.ContentRatingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentRatingPayload>
          }
          aggregate: {
            args: Prisma.ContentRatingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContentRating>
          }
          groupBy: {
            args: Prisma.ContentRatingGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContentRatingGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContentRatingCountArgs<ExtArgs>
            result: $Utils.Optional<ContentRatingCountAggregateOutputType> | number
          }
        }
      }
      Bookmark: {
        payload: Prisma.$BookmarkPayload<ExtArgs>
        fields: Prisma.BookmarkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookmarkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookmarkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkPayload>
          }
          findFirst: {
            args: Prisma.BookmarkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookmarkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkPayload>
          }
          findMany: {
            args: Prisma.BookmarkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkPayload>[]
          }
          create: {
            args: Prisma.BookmarkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkPayload>
          }
          createMany: {
            args: Prisma.BookmarkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookmarkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkPayload>[]
          }
          delete: {
            args: Prisma.BookmarkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkPayload>
          }
          update: {
            args: Prisma.BookmarkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkPayload>
          }
          deleteMany: {
            args: Prisma.BookmarkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookmarkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BookmarkUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkPayload>[]
          }
          upsert: {
            args: Prisma.BookmarkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkPayload>
          }
          aggregate: {
            args: Prisma.BookmarkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBookmark>
          }
          groupBy: {
            args: Prisma.BookmarkGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookmarkGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookmarkCountArgs<ExtArgs>
            result: $Utils.Optional<BookmarkCountAggregateOutputType> | number
          }
        }
      }
      QuizAttempt: {
        payload: Prisma.$QuizAttemptPayload<ExtArgs>
        fields: Prisma.QuizAttemptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuizAttemptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuizAttemptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload>
          }
          findFirst: {
            args: Prisma.QuizAttemptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuizAttemptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload>
          }
          findMany: {
            args: Prisma.QuizAttemptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload>[]
          }
          create: {
            args: Prisma.QuizAttemptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload>
          }
          createMany: {
            args: Prisma.QuizAttemptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuizAttemptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload>[]
          }
          delete: {
            args: Prisma.QuizAttemptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload>
          }
          update: {
            args: Prisma.QuizAttemptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload>
          }
          deleteMany: {
            args: Prisma.QuizAttemptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuizAttemptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuizAttemptUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload>[]
          }
          upsert: {
            args: Prisma.QuizAttemptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload>
          }
          aggregate: {
            args: Prisma.QuizAttemptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuizAttempt>
          }
          groupBy: {
            args: Prisma.QuizAttemptGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuizAttemptGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuizAttemptCountArgs<ExtArgs>
            result: $Utils.Optional<QuizAttemptCountAggregateOutputType> | number
          }
        }
      }
      KnowledgeNode: {
        payload: Prisma.$KnowledgeNodePayload<ExtArgs>
        fields: Prisma.KnowledgeNodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KnowledgeNodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeNodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KnowledgeNodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeNodePayload>
          }
          findFirst: {
            args: Prisma.KnowledgeNodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeNodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KnowledgeNodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeNodePayload>
          }
          findMany: {
            args: Prisma.KnowledgeNodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeNodePayload>[]
          }
          create: {
            args: Prisma.KnowledgeNodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeNodePayload>
          }
          createMany: {
            args: Prisma.KnowledgeNodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KnowledgeNodeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeNodePayload>[]
          }
          delete: {
            args: Prisma.KnowledgeNodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeNodePayload>
          }
          update: {
            args: Prisma.KnowledgeNodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeNodePayload>
          }
          deleteMany: {
            args: Prisma.KnowledgeNodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KnowledgeNodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.KnowledgeNodeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeNodePayload>[]
          }
          upsert: {
            args: Prisma.KnowledgeNodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeNodePayload>
          }
          aggregate: {
            args: Prisma.KnowledgeNodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKnowledgeNode>
          }
          groupBy: {
            args: Prisma.KnowledgeNodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<KnowledgeNodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.KnowledgeNodeCountArgs<ExtArgs>
            result: $Utils.Optional<KnowledgeNodeCountAggregateOutputType> | number
          }
        }
      }
      LeaderboardEntry: {
        payload: Prisma.$LeaderboardEntryPayload<ExtArgs>
        fields: Prisma.LeaderboardEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeaderboardEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeaderboardEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload>
          }
          findFirst: {
            args: Prisma.LeaderboardEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeaderboardEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload>
          }
          findMany: {
            args: Prisma.LeaderboardEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload>[]
          }
          create: {
            args: Prisma.LeaderboardEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload>
          }
          createMany: {
            args: Prisma.LeaderboardEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeaderboardEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload>[]
          }
          delete: {
            args: Prisma.LeaderboardEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload>
          }
          update: {
            args: Prisma.LeaderboardEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload>
          }
          deleteMany: {
            args: Prisma.LeaderboardEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeaderboardEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LeaderboardEntryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload>[]
          }
          upsert: {
            args: Prisma.LeaderboardEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload>
          }
          aggregate: {
            args: Prisma.LeaderboardEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeaderboardEntry>
          }
          groupBy: {
            args: Prisma.LeaderboardEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeaderboardEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeaderboardEntryCountArgs<ExtArgs>
            result: $Utils.Optional<LeaderboardEntryCountAggregateOutputType> | number
          }
        }
      }
      ReviewSession: {
        payload: Prisma.$ReviewSessionPayload<ExtArgs>
        fields: Prisma.ReviewSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewSessionPayload>
          }
          findFirst: {
            args: Prisma.ReviewSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewSessionPayload>
          }
          findMany: {
            args: Prisma.ReviewSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewSessionPayload>[]
          }
          create: {
            args: Prisma.ReviewSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewSessionPayload>
          }
          createMany: {
            args: Prisma.ReviewSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewSessionPayload>[]
          }
          delete: {
            args: Prisma.ReviewSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewSessionPayload>
          }
          update: {
            args: Prisma.ReviewSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewSessionPayload>
          }
          deleteMany: {
            args: Prisma.ReviewSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReviewSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewSessionPayload>[]
          }
          upsert: {
            args: Prisma.ReviewSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewSessionPayload>
          }
          aggregate: {
            args: Prisma.ReviewSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReviewSession>
          }
          groupBy: {
            args: Prisma.ReviewSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewSessionCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewSessionCountAggregateOutputType> | number
          }
        }
      }
      ReviewItem: {
        payload: Prisma.$ReviewItemPayload<ExtArgs>
        fields: Prisma.ReviewItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewItemPayload>
          }
          findFirst: {
            args: Prisma.ReviewItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewItemPayload>
          }
          findMany: {
            args: Prisma.ReviewItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewItemPayload>[]
          }
          create: {
            args: Prisma.ReviewItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewItemPayload>
          }
          createMany: {
            args: Prisma.ReviewItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewItemPayload>[]
          }
          delete: {
            args: Prisma.ReviewItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewItemPayload>
          }
          update: {
            args: Prisma.ReviewItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewItemPayload>
          }
          deleteMany: {
            args: Prisma.ReviewItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReviewItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewItemPayload>[]
          }
          upsert: {
            args: Prisma.ReviewItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewItemPayload>
          }
          aggregate: {
            args: Prisma.ReviewItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReviewItem>
          }
          groupBy: {
            args: Prisma.ReviewItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewItemCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewItemCountAggregateOutputType> | number
          }
        }
      }
      Workspace: {
        payload: Prisma.$WorkspacePayload<ExtArgs>
        fields: Prisma.WorkspaceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkspaceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkspaceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          findFirst: {
            args: Prisma.WorkspaceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkspaceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          findMany: {
            args: Prisma.WorkspaceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>[]
          }
          create: {
            args: Prisma.WorkspaceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          createMany: {
            args: Prisma.WorkspaceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkspaceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>[]
          }
          delete: {
            args: Prisma.WorkspaceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          update: {
            args: Prisma.WorkspaceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          deleteMany: {
            args: Prisma.WorkspaceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkspaceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkspaceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>[]
          }
          upsert: {
            args: Prisma.WorkspaceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          aggregate: {
            args: Prisma.WorkspaceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkspace>
          }
          groupBy: {
            args: Prisma.WorkspaceGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkspaceCountArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceCountAggregateOutputType> | number
          }
        }
      }
      WorkspaceMember: {
        payload: Prisma.$WorkspaceMemberPayload<ExtArgs>
        fields: Prisma.WorkspaceMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkspaceMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkspaceMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceMemberPayload>
          }
          findFirst: {
            args: Prisma.WorkspaceMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkspaceMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceMemberPayload>
          }
          findMany: {
            args: Prisma.WorkspaceMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceMemberPayload>[]
          }
          create: {
            args: Prisma.WorkspaceMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceMemberPayload>
          }
          createMany: {
            args: Prisma.WorkspaceMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkspaceMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceMemberPayload>[]
          }
          delete: {
            args: Prisma.WorkspaceMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceMemberPayload>
          }
          update: {
            args: Prisma.WorkspaceMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceMemberPayload>
          }
          deleteMany: {
            args: Prisma.WorkspaceMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkspaceMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkspaceMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceMemberPayload>[]
          }
          upsert: {
            args: Prisma.WorkspaceMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceMemberPayload>
          }
          aggregate: {
            args: Prisma.WorkspaceMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkspaceMember>
          }
          groupBy: {
            args: Prisma.WorkspaceMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkspaceMemberCountArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceMemberCountAggregateOutputType> | number
          }
        }
      }
      Whiteboard: {
        payload: Prisma.$WhiteboardPayload<ExtArgs>
        fields: Prisma.WhiteboardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WhiteboardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhiteboardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WhiteboardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhiteboardPayload>
          }
          findFirst: {
            args: Prisma.WhiteboardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhiteboardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WhiteboardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhiteboardPayload>
          }
          findMany: {
            args: Prisma.WhiteboardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhiteboardPayload>[]
          }
          create: {
            args: Prisma.WhiteboardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhiteboardPayload>
          }
          createMany: {
            args: Prisma.WhiteboardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WhiteboardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhiteboardPayload>[]
          }
          delete: {
            args: Prisma.WhiteboardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhiteboardPayload>
          }
          update: {
            args: Prisma.WhiteboardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhiteboardPayload>
          }
          deleteMany: {
            args: Prisma.WhiteboardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WhiteboardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WhiteboardUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhiteboardPayload>[]
          }
          upsert: {
            args: Prisma.WhiteboardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhiteboardPayload>
          }
          aggregate: {
            args: Prisma.WhiteboardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWhiteboard>
          }
          groupBy: {
            args: Prisma.WhiteboardGroupByArgs<ExtArgs>
            result: $Utils.Optional<WhiteboardGroupByOutputType>[]
          }
          count: {
            args: Prisma.WhiteboardCountArgs<ExtArgs>
            result: $Utils.Optional<WhiteboardCountAggregateOutputType> | number
          }
        }
      }
      WhiteboardVersion: {
        payload: Prisma.$WhiteboardVersionPayload<ExtArgs>
        fields: Prisma.WhiteboardVersionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WhiteboardVersionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhiteboardVersionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WhiteboardVersionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhiteboardVersionPayload>
          }
          findFirst: {
            args: Prisma.WhiteboardVersionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhiteboardVersionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WhiteboardVersionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhiteboardVersionPayload>
          }
          findMany: {
            args: Prisma.WhiteboardVersionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhiteboardVersionPayload>[]
          }
          create: {
            args: Prisma.WhiteboardVersionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhiteboardVersionPayload>
          }
          createMany: {
            args: Prisma.WhiteboardVersionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WhiteboardVersionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhiteboardVersionPayload>[]
          }
          delete: {
            args: Prisma.WhiteboardVersionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhiteboardVersionPayload>
          }
          update: {
            args: Prisma.WhiteboardVersionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhiteboardVersionPayload>
          }
          deleteMany: {
            args: Prisma.WhiteboardVersionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WhiteboardVersionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WhiteboardVersionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhiteboardVersionPayload>[]
          }
          upsert: {
            args: Prisma.WhiteboardVersionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhiteboardVersionPayload>
          }
          aggregate: {
            args: Prisma.WhiteboardVersionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWhiteboardVersion>
          }
          groupBy: {
            args: Prisma.WhiteboardVersionGroupByArgs<ExtArgs>
            result: $Utils.Optional<WhiteboardVersionGroupByOutputType>[]
          }
          count: {
            args: Prisma.WhiteboardVersionCountArgs<ExtArgs>
            result: $Utils.Optional<WhiteboardVersionCountAggregateOutputType> | number
          }
        }
      }
      BreakoutRoom: {
        payload: Prisma.$BreakoutRoomPayload<ExtArgs>
        fields: Prisma.BreakoutRoomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BreakoutRoomFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreakoutRoomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BreakoutRoomFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreakoutRoomPayload>
          }
          findFirst: {
            args: Prisma.BreakoutRoomFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreakoutRoomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BreakoutRoomFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreakoutRoomPayload>
          }
          findMany: {
            args: Prisma.BreakoutRoomFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreakoutRoomPayload>[]
          }
          create: {
            args: Prisma.BreakoutRoomCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreakoutRoomPayload>
          }
          createMany: {
            args: Prisma.BreakoutRoomCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BreakoutRoomCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreakoutRoomPayload>[]
          }
          delete: {
            args: Prisma.BreakoutRoomDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreakoutRoomPayload>
          }
          update: {
            args: Prisma.BreakoutRoomUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreakoutRoomPayload>
          }
          deleteMany: {
            args: Prisma.BreakoutRoomDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BreakoutRoomUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BreakoutRoomUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreakoutRoomPayload>[]
          }
          upsert: {
            args: Prisma.BreakoutRoomUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreakoutRoomPayload>
          }
          aggregate: {
            args: Prisma.BreakoutRoomAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBreakoutRoom>
          }
          groupBy: {
            args: Prisma.BreakoutRoomGroupByArgs<ExtArgs>
            result: $Utils.Optional<BreakoutRoomGroupByOutputType>[]
          }
          count: {
            args: Prisma.BreakoutRoomCountArgs<ExtArgs>
            result: $Utils.Optional<BreakoutRoomCountAggregateOutputType> | number
          }
        }
      }
      LivePoll: {
        payload: Prisma.$LivePollPayload<ExtArgs>
        fields: Prisma.LivePollFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LivePollFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivePollPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LivePollFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivePollPayload>
          }
          findFirst: {
            args: Prisma.LivePollFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivePollPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LivePollFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivePollPayload>
          }
          findMany: {
            args: Prisma.LivePollFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivePollPayload>[]
          }
          create: {
            args: Prisma.LivePollCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivePollPayload>
          }
          createMany: {
            args: Prisma.LivePollCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LivePollCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivePollPayload>[]
          }
          delete: {
            args: Prisma.LivePollDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivePollPayload>
          }
          update: {
            args: Prisma.LivePollUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivePollPayload>
          }
          deleteMany: {
            args: Prisma.LivePollDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LivePollUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LivePollUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivePollPayload>[]
          }
          upsert: {
            args: Prisma.LivePollUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivePollPayload>
          }
          aggregate: {
            args: Prisma.LivePollAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLivePoll>
          }
          groupBy: {
            args: Prisma.LivePollGroupByArgs<ExtArgs>
            result: $Utils.Optional<LivePollGroupByOutputType>[]
          }
          count: {
            args: Prisma.LivePollCountArgs<ExtArgs>
            result: $Utils.Optional<LivePollCountAggregateOutputType> | number
          }
        }
      }
      PollVote: {
        payload: Prisma.$PollVotePayload<ExtArgs>
        fields: Prisma.PollVoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PollVoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollVotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PollVoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollVotePayload>
          }
          findFirst: {
            args: Prisma.PollVoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollVotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PollVoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollVotePayload>
          }
          findMany: {
            args: Prisma.PollVoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollVotePayload>[]
          }
          create: {
            args: Prisma.PollVoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollVotePayload>
          }
          createMany: {
            args: Prisma.PollVoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PollVoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollVotePayload>[]
          }
          delete: {
            args: Prisma.PollVoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollVotePayload>
          }
          update: {
            args: Prisma.PollVoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollVotePayload>
          }
          deleteMany: {
            args: Prisma.PollVoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PollVoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PollVoteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollVotePayload>[]
          }
          upsert: {
            args: Prisma.PollVoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollVotePayload>
          }
          aggregate: {
            args: Prisma.PollVoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePollVote>
          }
          groupBy: {
            args: Prisma.PollVoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<PollVoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.PollVoteCountArgs<ExtArgs>
            result: $Utils.Optional<PollVoteCountAggregateOutputType> | number
          }
        }
      }
      SessionSummary: {
        payload: Prisma.$SessionSummaryPayload<ExtArgs>
        fields: Prisma.SessionSummaryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionSummaryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionSummaryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionSummaryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionSummaryPayload>
          }
          findFirst: {
            args: Prisma.SessionSummaryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionSummaryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionSummaryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionSummaryPayload>
          }
          findMany: {
            args: Prisma.SessionSummaryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionSummaryPayload>[]
          }
          create: {
            args: Prisma.SessionSummaryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionSummaryPayload>
          }
          createMany: {
            args: Prisma.SessionSummaryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionSummaryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionSummaryPayload>[]
          }
          delete: {
            args: Prisma.SessionSummaryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionSummaryPayload>
          }
          update: {
            args: Prisma.SessionSummaryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionSummaryPayload>
          }
          deleteMany: {
            args: Prisma.SessionSummaryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionSummaryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionSummaryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionSummaryPayload>[]
          }
          upsert: {
            args: Prisma.SessionSummaryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionSummaryPayload>
          }
          aggregate: {
            args: Prisma.SessionSummaryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSessionSummary>
          }
          groupBy: {
            args: Prisma.SessionSummaryGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionSummaryGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionSummaryCountArgs<ExtArgs>
            result: $Utils.Optional<SessionSummaryCountAggregateOutputType> | number
          }
        }
      }
      Chat: {
        payload: Prisma.$ChatPayload<ExtArgs>
        fields: Prisma.ChatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          findFirst: {
            args: Prisma.ChatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          findMany: {
            args: Prisma.ChatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>[]
          }
          create: {
            args: Prisma.ChatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          createMany: {
            args: Prisma.ChatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChatCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>[]
          }
          delete: {
            args: Prisma.ChatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          update: {
            args: Prisma.ChatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          deleteMany: {
            args: Prisma.ChatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChatUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>[]
          }
          upsert: {
            args: Prisma.ChatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          aggregate: {
            args: Prisma.ChatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChat>
          }
          groupBy: {
            args: Prisma.ChatGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatCountArgs<ExtArgs>
            result: $Utils.Optional<ChatCountAggregateOutputType> | number
          }
        }
      }
      ChatMessage: {
        payload: Prisma.$ChatMessagePayload<ExtArgs>
        fields: Prisma.ChatMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          findFirst: {
            args: Prisma.ChatMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          findMany: {
            args: Prisma.ChatMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>[]
          }
          create: {
            args: Prisma.ChatMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          createMany: {
            args: Prisma.ChatMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChatMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>[]
          }
          delete: {
            args: Prisma.ChatMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          update: {
            args: Prisma.ChatMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          deleteMany: {
            args: Prisma.ChatMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChatMessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>[]
          }
          upsert: {
            args: Prisma.ChatMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          aggregate: {
            args: Prisma.ChatMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatMessage>
          }
          groupBy: {
            args: Prisma.ChatMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatMessageCountArgs<ExtArgs>
            result: $Utils.Optional<ChatMessageCountAggregateOutputType> | number
          }
        }
      }
      UserSettings: {
        payload: Prisma.$UserSettingsPayload<ExtArgs>
        fields: Prisma.UserSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          findFirst: {
            args: Prisma.UserSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          findMany: {
            args: Prisma.UserSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>[]
          }
          create: {
            args: Prisma.UserSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          createMany: {
            args: Prisma.UserSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>[]
          }
          delete: {
            args: Prisma.UserSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          update: {
            args: Prisma.UserSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          deleteMany: {
            args: Prisma.UserSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserSettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>[]
          }
          upsert: {
            args: Prisma.UserSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          aggregate: {
            args: Prisma.UserSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSettings>
          }
          groupBy: {
            args: Prisma.UserSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<UserSettingsCountAggregateOutputType> | number
          }
        }
      }
      AnalyticsEntry: {
        payload: Prisma.$AnalyticsEntryPayload<ExtArgs>
        fields: Prisma.AnalyticsEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnalyticsEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnalyticsEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEntryPayload>
          }
          findFirst: {
            args: Prisma.AnalyticsEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnalyticsEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEntryPayload>
          }
          findMany: {
            args: Prisma.AnalyticsEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEntryPayload>[]
          }
          create: {
            args: Prisma.AnalyticsEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEntryPayload>
          }
          createMany: {
            args: Prisma.AnalyticsEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnalyticsEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEntryPayload>[]
          }
          delete: {
            args: Prisma.AnalyticsEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEntryPayload>
          }
          update: {
            args: Prisma.AnalyticsEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEntryPayload>
          }
          deleteMany: {
            args: Prisma.AnalyticsEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnalyticsEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AnalyticsEntryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEntryPayload>[]
          }
          upsert: {
            args: Prisma.AnalyticsEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEntryPayload>
          }
          aggregate: {
            args: Prisma.AnalyticsEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnalyticsEntry>
          }
          groupBy: {
            args: Prisma.AnalyticsEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnalyticsEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnalyticsEntryCountArgs<ExtArgs>
            result: $Utils.Optional<AnalyticsEntryCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      PasswordlessToken: {
        payload: Prisma.$PasswordlessTokenPayload<ExtArgs>
        fields: Prisma.PasswordlessTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordlessTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordlessTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordlessTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordlessTokenPayload>
          }
          findFirst: {
            args: Prisma.PasswordlessTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordlessTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordlessTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordlessTokenPayload>
          }
          findMany: {
            args: Prisma.PasswordlessTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordlessTokenPayload>[]
          }
          create: {
            args: Prisma.PasswordlessTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordlessTokenPayload>
          }
          createMany: {
            args: Prisma.PasswordlessTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasswordlessTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordlessTokenPayload>[]
          }
          delete: {
            args: Prisma.PasswordlessTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordlessTokenPayload>
          }
          update: {
            args: Prisma.PasswordlessTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordlessTokenPayload>
          }
          deleteMany: {
            args: Prisma.PasswordlessTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordlessTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PasswordlessTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordlessTokenPayload>[]
          }
          upsert: {
            args: Prisma.PasswordlessTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordlessTokenPayload>
          }
          aggregate: {
            args: Prisma.PasswordlessTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordlessToken>
          }
          groupBy: {
            args: Prisma.PasswordlessTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordlessTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordlessTokenCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordlessTokenCountAggregateOutputType> | number
          }
        }
      }
      DailyChallenge: {
        payload: Prisma.$DailyChallengePayload<ExtArgs>
        fields: Prisma.DailyChallengeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DailyChallengeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyChallengePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DailyChallengeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyChallengePayload>
          }
          findFirst: {
            args: Prisma.DailyChallengeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyChallengePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DailyChallengeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyChallengePayload>
          }
          findMany: {
            args: Prisma.DailyChallengeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyChallengePayload>[]
          }
          create: {
            args: Prisma.DailyChallengeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyChallengePayload>
          }
          createMany: {
            args: Prisma.DailyChallengeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DailyChallengeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyChallengePayload>[]
          }
          delete: {
            args: Prisma.DailyChallengeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyChallengePayload>
          }
          update: {
            args: Prisma.DailyChallengeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyChallengePayload>
          }
          deleteMany: {
            args: Prisma.DailyChallengeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DailyChallengeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DailyChallengeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyChallengePayload>[]
          }
          upsert: {
            args: Prisma.DailyChallengeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyChallengePayload>
          }
          aggregate: {
            args: Prisma.DailyChallengeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDailyChallenge>
          }
          groupBy: {
            args: Prisma.DailyChallengeGroupByArgs<ExtArgs>
            result: $Utils.Optional<DailyChallengeGroupByOutputType>[]
          }
          count: {
            args: Prisma.DailyChallengeCountArgs<ExtArgs>
            result: $Utils.Optional<DailyChallengeCountAggregateOutputType> | number
          }
        }
      }
      ExternalGoal: {
        payload: Prisma.$ExternalGoalPayload<ExtArgs>
        fields: Prisma.ExternalGoalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExternalGoalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalGoalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExternalGoalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalGoalPayload>
          }
          findFirst: {
            args: Prisma.ExternalGoalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalGoalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExternalGoalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalGoalPayload>
          }
          findMany: {
            args: Prisma.ExternalGoalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalGoalPayload>[]
          }
          create: {
            args: Prisma.ExternalGoalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalGoalPayload>
          }
          createMany: {
            args: Prisma.ExternalGoalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExternalGoalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalGoalPayload>[]
          }
          delete: {
            args: Prisma.ExternalGoalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalGoalPayload>
          }
          update: {
            args: Prisma.ExternalGoalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalGoalPayload>
          }
          deleteMany: {
            args: Prisma.ExternalGoalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExternalGoalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExternalGoalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalGoalPayload>[]
          }
          upsert: {
            args: Prisma.ExternalGoalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalGoalPayload>
          }
          aggregate: {
            args: Prisma.ExternalGoalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExternalGoal>
          }
          groupBy: {
            args: Prisma.ExternalGoalGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExternalGoalGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExternalGoalCountArgs<ExtArgs>
            result: $Utils.Optional<ExternalGoalCountAggregateOutputType> | number
          }
        }
      }
      Prerequisite: {
        payload: Prisma.$PrerequisitePayload<ExtArgs>
        fields: Prisma.PrerequisiteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PrerequisiteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrerequisitePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PrerequisiteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrerequisitePayload>
          }
          findFirst: {
            args: Prisma.PrerequisiteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrerequisitePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PrerequisiteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrerequisitePayload>
          }
          findMany: {
            args: Prisma.PrerequisiteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrerequisitePayload>[]
          }
          create: {
            args: Prisma.PrerequisiteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrerequisitePayload>
          }
          createMany: {
            args: Prisma.PrerequisiteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PrerequisiteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrerequisitePayload>[]
          }
          delete: {
            args: Prisma.PrerequisiteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrerequisitePayload>
          }
          update: {
            args: Prisma.PrerequisiteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrerequisitePayload>
          }
          deleteMany: {
            args: Prisma.PrerequisiteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PrerequisiteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PrerequisiteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrerequisitePayload>[]
          }
          upsert: {
            args: Prisma.PrerequisiteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrerequisitePayload>
          }
          aggregate: {
            args: Prisma.PrerequisiteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrerequisite>
          }
          groupBy: {
            args: Prisma.PrerequisiteGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrerequisiteGroupByOutputType>[]
          }
          count: {
            args: Prisma.PrerequisiteCountArgs<ExtArgs>
            result: $Utils.Optional<PrerequisiteCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      AIPlaylist: {
        payload: Prisma.$AIPlaylistPayload<ExtArgs>
        fields: Prisma.AIPlaylistFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AIPlaylistFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIPlaylistPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AIPlaylistFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIPlaylistPayload>
          }
          findFirst: {
            args: Prisma.AIPlaylistFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIPlaylistPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AIPlaylistFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIPlaylistPayload>
          }
          findMany: {
            args: Prisma.AIPlaylistFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIPlaylistPayload>[]
          }
          create: {
            args: Prisma.AIPlaylistCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIPlaylistPayload>
          }
          createMany: {
            args: Prisma.AIPlaylistCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AIPlaylistCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIPlaylistPayload>[]
          }
          delete: {
            args: Prisma.AIPlaylistDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIPlaylistPayload>
          }
          update: {
            args: Prisma.AIPlaylistUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIPlaylistPayload>
          }
          deleteMany: {
            args: Prisma.AIPlaylistDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AIPlaylistUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AIPlaylistUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIPlaylistPayload>[]
          }
          upsert: {
            args: Prisma.AIPlaylistUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIPlaylistPayload>
          }
          aggregate: {
            args: Prisma.AIPlaylistAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAIPlaylist>
          }
          groupBy: {
            args: Prisma.AIPlaylistGroupByArgs<ExtArgs>
            result: $Utils.Optional<AIPlaylistGroupByOutputType>[]
          }
          count: {
            args: Prisma.AIPlaylistCountArgs<ExtArgs>
            result: $Utils.Optional<AIPlaylistCountAggregateOutputType> | number
          }
        }
      }
      AIPlaylistItem: {
        payload: Prisma.$AIPlaylistItemPayload<ExtArgs>
        fields: Prisma.AIPlaylistItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AIPlaylistItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIPlaylistItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AIPlaylistItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIPlaylistItemPayload>
          }
          findFirst: {
            args: Prisma.AIPlaylistItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIPlaylistItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AIPlaylistItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIPlaylistItemPayload>
          }
          findMany: {
            args: Prisma.AIPlaylistItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIPlaylistItemPayload>[]
          }
          create: {
            args: Prisma.AIPlaylistItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIPlaylistItemPayload>
          }
          createMany: {
            args: Prisma.AIPlaylistItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AIPlaylistItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIPlaylistItemPayload>[]
          }
          delete: {
            args: Prisma.AIPlaylistItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIPlaylistItemPayload>
          }
          update: {
            args: Prisma.AIPlaylistItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIPlaylistItemPayload>
          }
          deleteMany: {
            args: Prisma.AIPlaylistItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AIPlaylistItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AIPlaylistItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIPlaylistItemPayload>[]
          }
          upsert: {
            args: Prisma.AIPlaylistItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIPlaylistItemPayload>
          }
          aggregate: {
            args: Prisma.AIPlaylistItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAIPlaylistItem>
          }
          groupBy: {
            args: Prisma.AIPlaylistItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<AIPlaylistItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.AIPlaylistItemCountArgs<ExtArgs>
            result: $Utils.Optional<AIPlaylistItemCountAggregateOutputType> | number
          }
        }
      }
      ChallengeScore: {
        payload: Prisma.$ChallengeScorePayload<ExtArgs>
        fields: Prisma.ChallengeScoreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChallengeScoreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeScorePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChallengeScoreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeScorePayload>
          }
          findFirst: {
            args: Prisma.ChallengeScoreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeScorePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChallengeScoreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeScorePayload>
          }
          findMany: {
            args: Prisma.ChallengeScoreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeScorePayload>[]
          }
          create: {
            args: Prisma.ChallengeScoreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeScorePayload>
          }
          createMany: {
            args: Prisma.ChallengeScoreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChallengeScoreCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeScorePayload>[]
          }
          delete: {
            args: Prisma.ChallengeScoreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeScorePayload>
          }
          update: {
            args: Prisma.ChallengeScoreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeScorePayload>
          }
          deleteMany: {
            args: Prisma.ChallengeScoreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChallengeScoreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChallengeScoreUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeScorePayload>[]
          }
          upsert: {
            args: Prisma.ChallengeScoreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeScorePayload>
          }
          aggregate: {
            args: Prisma.ChallengeScoreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChallengeScore>
          }
          groupBy: {
            args: Prisma.ChallengeScoreGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChallengeScoreGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChallengeScoreCountArgs<ExtArgs>
            result: $Utils.Optional<ChallengeScoreCountAggregateOutputType> | number
          }
        }
      }
      AIRecommendation: {
        payload: Prisma.$AIRecommendationPayload<ExtArgs>
        fields: Prisma.AIRecommendationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AIRecommendationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIRecommendationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AIRecommendationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIRecommendationPayload>
          }
          findFirst: {
            args: Prisma.AIRecommendationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIRecommendationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AIRecommendationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIRecommendationPayload>
          }
          findMany: {
            args: Prisma.AIRecommendationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIRecommendationPayload>[]
          }
          create: {
            args: Prisma.AIRecommendationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIRecommendationPayload>
          }
          createMany: {
            args: Prisma.AIRecommendationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AIRecommendationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIRecommendationPayload>[]
          }
          delete: {
            args: Prisma.AIRecommendationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIRecommendationPayload>
          }
          update: {
            args: Prisma.AIRecommendationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIRecommendationPayload>
          }
          deleteMany: {
            args: Prisma.AIRecommendationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AIRecommendationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AIRecommendationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIRecommendationPayload>[]
          }
          upsert: {
            args: Prisma.AIRecommendationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIRecommendationPayload>
          }
          aggregate: {
            args: Prisma.AIRecommendationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAIRecommendation>
          }
          groupBy: {
            args: Prisma.AIRecommendationGroupByArgs<ExtArgs>
            result: $Utils.Optional<AIRecommendationGroupByOutputType>[]
          }
          count: {
            args: Prisma.AIRecommendationCountArgs<ExtArgs>
            result: $Utils.Optional<AIRecommendationCountAggregateOutputType> | number
          }
        }
      }
      AIModule: {
        payload: Prisma.$AIModulePayload<ExtArgs>
        fields: Prisma.AIModuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AIModuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIModulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AIModuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIModulePayload>
          }
          findFirst: {
            args: Prisma.AIModuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIModulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AIModuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIModulePayload>
          }
          findMany: {
            args: Prisma.AIModuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIModulePayload>[]
          }
          create: {
            args: Prisma.AIModuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIModulePayload>
          }
          createMany: {
            args: Prisma.AIModuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AIModuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIModulePayload>[]
          }
          delete: {
            args: Prisma.AIModuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIModulePayload>
          }
          update: {
            args: Prisma.AIModuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIModulePayload>
          }
          deleteMany: {
            args: Prisma.AIModuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AIModuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AIModuleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIModulePayload>[]
          }
          upsert: {
            args: Prisma.AIModuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIModulePayload>
          }
          aggregate: {
            args: Prisma.AIModuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAIModule>
          }
          groupBy: {
            args: Prisma.AIModuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<AIModuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.AIModuleCountArgs<ExtArgs>
            result: $Utils.Optional<AIModuleCountAggregateOutputType> | number
          }
        }
      }
      AIModuleLearningPathItem: {
        payload: Prisma.$AIModuleLearningPathItemPayload<ExtArgs>
        fields: Prisma.AIModuleLearningPathItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AIModuleLearningPathItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIModuleLearningPathItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AIModuleLearningPathItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIModuleLearningPathItemPayload>
          }
          findFirst: {
            args: Prisma.AIModuleLearningPathItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIModuleLearningPathItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AIModuleLearningPathItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIModuleLearningPathItemPayload>
          }
          findMany: {
            args: Prisma.AIModuleLearningPathItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIModuleLearningPathItemPayload>[]
          }
          create: {
            args: Prisma.AIModuleLearningPathItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIModuleLearningPathItemPayload>
          }
          createMany: {
            args: Prisma.AIModuleLearningPathItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AIModuleLearningPathItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIModuleLearningPathItemPayload>[]
          }
          delete: {
            args: Prisma.AIModuleLearningPathItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIModuleLearningPathItemPayload>
          }
          update: {
            args: Prisma.AIModuleLearningPathItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIModuleLearningPathItemPayload>
          }
          deleteMany: {
            args: Prisma.AIModuleLearningPathItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AIModuleLearningPathItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AIModuleLearningPathItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIModuleLearningPathItemPayload>[]
          }
          upsert: {
            args: Prisma.AIModuleLearningPathItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIModuleLearningPathItemPayload>
          }
          aggregate: {
            args: Prisma.AIModuleLearningPathItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAIModuleLearningPathItem>
          }
          groupBy: {
            args: Prisma.AIModuleLearningPathItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<AIModuleLearningPathItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.AIModuleLearningPathItemCountArgs<ExtArgs>
            result: $Utils.Optional<AIModuleLearningPathItemCountAggregateOutputType> | number
          }
        }
      }
      AIModuleQuizAttempt: {
        payload: Prisma.$AIModuleQuizAttemptPayload<ExtArgs>
        fields: Prisma.AIModuleQuizAttemptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AIModuleQuizAttemptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIModuleQuizAttemptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AIModuleQuizAttemptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIModuleQuizAttemptPayload>
          }
          findFirst: {
            args: Prisma.AIModuleQuizAttemptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIModuleQuizAttemptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AIModuleQuizAttemptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIModuleQuizAttemptPayload>
          }
          findMany: {
            args: Prisma.AIModuleQuizAttemptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIModuleQuizAttemptPayload>[]
          }
          create: {
            args: Prisma.AIModuleQuizAttemptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIModuleQuizAttemptPayload>
          }
          createMany: {
            args: Prisma.AIModuleQuizAttemptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AIModuleQuizAttemptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIModuleQuizAttemptPayload>[]
          }
          delete: {
            args: Prisma.AIModuleQuizAttemptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIModuleQuizAttemptPayload>
          }
          update: {
            args: Prisma.AIModuleQuizAttemptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIModuleQuizAttemptPayload>
          }
          deleteMany: {
            args: Prisma.AIModuleQuizAttemptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AIModuleQuizAttemptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AIModuleQuizAttemptUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIModuleQuizAttemptPayload>[]
          }
          upsert: {
            args: Prisma.AIModuleQuizAttemptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIModuleQuizAttemptPayload>
          }
          aggregate: {
            args: Prisma.AIModuleQuizAttemptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAIModuleQuizAttempt>
          }
          groupBy: {
            args: Prisma.AIModuleQuizAttemptGroupByArgs<ExtArgs>
            result: $Utils.Optional<AIModuleQuizAttemptGroupByOutputType>[]
          }
          count: {
            args: Prisma.AIModuleQuizAttemptCountArgs<ExtArgs>
            result: $Utils.Optional<AIModuleQuizAttemptCountAggregateOutputType> | number
          }
        }
      }
      AIModuleRating: {
        payload: Prisma.$AIModuleRatingPayload<ExtArgs>
        fields: Prisma.AIModuleRatingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AIModuleRatingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIModuleRatingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AIModuleRatingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIModuleRatingPayload>
          }
          findFirst: {
            args: Prisma.AIModuleRatingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIModuleRatingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AIModuleRatingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIModuleRatingPayload>
          }
          findMany: {
            args: Prisma.AIModuleRatingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIModuleRatingPayload>[]
          }
          create: {
            args: Prisma.AIModuleRatingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIModuleRatingPayload>
          }
          createMany: {
            args: Prisma.AIModuleRatingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AIModuleRatingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIModuleRatingPayload>[]
          }
          delete: {
            args: Prisma.AIModuleRatingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIModuleRatingPayload>
          }
          update: {
            args: Prisma.AIModuleRatingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIModuleRatingPayload>
          }
          deleteMany: {
            args: Prisma.AIModuleRatingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AIModuleRatingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AIModuleRatingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIModuleRatingPayload>[]
          }
          upsert: {
            args: Prisma.AIModuleRatingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIModuleRatingPayload>
          }
          aggregate: {
            args: Prisma.AIModuleRatingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAIModuleRating>
          }
          groupBy: {
            args: Prisma.AIModuleRatingGroupByArgs<ExtArgs>
            result: $Utils.Optional<AIModuleRatingGroupByOutputType>[]
          }
          count: {
            args: Prisma.AIModuleRatingCountArgs<ExtArgs>
            result: $Utils.Optional<AIModuleRatingCountAggregateOutputType> | number
          }
        }
      }
      UserProgress: {
        payload: Prisma.$UserProgressPayload<ExtArgs>
        fields: Prisma.UserProgressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserProgressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserProgressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>
          }
          findFirst: {
            args: Prisma.UserProgressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserProgressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>
          }
          findMany: {
            args: Prisma.UserProgressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>[]
          }
          create: {
            args: Prisma.UserProgressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>
          }
          createMany: {
            args: Prisma.UserProgressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserProgressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>[]
          }
          delete: {
            args: Prisma.UserProgressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>
          }
          update: {
            args: Prisma.UserProgressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>
          }
          deleteMany: {
            args: Prisma.UserProgressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserProgressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserProgressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>[]
          }
          upsert: {
            args: Prisma.UserProgressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>
          }
          aggregate: {
            args: Prisma.UserProgressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserProgress>
          }
          groupBy: {
            args: Prisma.UserProgressGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserProgressGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserProgressCountArgs<ExtArgs>
            result: $Utils.Optional<UserProgressCountAggregateOutputType> | number
          }
        }
      }
      AIChat: {
        payload: Prisma.$AIChatPayload<ExtArgs>
        fields: Prisma.AIChatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AIChatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIChatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AIChatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIChatPayload>
          }
          findFirst: {
            args: Prisma.AIChatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIChatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AIChatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIChatPayload>
          }
          findMany: {
            args: Prisma.AIChatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIChatPayload>[]
          }
          create: {
            args: Prisma.AIChatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIChatPayload>
          }
          createMany: {
            args: Prisma.AIChatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AIChatCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIChatPayload>[]
          }
          delete: {
            args: Prisma.AIChatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIChatPayload>
          }
          update: {
            args: Prisma.AIChatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIChatPayload>
          }
          deleteMany: {
            args: Prisma.AIChatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AIChatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AIChatUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIChatPayload>[]
          }
          upsert: {
            args: Prisma.AIChatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIChatPayload>
          }
          aggregate: {
            args: Prisma.AIChatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAIChat>
          }
          groupBy: {
            args: Prisma.AIChatGroupByArgs<ExtArgs>
            result: $Utils.Optional<AIChatGroupByOutputType>[]
          }
          count: {
            args: Prisma.AIChatCountArgs<ExtArgs>
            result: $Utils.Optional<AIChatCountAggregateOutputType> | number
          }
        }
      }
      AIChatMessage: {
        payload: Prisma.$AIChatMessagePayload<ExtArgs>
        fields: Prisma.AIChatMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AIChatMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIChatMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AIChatMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIChatMessagePayload>
          }
          findFirst: {
            args: Prisma.AIChatMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIChatMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AIChatMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIChatMessagePayload>
          }
          findMany: {
            args: Prisma.AIChatMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIChatMessagePayload>[]
          }
          create: {
            args: Prisma.AIChatMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIChatMessagePayload>
          }
          createMany: {
            args: Prisma.AIChatMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AIChatMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIChatMessagePayload>[]
          }
          delete: {
            args: Prisma.AIChatMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIChatMessagePayload>
          }
          update: {
            args: Prisma.AIChatMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIChatMessagePayload>
          }
          deleteMany: {
            args: Prisma.AIChatMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AIChatMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AIChatMessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIChatMessagePayload>[]
          }
          upsert: {
            args: Prisma.AIChatMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIChatMessagePayload>
          }
          aggregate: {
            args: Prisma.AIChatMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAIChatMessage>
          }
          groupBy: {
            args: Prisma.AIChatMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<AIChatMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.AIChatMessageCountArgs<ExtArgs>
            result: $Utils.Optional<AIChatMessageCountAggregateOutputType> | number
          }
        }
      }
      PracticeAttempt: {
        payload: Prisma.$PracticeAttemptPayload<ExtArgs>
        fields: Prisma.PracticeAttemptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PracticeAttemptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PracticeAttemptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PracticeAttemptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PracticeAttemptPayload>
          }
          findFirst: {
            args: Prisma.PracticeAttemptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PracticeAttemptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PracticeAttemptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PracticeAttemptPayload>
          }
          findMany: {
            args: Prisma.PracticeAttemptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PracticeAttemptPayload>[]
          }
          create: {
            args: Prisma.PracticeAttemptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PracticeAttemptPayload>
          }
          createMany: {
            args: Prisma.PracticeAttemptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PracticeAttemptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PracticeAttemptPayload>[]
          }
          delete: {
            args: Prisma.PracticeAttemptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PracticeAttemptPayload>
          }
          update: {
            args: Prisma.PracticeAttemptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PracticeAttemptPayload>
          }
          deleteMany: {
            args: Prisma.PracticeAttemptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PracticeAttemptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PracticeAttemptUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PracticeAttemptPayload>[]
          }
          upsert: {
            args: Prisma.PracticeAttemptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PracticeAttemptPayload>
          }
          aggregate: {
            args: Prisma.PracticeAttemptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePracticeAttempt>
          }
          groupBy: {
            args: Prisma.PracticeAttemptGroupByArgs<ExtArgs>
            result: $Utils.Optional<PracticeAttemptGroupByOutputType>[]
          }
          count: {
            args: Prisma.PracticeAttemptCountArgs<ExtArgs>
            result: $Utils.Optional<PracticeAttemptCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    account?: AccountOmit
    session?: SessionOmit
    verificationToken?: VerificationTokenOmit
    activity?: ActivityOmit
    learningPreferences?: LearningPreferencesOmit
    topic?: TopicOmit
    progress?: ProgressOmit
    badge?: BadgeOmit
    upcomingReview?: UpcomingReviewOmit
    learningPath?: LearningPathOmit
    learningPathItem?: LearningPathItemOmit
    contentItem?: ContentItemOmit
    contentRating?: ContentRatingOmit
    bookmark?: BookmarkOmit
    quizAttempt?: QuizAttemptOmit
    knowledgeNode?: KnowledgeNodeOmit
    leaderboardEntry?: LeaderboardEntryOmit
    reviewSession?: ReviewSessionOmit
    reviewItem?: ReviewItemOmit
    workspace?: WorkspaceOmit
    workspaceMember?: WorkspaceMemberOmit
    whiteboard?: WhiteboardOmit
    whiteboardVersion?: WhiteboardVersionOmit
    breakoutRoom?: BreakoutRoomOmit
    livePoll?: LivePollOmit
    pollVote?: PollVoteOmit
    sessionSummary?: SessionSummaryOmit
    chat?: ChatOmit
    chatMessage?: ChatMessageOmit
    userSettings?: UserSettingsOmit
    analyticsEntry?: AnalyticsEntryOmit
    notification?: NotificationOmit
    passwordlessToken?: PasswordlessTokenOmit
    dailyChallenge?: DailyChallengeOmit
    externalGoal?: ExternalGoalOmit
    prerequisite?: PrerequisiteOmit
    comment?: CommentOmit
    aIPlaylist?: AIPlaylistOmit
    aIPlaylistItem?: AIPlaylistItemOmit
    challengeScore?: ChallengeScoreOmit
    aIRecommendation?: AIRecommendationOmit
    aIModule?: AIModuleOmit
    aIModuleLearningPathItem?: AIModuleLearningPathItemOmit
    aIModuleQuizAttempt?: AIModuleQuizAttemptOmit
    aIModuleRating?: AIModuleRatingOmit
    userProgress?: UserProgressOmit
    aIChat?: AIChatOmit
    aIChatMessage?: AIChatMessageOmit
    practiceAttempt?: PracticeAttemptOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accounts: number
    sessions: number
    activities: number
    topics: number
    progress: number
    badges: number
    upcomingReviews: number
    learningPaths: number
    bookmarks: number
    quizAttempts: number
    knowledgeNodes: number
    leaderboardEntries: number
    reviewSessions: number
    workspaces: number
    chatMessages: number
    ownedWorkspaces: number
    analyticsEntries: number
    notifications: number
    passwordlessTokens: number
    dailyChallenges: number
    externalGoals: number
    comments: number
    contentRatings: number
    challengeScores: number
    pollVotes: number
    aiRecommendations: number
    aiModules: number
    aiModuleQuizAttempts: number
    aiModuleRatings: number
    UserProgress: number
    AIChat: number
    PracticeAttempts: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    activities?: boolean | UserCountOutputTypeCountActivitiesArgs
    topics?: boolean | UserCountOutputTypeCountTopicsArgs
    progress?: boolean | UserCountOutputTypeCountProgressArgs
    badges?: boolean | UserCountOutputTypeCountBadgesArgs
    upcomingReviews?: boolean | UserCountOutputTypeCountUpcomingReviewsArgs
    learningPaths?: boolean | UserCountOutputTypeCountLearningPathsArgs
    bookmarks?: boolean | UserCountOutputTypeCountBookmarksArgs
    quizAttempts?: boolean | UserCountOutputTypeCountQuizAttemptsArgs
    knowledgeNodes?: boolean | UserCountOutputTypeCountKnowledgeNodesArgs
    leaderboardEntries?: boolean | UserCountOutputTypeCountLeaderboardEntriesArgs
    reviewSessions?: boolean | UserCountOutputTypeCountReviewSessionsArgs
    workspaces?: boolean | UserCountOutputTypeCountWorkspacesArgs
    chatMessages?: boolean | UserCountOutputTypeCountChatMessagesArgs
    ownedWorkspaces?: boolean | UserCountOutputTypeCountOwnedWorkspacesArgs
    analyticsEntries?: boolean | UserCountOutputTypeCountAnalyticsEntriesArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    passwordlessTokens?: boolean | UserCountOutputTypeCountPasswordlessTokensArgs
    dailyChallenges?: boolean | UserCountOutputTypeCountDailyChallengesArgs
    externalGoals?: boolean | UserCountOutputTypeCountExternalGoalsArgs
    comments?: boolean | UserCountOutputTypeCountCommentsArgs
    contentRatings?: boolean | UserCountOutputTypeCountContentRatingsArgs
    challengeScores?: boolean | UserCountOutputTypeCountChallengeScoresArgs
    pollVotes?: boolean | UserCountOutputTypeCountPollVotesArgs
    aiRecommendations?: boolean | UserCountOutputTypeCountAiRecommendationsArgs
    aiModules?: boolean | UserCountOutputTypeCountAiModulesArgs
    aiModuleQuizAttempts?: boolean | UserCountOutputTypeCountAiModuleQuizAttemptsArgs
    aiModuleRatings?: boolean | UserCountOutputTypeCountAiModuleRatingsArgs
    UserProgress?: boolean | UserCountOutputTypeCountUserProgressArgs
    AIChat?: boolean | UserCountOutputTypeCountAIChatArgs
    PracticeAttempts?: boolean | UserCountOutputTypeCountPracticeAttemptsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTopicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TopicWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgressWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBadgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BadgeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUpcomingReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UpcomingReviewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLearningPathsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearningPathWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBookmarksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookmarkWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountQuizAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizAttemptWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountKnowledgeNodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KnowledgeNodeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLeaderboardEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaderboardEntryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWorkspacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChatMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatMessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOwnedWorkspacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAnalyticsEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalyticsEntryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPasswordlessTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordlessTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDailyChallengesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyChallengeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountExternalGoalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExternalGoalWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountContentRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentRatingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChallengeScoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeScoreWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPollVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PollVoteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAiRecommendationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIRecommendationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAiModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIModuleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAiModuleQuizAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIModuleQuizAttemptWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAiModuleRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIModuleRatingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProgressWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAIChatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIChatWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPracticeAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PracticeAttemptWhereInput
  }


  /**
   * Count Type TopicCountOutputType
   */

  export type TopicCountOutputType = {
    progress: number
    learningPathItems: number
    contentItems: number
    analyticsEntries: number
    comments: number
    prerequisites: number
    aiModules: number
    aiModuleQuizAttempts: number
    aiModuleRatings: number
  }

  export type TopicCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    progress?: boolean | TopicCountOutputTypeCountProgressArgs
    learningPathItems?: boolean | TopicCountOutputTypeCountLearningPathItemsArgs
    contentItems?: boolean | TopicCountOutputTypeCountContentItemsArgs
    analyticsEntries?: boolean | TopicCountOutputTypeCountAnalyticsEntriesArgs
    comments?: boolean | TopicCountOutputTypeCountCommentsArgs
    prerequisites?: boolean | TopicCountOutputTypeCountPrerequisitesArgs
    aiModules?: boolean | TopicCountOutputTypeCountAiModulesArgs
    aiModuleQuizAttempts?: boolean | TopicCountOutputTypeCountAiModuleQuizAttemptsArgs
    aiModuleRatings?: boolean | TopicCountOutputTypeCountAiModuleRatingsArgs
  }

  // Custom InputTypes
  /**
   * TopicCountOutputType without action
   */
  export type TopicCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicCountOutputType
     */
    select?: TopicCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TopicCountOutputType without action
   */
  export type TopicCountOutputTypeCountProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgressWhereInput
  }

  /**
   * TopicCountOutputType without action
   */
  export type TopicCountOutputTypeCountLearningPathItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearningPathItemWhereInput
  }

  /**
   * TopicCountOutputType without action
   */
  export type TopicCountOutputTypeCountContentItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentItemWhereInput
  }

  /**
   * TopicCountOutputType without action
   */
  export type TopicCountOutputTypeCountAnalyticsEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalyticsEntryWhereInput
  }

  /**
   * TopicCountOutputType without action
   */
  export type TopicCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * TopicCountOutputType without action
   */
  export type TopicCountOutputTypeCountPrerequisitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrerequisiteWhereInput
  }

  /**
   * TopicCountOutputType without action
   */
  export type TopicCountOutputTypeCountAiModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIModuleWhereInput
  }

  /**
   * TopicCountOutputType without action
   */
  export type TopicCountOutputTypeCountAiModuleQuizAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIModuleQuizAttemptWhereInput
  }

  /**
   * TopicCountOutputType without action
   */
  export type TopicCountOutputTypeCountAiModuleRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIModuleRatingWhereInput
  }


  /**
   * Count Type LearningPathCountOutputType
   */

  export type LearningPathCountOutputType = {
    items: number
    prerequisites: number
    aiModuleItems: number
    UserProgress: number
  }

  export type LearningPathCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | LearningPathCountOutputTypeCountItemsArgs
    prerequisites?: boolean | LearningPathCountOutputTypeCountPrerequisitesArgs
    aiModuleItems?: boolean | LearningPathCountOutputTypeCountAiModuleItemsArgs
    UserProgress?: boolean | LearningPathCountOutputTypeCountUserProgressArgs
  }

  // Custom InputTypes
  /**
   * LearningPathCountOutputType without action
   */
  export type LearningPathCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathCountOutputType
     */
    select?: LearningPathCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LearningPathCountOutputType without action
   */
  export type LearningPathCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearningPathItemWhereInput
  }

  /**
   * LearningPathCountOutputType without action
   */
  export type LearningPathCountOutputTypeCountPrerequisitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrerequisiteWhereInput
  }

  /**
   * LearningPathCountOutputType without action
   */
  export type LearningPathCountOutputTypeCountAiModuleItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIModuleLearningPathItemWhereInput
  }

  /**
   * LearningPathCountOutputType without action
   */
  export type LearningPathCountOutputTypeCountUserProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProgressWhereInput
  }


  /**
   * Count Type LearningPathItemCountOutputType
   */

  export type LearningPathItemCountOutputType = {
    UserProgress: number
  }

  export type LearningPathItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    UserProgress?: boolean | LearningPathItemCountOutputTypeCountUserProgressArgs
  }

  // Custom InputTypes
  /**
   * LearningPathItemCountOutputType without action
   */
  export type LearningPathItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathItemCountOutputType
     */
    select?: LearningPathItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LearningPathItemCountOutputType without action
   */
  export type LearningPathItemCountOutputTypeCountUserProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProgressWhereInput
  }


  /**
   * Count Type ContentItemCountOutputType
   */

  export type ContentItemCountOutputType = {
    bookmarks: number
    quizAttempts: number
    reviewItems: number
    ratings: number
    aiPlaylistItems: number
  }

  export type ContentItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookmarks?: boolean | ContentItemCountOutputTypeCountBookmarksArgs
    quizAttempts?: boolean | ContentItemCountOutputTypeCountQuizAttemptsArgs
    reviewItems?: boolean | ContentItemCountOutputTypeCountReviewItemsArgs
    ratings?: boolean | ContentItemCountOutputTypeCountRatingsArgs
    aiPlaylistItems?: boolean | ContentItemCountOutputTypeCountAiPlaylistItemsArgs
  }

  // Custom InputTypes
  /**
   * ContentItemCountOutputType without action
   */
  export type ContentItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentItemCountOutputType
     */
    select?: ContentItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContentItemCountOutputType without action
   */
  export type ContentItemCountOutputTypeCountBookmarksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookmarkWhereInput
  }

  /**
   * ContentItemCountOutputType without action
   */
  export type ContentItemCountOutputTypeCountQuizAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizAttemptWhereInput
  }

  /**
   * ContentItemCountOutputType without action
   */
  export type ContentItemCountOutputTypeCountReviewItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewItemWhereInput
  }

  /**
   * ContentItemCountOutputType without action
   */
  export type ContentItemCountOutputTypeCountRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentRatingWhereInput
  }

  /**
   * ContentItemCountOutputType without action
   */
  export type ContentItemCountOutputTypeCountAiPlaylistItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIPlaylistItemWhereInput
  }


  /**
   * Count Type KnowledgeNodeCountOutputType
   */

  export type KnowledgeNodeCountOutputType = {
    children: number
  }

  export type KnowledgeNodeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | KnowledgeNodeCountOutputTypeCountChildrenArgs
  }

  // Custom InputTypes
  /**
   * KnowledgeNodeCountOutputType without action
   */
  export type KnowledgeNodeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeNodeCountOutputType
     */
    select?: KnowledgeNodeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * KnowledgeNodeCountOutputType without action
   */
  export type KnowledgeNodeCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KnowledgeNodeWhereInput
  }


  /**
   * Count Type ReviewSessionCountOutputType
   */

  export type ReviewSessionCountOutputType = {
    items: number
  }

  export type ReviewSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | ReviewSessionCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * ReviewSessionCountOutputType without action
   */
  export type ReviewSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewSessionCountOutputType
     */
    select?: ReviewSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReviewSessionCountOutputType without action
   */
  export type ReviewSessionCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewItemWhereInput
  }


  /**
   * Count Type WorkspaceCountOutputType
   */

  export type WorkspaceCountOutputType = {
    members: number
    whiteboards: number
    chats: number
    breakoutRooms: number
    livePolls: number
    sessionSummaries: number
  }

  export type WorkspaceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | WorkspaceCountOutputTypeCountMembersArgs
    whiteboards?: boolean | WorkspaceCountOutputTypeCountWhiteboardsArgs
    chats?: boolean | WorkspaceCountOutputTypeCountChatsArgs
    breakoutRooms?: boolean | WorkspaceCountOutputTypeCountBreakoutRoomsArgs
    livePolls?: boolean | WorkspaceCountOutputTypeCountLivePollsArgs
    sessionSummaries?: boolean | WorkspaceCountOutputTypeCountSessionSummariesArgs
  }

  // Custom InputTypes
  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceCountOutputType
     */
    select?: WorkspaceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceMemberWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountWhiteboardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhiteboardWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountChatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountBreakoutRoomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BreakoutRoomWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountLivePollsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LivePollWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountSessionSummariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionSummaryWhereInput
  }


  /**
   * Count Type WorkspaceMemberCountOutputType
   */

  export type WorkspaceMemberCountOutputType = {
    breakoutRooms: number
  }

  export type WorkspaceMemberCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    breakoutRooms?: boolean | WorkspaceMemberCountOutputTypeCountBreakoutRoomsArgs
  }

  // Custom InputTypes
  /**
   * WorkspaceMemberCountOutputType without action
   */
  export type WorkspaceMemberCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceMemberCountOutputType
     */
    select?: WorkspaceMemberCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkspaceMemberCountOutputType without action
   */
  export type WorkspaceMemberCountOutputTypeCountBreakoutRoomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BreakoutRoomWhereInput
  }


  /**
   * Count Type WhiteboardCountOutputType
   */

  export type WhiteboardCountOutputType = {
    versions: number
  }

  export type WhiteboardCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    versions?: boolean | WhiteboardCountOutputTypeCountVersionsArgs
  }

  // Custom InputTypes
  /**
   * WhiteboardCountOutputType without action
   */
  export type WhiteboardCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhiteboardCountOutputType
     */
    select?: WhiteboardCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WhiteboardCountOutputType without action
   */
  export type WhiteboardCountOutputTypeCountVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhiteboardVersionWhereInput
  }


  /**
   * Count Type BreakoutRoomCountOutputType
   */

  export type BreakoutRoomCountOutputType = {
    participants: number
  }

  export type BreakoutRoomCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participants?: boolean | BreakoutRoomCountOutputTypeCountParticipantsArgs
  }

  // Custom InputTypes
  /**
   * BreakoutRoomCountOutputType without action
   */
  export type BreakoutRoomCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreakoutRoomCountOutputType
     */
    select?: BreakoutRoomCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BreakoutRoomCountOutputType without action
   */
  export type BreakoutRoomCountOutputTypeCountParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceMemberWhereInput
  }


  /**
   * Count Type LivePollCountOutputType
   */

  export type LivePollCountOutputType = {
    votes: number
  }

  export type LivePollCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    votes?: boolean | LivePollCountOutputTypeCountVotesArgs
  }

  // Custom InputTypes
  /**
   * LivePollCountOutputType without action
   */
  export type LivePollCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LivePollCountOutputType
     */
    select?: LivePollCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LivePollCountOutputType without action
   */
  export type LivePollCountOutputTypeCountVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PollVoteWhereInput
  }


  /**
   * Count Type ChatCountOutputType
   */

  export type ChatCountOutputType = {
    messages: number
  }

  export type ChatCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | ChatCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * ChatCountOutputType without action
   */
  export type ChatCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatCountOutputType
     */
    select?: ChatCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChatCountOutputType without action
   */
  export type ChatCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatMessageWhereInput
  }


  /**
   * Count Type AIPlaylistCountOutputType
   */

  export type AIPlaylistCountOutputType = {
    items: number
  }

  export type AIPlaylistCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | AIPlaylistCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * AIPlaylistCountOutputType without action
   */
  export type AIPlaylistCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIPlaylistCountOutputType
     */
    select?: AIPlaylistCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AIPlaylistCountOutputType without action
   */
  export type AIPlaylistCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIPlaylistItemWhereInput
  }


  /**
   * Count Type AIModuleCountOutputType
   */

  export type AIModuleCountOutputType = {
    learningPathItems: number
    quizAttempts: number
    ratings: number
    PracticeAttempts: number
  }

  export type AIModuleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    learningPathItems?: boolean | AIModuleCountOutputTypeCountLearningPathItemsArgs
    quizAttempts?: boolean | AIModuleCountOutputTypeCountQuizAttemptsArgs
    ratings?: boolean | AIModuleCountOutputTypeCountRatingsArgs
    PracticeAttempts?: boolean | AIModuleCountOutputTypeCountPracticeAttemptsArgs
  }

  // Custom InputTypes
  /**
   * AIModuleCountOutputType without action
   */
  export type AIModuleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModuleCountOutputType
     */
    select?: AIModuleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AIModuleCountOutputType without action
   */
  export type AIModuleCountOutputTypeCountLearningPathItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIModuleLearningPathItemWhereInput
  }

  /**
   * AIModuleCountOutputType without action
   */
  export type AIModuleCountOutputTypeCountQuizAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIModuleQuizAttemptWhereInput
  }

  /**
   * AIModuleCountOutputType without action
   */
  export type AIModuleCountOutputTypeCountRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIModuleRatingWhereInput
  }

  /**
   * AIModuleCountOutputType without action
   */
  export type AIModuleCountOutputTypeCountPracticeAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PracticeAttemptWhereInput
  }


  /**
   * Count Type AIChatCountOutputType
   */

  export type AIChatCountOutputType = {
    messages: number
  }

  export type AIChatCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | AIChatCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * AIChatCountOutputType without action
   */
  export type AIChatCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIChatCountOutputType
     */
    select?: AIChatCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AIChatCountOutputType without action
   */
  export type AIChatCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIChatMessageWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    xp: number | null
    level: number | null
    streak: number | null
  }

  export type UserSumAggregateOutputType = {
    xp: number | null
    level: number | null
    streak: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
    bio: string | null
    avatarUrl: string | null
    password: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    xp: number | null
    level: number | null
    streak: number | null
    lastStreakUpdate: Date | null
    lastLoginDate: Date | null
    isAdmin: boolean | null
    role: string | null
    cramMode: boolean | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
    bio: string | null
    avatarUrl: string | null
    password: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    xp: number | null
    level: number | null
    streak: number | null
    lastStreakUpdate: Date | null
    lastLoginDate: Date | null
    isAdmin: boolean | null
    role: string | null
    cramMode: boolean | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    emailVerified: number
    image: number
    bio: number
    avatarUrl: number
    password: number
    name: number
    createdAt: number
    updatedAt: number
    xp: number
    level: number
    streak: number
    lastStreakUpdate: number
    lastLoginDate: number
    isAdmin: number
    role: number
    interests: number
    learningStyle: number
    cramMode: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    xp?: true
    level?: true
    streak?: true
  }

  export type UserSumAggregateInputType = {
    xp?: true
    level?: true
    streak?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    emailVerified?: true
    image?: true
    bio?: true
    avatarUrl?: true
    password?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    xp?: true
    level?: true
    streak?: true
    lastStreakUpdate?: true
    lastLoginDate?: true
    isAdmin?: true
    role?: true
    cramMode?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    emailVerified?: true
    image?: true
    bio?: true
    avatarUrl?: true
    password?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    xp?: true
    level?: true
    streak?: true
    lastStreakUpdate?: true
    lastLoginDate?: true
    isAdmin?: true
    role?: true
    cramMode?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    emailVerified?: true
    image?: true
    bio?: true
    avatarUrl?: true
    password?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    xp?: true
    level?: true
    streak?: true
    lastStreakUpdate?: true
    lastLoginDate?: true
    isAdmin?: true
    role?: true
    interests?: true
    learningStyle?: true
    cramMode?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    emailVerified: Date | null
    image: string | null
    bio: string | null
    avatarUrl: string | null
    password: string
    name: string | null
    createdAt: Date
    updatedAt: Date
    xp: number
    level: number
    streak: number
    lastStreakUpdate: Date | null
    lastLoginDate: Date
    isAdmin: boolean
    role: string | null
    interests: string[]
    learningStyle: JsonValue | null
    cramMode: boolean
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    bio?: boolean
    avatarUrl?: boolean
    password?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    xp?: boolean
    level?: boolean
    streak?: boolean
    lastStreakUpdate?: boolean
    lastLoginDate?: boolean
    isAdmin?: boolean
    role?: boolean
    interests?: boolean
    learningStyle?: boolean
    cramMode?: boolean
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    activities?: boolean | User$activitiesArgs<ExtArgs>
    learningPreferences?: boolean | User$learningPreferencesArgs<ExtArgs>
    topics?: boolean | User$topicsArgs<ExtArgs>
    progress?: boolean | User$progressArgs<ExtArgs>
    badges?: boolean | User$badgesArgs<ExtArgs>
    upcomingReviews?: boolean | User$upcomingReviewsArgs<ExtArgs>
    learningPaths?: boolean | User$learningPathsArgs<ExtArgs>
    bookmarks?: boolean | User$bookmarksArgs<ExtArgs>
    quizAttempts?: boolean | User$quizAttemptsArgs<ExtArgs>
    knowledgeNodes?: boolean | User$knowledgeNodesArgs<ExtArgs>
    leaderboardEntries?: boolean | User$leaderboardEntriesArgs<ExtArgs>
    reviewSessions?: boolean | User$reviewSessionsArgs<ExtArgs>
    workspaces?: boolean | User$workspacesArgs<ExtArgs>
    chatMessages?: boolean | User$chatMessagesArgs<ExtArgs>
    ownedWorkspaces?: boolean | User$ownedWorkspacesArgs<ExtArgs>
    settings?: boolean | User$settingsArgs<ExtArgs>
    analyticsEntries?: boolean | User$analyticsEntriesArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    passwordlessTokens?: boolean | User$passwordlessTokensArgs<ExtArgs>
    dailyChallenges?: boolean | User$dailyChallengesArgs<ExtArgs>
    externalGoals?: boolean | User$externalGoalsArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    contentRatings?: boolean | User$contentRatingsArgs<ExtArgs>
    challengeScores?: boolean | User$challengeScoresArgs<ExtArgs>
    pollVotes?: boolean | User$pollVotesArgs<ExtArgs>
    aiRecommendations?: boolean | User$aiRecommendationsArgs<ExtArgs>
    aiModules?: boolean | User$aiModulesArgs<ExtArgs>
    aiModuleQuizAttempts?: boolean | User$aiModuleQuizAttemptsArgs<ExtArgs>
    aiModuleRatings?: boolean | User$aiModuleRatingsArgs<ExtArgs>
    UserProgress?: boolean | User$UserProgressArgs<ExtArgs>
    AIChat?: boolean | User$AIChatArgs<ExtArgs>
    PracticeAttempts?: boolean | User$PracticeAttemptsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    bio?: boolean
    avatarUrl?: boolean
    password?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    xp?: boolean
    level?: boolean
    streak?: boolean
    lastStreakUpdate?: boolean
    lastLoginDate?: boolean
    isAdmin?: boolean
    role?: boolean
    interests?: boolean
    learningStyle?: boolean
    cramMode?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    bio?: boolean
    avatarUrl?: boolean
    password?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    xp?: boolean
    level?: boolean
    streak?: boolean
    lastStreakUpdate?: boolean
    lastLoginDate?: boolean
    isAdmin?: boolean
    role?: boolean
    interests?: boolean
    learningStyle?: boolean
    cramMode?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    bio?: boolean
    avatarUrl?: boolean
    password?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    xp?: boolean
    level?: boolean
    streak?: boolean
    lastStreakUpdate?: boolean
    lastLoginDate?: boolean
    isAdmin?: boolean
    role?: boolean
    interests?: boolean
    learningStyle?: boolean
    cramMode?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "emailVerified" | "image" | "bio" | "avatarUrl" | "password" | "name" | "createdAt" | "updatedAt" | "xp" | "level" | "streak" | "lastStreakUpdate" | "lastLoginDate" | "isAdmin" | "role" | "interests" | "learningStyle" | "cramMode", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    activities?: boolean | User$activitiesArgs<ExtArgs>
    learningPreferences?: boolean | User$learningPreferencesArgs<ExtArgs>
    topics?: boolean | User$topicsArgs<ExtArgs>
    progress?: boolean | User$progressArgs<ExtArgs>
    badges?: boolean | User$badgesArgs<ExtArgs>
    upcomingReviews?: boolean | User$upcomingReviewsArgs<ExtArgs>
    learningPaths?: boolean | User$learningPathsArgs<ExtArgs>
    bookmarks?: boolean | User$bookmarksArgs<ExtArgs>
    quizAttempts?: boolean | User$quizAttemptsArgs<ExtArgs>
    knowledgeNodes?: boolean | User$knowledgeNodesArgs<ExtArgs>
    leaderboardEntries?: boolean | User$leaderboardEntriesArgs<ExtArgs>
    reviewSessions?: boolean | User$reviewSessionsArgs<ExtArgs>
    workspaces?: boolean | User$workspacesArgs<ExtArgs>
    chatMessages?: boolean | User$chatMessagesArgs<ExtArgs>
    ownedWorkspaces?: boolean | User$ownedWorkspacesArgs<ExtArgs>
    settings?: boolean | User$settingsArgs<ExtArgs>
    analyticsEntries?: boolean | User$analyticsEntriesArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    passwordlessTokens?: boolean | User$passwordlessTokensArgs<ExtArgs>
    dailyChallenges?: boolean | User$dailyChallengesArgs<ExtArgs>
    externalGoals?: boolean | User$externalGoalsArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    contentRatings?: boolean | User$contentRatingsArgs<ExtArgs>
    challengeScores?: boolean | User$challengeScoresArgs<ExtArgs>
    pollVotes?: boolean | User$pollVotesArgs<ExtArgs>
    aiRecommendations?: boolean | User$aiRecommendationsArgs<ExtArgs>
    aiModules?: boolean | User$aiModulesArgs<ExtArgs>
    aiModuleQuizAttempts?: boolean | User$aiModuleQuizAttemptsArgs<ExtArgs>
    aiModuleRatings?: boolean | User$aiModuleRatingsArgs<ExtArgs>
    UserProgress?: boolean | User$UserProgressArgs<ExtArgs>
    AIChat?: boolean | User$AIChatArgs<ExtArgs>
    PracticeAttempts?: boolean | User$PracticeAttemptsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      activities: Prisma.$ActivityPayload<ExtArgs>[]
      learningPreferences: Prisma.$LearningPreferencesPayload<ExtArgs> | null
      topics: Prisma.$TopicPayload<ExtArgs>[]
      progress: Prisma.$ProgressPayload<ExtArgs>[]
      badges: Prisma.$BadgePayload<ExtArgs>[]
      upcomingReviews: Prisma.$UpcomingReviewPayload<ExtArgs>[]
      learningPaths: Prisma.$LearningPathPayload<ExtArgs>[]
      bookmarks: Prisma.$BookmarkPayload<ExtArgs>[]
      quizAttempts: Prisma.$QuizAttemptPayload<ExtArgs>[]
      knowledgeNodes: Prisma.$KnowledgeNodePayload<ExtArgs>[]
      leaderboardEntries: Prisma.$LeaderboardEntryPayload<ExtArgs>[]
      reviewSessions: Prisma.$ReviewSessionPayload<ExtArgs>[]
      workspaces: Prisma.$WorkspaceMemberPayload<ExtArgs>[]
      chatMessages: Prisma.$ChatMessagePayload<ExtArgs>[]
      ownedWorkspaces: Prisma.$WorkspacePayload<ExtArgs>[]
      settings: Prisma.$UserSettingsPayload<ExtArgs> | null
      analyticsEntries: Prisma.$AnalyticsEntryPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      passwordlessTokens: Prisma.$PasswordlessTokenPayload<ExtArgs>[]
      dailyChallenges: Prisma.$DailyChallengePayload<ExtArgs>[]
      externalGoals: Prisma.$ExternalGoalPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      contentRatings: Prisma.$ContentRatingPayload<ExtArgs>[]
      challengeScores: Prisma.$ChallengeScorePayload<ExtArgs>[]
      pollVotes: Prisma.$PollVotePayload<ExtArgs>[]
      aiRecommendations: Prisma.$AIRecommendationPayload<ExtArgs>[]
      aiModules: Prisma.$AIModulePayload<ExtArgs>[]
      aiModuleQuizAttempts: Prisma.$AIModuleQuizAttemptPayload<ExtArgs>[]
      aiModuleRatings: Prisma.$AIModuleRatingPayload<ExtArgs>[]
      UserProgress: Prisma.$UserProgressPayload<ExtArgs>[]
      AIChat: Prisma.$AIChatPayload<ExtArgs>[]
      PracticeAttempts: Prisma.$PracticeAttemptPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      emailVerified: Date | null
      image: string | null
      bio: string | null
      avatarUrl: string | null
      password: string
      name: string | null
      createdAt: Date
      updatedAt: Date
      xp: number
      level: number
      streak: number
      lastStreakUpdate: Date | null
      lastLoginDate: Date
      isAdmin: boolean
      role: string | null
      interests: string[]
      learningStyle: Prisma.JsonValue | null
      cramMode: boolean
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    activities<T extends User$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, User$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    learningPreferences<T extends User$learningPreferencesArgs<ExtArgs> = {}>(args?: Subset<T, User$learningPreferencesArgs<ExtArgs>>): Prisma__LearningPreferencesClient<$Result.GetResult<Prisma.$LearningPreferencesPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    topics<T extends User$topicsArgs<ExtArgs> = {}>(args?: Subset<T, User$topicsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    progress<T extends User$progressArgs<ExtArgs> = {}>(args?: Subset<T, User$progressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgressPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    badges<T extends User$badgesArgs<ExtArgs> = {}>(args?: Subset<T, User$badgesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    upcomingReviews<T extends User$upcomingReviewsArgs<ExtArgs> = {}>(args?: Subset<T, User$upcomingReviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UpcomingReviewPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    learningPaths<T extends User$learningPathsArgs<ExtArgs> = {}>(args?: Subset<T, User$learningPathsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningPathPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    bookmarks<T extends User$bookmarksArgs<ExtArgs> = {}>(args?: Subset<T, User$bookmarksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookmarkPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    quizAttempts<T extends User$quizAttemptsArgs<ExtArgs> = {}>(args?: Subset<T, User$quizAttemptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    knowledgeNodes<T extends User$knowledgeNodesArgs<ExtArgs> = {}>(args?: Subset<T, User$knowledgeNodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeNodePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    leaderboardEntries<T extends User$leaderboardEntriesArgs<ExtArgs> = {}>(args?: Subset<T, User$leaderboardEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaderboardEntryPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    reviewSessions<T extends User$reviewSessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewSessionPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    workspaces<T extends User$workspacesArgs<ExtArgs> = {}>(args?: Subset<T, User$workspacesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceMemberPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    chatMessages<T extends User$chatMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$chatMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    ownedWorkspaces<T extends User$ownedWorkspacesArgs<ExtArgs> = {}>(args?: Subset<T, User$ownedWorkspacesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    settings<T extends User$settingsArgs<ExtArgs> = {}>(args?: Subset<T, User$settingsArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    analyticsEntries<T extends User$analyticsEntriesArgs<ExtArgs> = {}>(args?: Subset<T, User$analyticsEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsEntryPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    passwordlessTokens<T extends User$passwordlessTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$passwordlessTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordlessTokenPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    dailyChallenges<T extends User$dailyChallengesArgs<ExtArgs> = {}>(args?: Subset<T, User$dailyChallengesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyChallengePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    externalGoals<T extends User$externalGoalsArgs<ExtArgs> = {}>(args?: Subset<T, User$externalGoalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExternalGoalPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    comments<T extends User$commentsArgs<ExtArgs> = {}>(args?: Subset<T, User$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    contentRatings<T extends User$contentRatingsArgs<ExtArgs> = {}>(args?: Subset<T, User$contentRatingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentRatingPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    challengeScores<T extends User$challengeScoresArgs<ExtArgs> = {}>(args?: Subset<T, User$challengeScoresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeScorePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    pollVotes<T extends User$pollVotesArgs<ExtArgs> = {}>(args?: Subset<T, User$pollVotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PollVotePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    aiRecommendations<T extends User$aiRecommendationsArgs<ExtArgs> = {}>(args?: Subset<T, User$aiRecommendationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIRecommendationPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    aiModules<T extends User$aiModulesArgs<ExtArgs> = {}>(args?: Subset<T, User$aiModulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIModulePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    aiModuleQuizAttempts<T extends User$aiModuleQuizAttemptsArgs<ExtArgs> = {}>(args?: Subset<T, User$aiModuleQuizAttemptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIModuleQuizAttemptPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    aiModuleRatings<T extends User$aiModuleRatingsArgs<ExtArgs> = {}>(args?: Subset<T, User$aiModuleRatingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIModuleRatingPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    UserProgress<T extends User$UserProgressArgs<ExtArgs> = {}>(args?: Subset<T, User$UserProgressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    AIChat<T extends User$AIChatArgs<ExtArgs> = {}>(args?: Subset<T, User$AIChatArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIChatPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    PracticeAttempts<T extends User$PracticeAttemptsArgs<ExtArgs> = {}>(args?: Subset<T, User$PracticeAttemptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PracticeAttemptPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly image: FieldRef<"User", 'String'>
    readonly bio: FieldRef<"User", 'String'>
    readonly avatarUrl: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly xp: FieldRef<"User", 'Int'>
    readonly level: FieldRef<"User", 'Int'>
    readonly streak: FieldRef<"User", 'Int'>
    readonly lastStreakUpdate: FieldRef<"User", 'DateTime'>
    readonly lastLoginDate: FieldRef<"User", 'DateTime'>
    readonly isAdmin: FieldRef<"User", 'Boolean'>
    readonly role: FieldRef<"User", 'String'>
    readonly interests: FieldRef<"User", 'String[]'>
    readonly learningStyle: FieldRef<"User", 'Json'>
    readonly cramMode: FieldRef<"User", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.activities
   */
  export type User$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    cursor?: ActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * User.learningPreferences
   */
  export type User$learningPreferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPreferences
     */
    select?: LearningPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPreferences
     */
    omit?: LearningPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPreferencesInclude<ExtArgs> | null
    where?: LearningPreferencesWhereInput
  }

  /**
   * User.topics
   */
  export type User$topicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    where?: TopicWhereInput
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    cursor?: TopicWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * User.progress
   */
  export type User$progressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Progress
     */
    select?: ProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Progress
     */
    omit?: ProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressInclude<ExtArgs> | null
    where?: ProgressWhereInput
    orderBy?: ProgressOrderByWithRelationInput | ProgressOrderByWithRelationInput[]
    cursor?: ProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProgressScalarFieldEnum | ProgressScalarFieldEnum[]
  }

  /**
   * User.badges
   */
  export type User$badgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    where?: BadgeWhereInput
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    cursor?: BadgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * User.upcomingReviews
   */
  export type User$upcomingReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpcomingReview
     */
    select?: UpcomingReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UpcomingReview
     */
    omit?: UpcomingReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpcomingReviewInclude<ExtArgs> | null
    where?: UpcomingReviewWhereInput
    orderBy?: UpcomingReviewOrderByWithRelationInput | UpcomingReviewOrderByWithRelationInput[]
    cursor?: UpcomingReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UpcomingReviewScalarFieldEnum | UpcomingReviewScalarFieldEnum[]
  }

  /**
   * User.learningPaths
   */
  export type User$learningPathsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPath
     */
    select?: LearningPathSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPath
     */
    omit?: LearningPathOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathInclude<ExtArgs> | null
    where?: LearningPathWhereInput
    orderBy?: LearningPathOrderByWithRelationInput | LearningPathOrderByWithRelationInput[]
    cursor?: LearningPathWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LearningPathScalarFieldEnum | LearningPathScalarFieldEnum[]
  }

  /**
   * User.bookmarks
   */
  export type User$bookmarksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookmark
     */
    omit?: BookmarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkInclude<ExtArgs> | null
    where?: BookmarkWhereInput
    orderBy?: BookmarkOrderByWithRelationInput | BookmarkOrderByWithRelationInput[]
    cursor?: BookmarkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookmarkScalarFieldEnum | BookmarkScalarFieldEnum[]
  }

  /**
   * User.quizAttempts
   */
  export type User$quizAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    where?: QuizAttemptWhereInput
    orderBy?: QuizAttemptOrderByWithRelationInput | QuizAttemptOrderByWithRelationInput[]
    cursor?: QuizAttemptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizAttemptScalarFieldEnum | QuizAttemptScalarFieldEnum[]
  }

  /**
   * User.knowledgeNodes
   */
  export type User$knowledgeNodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeNode
     */
    select?: KnowledgeNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeNode
     */
    omit?: KnowledgeNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeNodeInclude<ExtArgs> | null
    where?: KnowledgeNodeWhereInput
    orderBy?: KnowledgeNodeOrderByWithRelationInput | KnowledgeNodeOrderByWithRelationInput[]
    cursor?: KnowledgeNodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KnowledgeNodeScalarFieldEnum | KnowledgeNodeScalarFieldEnum[]
  }

  /**
   * User.leaderboardEntries
   */
  export type User$leaderboardEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaderboardEntry
     */
    omit?: LeaderboardEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null
    where?: LeaderboardEntryWhereInput
    orderBy?: LeaderboardEntryOrderByWithRelationInput | LeaderboardEntryOrderByWithRelationInput[]
    cursor?: LeaderboardEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaderboardEntryScalarFieldEnum | LeaderboardEntryScalarFieldEnum[]
  }

  /**
   * User.reviewSessions
   */
  export type User$reviewSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewSession
     */
    select?: ReviewSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewSession
     */
    omit?: ReviewSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewSessionInclude<ExtArgs> | null
    where?: ReviewSessionWhereInput
    orderBy?: ReviewSessionOrderByWithRelationInput | ReviewSessionOrderByWithRelationInput[]
    cursor?: ReviewSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewSessionScalarFieldEnum | ReviewSessionScalarFieldEnum[]
  }

  /**
   * User.workspaces
   */
  export type User$workspacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceMember
     */
    select?: WorkspaceMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceMember
     */
    omit?: WorkspaceMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceMemberInclude<ExtArgs> | null
    where?: WorkspaceMemberWhereInput
    orderBy?: WorkspaceMemberOrderByWithRelationInput | WorkspaceMemberOrderByWithRelationInput[]
    cursor?: WorkspaceMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkspaceMemberScalarFieldEnum | WorkspaceMemberScalarFieldEnum[]
  }

  /**
   * User.chatMessages
   */
  export type User$chatMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    where?: ChatMessageWhereInput
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    cursor?: ChatMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * User.ownedWorkspaces
   */
  export type User$ownedWorkspacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    where?: WorkspaceWhereInput
    orderBy?: WorkspaceOrderByWithRelationInput | WorkspaceOrderByWithRelationInput[]
    cursor?: WorkspaceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkspaceScalarFieldEnum | WorkspaceScalarFieldEnum[]
  }

  /**
   * User.settings
   */
  export type User$settingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    where?: UserSettingsWhereInput
  }

  /**
   * User.analyticsEntries
   */
  export type User$analyticsEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEntry
     */
    select?: AnalyticsEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEntry
     */
    omit?: AnalyticsEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEntryInclude<ExtArgs> | null
    where?: AnalyticsEntryWhereInput
    orderBy?: AnalyticsEntryOrderByWithRelationInput | AnalyticsEntryOrderByWithRelationInput[]
    cursor?: AnalyticsEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnalyticsEntryScalarFieldEnum | AnalyticsEntryScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.passwordlessTokens
   */
  export type User$passwordlessTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordlessToken
     */
    select?: PasswordlessTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordlessToken
     */
    omit?: PasswordlessTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordlessTokenInclude<ExtArgs> | null
    where?: PasswordlessTokenWhereInput
    orderBy?: PasswordlessTokenOrderByWithRelationInput | PasswordlessTokenOrderByWithRelationInput[]
    cursor?: PasswordlessTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordlessTokenScalarFieldEnum | PasswordlessTokenScalarFieldEnum[]
  }

  /**
   * User.dailyChallenges
   */
  export type User$dailyChallengesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyChallenge
     */
    select?: DailyChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyChallenge
     */
    omit?: DailyChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyChallengeInclude<ExtArgs> | null
    where?: DailyChallengeWhereInput
    orderBy?: DailyChallengeOrderByWithRelationInput | DailyChallengeOrderByWithRelationInput[]
    cursor?: DailyChallengeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DailyChallengeScalarFieldEnum | DailyChallengeScalarFieldEnum[]
  }

  /**
   * User.externalGoals
   */
  export type User$externalGoalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalGoal
     */
    select?: ExternalGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalGoal
     */
    omit?: ExternalGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalGoalInclude<ExtArgs> | null
    where?: ExternalGoalWhereInput
    orderBy?: ExternalGoalOrderByWithRelationInput | ExternalGoalOrderByWithRelationInput[]
    cursor?: ExternalGoalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExternalGoalScalarFieldEnum | ExternalGoalScalarFieldEnum[]
  }

  /**
   * User.comments
   */
  export type User$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * User.contentRatings
   */
  export type User$contentRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentRating
     */
    select?: ContentRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentRating
     */
    omit?: ContentRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentRatingInclude<ExtArgs> | null
    where?: ContentRatingWhereInput
    orderBy?: ContentRatingOrderByWithRelationInput | ContentRatingOrderByWithRelationInput[]
    cursor?: ContentRatingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentRatingScalarFieldEnum | ContentRatingScalarFieldEnum[]
  }

  /**
   * User.challengeScores
   */
  export type User$challengeScoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeScore
     */
    select?: ChallengeScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeScore
     */
    omit?: ChallengeScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeScoreInclude<ExtArgs> | null
    where?: ChallengeScoreWhereInput
    orderBy?: ChallengeScoreOrderByWithRelationInput | ChallengeScoreOrderByWithRelationInput[]
    cursor?: ChallengeScoreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChallengeScoreScalarFieldEnum | ChallengeScoreScalarFieldEnum[]
  }

  /**
   * User.pollVotes
   */
  export type User$pollVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollVote
     */
    select?: PollVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PollVote
     */
    omit?: PollVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollVoteInclude<ExtArgs> | null
    where?: PollVoteWhereInput
    orderBy?: PollVoteOrderByWithRelationInput | PollVoteOrderByWithRelationInput[]
    cursor?: PollVoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PollVoteScalarFieldEnum | PollVoteScalarFieldEnum[]
  }

  /**
   * User.aiRecommendations
   */
  export type User$aiRecommendationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRecommendation
     */
    select?: AIRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIRecommendation
     */
    omit?: AIRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRecommendationInclude<ExtArgs> | null
    where?: AIRecommendationWhereInput
    orderBy?: AIRecommendationOrderByWithRelationInput | AIRecommendationOrderByWithRelationInput[]
    cursor?: AIRecommendationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AIRecommendationScalarFieldEnum | AIRecommendationScalarFieldEnum[]
  }

  /**
   * User.aiModules
   */
  export type User$aiModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModule
     */
    select?: AIModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIModule
     */
    omit?: AIModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModuleInclude<ExtArgs> | null
    where?: AIModuleWhereInput
    orderBy?: AIModuleOrderByWithRelationInput | AIModuleOrderByWithRelationInput[]
    cursor?: AIModuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AIModuleScalarFieldEnum | AIModuleScalarFieldEnum[]
  }

  /**
   * User.aiModuleQuizAttempts
   */
  export type User$aiModuleQuizAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModuleQuizAttempt
     */
    select?: AIModuleQuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIModuleQuizAttempt
     */
    omit?: AIModuleQuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModuleQuizAttemptInclude<ExtArgs> | null
    where?: AIModuleQuizAttemptWhereInput
    orderBy?: AIModuleQuizAttemptOrderByWithRelationInput | AIModuleQuizAttemptOrderByWithRelationInput[]
    cursor?: AIModuleQuizAttemptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AIModuleQuizAttemptScalarFieldEnum | AIModuleQuizAttemptScalarFieldEnum[]
  }

  /**
   * User.aiModuleRatings
   */
  export type User$aiModuleRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModuleRating
     */
    select?: AIModuleRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIModuleRating
     */
    omit?: AIModuleRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModuleRatingInclude<ExtArgs> | null
    where?: AIModuleRatingWhereInput
    orderBy?: AIModuleRatingOrderByWithRelationInput | AIModuleRatingOrderByWithRelationInput[]
    cursor?: AIModuleRatingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AIModuleRatingScalarFieldEnum | AIModuleRatingScalarFieldEnum[]
  }

  /**
   * User.UserProgress
   */
  export type User$UserProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    where?: UserProgressWhereInput
    orderBy?: UserProgressOrderByWithRelationInput | UserProgressOrderByWithRelationInput[]
    cursor?: UserProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserProgressScalarFieldEnum | UserProgressScalarFieldEnum[]
  }

  /**
   * User.AIChat
   */
  export type User$AIChatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIChat
     */
    select?: AIChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIChat
     */
    omit?: AIChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIChatInclude<ExtArgs> | null
    where?: AIChatWhereInput
    orderBy?: AIChatOrderByWithRelationInput | AIChatOrderByWithRelationInput[]
    cursor?: AIChatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AIChatScalarFieldEnum | AIChatScalarFieldEnum[]
  }

  /**
   * User.PracticeAttempts
   */
  export type User$PracticeAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticeAttempt
     */
    select?: PracticeAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PracticeAttempt
     */
    omit?: PracticeAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PracticeAttemptInclude<ExtArgs> | null
    where?: PracticeAttemptWhereInput
    orderBy?: PracticeAttemptOrderByWithRelationInput | PracticeAttemptOrderByWithRelationInput[]
    cursor?: PracticeAttemptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PracticeAttemptScalarFieldEnum | PracticeAttemptScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    oauth_token_secret: string | null
    oauth_token: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    oauth_token_secret: string | null
    oauth_token: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    oauth_token_secret: number
    oauth_token: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    oauth_token_secret?: true
    oauth_token?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    oauth_token_secret?: true
    oauth_token?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    oauth_token_secret?: true
    oauth_token?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    oauth_token_secret: string | null
    oauth_token: string | null
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    oauth_token_secret?: boolean
    oauth_token?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    oauth_token_secret?: boolean
    oauth_token?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    oauth_token_secret?: boolean
    oauth_token?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    oauth_token_secret?: boolean
    oauth_token?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "provider" | "providerAccountId" | "refresh_token" | "access_token" | "expires_at" | "token_type" | "scope" | "id_token" | "session_state" | "oauth_token_secret" | "oauth_token", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      provider: string
      providerAccountId: string
      refresh_token: string | null
      access_token: string | null
      expires_at: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      session_state: string | null
      oauth_token_secret: string | null
      oauth_token: string | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */ 
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'String'>
    readonly provider: FieldRef<"Account", 'String'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly refresh_token: FieldRef<"Account", 'String'>
    readonly access_token: FieldRef<"Account", 'String'>
    readonly expires_at: FieldRef<"Account", 'Int'>
    readonly token_type: FieldRef<"Account", 'String'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly id_token: FieldRef<"Account", 'String'>
    readonly session_state: FieldRef<"Account", 'String'>
    readonly oauth_token_secret: FieldRef<"Account", 'String'>
    readonly oauth_token: FieldRef<"Account", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expires: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    sessionToken: string
    userId: string
    expires: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionToken" | "userId" | "expires", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionToken: string
      userId: string
      expires: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */ 
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly expires: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    identifier: number
    token: number
    expires: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithAggregationInput | VerificationTokenOrderByWithAggregationInput[]
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type VerificationTokenGroupByOutputType = {
    identifier: string
    token: string
    expires: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectScalar = {
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }

  export type VerificationTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"identifier" | "token" | "expires", ExtArgs["result"]["verificationToken"]>

  export type $VerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      identifier: string
      token: string
      expires: Date
    }, ExtArgs["result"]["verificationToken"]>
    composites: {}
  }

  type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$VerificationTokenPayload, S>

  type VerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'], meta: { name: 'VerificationToken' } }
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.findMany({ select: { identifier: true } })
     * 
     */
    findMany<T extends VerificationTokenFindManyArgs>(args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
     */
    create<T extends VerificationTokenCreateArgs>(args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationTokenCreateManyArgs>(args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerificationTokens and returns the data saved in the database.
     * @param {VerificationTokenCreateManyAndReturnArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.createManyAndReturn({
     *   select: { identifier: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
     */
    delete<T extends VerificationTokenDeleteArgs>(args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationTokenUpdateArgs>(args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens and returns the data updated in the database.
     * @param {VerificationTokenUpdateManyAndReturnArgs} args - Arguments to update many VerificationTokens.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.updateManyAndReturn({
     *   select: { identifier: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationToken model
   */
  readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationToken model
   */ 
  interface VerificationTokenFieldRefs {
    readonly identifier: FieldRef<"VerificationToken", 'String'>
    readonly token: FieldRef<"VerificationToken", 'String'>
    readonly expires: FieldRef<"VerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken createManyAndReturn
   */
  export type VerificationTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken updateManyAndReturn
   */
  export type VerificationTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to delete.
     */
    limit?: number
  }

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
  }


  /**
   * Model Activity
   */

  export type AggregateActivity = {
    _count: ActivityCountAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  export type ActivityMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    description: string | null
    createdAt: Date | null
  }

  export type ActivityMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    description: string | null
    createdAt: Date | null
  }

  export type ActivityCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    description: number
    createdAt: number
    _all: number
  }


  export type ActivityMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    description?: true
    createdAt?: true
  }

  export type ActivityMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    description?: true
    createdAt?: true
  }

  export type ActivityCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    description?: true
    createdAt?: true
    _all?: true
  }

  export type ActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Activity to aggregate.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Activities
    **/
    _count?: true | ActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityMaxAggregateInputType
  }

  export type GetActivityAggregateType<T extends ActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivity[P]>
      : GetScalarType<T[P], AggregateActivity[P]>
  }




  export type ActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithAggregationInput | ActivityOrderByWithAggregationInput[]
    by: ActivityScalarFieldEnum[] | ActivityScalarFieldEnum
    having?: ActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityCountAggregateInputType | true
    _min?: ActivityMinAggregateInputType
    _max?: ActivityMaxAggregateInputType
  }

  export type ActivityGroupByOutputType = {
    id: string
    userId: string
    type: string
    description: string
    createdAt: Date
    _count: ActivityCountAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  type GetActivityGroupByPayload<T extends ActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityGroupByOutputType[P]>
        }
      >
    >


  export type ActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    description?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    description?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    description?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    description?: boolean
    createdAt?: boolean
  }

  export type ActivityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "description" | "createdAt", ExtArgs["result"]["activity"]>
  export type ActivityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ActivityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ActivityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Activity"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      description: string
      createdAt: Date
    }, ExtArgs["result"]["activity"]>
    composites: {}
  }

  type ActivityGetPayload<S extends boolean | null | undefined | ActivityDefaultArgs> = $Result.GetResult<Prisma.$ActivityPayload, S>

  type ActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActivityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActivityCountAggregateInputType | true
    }

  export interface ActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Activity'], meta: { name: 'Activity' } }
    /**
     * Find zero or one Activity that matches the filter.
     * @param {ActivityFindUniqueArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityFindUniqueArgs>(args: SelectSubset<T, ActivityFindUniqueArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Activity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActivityFindUniqueOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Activity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityFindFirstArgs>(args?: SelectSubset<T, ActivityFindFirstArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Activity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Activities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Activities
     * const activities = await prisma.activity.findMany()
     * 
     * // Get first 10 Activities
     * const activities = await prisma.activity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityWithIdOnly = await prisma.activity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityFindManyArgs>(args?: SelectSubset<T, ActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Activity.
     * @param {ActivityCreateArgs} args - Arguments to create a Activity.
     * @example
     * // Create one Activity
     * const Activity = await prisma.activity.create({
     *   data: {
     *     // ... data to create a Activity
     *   }
     * })
     * 
     */
    create<T extends ActivityCreateArgs>(args: SelectSubset<T, ActivityCreateArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Activities.
     * @param {ActivityCreateManyArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activity = await prisma.activity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityCreateManyArgs>(args?: SelectSubset<T, ActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Activities and returns the data saved in the database.
     * @param {ActivityCreateManyAndReturnArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activity = await prisma.activity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Activities and only return the `id`
     * const activityWithIdOnly = await prisma.activity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Activity.
     * @param {ActivityDeleteArgs} args - Arguments to delete one Activity.
     * @example
     * // Delete one Activity
     * const Activity = await prisma.activity.delete({
     *   where: {
     *     // ... filter to delete one Activity
     *   }
     * })
     * 
     */
    delete<T extends ActivityDeleteArgs>(args: SelectSubset<T, ActivityDeleteArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Activity.
     * @param {ActivityUpdateArgs} args - Arguments to update one Activity.
     * @example
     * // Update one Activity
     * const activity = await prisma.activity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityUpdateArgs>(args: SelectSubset<T, ActivityUpdateArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Activities.
     * @param {ActivityDeleteManyArgs} args - Arguments to filter Activities to delete.
     * @example
     * // Delete a few Activities
     * const { count } = await prisma.activity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityDeleteManyArgs>(args?: SelectSubset<T, ActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Activities
     * const activity = await prisma.activity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityUpdateManyArgs>(args: SelectSubset<T, ActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activities and returns the data updated in the database.
     * @param {ActivityUpdateManyAndReturnArgs} args - Arguments to update many Activities.
     * @example
     * // Update many Activities
     * const activity = await prisma.activity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Activities and only return the `id`
     * const activityWithIdOnly = await prisma.activity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActivityUpdateManyAndReturnArgs>(args: SelectSubset<T, ActivityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Activity.
     * @param {ActivityUpsertArgs} args - Arguments to update or create a Activity.
     * @example
     * // Update or create a Activity
     * const activity = await prisma.activity.upsert({
     *   create: {
     *     // ... data to create a Activity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Activity we want to update
     *   }
     * })
     */
    upsert<T extends ActivityUpsertArgs>(args: SelectSubset<T, ActivityUpsertArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityCountArgs} args - Arguments to filter Activities to count.
     * @example
     * // Count the number of Activities
     * const count = await prisma.activity.count({
     *   where: {
     *     // ... the filter for the Activities we want to count
     *   }
     * })
    **/
    count<T extends ActivityCountArgs>(
      args?: Subset<T, ActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityAggregateArgs>(args: Subset<T, ActivityAggregateArgs>): Prisma.PrismaPromise<GetActivityAggregateType<T>>

    /**
     * Group by Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityGroupByArgs['orderBy'] }
        : { orderBy?: ActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Activity model
   */
  readonly fields: ActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Activity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Activity model
   */ 
  interface ActivityFieldRefs {
    readonly id: FieldRef<"Activity", 'String'>
    readonly userId: FieldRef<"Activity", 'String'>
    readonly type: FieldRef<"Activity", 'String'>
    readonly description: FieldRef<"Activity", 'String'>
    readonly createdAt: FieldRef<"Activity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Activity findUnique
   */
  export type ActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity findUniqueOrThrow
   */
  export type ActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity findFirst
   */
  export type ActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity findFirstOrThrow
   */
  export type ActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity findMany
   */
  export type ActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activities to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity create
   */
  export type ActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The data needed to create a Activity.
     */
    data: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
  }

  /**
   * Activity createMany
   */
  export type ActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Activities.
     */
    data: ActivityCreateManyInput | ActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Activity createManyAndReturn
   */
  export type ActivityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * The data used to create many Activities.
     */
    data: ActivityCreateManyInput | ActivityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Activity update
   */
  export type ActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The data needed to update a Activity.
     */
    data: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
    /**
     * Choose, which Activity to update.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity updateMany
   */
  export type ActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Activities.
     */
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyInput>
    /**
     * Filter which Activities to update
     */
    where?: ActivityWhereInput
    /**
     * Limit how many Activities to update.
     */
    limit?: number
  }

  /**
   * Activity updateManyAndReturn
   */
  export type ActivityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * The data used to update Activities.
     */
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyInput>
    /**
     * Filter which Activities to update
     */
    where?: ActivityWhereInput
    /**
     * Limit how many Activities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Activity upsert
   */
  export type ActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The filter to search for the Activity to update in case it exists.
     */
    where: ActivityWhereUniqueInput
    /**
     * In case the Activity found by the `where` argument doesn't exist, create a new Activity with this data.
     */
    create: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
    /**
     * In case the Activity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
  }

  /**
   * Activity delete
   */
  export type ActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter which Activity to delete.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity deleteMany
   */
  export type ActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Activities to delete
     */
    where?: ActivityWhereInput
    /**
     * Limit how many Activities to delete.
     */
    limit?: number
  }

  /**
   * Activity without action
   */
  export type ActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
  }


  /**
   * Model LearningPreferences
   */

  export type AggregateLearningPreferences = {
    _count: LearningPreferencesCountAggregateOutputType | null
    _avg: LearningPreferencesAvgAggregateOutputType | null
    _sum: LearningPreferencesSumAggregateOutputType | null
    _min: LearningPreferencesMinAggregateOutputType | null
    _max: LearningPreferencesMaxAggregateOutputType | null
  }

  export type LearningPreferencesAvgAggregateOutputType = {
    visualLearning: number | null
    auditoryLearning: number | null
    kinestheticLearning: number | null
  }

  export type LearningPreferencesSumAggregateOutputType = {
    visualLearning: number | null
    auditoryLearning: number | null
    kinestheticLearning: number | null
  }

  export type LearningPreferencesMinAggregateOutputType = {
    id: string | null
    userId: string | null
    visualLearning: number | null
    auditoryLearning: number | null
    kinestheticLearning: number | null
  }

  export type LearningPreferencesMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    visualLearning: number | null
    auditoryLearning: number | null
    kinestheticLearning: number | null
  }

  export type LearningPreferencesCountAggregateOutputType = {
    id: number
    userId: number
    visualLearning: number
    auditoryLearning: number
    kinestheticLearning: number
    _all: number
  }


  export type LearningPreferencesAvgAggregateInputType = {
    visualLearning?: true
    auditoryLearning?: true
    kinestheticLearning?: true
  }

  export type LearningPreferencesSumAggregateInputType = {
    visualLearning?: true
    auditoryLearning?: true
    kinestheticLearning?: true
  }

  export type LearningPreferencesMinAggregateInputType = {
    id?: true
    userId?: true
    visualLearning?: true
    auditoryLearning?: true
    kinestheticLearning?: true
  }

  export type LearningPreferencesMaxAggregateInputType = {
    id?: true
    userId?: true
    visualLearning?: true
    auditoryLearning?: true
    kinestheticLearning?: true
  }

  export type LearningPreferencesCountAggregateInputType = {
    id?: true
    userId?: true
    visualLearning?: true
    auditoryLearning?: true
    kinestheticLearning?: true
    _all?: true
  }

  export type LearningPreferencesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LearningPreferences to aggregate.
     */
    where?: LearningPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningPreferences to fetch.
     */
    orderBy?: LearningPreferencesOrderByWithRelationInput | LearningPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LearningPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LearningPreferences
    **/
    _count?: true | LearningPreferencesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LearningPreferencesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LearningPreferencesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LearningPreferencesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LearningPreferencesMaxAggregateInputType
  }

  export type GetLearningPreferencesAggregateType<T extends LearningPreferencesAggregateArgs> = {
        [P in keyof T & keyof AggregateLearningPreferences]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLearningPreferences[P]>
      : GetScalarType<T[P], AggregateLearningPreferences[P]>
  }




  export type LearningPreferencesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearningPreferencesWhereInput
    orderBy?: LearningPreferencesOrderByWithAggregationInput | LearningPreferencesOrderByWithAggregationInput[]
    by: LearningPreferencesScalarFieldEnum[] | LearningPreferencesScalarFieldEnum
    having?: LearningPreferencesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LearningPreferencesCountAggregateInputType | true
    _avg?: LearningPreferencesAvgAggregateInputType
    _sum?: LearningPreferencesSumAggregateInputType
    _min?: LearningPreferencesMinAggregateInputType
    _max?: LearningPreferencesMaxAggregateInputType
  }

  export type LearningPreferencesGroupByOutputType = {
    id: string
    userId: string
    visualLearning: number
    auditoryLearning: number
    kinestheticLearning: number
    _count: LearningPreferencesCountAggregateOutputType | null
    _avg: LearningPreferencesAvgAggregateOutputType | null
    _sum: LearningPreferencesSumAggregateOutputType | null
    _min: LearningPreferencesMinAggregateOutputType | null
    _max: LearningPreferencesMaxAggregateOutputType | null
  }

  type GetLearningPreferencesGroupByPayload<T extends LearningPreferencesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LearningPreferencesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LearningPreferencesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LearningPreferencesGroupByOutputType[P]>
            : GetScalarType<T[P], LearningPreferencesGroupByOutputType[P]>
        }
      >
    >


  export type LearningPreferencesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    visualLearning?: boolean
    auditoryLearning?: boolean
    kinestheticLearning?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["learningPreferences"]>

  export type LearningPreferencesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    visualLearning?: boolean
    auditoryLearning?: boolean
    kinestheticLearning?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["learningPreferences"]>

  export type LearningPreferencesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    visualLearning?: boolean
    auditoryLearning?: boolean
    kinestheticLearning?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["learningPreferences"]>

  export type LearningPreferencesSelectScalar = {
    id?: boolean
    userId?: boolean
    visualLearning?: boolean
    auditoryLearning?: boolean
    kinestheticLearning?: boolean
  }

  export type LearningPreferencesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "visualLearning" | "auditoryLearning" | "kinestheticLearning", ExtArgs["result"]["learningPreferences"]>
  export type LearningPreferencesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LearningPreferencesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LearningPreferencesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LearningPreferencesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LearningPreferences"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      visualLearning: number
      auditoryLearning: number
      kinestheticLearning: number
    }, ExtArgs["result"]["learningPreferences"]>
    composites: {}
  }

  type LearningPreferencesGetPayload<S extends boolean | null | undefined | LearningPreferencesDefaultArgs> = $Result.GetResult<Prisma.$LearningPreferencesPayload, S>

  type LearningPreferencesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LearningPreferencesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LearningPreferencesCountAggregateInputType | true
    }

  export interface LearningPreferencesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LearningPreferences'], meta: { name: 'LearningPreferences' } }
    /**
     * Find zero or one LearningPreferences that matches the filter.
     * @param {LearningPreferencesFindUniqueArgs} args - Arguments to find a LearningPreferences
     * @example
     * // Get one LearningPreferences
     * const learningPreferences = await prisma.learningPreferences.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LearningPreferencesFindUniqueArgs>(args: SelectSubset<T, LearningPreferencesFindUniqueArgs<ExtArgs>>): Prisma__LearningPreferencesClient<$Result.GetResult<Prisma.$LearningPreferencesPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one LearningPreferences that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LearningPreferencesFindUniqueOrThrowArgs} args - Arguments to find a LearningPreferences
     * @example
     * // Get one LearningPreferences
     * const learningPreferences = await prisma.learningPreferences.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LearningPreferencesFindUniqueOrThrowArgs>(args: SelectSubset<T, LearningPreferencesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LearningPreferencesClient<$Result.GetResult<Prisma.$LearningPreferencesPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first LearningPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPreferencesFindFirstArgs} args - Arguments to find a LearningPreferences
     * @example
     * // Get one LearningPreferences
     * const learningPreferences = await prisma.learningPreferences.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LearningPreferencesFindFirstArgs>(args?: SelectSubset<T, LearningPreferencesFindFirstArgs<ExtArgs>>): Prisma__LearningPreferencesClient<$Result.GetResult<Prisma.$LearningPreferencesPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first LearningPreferences that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPreferencesFindFirstOrThrowArgs} args - Arguments to find a LearningPreferences
     * @example
     * // Get one LearningPreferences
     * const learningPreferences = await prisma.learningPreferences.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LearningPreferencesFindFirstOrThrowArgs>(args?: SelectSubset<T, LearningPreferencesFindFirstOrThrowArgs<ExtArgs>>): Prisma__LearningPreferencesClient<$Result.GetResult<Prisma.$LearningPreferencesPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more LearningPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPreferencesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LearningPreferences
     * const learningPreferences = await prisma.learningPreferences.findMany()
     * 
     * // Get first 10 LearningPreferences
     * const learningPreferences = await prisma.learningPreferences.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const learningPreferencesWithIdOnly = await prisma.learningPreferences.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LearningPreferencesFindManyArgs>(args?: SelectSubset<T, LearningPreferencesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningPreferencesPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a LearningPreferences.
     * @param {LearningPreferencesCreateArgs} args - Arguments to create a LearningPreferences.
     * @example
     * // Create one LearningPreferences
     * const LearningPreferences = await prisma.learningPreferences.create({
     *   data: {
     *     // ... data to create a LearningPreferences
     *   }
     * })
     * 
     */
    create<T extends LearningPreferencesCreateArgs>(args: SelectSubset<T, LearningPreferencesCreateArgs<ExtArgs>>): Prisma__LearningPreferencesClient<$Result.GetResult<Prisma.$LearningPreferencesPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many LearningPreferences.
     * @param {LearningPreferencesCreateManyArgs} args - Arguments to create many LearningPreferences.
     * @example
     * // Create many LearningPreferences
     * const learningPreferences = await prisma.learningPreferences.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LearningPreferencesCreateManyArgs>(args?: SelectSubset<T, LearningPreferencesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LearningPreferences and returns the data saved in the database.
     * @param {LearningPreferencesCreateManyAndReturnArgs} args - Arguments to create many LearningPreferences.
     * @example
     * // Create many LearningPreferences
     * const learningPreferences = await prisma.learningPreferences.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LearningPreferences and only return the `id`
     * const learningPreferencesWithIdOnly = await prisma.learningPreferences.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LearningPreferencesCreateManyAndReturnArgs>(args?: SelectSubset<T, LearningPreferencesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningPreferencesPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a LearningPreferences.
     * @param {LearningPreferencesDeleteArgs} args - Arguments to delete one LearningPreferences.
     * @example
     * // Delete one LearningPreferences
     * const LearningPreferences = await prisma.learningPreferences.delete({
     *   where: {
     *     // ... filter to delete one LearningPreferences
     *   }
     * })
     * 
     */
    delete<T extends LearningPreferencesDeleteArgs>(args: SelectSubset<T, LearningPreferencesDeleteArgs<ExtArgs>>): Prisma__LearningPreferencesClient<$Result.GetResult<Prisma.$LearningPreferencesPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one LearningPreferences.
     * @param {LearningPreferencesUpdateArgs} args - Arguments to update one LearningPreferences.
     * @example
     * // Update one LearningPreferences
     * const learningPreferences = await prisma.learningPreferences.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LearningPreferencesUpdateArgs>(args: SelectSubset<T, LearningPreferencesUpdateArgs<ExtArgs>>): Prisma__LearningPreferencesClient<$Result.GetResult<Prisma.$LearningPreferencesPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more LearningPreferences.
     * @param {LearningPreferencesDeleteManyArgs} args - Arguments to filter LearningPreferences to delete.
     * @example
     * // Delete a few LearningPreferences
     * const { count } = await prisma.learningPreferences.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LearningPreferencesDeleteManyArgs>(args?: SelectSubset<T, LearningPreferencesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LearningPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPreferencesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LearningPreferences
     * const learningPreferences = await prisma.learningPreferences.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LearningPreferencesUpdateManyArgs>(args: SelectSubset<T, LearningPreferencesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LearningPreferences and returns the data updated in the database.
     * @param {LearningPreferencesUpdateManyAndReturnArgs} args - Arguments to update many LearningPreferences.
     * @example
     * // Update many LearningPreferences
     * const learningPreferences = await prisma.learningPreferences.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LearningPreferences and only return the `id`
     * const learningPreferencesWithIdOnly = await prisma.learningPreferences.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LearningPreferencesUpdateManyAndReturnArgs>(args: SelectSubset<T, LearningPreferencesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningPreferencesPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one LearningPreferences.
     * @param {LearningPreferencesUpsertArgs} args - Arguments to update or create a LearningPreferences.
     * @example
     * // Update or create a LearningPreferences
     * const learningPreferences = await prisma.learningPreferences.upsert({
     *   create: {
     *     // ... data to create a LearningPreferences
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LearningPreferences we want to update
     *   }
     * })
     */
    upsert<T extends LearningPreferencesUpsertArgs>(args: SelectSubset<T, LearningPreferencesUpsertArgs<ExtArgs>>): Prisma__LearningPreferencesClient<$Result.GetResult<Prisma.$LearningPreferencesPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of LearningPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPreferencesCountArgs} args - Arguments to filter LearningPreferences to count.
     * @example
     * // Count the number of LearningPreferences
     * const count = await prisma.learningPreferences.count({
     *   where: {
     *     // ... the filter for the LearningPreferences we want to count
     *   }
     * })
    **/
    count<T extends LearningPreferencesCountArgs>(
      args?: Subset<T, LearningPreferencesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LearningPreferencesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LearningPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPreferencesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LearningPreferencesAggregateArgs>(args: Subset<T, LearningPreferencesAggregateArgs>): Prisma.PrismaPromise<GetLearningPreferencesAggregateType<T>>

    /**
     * Group by LearningPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPreferencesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LearningPreferencesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LearningPreferencesGroupByArgs['orderBy'] }
        : { orderBy?: LearningPreferencesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LearningPreferencesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLearningPreferencesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LearningPreferences model
   */
  readonly fields: LearningPreferencesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LearningPreferences.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LearningPreferencesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LearningPreferences model
   */ 
  interface LearningPreferencesFieldRefs {
    readonly id: FieldRef<"LearningPreferences", 'String'>
    readonly userId: FieldRef<"LearningPreferences", 'String'>
    readonly visualLearning: FieldRef<"LearningPreferences", 'Int'>
    readonly auditoryLearning: FieldRef<"LearningPreferences", 'Int'>
    readonly kinestheticLearning: FieldRef<"LearningPreferences", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * LearningPreferences findUnique
   */
  export type LearningPreferencesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPreferences
     */
    select?: LearningPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPreferences
     */
    omit?: LearningPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which LearningPreferences to fetch.
     */
    where: LearningPreferencesWhereUniqueInput
  }

  /**
   * LearningPreferences findUniqueOrThrow
   */
  export type LearningPreferencesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPreferences
     */
    select?: LearningPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPreferences
     */
    omit?: LearningPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which LearningPreferences to fetch.
     */
    where: LearningPreferencesWhereUniqueInput
  }

  /**
   * LearningPreferences findFirst
   */
  export type LearningPreferencesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPreferences
     */
    select?: LearningPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPreferences
     */
    omit?: LearningPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which LearningPreferences to fetch.
     */
    where?: LearningPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningPreferences to fetch.
     */
    orderBy?: LearningPreferencesOrderByWithRelationInput | LearningPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LearningPreferences.
     */
    cursor?: LearningPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LearningPreferences.
     */
    distinct?: LearningPreferencesScalarFieldEnum | LearningPreferencesScalarFieldEnum[]
  }

  /**
   * LearningPreferences findFirstOrThrow
   */
  export type LearningPreferencesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPreferences
     */
    select?: LearningPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPreferences
     */
    omit?: LearningPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which LearningPreferences to fetch.
     */
    where?: LearningPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningPreferences to fetch.
     */
    orderBy?: LearningPreferencesOrderByWithRelationInput | LearningPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LearningPreferences.
     */
    cursor?: LearningPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LearningPreferences.
     */
    distinct?: LearningPreferencesScalarFieldEnum | LearningPreferencesScalarFieldEnum[]
  }

  /**
   * LearningPreferences findMany
   */
  export type LearningPreferencesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPreferences
     */
    select?: LearningPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPreferences
     */
    omit?: LearningPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which LearningPreferences to fetch.
     */
    where?: LearningPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningPreferences to fetch.
     */
    orderBy?: LearningPreferencesOrderByWithRelationInput | LearningPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LearningPreferences.
     */
    cursor?: LearningPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningPreferences.
     */
    skip?: number
    distinct?: LearningPreferencesScalarFieldEnum | LearningPreferencesScalarFieldEnum[]
  }

  /**
   * LearningPreferences create
   */
  export type LearningPreferencesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPreferences
     */
    select?: LearningPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPreferences
     */
    omit?: LearningPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPreferencesInclude<ExtArgs> | null
    /**
     * The data needed to create a LearningPreferences.
     */
    data: XOR<LearningPreferencesCreateInput, LearningPreferencesUncheckedCreateInput>
  }

  /**
   * LearningPreferences createMany
   */
  export type LearningPreferencesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LearningPreferences.
     */
    data: LearningPreferencesCreateManyInput | LearningPreferencesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LearningPreferences createManyAndReturn
   */
  export type LearningPreferencesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPreferences
     */
    select?: LearningPreferencesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPreferences
     */
    omit?: LearningPreferencesOmit<ExtArgs> | null
    /**
     * The data used to create many LearningPreferences.
     */
    data: LearningPreferencesCreateManyInput | LearningPreferencesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPreferencesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LearningPreferences update
   */
  export type LearningPreferencesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPreferences
     */
    select?: LearningPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPreferences
     */
    omit?: LearningPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPreferencesInclude<ExtArgs> | null
    /**
     * The data needed to update a LearningPreferences.
     */
    data: XOR<LearningPreferencesUpdateInput, LearningPreferencesUncheckedUpdateInput>
    /**
     * Choose, which LearningPreferences to update.
     */
    where: LearningPreferencesWhereUniqueInput
  }

  /**
   * LearningPreferences updateMany
   */
  export type LearningPreferencesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LearningPreferences.
     */
    data: XOR<LearningPreferencesUpdateManyMutationInput, LearningPreferencesUncheckedUpdateManyInput>
    /**
     * Filter which LearningPreferences to update
     */
    where?: LearningPreferencesWhereInput
    /**
     * Limit how many LearningPreferences to update.
     */
    limit?: number
  }

  /**
   * LearningPreferences updateManyAndReturn
   */
  export type LearningPreferencesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPreferences
     */
    select?: LearningPreferencesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPreferences
     */
    omit?: LearningPreferencesOmit<ExtArgs> | null
    /**
     * The data used to update LearningPreferences.
     */
    data: XOR<LearningPreferencesUpdateManyMutationInput, LearningPreferencesUncheckedUpdateManyInput>
    /**
     * Filter which LearningPreferences to update
     */
    where?: LearningPreferencesWhereInput
    /**
     * Limit how many LearningPreferences to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPreferencesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LearningPreferences upsert
   */
  export type LearningPreferencesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPreferences
     */
    select?: LearningPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPreferences
     */
    omit?: LearningPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPreferencesInclude<ExtArgs> | null
    /**
     * The filter to search for the LearningPreferences to update in case it exists.
     */
    where: LearningPreferencesWhereUniqueInput
    /**
     * In case the LearningPreferences found by the `where` argument doesn't exist, create a new LearningPreferences with this data.
     */
    create: XOR<LearningPreferencesCreateInput, LearningPreferencesUncheckedCreateInput>
    /**
     * In case the LearningPreferences was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LearningPreferencesUpdateInput, LearningPreferencesUncheckedUpdateInput>
  }

  /**
   * LearningPreferences delete
   */
  export type LearningPreferencesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPreferences
     */
    select?: LearningPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPreferences
     */
    omit?: LearningPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPreferencesInclude<ExtArgs> | null
    /**
     * Filter which LearningPreferences to delete.
     */
    where: LearningPreferencesWhereUniqueInput
  }

  /**
   * LearningPreferences deleteMany
   */
  export type LearningPreferencesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LearningPreferences to delete
     */
    where?: LearningPreferencesWhereInput
    /**
     * Limit how many LearningPreferences to delete.
     */
    limit?: number
  }

  /**
   * LearningPreferences without action
   */
  export type LearningPreferencesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPreferences
     */
    select?: LearningPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPreferences
     */
    omit?: LearningPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPreferencesInclude<ExtArgs> | null
  }


  /**
   * Model Topic
   */

  export type AggregateTopic = {
    _count: TopicCountAggregateOutputType | null
    _min: TopicMinAggregateOutputType | null
    _max: TopicMaxAggregateOutputType | null
  }

  export type TopicMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    userId: string | null
  }

  export type TopicMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    userId: string | null
  }

  export type TopicCountAggregateOutputType = {
    id: number
    title: number
    description: number
    userId: number
    _all: number
  }


  export type TopicMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    userId?: true
  }

  export type TopicMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    userId?: true
  }

  export type TopicCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    userId?: true
    _all?: true
  }

  export type TopicAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Topic to aggregate.
     */
    where?: TopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Topics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Topics
    **/
    _count?: true | TopicCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TopicMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TopicMaxAggregateInputType
  }

  export type GetTopicAggregateType<T extends TopicAggregateArgs> = {
        [P in keyof T & keyof AggregateTopic]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTopic[P]>
      : GetScalarType<T[P], AggregateTopic[P]>
  }




  export type TopicGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TopicWhereInput
    orderBy?: TopicOrderByWithAggregationInput | TopicOrderByWithAggregationInput[]
    by: TopicScalarFieldEnum[] | TopicScalarFieldEnum
    having?: TopicScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TopicCountAggregateInputType | true
    _min?: TopicMinAggregateInputType
    _max?: TopicMaxAggregateInputType
  }

  export type TopicGroupByOutputType = {
    id: string
    title: string
    description: string | null
    userId: string
    _count: TopicCountAggregateOutputType | null
    _min: TopicMinAggregateOutputType | null
    _max: TopicMaxAggregateOutputType | null
  }

  type GetTopicGroupByPayload<T extends TopicGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TopicGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TopicGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TopicGroupByOutputType[P]>
            : GetScalarType<T[P], TopicGroupByOutputType[P]>
        }
      >
    >


  export type TopicSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    progress?: boolean | Topic$progressArgs<ExtArgs>
    learningPathItems?: boolean | Topic$learningPathItemsArgs<ExtArgs>
    contentItems?: boolean | Topic$contentItemsArgs<ExtArgs>
    analyticsEntries?: boolean | Topic$analyticsEntriesArgs<ExtArgs>
    comments?: boolean | Topic$commentsArgs<ExtArgs>
    prerequisites?: boolean | Topic$prerequisitesArgs<ExtArgs>
    aiModules?: boolean | Topic$aiModulesArgs<ExtArgs>
    aiModuleQuizAttempts?: boolean | Topic$aiModuleQuizAttemptsArgs<ExtArgs>
    aiModuleRatings?: boolean | Topic$aiModuleRatingsArgs<ExtArgs>
    _count?: boolean | TopicCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["topic"]>

  export type TopicSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["topic"]>

  export type TopicSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["topic"]>

  export type TopicSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    userId?: boolean
  }

  export type TopicOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "userId", ExtArgs["result"]["topic"]>
  export type TopicInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    progress?: boolean | Topic$progressArgs<ExtArgs>
    learningPathItems?: boolean | Topic$learningPathItemsArgs<ExtArgs>
    contentItems?: boolean | Topic$contentItemsArgs<ExtArgs>
    analyticsEntries?: boolean | Topic$analyticsEntriesArgs<ExtArgs>
    comments?: boolean | Topic$commentsArgs<ExtArgs>
    prerequisites?: boolean | Topic$prerequisitesArgs<ExtArgs>
    aiModules?: boolean | Topic$aiModulesArgs<ExtArgs>
    aiModuleQuizAttempts?: boolean | Topic$aiModuleQuizAttemptsArgs<ExtArgs>
    aiModuleRatings?: boolean | Topic$aiModuleRatingsArgs<ExtArgs>
    _count?: boolean | TopicCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TopicIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TopicIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TopicPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Topic"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      progress: Prisma.$ProgressPayload<ExtArgs>[]
      learningPathItems: Prisma.$LearningPathItemPayload<ExtArgs>[]
      contentItems: Prisma.$ContentItemPayload<ExtArgs>[]
      analyticsEntries: Prisma.$AnalyticsEntryPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      prerequisites: Prisma.$PrerequisitePayload<ExtArgs>[]
      aiModules: Prisma.$AIModulePayload<ExtArgs>[]
      aiModuleQuizAttempts: Prisma.$AIModuleQuizAttemptPayload<ExtArgs>[]
      aiModuleRatings: Prisma.$AIModuleRatingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      userId: string
    }, ExtArgs["result"]["topic"]>
    composites: {}
  }

  type TopicGetPayload<S extends boolean | null | undefined | TopicDefaultArgs> = $Result.GetResult<Prisma.$TopicPayload, S>

  type TopicCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TopicFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TopicCountAggregateInputType | true
    }

  export interface TopicDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Topic'], meta: { name: 'Topic' } }
    /**
     * Find zero or one Topic that matches the filter.
     * @param {TopicFindUniqueArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TopicFindUniqueArgs>(args: SelectSubset<T, TopicFindUniqueArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Topic that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TopicFindUniqueOrThrowArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TopicFindUniqueOrThrowArgs>(args: SelectSubset<T, TopicFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Topic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicFindFirstArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TopicFindFirstArgs>(args?: SelectSubset<T, TopicFindFirstArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Topic that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicFindFirstOrThrowArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TopicFindFirstOrThrowArgs>(args?: SelectSubset<T, TopicFindFirstOrThrowArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Topics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Topics
     * const topics = await prisma.topic.findMany()
     * 
     * // Get first 10 Topics
     * const topics = await prisma.topic.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const topicWithIdOnly = await prisma.topic.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TopicFindManyArgs>(args?: SelectSubset<T, TopicFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Topic.
     * @param {TopicCreateArgs} args - Arguments to create a Topic.
     * @example
     * // Create one Topic
     * const Topic = await prisma.topic.create({
     *   data: {
     *     // ... data to create a Topic
     *   }
     * })
     * 
     */
    create<T extends TopicCreateArgs>(args: SelectSubset<T, TopicCreateArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Topics.
     * @param {TopicCreateManyArgs} args - Arguments to create many Topics.
     * @example
     * // Create many Topics
     * const topic = await prisma.topic.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TopicCreateManyArgs>(args?: SelectSubset<T, TopicCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Topics and returns the data saved in the database.
     * @param {TopicCreateManyAndReturnArgs} args - Arguments to create many Topics.
     * @example
     * // Create many Topics
     * const topic = await prisma.topic.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Topics and only return the `id`
     * const topicWithIdOnly = await prisma.topic.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TopicCreateManyAndReturnArgs>(args?: SelectSubset<T, TopicCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Topic.
     * @param {TopicDeleteArgs} args - Arguments to delete one Topic.
     * @example
     * // Delete one Topic
     * const Topic = await prisma.topic.delete({
     *   where: {
     *     // ... filter to delete one Topic
     *   }
     * })
     * 
     */
    delete<T extends TopicDeleteArgs>(args: SelectSubset<T, TopicDeleteArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Topic.
     * @param {TopicUpdateArgs} args - Arguments to update one Topic.
     * @example
     * // Update one Topic
     * const topic = await prisma.topic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TopicUpdateArgs>(args: SelectSubset<T, TopicUpdateArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Topics.
     * @param {TopicDeleteManyArgs} args - Arguments to filter Topics to delete.
     * @example
     * // Delete a few Topics
     * const { count } = await prisma.topic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TopicDeleteManyArgs>(args?: SelectSubset<T, TopicDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Topics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Topics
     * const topic = await prisma.topic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TopicUpdateManyArgs>(args: SelectSubset<T, TopicUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Topics and returns the data updated in the database.
     * @param {TopicUpdateManyAndReturnArgs} args - Arguments to update many Topics.
     * @example
     * // Update many Topics
     * const topic = await prisma.topic.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Topics and only return the `id`
     * const topicWithIdOnly = await prisma.topic.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TopicUpdateManyAndReturnArgs>(args: SelectSubset<T, TopicUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Topic.
     * @param {TopicUpsertArgs} args - Arguments to update or create a Topic.
     * @example
     * // Update or create a Topic
     * const topic = await prisma.topic.upsert({
     *   create: {
     *     // ... data to create a Topic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Topic we want to update
     *   }
     * })
     */
    upsert<T extends TopicUpsertArgs>(args: SelectSubset<T, TopicUpsertArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Topics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicCountArgs} args - Arguments to filter Topics to count.
     * @example
     * // Count the number of Topics
     * const count = await prisma.topic.count({
     *   where: {
     *     // ... the filter for the Topics we want to count
     *   }
     * })
    **/
    count<T extends TopicCountArgs>(
      args?: Subset<T, TopicCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TopicCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Topic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TopicAggregateArgs>(args: Subset<T, TopicAggregateArgs>): Prisma.PrismaPromise<GetTopicAggregateType<T>>

    /**
     * Group by Topic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TopicGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TopicGroupByArgs['orderBy'] }
        : { orderBy?: TopicGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TopicGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTopicGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Topic model
   */
  readonly fields: TopicFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Topic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TopicClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    progress<T extends Topic$progressArgs<ExtArgs> = {}>(args?: Subset<T, Topic$progressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgressPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    learningPathItems<T extends Topic$learningPathItemsArgs<ExtArgs> = {}>(args?: Subset<T, Topic$learningPathItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningPathItemPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    contentItems<T extends Topic$contentItemsArgs<ExtArgs> = {}>(args?: Subset<T, Topic$contentItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentItemPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    analyticsEntries<T extends Topic$analyticsEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Topic$analyticsEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsEntryPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    comments<T extends Topic$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Topic$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    prerequisites<T extends Topic$prerequisitesArgs<ExtArgs> = {}>(args?: Subset<T, Topic$prerequisitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrerequisitePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    aiModules<T extends Topic$aiModulesArgs<ExtArgs> = {}>(args?: Subset<T, Topic$aiModulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIModulePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    aiModuleQuizAttempts<T extends Topic$aiModuleQuizAttemptsArgs<ExtArgs> = {}>(args?: Subset<T, Topic$aiModuleQuizAttemptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIModuleQuizAttemptPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    aiModuleRatings<T extends Topic$aiModuleRatingsArgs<ExtArgs> = {}>(args?: Subset<T, Topic$aiModuleRatingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIModuleRatingPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Topic model
   */ 
  interface TopicFieldRefs {
    readonly id: FieldRef<"Topic", 'String'>
    readonly title: FieldRef<"Topic", 'String'>
    readonly description: FieldRef<"Topic", 'String'>
    readonly userId: FieldRef<"Topic", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Topic findUnique
   */
  export type TopicFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topic to fetch.
     */
    where: TopicWhereUniqueInput
  }

  /**
   * Topic findUniqueOrThrow
   */
  export type TopicFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topic to fetch.
     */
    where: TopicWhereUniqueInput
  }

  /**
   * Topic findFirst
   */
  export type TopicFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topic to fetch.
     */
    where?: TopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Topics.
     */
    cursor?: TopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Topics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Topics.
     */
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * Topic findFirstOrThrow
   */
  export type TopicFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topic to fetch.
     */
    where?: TopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Topics.
     */
    cursor?: TopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Topics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Topics.
     */
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * Topic findMany
   */
  export type TopicFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topics to fetch.
     */
    where?: TopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Topics.
     */
    cursor?: TopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Topics.
     */
    skip?: number
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * Topic create
   */
  export type TopicCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * The data needed to create a Topic.
     */
    data: XOR<TopicCreateInput, TopicUncheckedCreateInput>
  }

  /**
   * Topic createMany
   */
  export type TopicCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Topics.
     */
    data: TopicCreateManyInput | TopicCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Topic createManyAndReturn
   */
  export type TopicCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * The data used to create many Topics.
     */
    data: TopicCreateManyInput | TopicCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Topic update
   */
  export type TopicUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * The data needed to update a Topic.
     */
    data: XOR<TopicUpdateInput, TopicUncheckedUpdateInput>
    /**
     * Choose, which Topic to update.
     */
    where: TopicWhereUniqueInput
  }

  /**
   * Topic updateMany
   */
  export type TopicUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Topics.
     */
    data: XOR<TopicUpdateManyMutationInput, TopicUncheckedUpdateManyInput>
    /**
     * Filter which Topics to update
     */
    where?: TopicWhereInput
    /**
     * Limit how many Topics to update.
     */
    limit?: number
  }

  /**
   * Topic updateManyAndReturn
   */
  export type TopicUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * The data used to update Topics.
     */
    data: XOR<TopicUpdateManyMutationInput, TopicUncheckedUpdateManyInput>
    /**
     * Filter which Topics to update
     */
    where?: TopicWhereInput
    /**
     * Limit how many Topics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Topic upsert
   */
  export type TopicUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * The filter to search for the Topic to update in case it exists.
     */
    where: TopicWhereUniqueInput
    /**
     * In case the Topic found by the `where` argument doesn't exist, create a new Topic with this data.
     */
    create: XOR<TopicCreateInput, TopicUncheckedCreateInput>
    /**
     * In case the Topic was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TopicUpdateInput, TopicUncheckedUpdateInput>
  }

  /**
   * Topic delete
   */
  export type TopicDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter which Topic to delete.
     */
    where: TopicWhereUniqueInput
  }

  /**
   * Topic deleteMany
   */
  export type TopicDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Topics to delete
     */
    where?: TopicWhereInput
    /**
     * Limit how many Topics to delete.
     */
    limit?: number
  }

  /**
   * Topic.progress
   */
  export type Topic$progressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Progress
     */
    select?: ProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Progress
     */
    omit?: ProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressInclude<ExtArgs> | null
    where?: ProgressWhereInput
    orderBy?: ProgressOrderByWithRelationInput | ProgressOrderByWithRelationInput[]
    cursor?: ProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProgressScalarFieldEnum | ProgressScalarFieldEnum[]
  }

  /**
   * Topic.learningPathItems
   */
  export type Topic$learningPathItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathItem
     */
    select?: LearningPathItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathItem
     */
    omit?: LearningPathItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathItemInclude<ExtArgs> | null
    where?: LearningPathItemWhereInput
    orderBy?: LearningPathItemOrderByWithRelationInput | LearningPathItemOrderByWithRelationInput[]
    cursor?: LearningPathItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LearningPathItemScalarFieldEnum | LearningPathItemScalarFieldEnum[]
  }

  /**
   * Topic.contentItems
   */
  export type Topic$contentItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentItem
     */
    select?: ContentItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentItem
     */
    omit?: ContentItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentItemInclude<ExtArgs> | null
    where?: ContentItemWhereInput
    orderBy?: ContentItemOrderByWithRelationInput | ContentItemOrderByWithRelationInput[]
    cursor?: ContentItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentItemScalarFieldEnum | ContentItemScalarFieldEnum[]
  }

  /**
   * Topic.analyticsEntries
   */
  export type Topic$analyticsEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEntry
     */
    select?: AnalyticsEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEntry
     */
    omit?: AnalyticsEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEntryInclude<ExtArgs> | null
    where?: AnalyticsEntryWhereInput
    orderBy?: AnalyticsEntryOrderByWithRelationInput | AnalyticsEntryOrderByWithRelationInput[]
    cursor?: AnalyticsEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnalyticsEntryScalarFieldEnum | AnalyticsEntryScalarFieldEnum[]
  }

  /**
   * Topic.comments
   */
  export type Topic$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Topic.prerequisites
   */
  export type Topic$prerequisitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prerequisite
     */
    select?: PrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prerequisite
     */
    omit?: PrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrerequisiteInclude<ExtArgs> | null
    where?: PrerequisiteWhereInput
    orderBy?: PrerequisiteOrderByWithRelationInput | PrerequisiteOrderByWithRelationInput[]
    cursor?: PrerequisiteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrerequisiteScalarFieldEnum | PrerequisiteScalarFieldEnum[]
  }

  /**
   * Topic.aiModules
   */
  export type Topic$aiModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModule
     */
    select?: AIModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIModule
     */
    omit?: AIModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModuleInclude<ExtArgs> | null
    where?: AIModuleWhereInput
    orderBy?: AIModuleOrderByWithRelationInput | AIModuleOrderByWithRelationInput[]
    cursor?: AIModuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AIModuleScalarFieldEnum | AIModuleScalarFieldEnum[]
  }

  /**
   * Topic.aiModuleQuizAttempts
   */
  export type Topic$aiModuleQuizAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModuleQuizAttempt
     */
    select?: AIModuleQuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIModuleQuizAttempt
     */
    omit?: AIModuleQuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModuleQuizAttemptInclude<ExtArgs> | null
    where?: AIModuleQuizAttemptWhereInput
    orderBy?: AIModuleQuizAttemptOrderByWithRelationInput | AIModuleQuizAttemptOrderByWithRelationInput[]
    cursor?: AIModuleQuizAttemptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AIModuleQuizAttemptScalarFieldEnum | AIModuleQuizAttemptScalarFieldEnum[]
  }

  /**
   * Topic.aiModuleRatings
   */
  export type Topic$aiModuleRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModuleRating
     */
    select?: AIModuleRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIModuleRating
     */
    omit?: AIModuleRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModuleRatingInclude<ExtArgs> | null
    where?: AIModuleRatingWhereInput
    orderBy?: AIModuleRatingOrderByWithRelationInput | AIModuleRatingOrderByWithRelationInput[]
    cursor?: AIModuleRatingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AIModuleRatingScalarFieldEnum | AIModuleRatingScalarFieldEnum[]
  }

  /**
   * Topic without action
   */
  export type TopicDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
  }


  /**
   * Model Progress
   */

  export type AggregateProgress = {
    _count: ProgressCountAggregateOutputType | null
    _avg: ProgressAvgAggregateOutputType | null
    _sum: ProgressSumAggregateOutputType | null
    _min: ProgressMinAggregateOutputType | null
    _max: ProgressMaxAggregateOutputType | null
  }

  export type ProgressAvgAggregateOutputType = {
    completed: number | null
  }

  export type ProgressSumAggregateOutputType = {
    completed: number | null
  }

  export type ProgressMinAggregateOutputType = {
    id: string | null
    userId: string | null
    topicId: string | null
    completed: number | null
  }

  export type ProgressMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    topicId: string | null
    completed: number | null
  }

  export type ProgressCountAggregateOutputType = {
    id: number
    userId: number
    topicId: number
    completed: number
    _all: number
  }


  export type ProgressAvgAggregateInputType = {
    completed?: true
  }

  export type ProgressSumAggregateInputType = {
    completed?: true
  }

  export type ProgressMinAggregateInputType = {
    id?: true
    userId?: true
    topicId?: true
    completed?: true
  }

  export type ProgressMaxAggregateInputType = {
    id?: true
    userId?: true
    topicId?: true
    completed?: true
  }

  export type ProgressCountAggregateInputType = {
    id?: true
    userId?: true
    topicId?: true
    completed?: true
    _all?: true
  }

  export type ProgressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Progress to aggregate.
     */
    where?: ProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Progresses to fetch.
     */
    orderBy?: ProgressOrderByWithRelationInput | ProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Progresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Progresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Progresses
    **/
    _count?: true | ProgressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProgressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProgressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProgressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProgressMaxAggregateInputType
  }

  export type GetProgressAggregateType<T extends ProgressAggregateArgs> = {
        [P in keyof T & keyof AggregateProgress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProgress[P]>
      : GetScalarType<T[P], AggregateProgress[P]>
  }




  export type ProgressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgressWhereInput
    orderBy?: ProgressOrderByWithAggregationInput | ProgressOrderByWithAggregationInput[]
    by: ProgressScalarFieldEnum[] | ProgressScalarFieldEnum
    having?: ProgressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProgressCountAggregateInputType | true
    _avg?: ProgressAvgAggregateInputType
    _sum?: ProgressSumAggregateInputType
    _min?: ProgressMinAggregateInputType
    _max?: ProgressMaxAggregateInputType
  }

  export type ProgressGroupByOutputType = {
    id: string
    userId: string
    topicId: string
    completed: number
    _count: ProgressCountAggregateOutputType | null
    _avg: ProgressAvgAggregateOutputType | null
    _sum: ProgressSumAggregateOutputType | null
    _min: ProgressMinAggregateOutputType | null
    _max: ProgressMaxAggregateOutputType | null
  }

  type GetProgressGroupByPayload<T extends ProgressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProgressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProgressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProgressGroupByOutputType[P]>
            : GetScalarType<T[P], ProgressGroupByOutputType[P]>
        }
      >
    >


  export type ProgressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    topicId?: boolean
    completed?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    topic?: boolean | TopicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["progress"]>

  export type ProgressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    topicId?: boolean
    completed?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    topic?: boolean | TopicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["progress"]>

  export type ProgressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    topicId?: boolean
    completed?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    topic?: boolean | TopicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["progress"]>

  export type ProgressSelectScalar = {
    id?: boolean
    userId?: boolean
    topicId?: boolean
    completed?: boolean
  }

  export type ProgressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "topicId" | "completed", ExtArgs["result"]["progress"]>
  export type ProgressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    topic?: boolean | TopicDefaultArgs<ExtArgs>
  }
  export type ProgressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    topic?: boolean | TopicDefaultArgs<ExtArgs>
  }
  export type ProgressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    topic?: boolean | TopicDefaultArgs<ExtArgs>
  }

  export type $ProgressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Progress"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      topic: Prisma.$TopicPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      topicId: string
      completed: number
    }, ExtArgs["result"]["progress"]>
    composites: {}
  }

  type ProgressGetPayload<S extends boolean | null | undefined | ProgressDefaultArgs> = $Result.GetResult<Prisma.$ProgressPayload, S>

  type ProgressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProgressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProgressCountAggregateInputType | true
    }

  export interface ProgressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Progress'], meta: { name: 'Progress' } }
    /**
     * Find zero or one Progress that matches the filter.
     * @param {ProgressFindUniqueArgs} args - Arguments to find a Progress
     * @example
     * // Get one Progress
     * const progress = await prisma.progress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProgressFindUniqueArgs>(args: SelectSubset<T, ProgressFindUniqueArgs<ExtArgs>>): Prisma__ProgressClient<$Result.GetResult<Prisma.$ProgressPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Progress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProgressFindUniqueOrThrowArgs} args - Arguments to find a Progress
     * @example
     * // Get one Progress
     * const progress = await prisma.progress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProgressFindUniqueOrThrowArgs>(args: SelectSubset<T, ProgressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProgressClient<$Result.GetResult<Prisma.$ProgressPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Progress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgressFindFirstArgs} args - Arguments to find a Progress
     * @example
     * // Get one Progress
     * const progress = await prisma.progress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProgressFindFirstArgs>(args?: SelectSubset<T, ProgressFindFirstArgs<ExtArgs>>): Prisma__ProgressClient<$Result.GetResult<Prisma.$ProgressPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Progress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgressFindFirstOrThrowArgs} args - Arguments to find a Progress
     * @example
     * // Get one Progress
     * const progress = await prisma.progress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProgressFindFirstOrThrowArgs>(args?: SelectSubset<T, ProgressFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProgressClient<$Result.GetResult<Prisma.$ProgressPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Progresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Progresses
     * const progresses = await prisma.progress.findMany()
     * 
     * // Get first 10 Progresses
     * const progresses = await prisma.progress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const progressWithIdOnly = await prisma.progress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProgressFindManyArgs>(args?: SelectSubset<T, ProgressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgressPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Progress.
     * @param {ProgressCreateArgs} args - Arguments to create a Progress.
     * @example
     * // Create one Progress
     * const Progress = await prisma.progress.create({
     *   data: {
     *     // ... data to create a Progress
     *   }
     * })
     * 
     */
    create<T extends ProgressCreateArgs>(args: SelectSubset<T, ProgressCreateArgs<ExtArgs>>): Prisma__ProgressClient<$Result.GetResult<Prisma.$ProgressPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Progresses.
     * @param {ProgressCreateManyArgs} args - Arguments to create many Progresses.
     * @example
     * // Create many Progresses
     * const progress = await prisma.progress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProgressCreateManyArgs>(args?: SelectSubset<T, ProgressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Progresses and returns the data saved in the database.
     * @param {ProgressCreateManyAndReturnArgs} args - Arguments to create many Progresses.
     * @example
     * // Create many Progresses
     * const progress = await prisma.progress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Progresses and only return the `id`
     * const progressWithIdOnly = await prisma.progress.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProgressCreateManyAndReturnArgs>(args?: SelectSubset<T, ProgressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgressPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Progress.
     * @param {ProgressDeleteArgs} args - Arguments to delete one Progress.
     * @example
     * // Delete one Progress
     * const Progress = await prisma.progress.delete({
     *   where: {
     *     // ... filter to delete one Progress
     *   }
     * })
     * 
     */
    delete<T extends ProgressDeleteArgs>(args: SelectSubset<T, ProgressDeleteArgs<ExtArgs>>): Prisma__ProgressClient<$Result.GetResult<Prisma.$ProgressPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Progress.
     * @param {ProgressUpdateArgs} args - Arguments to update one Progress.
     * @example
     * // Update one Progress
     * const progress = await prisma.progress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProgressUpdateArgs>(args: SelectSubset<T, ProgressUpdateArgs<ExtArgs>>): Prisma__ProgressClient<$Result.GetResult<Prisma.$ProgressPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Progresses.
     * @param {ProgressDeleteManyArgs} args - Arguments to filter Progresses to delete.
     * @example
     * // Delete a few Progresses
     * const { count } = await prisma.progress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProgressDeleteManyArgs>(args?: SelectSubset<T, ProgressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Progresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Progresses
     * const progress = await prisma.progress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProgressUpdateManyArgs>(args: SelectSubset<T, ProgressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Progresses and returns the data updated in the database.
     * @param {ProgressUpdateManyAndReturnArgs} args - Arguments to update many Progresses.
     * @example
     * // Update many Progresses
     * const progress = await prisma.progress.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Progresses and only return the `id`
     * const progressWithIdOnly = await prisma.progress.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProgressUpdateManyAndReturnArgs>(args: SelectSubset<T, ProgressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgressPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Progress.
     * @param {ProgressUpsertArgs} args - Arguments to update or create a Progress.
     * @example
     * // Update or create a Progress
     * const progress = await prisma.progress.upsert({
     *   create: {
     *     // ... data to create a Progress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Progress we want to update
     *   }
     * })
     */
    upsert<T extends ProgressUpsertArgs>(args: SelectSubset<T, ProgressUpsertArgs<ExtArgs>>): Prisma__ProgressClient<$Result.GetResult<Prisma.$ProgressPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Progresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgressCountArgs} args - Arguments to filter Progresses to count.
     * @example
     * // Count the number of Progresses
     * const count = await prisma.progress.count({
     *   where: {
     *     // ... the filter for the Progresses we want to count
     *   }
     * })
    **/
    count<T extends ProgressCountArgs>(
      args?: Subset<T, ProgressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProgressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Progress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProgressAggregateArgs>(args: Subset<T, ProgressAggregateArgs>): Prisma.PrismaPromise<GetProgressAggregateType<T>>

    /**
     * Group by Progress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProgressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProgressGroupByArgs['orderBy'] }
        : { orderBy?: ProgressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProgressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProgressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Progress model
   */
  readonly fields: ProgressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Progress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProgressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    topic<T extends TopicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TopicDefaultArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Progress model
   */ 
  interface ProgressFieldRefs {
    readonly id: FieldRef<"Progress", 'String'>
    readonly userId: FieldRef<"Progress", 'String'>
    readonly topicId: FieldRef<"Progress", 'String'>
    readonly completed: FieldRef<"Progress", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Progress findUnique
   */
  export type ProgressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Progress
     */
    select?: ProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Progress
     */
    omit?: ProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressInclude<ExtArgs> | null
    /**
     * Filter, which Progress to fetch.
     */
    where: ProgressWhereUniqueInput
  }

  /**
   * Progress findUniqueOrThrow
   */
  export type ProgressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Progress
     */
    select?: ProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Progress
     */
    omit?: ProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressInclude<ExtArgs> | null
    /**
     * Filter, which Progress to fetch.
     */
    where: ProgressWhereUniqueInput
  }

  /**
   * Progress findFirst
   */
  export type ProgressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Progress
     */
    select?: ProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Progress
     */
    omit?: ProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressInclude<ExtArgs> | null
    /**
     * Filter, which Progress to fetch.
     */
    where?: ProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Progresses to fetch.
     */
    orderBy?: ProgressOrderByWithRelationInput | ProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Progresses.
     */
    cursor?: ProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Progresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Progresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Progresses.
     */
    distinct?: ProgressScalarFieldEnum | ProgressScalarFieldEnum[]
  }

  /**
   * Progress findFirstOrThrow
   */
  export type ProgressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Progress
     */
    select?: ProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Progress
     */
    omit?: ProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressInclude<ExtArgs> | null
    /**
     * Filter, which Progress to fetch.
     */
    where?: ProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Progresses to fetch.
     */
    orderBy?: ProgressOrderByWithRelationInput | ProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Progresses.
     */
    cursor?: ProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Progresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Progresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Progresses.
     */
    distinct?: ProgressScalarFieldEnum | ProgressScalarFieldEnum[]
  }

  /**
   * Progress findMany
   */
  export type ProgressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Progress
     */
    select?: ProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Progress
     */
    omit?: ProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressInclude<ExtArgs> | null
    /**
     * Filter, which Progresses to fetch.
     */
    where?: ProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Progresses to fetch.
     */
    orderBy?: ProgressOrderByWithRelationInput | ProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Progresses.
     */
    cursor?: ProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Progresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Progresses.
     */
    skip?: number
    distinct?: ProgressScalarFieldEnum | ProgressScalarFieldEnum[]
  }

  /**
   * Progress create
   */
  export type ProgressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Progress
     */
    select?: ProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Progress
     */
    omit?: ProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressInclude<ExtArgs> | null
    /**
     * The data needed to create a Progress.
     */
    data: XOR<ProgressCreateInput, ProgressUncheckedCreateInput>
  }

  /**
   * Progress createMany
   */
  export type ProgressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Progresses.
     */
    data: ProgressCreateManyInput | ProgressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Progress createManyAndReturn
   */
  export type ProgressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Progress
     */
    select?: ProgressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Progress
     */
    omit?: ProgressOmit<ExtArgs> | null
    /**
     * The data used to create many Progresses.
     */
    data: ProgressCreateManyInput | ProgressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Progress update
   */
  export type ProgressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Progress
     */
    select?: ProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Progress
     */
    omit?: ProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressInclude<ExtArgs> | null
    /**
     * The data needed to update a Progress.
     */
    data: XOR<ProgressUpdateInput, ProgressUncheckedUpdateInput>
    /**
     * Choose, which Progress to update.
     */
    where: ProgressWhereUniqueInput
  }

  /**
   * Progress updateMany
   */
  export type ProgressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Progresses.
     */
    data: XOR<ProgressUpdateManyMutationInput, ProgressUncheckedUpdateManyInput>
    /**
     * Filter which Progresses to update
     */
    where?: ProgressWhereInput
    /**
     * Limit how many Progresses to update.
     */
    limit?: number
  }

  /**
   * Progress updateManyAndReturn
   */
  export type ProgressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Progress
     */
    select?: ProgressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Progress
     */
    omit?: ProgressOmit<ExtArgs> | null
    /**
     * The data used to update Progresses.
     */
    data: XOR<ProgressUpdateManyMutationInput, ProgressUncheckedUpdateManyInput>
    /**
     * Filter which Progresses to update
     */
    where?: ProgressWhereInput
    /**
     * Limit how many Progresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Progress upsert
   */
  export type ProgressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Progress
     */
    select?: ProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Progress
     */
    omit?: ProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressInclude<ExtArgs> | null
    /**
     * The filter to search for the Progress to update in case it exists.
     */
    where: ProgressWhereUniqueInput
    /**
     * In case the Progress found by the `where` argument doesn't exist, create a new Progress with this data.
     */
    create: XOR<ProgressCreateInput, ProgressUncheckedCreateInput>
    /**
     * In case the Progress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProgressUpdateInput, ProgressUncheckedUpdateInput>
  }

  /**
   * Progress delete
   */
  export type ProgressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Progress
     */
    select?: ProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Progress
     */
    omit?: ProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressInclude<ExtArgs> | null
    /**
     * Filter which Progress to delete.
     */
    where: ProgressWhereUniqueInput
  }

  /**
   * Progress deleteMany
   */
  export type ProgressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Progresses to delete
     */
    where?: ProgressWhereInput
    /**
     * Limit how many Progresses to delete.
     */
    limit?: number
  }

  /**
   * Progress without action
   */
  export type ProgressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Progress
     */
    select?: ProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Progress
     */
    omit?: ProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressInclude<ExtArgs> | null
  }


  /**
   * Model Badge
   */

  export type AggregateBadge = {
    _count: BadgeCountAggregateOutputType | null
    _min: BadgeMinAggregateOutputType | null
    _max: BadgeMaxAggregateOutputType | null
  }

  export type BadgeMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    imageUrl: string | null
    userId: string | null
    earnedAt: Date | null
  }

  export type BadgeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    imageUrl: string | null
    userId: string | null
    earnedAt: Date | null
  }

  export type BadgeCountAggregateOutputType = {
    id: number
    name: number
    description: number
    imageUrl: number
    userId: number
    earnedAt: number
    _all: number
  }


  export type BadgeMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    imageUrl?: true
    userId?: true
    earnedAt?: true
  }

  export type BadgeMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    imageUrl?: true
    userId?: true
    earnedAt?: true
  }

  export type BadgeCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    imageUrl?: true
    userId?: true
    earnedAt?: true
    _all?: true
  }

  export type BadgeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Badge to aggregate.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Badges
    **/
    _count?: true | BadgeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BadgeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BadgeMaxAggregateInputType
  }

  export type GetBadgeAggregateType<T extends BadgeAggregateArgs> = {
        [P in keyof T & keyof AggregateBadge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBadge[P]>
      : GetScalarType<T[P], AggregateBadge[P]>
  }




  export type BadgeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BadgeWhereInput
    orderBy?: BadgeOrderByWithAggregationInput | BadgeOrderByWithAggregationInput[]
    by: BadgeScalarFieldEnum[] | BadgeScalarFieldEnum
    having?: BadgeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BadgeCountAggregateInputType | true
    _min?: BadgeMinAggregateInputType
    _max?: BadgeMaxAggregateInputType
  }

  export type BadgeGroupByOutputType = {
    id: string
    name: string
    description: string | null
    imageUrl: string | null
    userId: string
    earnedAt: Date
    _count: BadgeCountAggregateOutputType | null
    _min: BadgeMinAggregateOutputType | null
    _max: BadgeMaxAggregateOutputType | null
  }

  type GetBadgeGroupByPayload<T extends BadgeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BadgeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BadgeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BadgeGroupByOutputType[P]>
            : GetScalarType<T[P], BadgeGroupByOutputType[P]>
        }
      >
    >


  export type BadgeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    userId?: boolean
    earnedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["badge"]>

  export type BadgeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    userId?: boolean
    earnedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["badge"]>

  export type BadgeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    userId?: boolean
    earnedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["badge"]>

  export type BadgeSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    userId?: boolean
    earnedAt?: boolean
  }

  export type BadgeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "imageUrl" | "userId" | "earnedAt", ExtArgs["result"]["badge"]>
  export type BadgeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BadgeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BadgeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BadgePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Badge"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      imageUrl: string | null
      userId: string
      earnedAt: Date
    }, ExtArgs["result"]["badge"]>
    composites: {}
  }

  type BadgeGetPayload<S extends boolean | null | undefined | BadgeDefaultArgs> = $Result.GetResult<Prisma.$BadgePayload, S>

  type BadgeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BadgeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BadgeCountAggregateInputType | true
    }

  export interface BadgeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Badge'], meta: { name: 'Badge' } }
    /**
     * Find zero or one Badge that matches the filter.
     * @param {BadgeFindUniqueArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BadgeFindUniqueArgs>(args: SelectSubset<T, BadgeFindUniqueArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Badge that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BadgeFindUniqueOrThrowArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BadgeFindUniqueOrThrowArgs>(args: SelectSubset<T, BadgeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Badge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeFindFirstArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BadgeFindFirstArgs>(args?: SelectSubset<T, BadgeFindFirstArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Badge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeFindFirstOrThrowArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BadgeFindFirstOrThrowArgs>(args?: SelectSubset<T, BadgeFindFirstOrThrowArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Badges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Badges
     * const badges = await prisma.badge.findMany()
     * 
     * // Get first 10 Badges
     * const badges = await prisma.badge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const badgeWithIdOnly = await prisma.badge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BadgeFindManyArgs>(args?: SelectSubset<T, BadgeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Badge.
     * @param {BadgeCreateArgs} args - Arguments to create a Badge.
     * @example
     * // Create one Badge
     * const Badge = await prisma.badge.create({
     *   data: {
     *     // ... data to create a Badge
     *   }
     * })
     * 
     */
    create<T extends BadgeCreateArgs>(args: SelectSubset<T, BadgeCreateArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Badges.
     * @param {BadgeCreateManyArgs} args - Arguments to create many Badges.
     * @example
     * // Create many Badges
     * const badge = await prisma.badge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BadgeCreateManyArgs>(args?: SelectSubset<T, BadgeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Badges and returns the data saved in the database.
     * @param {BadgeCreateManyAndReturnArgs} args - Arguments to create many Badges.
     * @example
     * // Create many Badges
     * const badge = await prisma.badge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Badges and only return the `id`
     * const badgeWithIdOnly = await prisma.badge.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BadgeCreateManyAndReturnArgs>(args?: SelectSubset<T, BadgeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Badge.
     * @param {BadgeDeleteArgs} args - Arguments to delete one Badge.
     * @example
     * // Delete one Badge
     * const Badge = await prisma.badge.delete({
     *   where: {
     *     // ... filter to delete one Badge
     *   }
     * })
     * 
     */
    delete<T extends BadgeDeleteArgs>(args: SelectSubset<T, BadgeDeleteArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Badge.
     * @param {BadgeUpdateArgs} args - Arguments to update one Badge.
     * @example
     * // Update one Badge
     * const badge = await prisma.badge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BadgeUpdateArgs>(args: SelectSubset<T, BadgeUpdateArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Badges.
     * @param {BadgeDeleteManyArgs} args - Arguments to filter Badges to delete.
     * @example
     * // Delete a few Badges
     * const { count } = await prisma.badge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BadgeDeleteManyArgs>(args?: SelectSubset<T, BadgeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Badges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Badges
     * const badge = await prisma.badge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BadgeUpdateManyArgs>(args: SelectSubset<T, BadgeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Badges and returns the data updated in the database.
     * @param {BadgeUpdateManyAndReturnArgs} args - Arguments to update many Badges.
     * @example
     * // Update many Badges
     * const badge = await prisma.badge.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Badges and only return the `id`
     * const badgeWithIdOnly = await prisma.badge.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BadgeUpdateManyAndReturnArgs>(args: SelectSubset<T, BadgeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Badge.
     * @param {BadgeUpsertArgs} args - Arguments to update or create a Badge.
     * @example
     * // Update or create a Badge
     * const badge = await prisma.badge.upsert({
     *   create: {
     *     // ... data to create a Badge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Badge we want to update
     *   }
     * })
     */
    upsert<T extends BadgeUpsertArgs>(args: SelectSubset<T, BadgeUpsertArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Badges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeCountArgs} args - Arguments to filter Badges to count.
     * @example
     * // Count the number of Badges
     * const count = await prisma.badge.count({
     *   where: {
     *     // ... the filter for the Badges we want to count
     *   }
     * })
    **/
    count<T extends BadgeCountArgs>(
      args?: Subset<T, BadgeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BadgeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Badge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BadgeAggregateArgs>(args: Subset<T, BadgeAggregateArgs>): Prisma.PrismaPromise<GetBadgeAggregateType<T>>

    /**
     * Group by Badge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BadgeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BadgeGroupByArgs['orderBy'] }
        : { orderBy?: BadgeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BadgeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBadgeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Badge model
   */
  readonly fields: BadgeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Badge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BadgeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Badge model
   */ 
  interface BadgeFieldRefs {
    readonly id: FieldRef<"Badge", 'String'>
    readonly name: FieldRef<"Badge", 'String'>
    readonly description: FieldRef<"Badge", 'String'>
    readonly imageUrl: FieldRef<"Badge", 'String'>
    readonly userId: FieldRef<"Badge", 'String'>
    readonly earnedAt: FieldRef<"Badge", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Badge findUnique
   */
  export type BadgeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge findUniqueOrThrow
   */
  export type BadgeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge findFirst
   */
  export type BadgeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Badges.
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Badges.
     */
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * Badge findFirstOrThrow
   */
  export type BadgeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Badges.
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Badges.
     */
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * Badge findMany
   */
  export type BadgeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badges to fetch.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Badges.
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * Badge create
   */
  export type BadgeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * The data needed to create a Badge.
     */
    data: XOR<BadgeCreateInput, BadgeUncheckedCreateInput>
  }

  /**
   * Badge createMany
   */
  export type BadgeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Badges.
     */
    data: BadgeCreateManyInput | BadgeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Badge createManyAndReturn
   */
  export type BadgeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * The data used to create many Badges.
     */
    data: BadgeCreateManyInput | BadgeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Badge update
   */
  export type BadgeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * The data needed to update a Badge.
     */
    data: XOR<BadgeUpdateInput, BadgeUncheckedUpdateInput>
    /**
     * Choose, which Badge to update.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge updateMany
   */
  export type BadgeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Badges.
     */
    data: XOR<BadgeUpdateManyMutationInput, BadgeUncheckedUpdateManyInput>
    /**
     * Filter which Badges to update
     */
    where?: BadgeWhereInput
    /**
     * Limit how many Badges to update.
     */
    limit?: number
  }

  /**
   * Badge updateManyAndReturn
   */
  export type BadgeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * The data used to update Badges.
     */
    data: XOR<BadgeUpdateManyMutationInput, BadgeUncheckedUpdateManyInput>
    /**
     * Filter which Badges to update
     */
    where?: BadgeWhereInput
    /**
     * Limit how many Badges to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Badge upsert
   */
  export type BadgeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * The filter to search for the Badge to update in case it exists.
     */
    where: BadgeWhereUniqueInput
    /**
     * In case the Badge found by the `where` argument doesn't exist, create a new Badge with this data.
     */
    create: XOR<BadgeCreateInput, BadgeUncheckedCreateInput>
    /**
     * In case the Badge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BadgeUpdateInput, BadgeUncheckedUpdateInput>
  }

  /**
   * Badge delete
   */
  export type BadgeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter which Badge to delete.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge deleteMany
   */
  export type BadgeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Badges to delete
     */
    where?: BadgeWhereInput
    /**
     * Limit how many Badges to delete.
     */
    limit?: number
  }

  /**
   * Badge without action
   */
  export type BadgeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
  }


  /**
   * Model UpcomingReview
   */

  export type AggregateUpcomingReview = {
    _count: UpcomingReviewCountAggregateOutputType | null
    _min: UpcomingReviewMinAggregateOutputType | null
    _max: UpcomingReviewMaxAggregateOutputType | null
  }

  export type UpcomingReviewMinAggregateOutputType = {
    id: string | null
    userId: string | null
    topicId: string | null
    dueDate: Date | null
  }

  export type UpcomingReviewMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    topicId: string | null
    dueDate: Date | null
  }

  export type UpcomingReviewCountAggregateOutputType = {
    id: number
    userId: number
    topicId: number
    dueDate: number
    _all: number
  }


  export type UpcomingReviewMinAggregateInputType = {
    id?: true
    userId?: true
    topicId?: true
    dueDate?: true
  }

  export type UpcomingReviewMaxAggregateInputType = {
    id?: true
    userId?: true
    topicId?: true
    dueDate?: true
  }

  export type UpcomingReviewCountAggregateInputType = {
    id?: true
    userId?: true
    topicId?: true
    dueDate?: true
    _all?: true
  }

  export type UpcomingReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UpcomingReview to aggregate.
     */
    where?: UpcomingReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UpcomingReviews to fetch.
     */
    orderBy?: UpcomingReviewOrderByWithRelationInput | UpcomingReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UpcomingReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UpcomingReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UpcomingReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UpcomingReviews
    **/
    _count?: true | UpcomingReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UpcomingReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UpcomingReviewMaxAggregateInputType
  }

  export type GetUpcomingReviewAggregateType<T extends UpcomingReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateUpcomingReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUpcomingReview[P]>
      : GetScalarType<T[P], AggregateUpcomingReview[P]>
  }




  export type UpcomingReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UpcomingReviewWhereInput
    orderBy?: UpcomingReviewOrderByWithAggregationInput | UpcomingReviewOrderByWithAggregationInput[]
    by: UpcomingReviewScalarFieldEnum[] | UpcomingReviewScalarFieldEnum
    having?: UpcomingReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UpcomingReviewCountAggregateInputType | true
    _min?: UpcomingReviewMinAggregateInputType
    _max?: UpcomingReviewMaxAggregateInputType
  }

  export type UpcomingReviewGroupByOutputType = {
    id: string
    userId: string
    topicId: string
    dueDate: Date
    _count: UpcomingReviewCountAggregateOutputType | null
    _min: UpcomingReviewMinAggregateOutputType | null
    _max: UpcomingReviewMaxAggregateOutputType | null
  }

  type GetUpcomingReviewGroupByPayload<T extends UpcomingReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UpcomingReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UpcomingReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UpcomingReviewGroupByOutputType[P]>
            : GetScalarType<T[P], UpcomingReviewGroupByOutputType[P]>
        }
      >
    >


  export type UpcomingReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    topicId?: boolean
    dueDate?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["upcomingReview"]>

  export type UpcomingReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    topicId?: boolean
    dueDate?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["upcomingReview"]>

  export type UpcomingReviewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    topicId?: boolean
    dueDate?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["upcomingReview"]>

  export type UpcomingReviewSelectScalar = {
    id?: boolean
    userId?: boolean
    topicId?: boolean
    dueDate?: boolean
  }

  export type UpcomingReviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "topicId" | "dueDate", ExtArgs["result"]["upcomingReview"]>
  export type UpcomingReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UpcomingReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UpcomingReviewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UpcomingReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UpcomingReview"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      topicId: string
      dueDate: Date
    }, ExtArgs["result"]["upcomingReview"]>
    composites: {}
  }

  type UpcomingReviewGetPayload<S extends boolean | null | undefined | UpcomingReviewDefaultArgs> = $Result.GetResult<Prisma.$UpcomingReviewPayload, S>

  type UpcomingReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UpcomingReviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UpcomingReviewCountAggregateInputType | true
    }

  export interface UpcomingReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UpcomingReview'], meta: { name: 'UpcomingReview' } }
    /**
     * Find zero or one UpcomingReview that matches the filter.
     * @param {UpcomingReviewFindUniqueArgs} args - Arguments to find a UpcomingReview
     * @example
     * // Get one UpcomingReview
     * const upcomingReview = await prisma.upcomingReview.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UpcomingReviewFindUniqueArgs>(args: SelectSubset<T, UpcomingReviewFindUniqueArgs<ExtArgs>>): Prisma__UpcomingReviewClient<$Result.GetResult<Prisma.$UpcomingReviewPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one UpcomingReview that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UpcomingReviewFindUniqueOrThrowArgs} args - Arguments to find a UpcomingReview
     * @example
     * // Get one UpcomingReview
     * const upcomingReview = await prisma.upcomingReview.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UpcomingReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, UpcomingReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UpcomingReviewClient<$Result.GetResult<Prisma.$UpcomingReviewPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first UpcomingReview that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UpcomingReviewFindFirstArgs} args - Arguments to find a UpcomingReview
     * @example
     * // Get one UpcomingReview
     * const upcomingReview = await prisma.upcomingReview.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UpcomingReviewFindFirstArgs>(args?: SelectSubset<T, UpcomingReviewFindFirstArgs<ExtArgs>>): Prisma__UpcomingReviewClient<$Result.GetResult<Prisma.$UpcomingReviewPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first UpcomingReview that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UpcomingReviewFindFirstOrThrowArgs} args - Arguments to find a UpcomingReview
     * @example
     * // Get one UpcomingReview
     * const upcomingReview = await prisma.upcomingReview.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UpcomingReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, UpcomingReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__UpcomingReviewClient<$Result.GetResult<Prisma.$UpcomingReviewPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more UpcomingReviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UpcomingReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UpcomingReviews
     * const upcomingReviews = await prisma.upcomingReview.findMany()
     * 
     * // Get first 10 UpcomingReviews
     * const upcomingReviews = await prisma.upcomingReview.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const upcomingReviewWithIdOnly = await prisma.upcomingReview.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UpcomingReviewFindManyArgs>(args?: SelectSubset<T, UpcomingReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UpcomingReviewPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a UpcomingReview.
     * @param {UpcomingReviewCreateArgs} args - Arguments to create a UpcomingReview.
     * @example
     * // Create one UpcomingReview
     * const UpcomingReview = await prisma.upcomingReview.create({
     *   data: {
     *     // ... data to create a UpcomingReview
     *   }
     * })
     * 
     */
    create<T extends UpcomingReviewCreateArgs>(args: SelectSubset<T, UpcomingReviewCreateArgs<ExtArgs>>): Prisma__UpcomingReviewClient<$Result.GetResult<Prisma.$UpcomingReviewPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many UpcomingReviews.
     * @param {UpcomingReviewCreateManyArgs} args - Arguments to create many UpcomingReviews.
     * @example
     * // Create many UpcomingReviews
     * const upcomingReview = await prisma.upcomingReview.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UpcomingReviewCreateManyArgs>(args?: SelectSubset<T, UpcomingReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UpcomingReviews and returns the data saved in the database.
     * @param {UpcomingReviewCreateManyAndReturnArgs} args - Arguments to create many UpcomingReviews.
     * @example
     * // Create many UpcomingReviews
     * const upcomingReview = await prisma.upcomingReview.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UpcomingReviews and only return the `id`
     * const upcomingReviewWithIdOnly = await prisma.upcomingReview.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UpcomingReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, UpcomingReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UpcomingReviewPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a UpcomingReview.
     * @param {UpcomingReviewDeleteArgs} args - Arguments to delete one UpcomingReview.
     * @example
     * // Delete one UpcomingReview
     * const UpcomingReview = await prisma.upcomingReview.delete({
     *   where: {
     *     // ... filter to delete one UpcomingReview
     *   }
     * })
     * 
     */
    delete<T extends UpcomingReviewDeleteArgs>(args: SelectSubset<T, UpcomingReviewDeleteArgs<ExtArgs>>): Prisma__UpcomingReviewClient<$Result.GetResult<Prisma.$UpcomingReviewPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one UpcomingReview.
     * @param {UpcomingReviewUpdateArgs} args - Arguments to update one UpcomingReview.
     * @example
     * // Update one UpcomingReview
     * const upcomingReview = await prisma.upcomingReview.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UpcomingReviewUpdateArgs>(args: SelectSubset<T, UpcomingReviewUpdateArgs<ExtArgs>>): Prisma__UpcomingReviewClient<$Result.GetResult<Prisma.$UpcomingReviewPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more UpcomingReviews.
     * @param {UpcomingReviewDeleteManyArgs} args - Arguments to filter UpcomingReviews to delete.
     * @example
     * // Delete a few UpcomingReviews
     * const { count } = await prisma.upcomingReview.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UpcomingReviewDeleteManyArgs>(args?: SelectSubset<T, UpcomingReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UpcomingReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UpcomingReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UpcomingReviews
     * const upcomingReview = await prisma.upcomingReview.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UpcomingReviewUpdateManyArgs>(args: SelectSubset<T, UpcomingReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UpcomingReviews and returns the data updated in the database.
     * @param {UpcomingReviewUpdateManyAndReturnArgs} args - Arguments to update many UpcomingReviews.
     * @example
     * // Update many UpcomingReviews
     * const upcomingReview = await prisma.upcomingReview.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UpcomingReviews and only return the `id`
     * const upcomingReviewWithIdOnly = await prisma.upcomingReview.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UpcomingReviewUpdateManyAndReturnArgs>(args: SelectSubset<T, UpcomingReviewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UpcomingReviewPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one UpcomingReview.
     * @param {UpcomingReviewUpsertArgs} args - Arguments to update or create a UpcomingReview.
     * @example
     * // Update or create a UpcomingReview
     * const upcomingReview = await prisma.upcomingReview.upsert({
     *   create: {
     *     // ... data to create a UpcomingReview
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UpcomingReview we want to update
     *   }
     * })
     */
    upsert<T extends UpcomingReviewUpsertArgs>(args: SelectSubset<T, UpcomingReviewUpsertArgs<ExtArgs>>): Prisma__UpcomingReviewClient<$Result.GetResult<Prisma.$UpcomingReviewPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of UpcomingReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UpcomingReviewCountArgs} args - Arguments to filter UpcomingReviews to count.
     * @example
     * // Count the number of UpcomingReviews
     * const count = await prisma.upcomingReview.count({
     *   where: {
     *     // ... the filter for the UpcomingReviews we want to count
     *   }
     * })
    **/
    count<T extends UpcomingReviewCountArgs>(
      args?: Subset<T, UpcomingReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UpcomingReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UpcomingReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UpcomingReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UpcomingReviewAggregateArgs>(args: Subset<T, UpcomingReviewAggregateArgs>): Prisma.PrismaPromise<GetUpcomingReviewAggregateType<T>>

    /**
     * Group by UpcomingReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UpcomingReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UpcomingReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UpcomingReviewGroupByArgs['orderBy'] }
        : { orderBy?: UpcomingReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UpcomingReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUpcomingReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UpcomingReview model
   */
  readonly fields: UpcomingReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UpcomingReview.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UpcomingReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UpcomingReview model
   */ 
  interface UpcomingReviewFieldRefs {
    readonly id: FieldRef<"UpcomingReview", 'String'>
    readonly userId: FieldRef<"UpcomingReview", 'String'>
    readonly topicId: FieldRef<"UpcomingReview", 'String'>
    readonly dueDate: FieldRef<"UpcomingReview", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UpcomingReview findUnique
   */
  export type UpcomingReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpcomingReview
     */
    select?: UpcomingReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UpcomingReview
     */
    omit?: UpcomingReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpcomingReviewInclude<ExtArgs> | null
    /**
     * Filter, which UpcomingReview to fetch.
     */
    where: UpcomingReviewWhereUniqueInput
  }

  /**
   * UpcomingReview findUniqueOrThrow
   */
  export type UpcomingReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpcomingReview
     */
    select?: UpcomingReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UpcomingReview
     */
    omit?: UpcomingReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpcomingReviewInclude<ExtArgs> | null
    /**
     * Filter, which UpcomingReview to fetch.
     */
    where: UpcomingReviewWhereUniqueInput
  }

  /**
   * UpcomingReview findFirst
   */
  export type UpcomingReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpcomingReview
     */
    select?: UpcomingReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UpcomingReview
     */
    omit?: UpcomingReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpcomingReviewInclude<ExtArgs> | null
    /**
     * Filter, which UpcomingReview to fetch.
     */
    where?: UpcomingReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UpcomingReviews to fetch.
     */
    orderBy?: UpcomingReviewOrderByWithRelationInput | UpcomingReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UpcomingReviews.
     */
    cursor?: UpcomingReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UpcomingReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UpcomingReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UpcomingReviews.
     */
    distinct?: UpcomingReviewScalarFieldEnum | UpcomingReviewScalarFieldEnum[]
  }

  /**
   * UpcomingReview findFirstOrThrow
   */
  export type UpcomingReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpcomingReview
     */
    select?: UpcomingReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UpcomingReview
     */
    omit?: UpcomingReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpcomingReviewInclude<ExtArgs> | null
    /**
     * Filter, which UpcomingReview to fetch.
     */
    where?: UpcomingReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UpcomingReviews to fetch.
     */
    orderBy?: UpcomingReviewOrderByWithRelationInput | UpcomingReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UpcomingReviews.
     */
    cursor?: UpcomingReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UpcomingReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UpcomingReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UpcomingReviews.
     */
    distinct?: UpcomingReviewScalarFieldEnum | UpcomingReviewScalarFieldEnum[]
  }

  /**
   * UpcomingReview findMany
   */
  export type UpcomingReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpcomingReview
     */
    select?: UpcomingReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UpcomingReview
     */
    omit?: UpcomingReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpcomingReviewInclude<ExtArgs> | null
    /**
     * Filter, which UpcomingReviews to fetch.
     */
    where?: UpcomingReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UpcomingReviews to fetch.
     */
    orderBy?: UpcomingReviewOrderByWithRelationInput | UpcomingReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UpcomingReviews.
     */
    cursor?: UpcomingReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UpcomingReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UpcomingReviews.
     */
    skip?: number
    distinct?: UpcomingReviewScalarFieldEnum | UpcomingReviewScalarFieldEnum[]
  }

  /**
   * UpcomingReview create
   */
  export type UpcomingReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpcomingReview
     */
    select?: UpcomingReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UpcomingReview
     */
    omit?: UpcomingReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpcomingReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a UpcomingReview.
     */
    data: XOR<UpcomingReviewCreateInput, UpcomingReviewUncheckedCreateInput>
  }

  /**
   * UpcomingReview createMany
   */
  export type UpcomingReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UpcomingReviews.
     */
    data: UpcomingReviewCreateManyInput | UpcomingReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UpcomingReview createManyAndReturn
   */
  export type UpcomingReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpcomingReview
     */
    select?: UpcomingReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UpcomingReview
     */
    omit?: UpcomingReviewOmit<ExtArgs> | null
    /**
     * The data used to create many UpcomingReviews.
     */
    data: UpcomingReviewCreateManyInput | UpcomingReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpcomingReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UpcomingReview update
   */
  export type UpcomingReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpcomingReview
     */
    select?: UpcomingReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UpcomingReview
     */
    omit?: UpcomingReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpcomingReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a UpcomingReview.
     */
    data: XOR<UpcomingReviewUpdateInput, UpcomingReviewUncheckedUpdateInput>
    /**
     * Choose, which UpcomingReview to update.
     */
    where: UpcomingReviewWhereUniqueInput
  }

  /**
   * UpcomingReview updateMany
   */
  export type UpcomingReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UpcomingReviews.
     */
    data: XOR<UpcomingReviewUpdateManyMutationInput, UpcomingReviewUncheckedUpdateManyInput>
    /**
     * Filter which UpcomingReviews to update
     */
    where?: UpcomingReviewWhereInput
    /**
     * Limit how many UpcomingReviews to update.
     */
    limit?: number
  }

  /**
   * UpcomingReview updateManyAndReturn
   */
  export type UpcomingReviewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpcomingReview
     */
    select?: UpcomingReviewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UpcomingReview
     */
    omit?: UpcomingReviewOmit<ExtArgs> | null
    /**
     * The data used to update UpcomingReviews.
     */
    data: XOR<UpcomingReviewUpdateManyMutationInput, UpcomingReviewUncheckedUpdateManyInput>
    /**
     * Filter which UpcomingReviews to update
     */
    where?: UpcomingReviewWhereInput
    /**
     * Limit how many UpcomingReviews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpcomingReviewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UpcomingReview upsert
   */
  export type UpcomingReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpcomingReview
     */
    select?: UpcomingReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UpcomingReview
     */
    omit?: UpcomingReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpcomingReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the UpcomingReview to update in case it exists.
     */
    where: UpcomingReviewWhereUniqueInput
    /**
     * In case the UpcomingReview found by the `where` argument doesn't exist, create a new UpcomingReview with this data.
     */
    create: XOR<UpcomingReviewCreateInput, UpcomingReviewUncheckedCreateInput>
    /**
     * In case the UpcomingReview was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UpcomingReviewUpdateInput, UpcomingReviewUncheckedUpdateInput>
  }

  /**
   * UpcomingReview delete
   */
  export type UpcomingReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpcomingReview
     */
    select?: UpcomingReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UpcomingReview
     */
    omit?: UpcomingReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpcomingReviewInclude<ExtArgs> | null
    /**
     * Filter which UpcomingReview to delete.
     */
    where: UpcomingReviewWhereUniqueInput
  }

  /**
   * UpcomingReview deleteMany
   */
  export type UpcomingReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UpcomingReviews to delete
     */
    where?: UpcomingReviewWhereInput
    /**
     * Limit how many UpcomingReviews to delete.
     */
    limit?: number
  }

  /**
   * UpcomingReview without action
   */
  export type UpcomingReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpcomingReview
     */
    select?: UpcomingReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UpcomingReview
     */
    omit?: UpcomingReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpcomingReviewInclude<ExtArgs> | null
  }


  /**
   * Model LearningPath
   */

  export type AggregateLearningPath = {
    _count: LearningPathCountAggregateOutputType | null
    _min: LearningPathMinAggregateOutputType | null
    _max: LearningPathMaxAggregateOutputType | null
  }

  export type LearningPathMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    shareId: string | null
    sharedAt: Date | null
  }

  export type LearningPathMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    shareId: string | null
    sharedAt: Date | null
  }

  export type LearningPathCountAggregateOutputType = {
    id: number
    title: number
    description: number
    userId: number
    content: number
    createdAt: number
    updatedAt: number
    shareId: number
    sharedAt: number
    _all: number
  }


  export type LearningPathMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    shareId?: true
    sharedAt?: true
  }

  export type LearningPathMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    shareId?: true
    sharedAt?: true
  }

  export type LearningPathCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    userId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    shareId?: true
    sharedAt?: true
    _all?: true
  }

  export type LearningPathAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LearningPath to aggregate.
     */
    where?: LearningPathWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningPaths to fetch.
     */
    orderBy?: LearningPathOrderByWithRelationInput | LearningPathOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LearningPathWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningPaths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningPaths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LearningPaths
    **/
    _count?: true | LearningPathCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LearningPathMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LearningPathMaxAggregateInputType
  }

  export type GetLearningPathAggregateType<T extends LearningPathAggregateArgs> = {
        [P in keyof T & keyof AggregateLearningPath]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLearningPath[P]>
      : GetScalarType<T[P], AggregateLearningPath[P]>
  }




  export type LearningPathGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearningPathWhereInput
    orderBy?: LearningPathOrderByWithAggregationInput | LearningPathOrderByWithAggregationInput[]
    by: LearningPathScalarFieldEnum[] | LearningPathScalarFieldEnum
    having?: LearningPathScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LearningPathCountAggregateInputType | true
    _min?: LearningPathMinAggregateInputType
    _max?: LearningPathMaxAggregateInputType
  }

  export type LearningPathGroupByOutputType = {
    id: string
    title: string
    description: string | null
    userId: string
    content: JsonValue
    createdAt: Date
    updatedAt: Date
    shareId: string | null
    sharedAt: Date | null
    _count: LearningPathCountAggregateOutputType | null
    _min: LearningPathMinAggregateOutputType | null
    _max: LearningPathMaxAggregateOutputType | null
  }

  type GetLearningPathGroupByPayload<T extends LearningPathGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LearningPathGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LearningPathGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LearningPathGroupByOutputType[P]>
            : GetScalarType<T[P], LearningPathGroupByOutputType[P]>
        }
      >
    >


  export type LearningPathSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    shareId?: boolean
    sharedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    items?: boolean | LearningPath$itemsArgs<ExtArgs>
    prerequisites?: boolean | LearningPath$prerequisitesArgs<ExtArgs>
    aiModuleItems?: boolean | LearningPath$aiModuleItemsArgs<ExtArgs>
    UserProgress?: boolean | LearningPath$UserProgressArgs<ExtArgs>
    _count?: boolean | LearningPathCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["learningPath"]>

  export type LearningPathSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    shareId?: boolean
    sharedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["learningPath"]>

  export type LearningPathSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    shareId?: boolean
    sharedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["learningPath"]>

  export type LearningPathSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    shareId?: boolean
    sharedAt?: boolean
  }

  export type LearningPathOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "userId" | "content" | "createdAt" | "updatedAt" | "shareId" | "sharedAt", ExtArgs["result"]["learningPath"]>
  export type LearningPathInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    items?: boolean | LearningPath$itemsArgs<ExtArgs>
    prerequisites?: boolean | LearningPath$prerequisitesArgs<ExtArgs>
    aiModuleItems?: boolean | LearningPath$aiModuleItemsArgs<ExtArgs>
    UserProgress?: boolean | LearningPath$UserProgressArgs<ExtArgs>
    _count?: boolean | LearningPathCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LearningPathIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LearningPathIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LearningPathPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LearningPath"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      items: Prisma.$LearningPathItemPayload<ExtArgs>[]
      prerequisites: Prisma.$PrerequisitePayload<ExtArgs>[]
      aiModuleItems: Prisma.$AIModuleLearningPathItemPayload<ExtArgs>[]
      UserProgress: Prisma.$UserProgressPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      userId: string
      content: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
      shareId: string | null
      sharedAt: Date | null
    }, ExtArgs["result"]["learningPath"]>
    composites: {}
  }

  type LearningPathGetPayload<S extends boolean | null | undefined | LearningPathDefaultArgs> = $Result.GetResult<Prisma.$LearningPathPayload, S>

  type LearningPathCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LearningPathFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LearningPathCountAggregateInputType | true
    }

  export interface LearningPathDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LearningPath'], meta: { name: 'LearningPath' } }
    /**
     * Find zero or one LearningPath that matches the filter.
     * @param {LearningPathFindUniqueArgs} args - Arguments to find a LearningPath
     * @example
     * // Get one LearningPath
     * const learningPath = await prisma.learningPath.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LearningPathFindUniqueArgs>(args: SelectSubset<T, LearningPathFindUniqueArgs<ExtArgs>>): Prisma__LearningPathClient<$Result.GetResult<Prisma.$LearningPathPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one LearningPath that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LearningPathFindUniqueOrThrowArgs} args - Arguments to find a LearningPath
     * @example
     * // Get one LearningPath
     * const learningPath = await prisma.learningPath.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LearningPathFindUniqueOrThrowArgs>(args: SelectSubset<T, LearningPathFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LearningPathClient<$Result.GetResult<Prisma.$LearningPathPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first LearningPath that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPathFindFirstArgs} args - Arguments to find a LearningPath
     * @example
     * // Get one LearningPath
     * const learningPath = await prisma.learningPath.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LearningPathFindFirstArgs>(args?: SelectSubset<T, LearningPathFindFirstArgs<ExtArgs>>): Prisma__LearningPathClient<$Result.GetResult<Prisma.$LearningPathPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first LearningPath that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPathFindFirstOrThrowArgs} args - Arguments to find a LearningPath
     * @example
     * // Get one LearningPath
     * const learningPath = await prisma.learningPath.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LearningPathFindFirstOrThrowArgs>(args?: SelectSubset<T, LearningPathFindFirstOrThrowArgs<ExtArgs>>): Prisma__LearningPathClient<$Result.GetResult<Prisma.$LearningPathPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more LearningPaths that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPathFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LearningPaths
     * const learningPaths = await prisma.learningPath.findMany()
     * 
     * // Get first 10 LearningPaths
     * const learningPaths = await prisma.learningPath.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const learningPathWithIdOnly = await prisma.learningPath.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LearningPathFindManyArgs>(args?: SelectSubset<T, LearningPathFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningPathPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a LearningPath.
     * @param {LearningPathCreateArgs} args - Arguments to create a LearningPath.
     * @example
     * // Create one LearningPath
     * const LearningPath = await prisma.learningPath.create({
     *   data: {
     *     // ... data to create a LearningPath
     *   }
     * })
     * 
     */
    create<T extends LearningPathCreateArgs>(args: SelectSubset<T, LearningPathCreateArgs<ExtArgs>>): Prisma__LearningPathClient<$Result.GetResult<Prisma.$LearningPathPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many LearningPaths.
     * @param {LearningPathCreateManyArgs} args - Arguments to create many LearningPaths.
     * @example
     * // Create many LearningPaths
     * const learningPath = await prisma.learningPath.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LearningPathCreateManyArgs>(args?: SelectSubset<T, LearningPathCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LearningPaths and returns the data saved in the database.
     * @param {LearningPathCreateManyAndReturnArgs} args - Arguments to create many LearningPaths.
     * @example
     * // Create many LearningPaths
     * const learningPath = await prisma.learningPath.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LearningPaths and only return the `id`
     * const learningPathWithIdOnly = await prisma.learningPath.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LearningPathCreateManyAndReturnArgs>(args?: SelectSubset<T, LearningPathCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningPathPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a LearningPath.
     * @param {LearningPathDeleteArgs} args - Arguments to delete one LearningPath.
     * @example
     * // Delete one LearningPath
     * const LearningPath = await prisma.learningPath.delete({
     *   where: {
     *     // ... filter to delete one LearningPath
     *   }
     * })
     * 
     */
    delete<T extends LearningPathDeleteArgs>(args: SelectSubset<T, LearningPathDeleteArgs<ExtArgs>>): Prisma__LearningPathClient<$Result.GetResult<Prisma.$LearningPathPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one LearningPath.
     * @param {LearningPathUpdateArgs} args - Arguments to update one LearningPath.
     * @example
     * // Update one LearningPath
     * const learningPath = await prisma.learningPath.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LearningPathUpdateArgs>(args: SelectSubset<T, LearningPathUpdateArgs<ExtArgs>>): Prisma__LearningPathClient<$Result.GetResult<Prisma.$LearningPathPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more LearningPaths.
     * @param {LearningPathDeleteManyArgs} args - Arguments to filter LearningPaths to delete.
     * @example
     * // Delete a few LearningPaths
     * const { count } = await prisma.learningPath.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LearningPathDeleteManyArgs>(args?: SelectSubset<T, LearningPathDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LearningPaths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPathUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LearningPaths
     * const learningPath = await prisma.learningPath.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LearningPathUpdateManyArgs>(args: SelectSubset<T, LearningPathUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LearningPaths and returns the data updated in the database.
     * @param {LearningPathUpdateManyAndReturnArgs} args - Arguments to update many LearningPaths.
     * @example
     * // Update many LearningPaths
     * const learningPath = await prisma.learningPath.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LearningPaths and only return the `id`
     * const learningPathWithIdOnly = await prisma.learningPath.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LearningPathUpdateManyAndReturnArgs>(args: SelectSubset<T, LearningPathUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningPathPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one LearningPath.
     * @param {LearningPathUpsertArgs} args - Arguments to update or create a LearningPath.
     * @example
     * // Update or create a LearningPath
     * const learningPath = await prisma.learningPath.upsert({
     *   create: {
     *     // ... data to create a LearningPath
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LearningPath we want to update
     *   }
     * })
     */
    upsert<T extends LearningPathUpsertArgs>(args: SelectSubset<T, LearningPathUpsertArgs<ExtArgs>>): Prisma__LearningPathClient<$Result.GetResult<Prisma.$LearningPathPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of LearningPaths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPathCountArgs} args - Arguments to filter LearningPaths to count.
     * @example
     * // Count the number of LearningPaths
     * const count = await prisma.learningPath.count({
     *   where: {
     *     // ... the filter for the LearningPaths we want to count
     *   }
     * })
    **/
    count<T extends LearningPathCountArgs>(
      args?: Subset<T, LearningPathCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LearningPathCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LearningPath.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPathAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LearningPathAggregateArgs>(args: Subset<T, LearningPathAggregateArgs>): Prisma.PrismaPromise<GetLearningPathAggregateType<T>>

    /**
     * Group by LearningPath.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPathGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LearningPathGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LearningPathGroupByArgs['orderBy'] }
        : { orderBy?: LearningPathGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LearningPathGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLearningPathGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LearningPath model
   */
  readonly fields: LearningPathFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LearningPath.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LearningPathClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    items<T extends LearningPath$itemsArgs<ExtArgs> = {}>(args?: Subset<T, LearningPath$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningPathItemPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    prerequisites<T extends LearningPath$prerequisitesArgs<ExtArgs> = {}>(args?: Subset<T, LearningPath$prerequisitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrerequisitePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    aiModuleItems<T extends LearningPath$aiModuleItemsArgs<ExtArgs> = {}>(args?: Subset<T, LearningPath$aiModuleItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIModuleLearningPathItemPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    UserProgress<T extends LearningPath$UserProgressArgs<ExtArgs> = {}>(args?: Subset<T, LearningPath$UserProgressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LearningPath model
   */ 
  interface LearningPathFieldRefs {
    readonly id: FieldRef<"LearningPath", 'String'>
    readonly title: FieldRef<"LearningPath", 'String'>
    readonly description: FieldRef<"LearningPath", 'String'>
    readonly userId: FieldRef<"LearningPath", 'String'>
    readonly content: FieldRef<"LearningPath", 'Json'>
    readonly createdAt: FieldRef<"LearningPath", 'DateTime'>
    readonly updatedAt: FieldRef<"LearningPath", 'DateTime'>
    readonly shareId: FieldRef<"LearningPath", 'String'>
    readonly sharedAt: FieldRef<"LearningPath", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LearningPath findUnique
   */
  export type LearningPathFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPath
     */
    select?: LearningPathSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPath
     */
    omit?: LearningPathOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathInclude<ExtArgs> | null
    /**
     * Filter, which LearningPath to fetch.
     */
    where: LearningPathWhereUniqueInput
  }

  /**
   * LearningPath findUniqueOrThrow
   */
  export type LearningPathFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPath
     */
    select?: LearningPathSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPath
     */
    omit?: LearningPathOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathInclude<ExtArgs> | null
    /**
     * Filter, which LearningPath to fetch.
     */
    where: LearningPathWhereUniqueInput
  }

  /**
   * LearningPath findFirst
   */
  export type LearningPathFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPath
     */
    select?: LearningPathSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPath
     */
    omit?: LearningPathOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathInclude<ExtArgs> | null
    /**
     * Filter, which LearningPath to fetch.
     */
    where?: LearningPathWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningPaths to fetch.
     */
    orderBy?: LearningPathOrderByWithRelationInput | LearningPathOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LearningPaths.
     */
    cursor?: LearningPathWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningPaths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningPaths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LearningPaths.
     */
    distinct?: LearningPathScalarFieldEnum | LearningPathScalarFieldEnum[]
  }

  /**
   * LearningPath findFirstOrThrow
   */
  export type LearningPathFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPath
     */
    select?: LearningPathSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPath
     */
    omit?: LearningPathOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathInclude<ExtArgs> | null
    /**
     * Filter, which LearningPath to fetch.
     */
    where?: LearningPathWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningPaths to fetch.
     */
    orderBy?: LearningPathOrderByWithRelationInput | LearningPathOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LearningPaths.
     */
    cursor?: LearningPathWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningPaths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningPaths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LearningPaths.
     */
    distinct?: LearningPathScalarFieldEnum | LearningPathScalarFieldEnum[]
  }

  /**
   * LearningPath findMany
   */
  export type LearningPathFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPath
     */
    select?: LearningPathSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPath
     */
    omit?: LearningPathOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathInclude<ExtArgs> | null
    /**
     * Filter, which LearningPaths to fetch.
     */
    where?: LearningPathWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningPaths to fetch.
     */
    orderBy?: LearningPathOrderByWithRelationInput | LearningPathOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LearningPaths.
     */
    cursor?: LearningPathWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningPaths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningPaths.
     */
    skip?: number
    distinct?: LearningPathScalarFieldEnum | LearningPathScalarFieldEnum[]
  }

  /**
   * LearningPath create
   */
  export type LearningPathCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPath
     */
    select?: LearningPathSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPath
     */
    omit?: LearningPathOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathInclude<ExtArgs> | null
    /**
     * The data needed to create a LearningPath.
     */
    data: XOR<LearningPathCreateInput, LearningPathUncheckedCreateInput>
  }

  /**
   * LearningPath createMany
   */
  export type LearningPathCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LearningPaths.
     */
    data: LearningPathCreateManyInput | LearningPathCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LearningPath createManyAndReturn
   */
  export type LearningPathCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPath
     */
    select?: LearningPathSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPath
     */
    omit?: LearningPathOmit<ExtArgs> | null
    /**
     * The data used to create many LearningPaths.
     */
    data: LearningPathCreateManyInput | LearningPathCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LearningPath update
   */
  export type LearningPathUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPath
     */
    select?: LearningPathSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPath
     */
    omit?: LearningPathOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathInclude<ExtArgs> | null
    /**
     * The data needed to update a LearningPath.
     */
    data: XOR<LearningPathUpdateInput, LearningPathUncheckedUpdateInput>
    /**
     * Choose, which LearningPath to update.
     */
    where: LearningPathWhereUniqueInput
  }

  /**
   * LearningPath updateMany
   */
  export type LearningPathUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LearningPaths.
     */
    data: XOR<LearningPathUpdateManyMutationInput, LearningPathUncheckedUpdateManyInput>
    /**
     * Filter which LearningPaths to update
     */
    where?: LearningPathWhereInput
    /**
     * Limit how many LearningPaths to update.
     */
    limit?: number
  }

  /**
   * LearningPath updateManyAndReturn
   */
  export type LearningPathUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPath
     */
    select?: LearningPathSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPath
     */
    omit?: LearningPathOmit<ExtArgs> | null
    /**
     * The data used to update LearningPaths.
     */
    data: XOR<LearningPathUpdateManyMutationInput, LearningPathUncheckedUpdateManyInput>
    /**
     * Filter which LearningPaths to update
     */
    where?: LearningPathWhereInput
    /**
     * Limit how many LearningPaths to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LearningPath upsert
   */
  export type LearningPathUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPath
     */
    select?: LearningPathSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPath
     */
    omit?: LearningPathOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathInclude<ExtArgs> | null
    /**
     * The filter to search for the LearningPath to update in case it exists.
     */
    where: LearningPathWhereUniqueInput
    /**
     * In case the LearningPath found by the `where` argument doesn't exist, create a new LearningPath with this data.
     */
    create: XOR<LearningPathCreateInput, LearningPathUncheckedCreateInput>
    /**
     * In case the LearningPath was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LearningPathUpdateInput, LearningPathUncheckedUpdateInput>
  }

  /**
   * LearningPath delete
   */
  export type LearningPathDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPath
     */
    select?: LearningPathSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPath
     */
    omit?: LearningPathOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathInclude<ExtArgs> | null
    /**
     * Filter which LearningPath to delete.
     */
    where: LearningPathWhereUniqueInput
  }

  /**
   * LearningPath deleteMany
   */
  export type LearningPathDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LearningPaths to delete
     */
    where?: LearningPathWhereInput
    /**
     * Limit how many LearningPaths to delete.
     */
    limit?: number
  }

  /**
   * LearningPath.items
   */
  export type LearningPath$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathItem
     */
    select?: LearningPathItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathItem
     */
    omit?: LearningPathItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathItemInclude<ExtArgs> | null
    where?: LearningPathItemWhereInput
    orderBy?: LearningPathItemOrderByWithRelationInput | LearningPathItemOrderByWithRelationInput[]
    cursor?: LearningPathItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LearningPathItemScalarFieldEnum | LearningPathItemScalarFieldEnum[]
  }

  /**
   * LearningPath.prerequisites
   */
  export type LearningPath$prerequisitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prerequisite
     */
    select?: PrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prerequisite
     */
    omit?: PrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrerequisiteInclude<ExtArgs> | null
    where?: PrerequisiteWhereInput
    orderBy?: PrerequisiteOrderByWithRelationInput | PrerequisiteOrderByWithRelationInput[]
    cursor?: PrerequisiteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrerequisiteScalarFieldEnum | PrerequisiteScalarFieldEnum[]
  }

  /**
   * LearningPath.aiModuleItems
   */
  export type LearningPath$aiModuleItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModuleLearningPathItem
     */
    select?: AIModuleLearningPathItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIModuleLearningPathItem
     */
    omit?: AIModuleLearningPathItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModuleLearningPathItemInclude<ExtArgs> | null
    where?: AIModuleLearningPathItemWhereInput
    orderBy?: AIModuleLearningPathItemOrderByWithRelationInput | AIModuleLearningPathItemOrderByWithRelationInput[]
    cursor?: AIModuleLearningPathItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AIModuleLearningPathItemScalarFieldEnum | AIModuleLearningPathItemScalarFieldEnum[]
  }

  /**
   * LearningPath.UserProgress
   */
  export type LearningPath$UserProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    where?: UserProgressWhereInput
    orderBy?: UserProgressOrderByWithRelationInput | UserProgressOrderByWithRelationInput[]
    cursor?: UserProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserProgressScalarFieldEnum | UserProgressScalarFieldEnum[]
  }

  /**
   * LearningPath without action
   */
  export type LearningPathDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPath
     */
    select?: LearningPathSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPath
     */
    omit?: LearningPathOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathInclude<ExtArgs> | null
  }


  /**
   * Model LearningPathItem
   */

  export type AggregateLearningPathItem = {
    _count: LearningPathItemCountAggregateOutputType | null
    _avg: LearningPathItemAvgAggregateOutputType | null
    _sum: LearningPathItemSumAggregateOutputType | null
    _min: LearningPathItemMinAggregateOutputType | null
    _max: LearningPathItemMaxAggregateOutputType | null
  }

  export type LearningPathItemAvgAggregateOutputType = {
    order: number | null
    confidence: number | null
  }

  export type LearningPathItemSumAggregateOutputType = {
    order: number | null
    confidence: number | null
  }

  export type LearningPathItemMinAggregateOutputType = {
    id: string | null
    order: number | null
    learningPathId: string | null
    topicId: string | null
    confidence: number | null
  }

  export type LearningPathItemMaxAggregateOutputType = {
    id: string | null
    order: number | null
    learningPathId: string | null
    topicId: string | null
    confidence: number | null
  }

  export type LearningPathItemCountAggregateOutputType = {
    id: number
    order: number
    learningPathId: number
    topicId: number
    confidence: number
    _all: number
  }


  export type LearningPathItemAvgAggregateInputType = {
    order?: true
    confidence?: true
  }

  export type LearningPathItemSumAggregateInputType = {
    order?: true
    confidence?: true
  }

  export type LearningPathItemMinAggregateInputType = {
    id?: true
    order?: true
    learningPathId?: true
    topicId?: true
    confidence?: true
  }

  export type LearningPathItemMaxAggregateInputType = {
    id?: true
    order?: true
    learningPathId?: true
    topicId?: true
    confidence?: true
  }

  export type LearningPathItemCountAggregateInputType = {
    id?: true
    order?: true
    learningPathId?: true
    topicId?: true
    confidence?: true
    _all?: true
  }

  export type LearningPathItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LearningPathItem to aggregate.
     */
    where?: LearningPathItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningPathItems to fetch.
     */
    orderBy?: LearningPathItemOrderByWithRelationInput | LearningPathItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LearningPathItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningPathItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningPathItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LearningPathItems
    **/
    _count?: true | LearningPathItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LearningPathItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LearningPathItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LearningPathItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LearningPathItemMaxAggregateInputType
  }

  export type GetLearningPathItemAggregateType<T extends LearningPathItemAggregateArgs> = {
        [P in keyof T & keyof AggregateLearningPathItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLearningPathItem[P]>
      : GetScalarType<T[P], AggregateLearningPathItem[P]>
  }




  export type LearningPathItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearningPathItemWhereInput
    orderBy?: LearningPathItemOrderByWithAggregationInput | LearningPathItemOrderByWithAggregationInput[]
    by: LearningPathItemScalarFieldEnum[] | LearningPathItemScalarFieldEnum
    having?: LearningPathItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LearningPathItemCountAggregateInputType | true
    _avg?: LearningPathItemAvgAggregateInputType
    _sum?: LearningPathItemSumAggregateInputType
    _min?: LearningPathItemMinAggregateInputType
    _max?: LearningPathItemMaxAggregateInputType
  }

  export type LearningPathItemGroupByOutputType = {
    id: string
    order: number
    learningPathId: string
    topicId: string
    confidence: number
    _count: LearningPathItemCountAggregateOutputType | null
    _avg: LearningPathItemAvgAggregateOutputType | null
    _sum: LearningPathItemSumAggregateOutputType | null
    _min: LearningPathItemMinAggregateOutputType | null
    _max: LearningPathItemMaxAggregateOutputType | null
  }

  type GetLearningPathItemGroupByPayload<T extends LearningPathItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LearningPathItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LearningPathItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LearningPathItemGroupByOutputType[P]>
            : GetScalarType<T[P], LearningPathItemGroupByOutputType[P]>
        }
      >
    >


  export type LearningPathItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    order?: boolean
    learningPathId?: boolean
    topicId?: boolean
    confidence?: boolean
    learningPath?: boolean | LearningPathDefaultArgs<ExtArgs>
    topic?: boolean | TopicDefaultArgs<ExtArgs>
    UserProgress?: boolean | LearningPathItem$UserProgressArgs<ExtArgs>
    _count?: boolean | LearningPathItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["learningPathItem"]>

  export type LearningPathItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    order?: boolean
    learningPathId?: boolean
    topicId?: boolean
    confidence?: boolean
    learningPath?: boolean | LearningPathDefaultArgs<ExtArgs>
    topic?: boolean | TopicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["learningPathItem"]>

  export type LearningPathItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    order?: boolean
    learningPathId?: boolean
    topicId?: boolean
    confidence?: boolean
    learningPath?: boolean | LearningPathDefaultArgs<ExtArgs>
    topic?: boolean | TopicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["learningPathItem"]>

  export type LearningPathItemSelectScalar = {
    id?: boolean
    order?: boolean
    learningPathId?: boolean
    topicId?: boolean
    confidence?: boolean
  }

  export type LearningPathItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "order" | "learningPathId" | "topicId" | "confidence", ExtArgs["result"]["learningPathItem"]>
  export type LearningPathItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    learningPath?: boolean | LearningPathDefaultArgs<ExtArgs>
    topic?: boolean | TopicDefaultArgs<ExtArgs>
    UserProgress?: boolean | LearningPathItem$UserProgressArgs<ExtArgs>
    _count?: boolean | LearningPathItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LearningPathItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    learningPath?: boolean | LearningPathDefaultArgs<ExtArgs>
    topic?: boolean | TopicDefaultArgs<ExtArgs>
  }
  export type LearningPathItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    learningPath?: boolean | LearningPathDefaultArgs<ExtArgs>
    topic?: boolean | TopicDefaultArgs<ExtArgs>
  }

  export type $LearningPathItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LearningPathItem"
    objects: {
      learningPath: Prisma.$LearningPathPayload<ExtArgs>
      topic: Prisma.$TopicPayload<ExtArgs>
      UserProgress: Prisma.$UserProgressPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      order: number
      learningPathId: string
      topicId: string
      confidence: number
    }, ExtArgs["result"]["learningPathItem"]>
    composites: {}
  }

  type LearningPathItemGetPayload<S extends boolean | null | undefined | LearningPathItemDefaultArgs> = $Result.GetResult<Prisma.$LearningPathItemPayload, S>

  type LearningPathItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LearningPathItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LearningPathItemCountAggregateInputType | true
    }

  export interface LearningPathItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LearningPathItem'], meta: { name: 'LearningPathItem' } }
    /**
     * Find zero or one LearningPathItem that matches the filter.
     * @param {LearningPathItemFindUniqueArgs} args - Arguments to find a LearningPathItem
     * @example
     * // Get one LearningPathItem
     * const learningPathItem = await prisma.learningPathItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LearningPathItemFindUniqueArgs>(args: SelectSubset<T, LearningPathItemFindUniqueArgs<ExtArgs>>): Prisma__LearningPathItemClient<$Result.GetResult<Prisma.$LearningPathItemPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one LearningPathItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LearningPathItemFindUniqueOrThrowArgs} args - Arguments to find a LearningPathItem
     * @example
     * // Get one LearningPathItem
     * const learningPathItem = await prisma.learningPathItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LearningPathItemFindUniqueOrThrowArgs>(args: SelectSubset<T, LearningPathItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LearningPathItemClient<$Result.GetResult<Prisma.$LearningPathItemPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first LearningPathItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPathItemFindFirstArgs} args - Arguments to find a LearningPathItem
     * @example
     * // Get one LearningPathItem
     * const learningPathItem = await prisma.learningPathItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LearningPathItemFindFirstArgs>(args?: SelectSubset<T, LearningPathItemFindFirstArgs<ExtArgs>>): Prisma__LearningPathItemClient<$Result.GetResult<Prisma.$LearningPathItemPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first LearningPathItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPathItemFindFirstOrThrowArgs} args - Arguments to find a LearningPathItem
     * @example
     * // Get one LearningPathItem
     * const learningPathItem = await prisma.learningPathItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LearningPathItemFindFirstOrThrowArgs>(args?: SelectSubset<T, LearningPathItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__LearningPathItemClient<$Result.GetResult<Prisma.$LearningPathItemPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more LearningPathItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPathItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LearningPathItems
     * const learningPathItems = await prisma.learningPathItem.findMany()
     * 
     * // Get first 10 LearningPathItems
     * const learningPathItems = await prisma.learningPathItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const learningPathItemWithIdOnly = await prisma.learningPathItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LearningPathItemFindManyArgs>(args?: SelectSubset<T, LearningPathItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningPathItemPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a LearningPathItem.
     * @param {LearningPathItemCreateArgs} args - Arguments to create a LearningPathItem.
     * @example
     * // Create one LearningPathItem
     * const LearningPathItem = await prisma.learningPathItem.create({
     *   data: {
     *     // ... data to create a LearningPathItem
     *   }
     * })
     * 
     */
    create<T extends LearningPathItemCreateArgs>(args: SelectSubset<T, LearningPathItemCreateArgs<ExtArgs>>): Prisma__LearningPathItemClient<$Result.GetResult<Prisma.$LearningPathItemPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many LearningPathItems.
     * @param {LearningPathItemCreateManyArgs} args - Arguments to create many LearningPathItems.
     * @example
     * // Create many LearningPathItems
     * const learningPathItem = await prisma.learningPathItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LearningPathItemCreateManyArgs>(args?: SelectSubset<T, LearningPathItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LearningPathItems and returns the data saved in the database.
     * @param {LearningPathItemCreateManyAndReturnArgs} args - Arguments to create many LearningPathItems.
     * @example
     * // Create many LearningPathItems
     * const learningPathItem = await prisma.learningPathItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LearningPathItems and only return the `id`
     * const learningPathItemWithIdOnly = await prisma.learningPathItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LearningPathItemCreateManyAndReturnArgs>(args?: SelectSubset<T, LearningPathItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningPathItemPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a LearningPathItem.
     * @param {LearningPathItemDeleteArgs} args - Arguments to delete one LearningPathItem.
     * @example
     * // Delete one LearningPathItem
     * const LearningPathItem = await prisma.learningPathItem.delete({
     *   where: {
     *     // ... filter to delete one LearningPathItem
     *   }
     * })
     * 
     */
    delete<T extends LearningPathItemDeleteArgs>(args: SelectSubset<T, LearningPathItemDeleteArgs<ExtArgs>>): Prisma__LearningPathItemClient<$Result.GetResult<Prisma.$LearningPathItemPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one LearningPathItem.
     * @param {LearningPathItemUpdateArgs} args - Arguments to update one LearningPathItem.
     * @example
     * // Update one LearningPathItem
     * const learningPathItem = await prisma.learningPathItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LearningPathItemUpdateArgs>(args: SelectSubset<T, LearningPathItemUpdateArgs<ExtArgs>>): Prisma__LearningPathItemClient<$Result.GetResult<Prisma.$LearningPathItemPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more LearningPathItems.
     * @param {LearningPathItemDeleteManyArgs} args - Arguments to filter LearningPathItems to delete.
     * @example
     * // Delete a few LearningPathItems
     * const { count } = await prisma.learningPathItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LearningPathItemDeleteManyArgs>(args?: SelectSubset<T, LearningPathItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LearningPathItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPathItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LearningPathItems
     * const learningPathItem = await prisma.learningPathItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LearningPathItemUpdateManyArgs>(args: SelectSubset<T, LearningPathItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LearningPathItems and returns the data updated in the database.
     * @param {LearningPathItemUpdateManyAndReturnArgs} args - Arguments to update many LearningPathItems.
     * @example
     * // Update many LearningPathItems
     * const learningPathItem = await prisma.learningPathItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LearningPathItems and only return the `id`
     * const learningPathItemWithIdOnly = await prisma.learningPathItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LearningPathItemUpdateManyAndReturnArgs>(args: SelectSubset<T, LearningPathItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningPathItemPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one LearningPathItem.
     * @param {LearningPathItemUpsertArgs} args - Arguments to update or create a LearningPathItem.
     * @example
     * // Update or create a LearningPathItem
     * const learningPathItem = await prisma.learningPathItem.upsert({
     *   create: {
     *     // ... data to create a LearningPathItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LearningPathItem we want to update
     *   }
     * })
     */
    upsert<T extends LearningPathItemUpsertArgs>(args: SelectSubset<T, LearningPathItemUpsertArgs<ExtArgs>>): Prisma__LearningPathItemClient<$Result.GetResult<Prisma.$LearningPathItemPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of LearningPathItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPathItemCountArgs} args - Arguments to filter LearningPathItems to count.
     * @example
     * // Count the number of LearningPathItems
     * const count = await prisma.learningPathItem.count({
     *   where: {
     *     // ... the filter for the LearningPathItems we want to count
     *   }
     * })
    **/
    count<T extends LearningPathItemCountArgs>(
      args?: Subset<T, LearningPathItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LearningPathItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LearningPathItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPathItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LearningPathItemAggregateArgs>(args: Subset<T, LearningPathItemAggregateArgs>): Prisma.PrismaPromise<GetLearningPathItemAggregateType<T>>

    /**
     * Group by LearningPathItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPathItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LearningPathItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LearningPathItemGroupByArgs['orderBy'] }
        : { orderBy?: LearningPathItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LearningPathItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLearningPathItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LearningPathItem model
   */
  readonly fields: LearningPathItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LearningPathItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LearningPathItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    learningPath<T extends LearningPathDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LearningPathDefaultArgs<ExtArgs>>): Prisma__LearningPathClient<$Result.GetResult<Prisma.$LearningPathPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    topic<T extends TopicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TopicDefaultArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    UserProgress<T extends LearningPathItem$UserProgressArgs<ExtArgs> = {}>(args?: Subset<T, LearningPathItem$UserProgressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LearningPathItem model
   */ 
  interface LearningPathItemFieldRefs {
    readonly id: FieldRef<"LearningPathItem", 'String'>
    readonly order: FieldRef<"LearningPathItem", 'Int'>
    readonly learningPathId: FieldRef<"LearningPathItem", 'String'>
    readonly topicId: FieldRef<"LearningPathItem", 'String'>
    readonly confidence: FieldRef<"LearningPathItem", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * LearningPathItem findUnique
   */
  export type LearningPathItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathItem
     */
    select?: LearningPathItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathItem
     */
    omit?: LearningPathItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathItemInclude<ExtArgs> | null
    /**
     * Filter, which LearningPathItem to fetch.
     */
    where: LearningPathItemWhereUniqueInput
  }

  /**
   * LearningPathItem findUniqueOrThrow
   */
  export type LearningPathItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathItem
     */
    select?: LearningPathItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathItem
     */
    omit?: LearningPathItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathItemInclude<ExtArgs> | null
    /**
     * Filter, which LearningPathItem to fetch.
     */
    where: LearningPathItemWhereUniqueInput
  }

  /**
   * LearningPathItem findFirst
   */
  export type LearningPathItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathItem
     */
    select?: LearningPathItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathItem
     */
    omit?: LearningPathItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathItemInclude<ExtArgs> | null
    /**
     * Filter, which LearningPathItem to fetch.
     */
    where?: LearningPathItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningPathItems to fetch.
     */
    orderBy?: LearningPathItemOrderByWithRelationInput | LearningPathItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LearningPathItems.
     */
    cursor?: LearningPathItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningPathItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningPathItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LearningPathItems.
     */
    distinct?: LearningPathItemScalarFieldEnum | LearningPathItemScalarFieldEnum[]
  }

  /**
   * LearningPathItem findFirstOrThrow
   */
  export type LearningPathItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathItem
     */
    select?: LearningPathItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathItem
     */
    omit?: LearningPathItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathItemInclude<ExtArgs> | null
    /**
     * Filter, which LearningPathItem to fetch.
     */
    where?: LearningPathItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningPathItems to fetch.
     */
    orderBy?: LearningPathItemOrderByWithRelationInput | LearningPathItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LearningPathItems.
     */
    cursor?: LearningPathItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningPathItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningPathItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LearningPathItems.
     */
    distinct?: LearningPathItemScalarFieldEnum | LearningPathItemScalarFieldEnum[]
  }

  /**
   * LearningPathItem findMany
   */
  export type LearningPathItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathItem
     */
    select?: LearningPathItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathItem
     */
    omit?: LearningPathItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathItemInclude<ExtArgs> | null
    /**
     * Filter, which LearningPathItems to fetch.
     */
    where?: LearningPathItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningPathItems to fetch.
     */
    orderBy?: LearningPathItemOrderByWithRelationInput | LearningPathItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LearningPathItems.
     */
    cursor?: LearningPathItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningPathItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningPathItems.
     */
    skip?: number
    distinct?: LearningPathItemScalarFieldEnum | LearningPathItemScalarFieldEnum[]
  }

  /**
   * LearningPathItem create
   */
  export type LearningPathItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathItem
     */
    select?: LearningPathItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathItem
     */
    omit?: LearningPathItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathItemInclude<ExtArgs> | null
    /**
     * The data needed to create a LearningPathItem.
     */
    data: XOR<LearningPathItemCreateInput, LearningPathItemUncheckedCreateInput>
  }

  /**
   * LearningPathItem createMany
   */
  export type LearningPathItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LearningPathItems.
     */
    data: LearningPathItemCreateManyInput | LearningPathItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LearningPathItem createManyAndReturn
   */
  export type LearningPathItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathItem
     */
    select?: LearningPathItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathItem
     */
    omit?: LearningPathItemOmit<ExtArgs> | null
    /**
     * The data used to create many LearningPathItems.
     */
    data: LearningPathItemCreateManyInput | LearningPathItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LearningPathItem update
   */
  export type LearningPathItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathItem
     */
    select?: LearningPathItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathItem
     */
    omit?: LearningPathItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathItemInclude<ExtArgs> | null
    /**
     * The data needed to update a LearningPathItem.
     */
    data: XOR<LearningPathItemUpdateInput, LearningPathItemUncheckedUpdateInput>
    /**
     * Choose, which LearningPathItem to update.
     */
    where: LearningPathItemWhereUniqueInput
  }

  /**
   * LearningPathItem updateMany
   */
  export type LearningPathItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LearningPathItems.
     */
    data: XOR<LearningPathItemUpdateManyMutationInput, LearningPathItemUncheckedUpdateManyInput>
    /**
     * Filter which LearningPathItems to update
     */
    where?: LearningPathItemWhereInput
    /**
     * Limit how many LearningPathItems to update.
     */
    limit?: number
  }

  /**
   * LearningPathItem updateManyAndReturn
   */
  export type LearningPathItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathItem
     */
    select?: LearningPathItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathItem
     */
    omit?: LearningPathItemOmit<ExtArgs> | null
    /**
     * The data used to update LearningPathItems.
     */
    data: XOR<LearningPathItemUpdateManyMutationInput, LearningPathItemUncheckedUpdateManyInput>
    /**
     * Filter which LearningPathItems to update
     */
    where?: LearningPathItemWhereInput
    /**
     * Limit how many LearningPathItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LearningPathItem upsert
   */
  export type LearningPathItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathItem
     */
    select?: LearningPathItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathItem
     */
    omit?: LearningPathItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathItemInclude<ExtArgs> | null
    /**
     * The filter to search for the LearningPathItem to update in case it exists.
     */
    where: LearningPathItemWhereUniqueInput
    /**
     * In case the LearningPathItem found by the `where` argument doesn't exist, create a new LearningPathItem with this data.
     */
    create: XOR<LearningPathItemCreateInput, LearningPathItemUncheckedCreateInput>
    /**
     * In case the LearningPathItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LearningPathItemUpdateInput, LearningPathItemUncheckedUpdateInput>
  }

  /**
   * LearningPathItem delete
   */
  export type LearningPathItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathItem
     */
    select?: LearningPathItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathItem
     */
    omit?: LearningPathItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathItemInclude<ExtArgs> | null
    /**
     * Filter which LearningPathItem to delete.
     */
    where: LearningPathItemWhereUniqueInput
  }

  /**
   * LearningPathItem deleteMany
   */
  export type LearningPathItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LearningPathItems to delete
     */
    where?: LearningPathItemWhereInput
    /**
     * Limit how many LearningPathItems to delete.
     */
    limit?: number
  }

  /**
   * LearningPathItem.UserProgress
   */
  export type LearningPathItem$UserProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    where?: UserProgressWhereInput
    orderBy?: UserProgressOrderByWithRelationInput | UserProgressOrderByWithRelationInput[]
    cursor?: UserProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserProgressScalarFieldEnum | UserProgressScalarFieldEnum[]
  }

  /**
   * LearningPathItem without action
   */
  export type LearningPathItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPathItem
     */
    select?: LearningPathItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningPathItem
     */
    omit?: LearningPathItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningPathItemInclude<ExtArgs> | null
  }


  /**
   * Model ContentItem
   */

  export type AggregateContentItem = {
    _count: ContentItemCountAggregateOutputType | null
    _min: ContentItemMinAggregateOutputType | null
    _max: ContentItemMaxAggregateOutputType | null
  }

  export type ContentItemMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    content: string | null
    type: string | null
    difficulty: string | null
    topicId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    version: string | null
  }

  export type ContentItemMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    content: string | null
    type: string | null
    difficulty: string | null
    topicId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    version: string | null
  }

  export type ContentItemCountAggregateOutputType = {
    id: number
    title: number
    description: number
    content: number
    type: number
    difficulty: number
    topicId: number
    createdAt: number
    updatedAt: number
    version: number
    _all: number
  }


  export type ContentItemMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    content?: true
    type?: true
    difficulty?: true
    topicId?: true
    createdAt?: true
    updatedAt?: true
    version?: true
  }

  export type ContentItemMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    content?: true
    type?: true
    difficulty?: true
    topicId?: true
    createdAt?: true
    updatedAt?: true
    version?: true
  }

  export type ContentItemCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    content?: true
    type?: true
    difficulty?: true
    topicId?: true
    createdAt?: true
    updatedAt?: true
    version?: true
    _all?: true
  }

  export type ContentItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentItem to aggregate.
     */
    where?: ContentItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentItems to fetch.
     */
    orderBy?: ContentItemOrderByWithRelationInput | ContentItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContentItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContentItems
    **/
    _count?: true | ContentItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContentItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContentItemMaxAggregateInputType
  }

  export type GetContentItemAggregateType<T extends ContentItemAggregateArgs> = {
        [P in keyof T & keyof AggregateContentItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContentItem[P]>
      : GetScalarType<T[P], AggregateContentItem[P]>
  }




  export type ContentItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentItemWhereInput
    orderBy?: ContentItemOrderByWithAggregationInput | ContentItemOrderByWithAggregationInput[]
    by: ContentItemScalarFieldEnum[] | ContentItemScalarFieldEnum
    having?: ContentItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContentItemCountAggregateInputType | true
    _min?: ContentItemMinAggregateInputType
    _max?: ContentItemMaxAggregateInputType
  }

  export type ContentItemGroupByOutputType = {
    id: string
    title: string
    description: string | null
    content: string
    type: string
    difficulty: string
    topicId: string
    createdAt: Date
    updatedAt: Date
    version: string
    _count: ContentItemCountAggregateOutputType | null
    _min: ContentItemMinAggregateOutputType | null
    _max: ContentItemMaxAggregateOutputType | null
  }

  type GetContentItemGroupByPayload<T extends ContentItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContentItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContentItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContentItemGroupByOutputType[P]>
            : GetScalarType<T[P], ContentItemGroupByOutputType[P]>
        }
      >
    >


  export type ContentItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    content?: boolean
    type?: boolean
    difficulty?: boolean
    topicId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    version?: boolean
    topic?: boolean | TopicDefaultArgs<ExtArgs>
    bookmarks?: boolean | ContentItem$bookmarksArgs<ExtArgs>
    quizAttempts?: boolean | ContentItem$quizAttemptsArgs<ExtArgs>
    reviewItems?: boolean | ContentItem$reviewItemsArgs<ExtArgs>
    ratings?: boolean | ContentItem$ratingsArgs<ExtArgs>
    aiPlaylistItems?: boolean | ContentItem$aiPlaylistItemsArgs<ExtArgs>
    _count?: boolean | ContentItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentItem"]>

  export type ContentItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    content?: boolean
    type?: boolean
    difficulty?: boolean
    topicId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    version?: boolean
    topic?: boolean | TopicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentItem"]>

  export type ContentItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    content?: boolean
    type?: boolean
    difficulty?: boolean
    topicId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    version?: boolean
    topic?: boolean | TopicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentItem"]>

  export type ContentItemSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    content?: boolean
    type?: boolean
    difficulty?: boolean
    topicId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    version?: boolean
  }

  export type ContentItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "content" | "type" | "difficulty" | "topicId" | "createdAt" | "updatedAt" | "version", ExtArgs["result"]["contentItem"]>
  export type ContentItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    topic?: boolean | TopicDefaultArgs<ExtArgs>
    bookmarks?: boolean | ContentItem$bookmarksArgs<ExtArgs>
    quizAttempts?: boolean | ContentItem$quizAttemptsArgs<ExtArgs>
    reviewItems?: boolean | ContentItem$reviewItemsArgs<ExtArgs>
    ratings?: boolean | ContentItem$ratingsArgs<ExtArgs>
    aiPlaylistItems?: boolean | ContentItem$aiPlaylistItemsArgs<ExtArgs>
    _count?: boolean | ContentItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ContentItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    topic?: boolean | TopicDefaultArgs<ExtArgs>
  }
  export type ContentItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    topic?: boolean | TopicDefaultArgs<ExtArgs>
  }

  export type $ContentItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContentItem"
    objects: {
      topic: Prisma.$TopicPayload<ExtArgs>
      bookmarks: Prisma.$BookmarkPayload<ExtArgs>[]
      quizAttempts: Prisma.$QuizAttemptPayload<ExtArgs>[]
      reviewItems: Prisma.$ReviewItemPayload<ExtArgs>[]
      ratings: Prisma.$ContentRatingPayload<ExtArgs>[]
      aiPlaylistItems: Prisma.$AIPlaylistItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      content: string
      type: string
      difficulty: string
      topicId: string
      createdAt: Date
      updatedAt: Date
      version: string
    }, ExtArgs["result"]["contentItem"]>
    composites: {}
  }

  type ContentItemGetPayload<S extends boolean | null | undefined | ContentItemDefaultArgs> = $Result.GetResult<Prisma.$ContentItemPayload, S>

  type ContentItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContentItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContentItemCountAggregateInputType | true
    }

  export interface ContentItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContentItem'], meta: { name: 'ContentItem' } }
    /**
     * Find zero or one ContentItem that matches the filter.
     * @param {ContentItemFindUniqueArgs} args - Arguments to find a ContentItem
     * @example
     * // Get one ContentItem
     * const contentItem = await prisma.contentItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContentItemFindUniqueArgs>(args: SelectSubset<T, ContentItemFindUniqueArgs<ExtArgs>>): Prisma__ContentItemClient<$Result.GetResult<Prisma.$ContentItemPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ContentItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContentItemFindUniqueOrThrowArgs} args - Arguments to find a ContentItem
     * @example
     * // Get one ContentItem
     * const contentItem = await prisma.contentItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContentItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ContentItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContentItemClient<$Result.GetResult<Prisma.$ContentItemPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ContentItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentItemFindFirstArgs} args - Arguments to find a ContentItem
     * @example
     * // Get one ContentItem
     * const contentItem = await prisma.contentItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContentItemFindFirstArgs>(args?: SelectSubset<T, ContentItemFindFirstArgs<ExtArgs>>): Prisma__ContentItemClient<$Result.GetResult<Prisma.$ContentItemPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ContentItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentItemFindFirstOrThrowArgs} args - Arguments to find a ContentItem
     * @example
     * // Get one ContentItem
     * const contentItem = await prisma.contentItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContentItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ContentItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContentItemClient<$Result.GetResult<Prisma.$ContentItemPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ContentItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContentItems
     * const contentItems = await prisma.contentItem.findMany()
     * 
     * // Get first 10 ContentItems
     * const contentItems = await prisma.contentItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contentItemWithIdOnly = await prisma.contentItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContentItemFindManyArgs>(args?: SelectSubset<T, ContentItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentItemPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ContentItem.
     * @param {ContentItemCreateArgs} args - Arguments to create a ContentItem.
     * @example
     * // Create one ContentItem
     * const ContentItem = await prisma.contentItem.create({
     *   data: {
     *     // ... data to create a ContentItem
     *   }
     * })
     * 
     */
    create<T extends ContentItemCreateArgs>(args: SelectSubset<T, ContentItemCreateArgs<ExtArgs>>): Prisma__ContentItemClient<$Result.GetResult<Prisma.$ContentItemPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ContentItems.
     * @param {ContentItemCreateManyArgs} args - Arguments to create many ContentItems.
     * @example
     * // Create many ContentItems
     * const contentItem = await prisma.contentItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContentItemCreateManyArgs>(args?: SelectSubset<T, ContentItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContentItems and returns the data saved in the database.
     * @param {ContentItemCreateManyAndReturnArgs} args - Arguments to create many ContentItems.
     * @example
     * // Create many ContentItems
     * const contentItem = await prisma.contentItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContentItems and only return the `id`
     * const contentItemWithIdOnly = await prisma.contentItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContentItemCreateManyAndReturnArgs>(args?: SelectSubset<T, ContentItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentItemPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a ContentItem.
     * @param {ContentItemDeleteArgs} args - Arguments to delete one ContentItem.
     * @example
     * // Delete one ContentItem
     * const ContentItem = await prisma.contentItem.delete({
     *   where: {
     *     // ... filter to delete one ContentItem
     *   }
     * })
     * 
     */
    delete<T extends ContentItemDeleteArgs>(args: SelectSubset<T, ContentItemDeleteArgs<ExtArgs>>): Prisma__ContentItemClient<$Result.GetResult<Prisma.$ContentItemPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ContentItem.
     * @param {ContentItemUpdateArgs} args - Arguments to update one ContentItem.
     * @example
     * // Update one ContentItem
     * const contentItem = await prisma.contentItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContentItemUpdateArgs>(args: SelectSubset<T, ContentItemUpdateArgs<ExtArgs>>): Prisma__ContentItemClient<$Result.GetResult<Prisma.$ContentItemPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ContentItems.
     * @param {ContentItemDeleteManyArgs} args - Arguments to filter ContentItems to delete.
     * @example
     * // Delete a few ContentItems
     * const { count } = await prisma.contentItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContentItemDeleteManyArgs>(args?: SelectSubset<T, ContentItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContentItems
     * const contentItem = await prisma.contentItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContentItemUpdateManyArgs>(args: SelectSubset<T, ContentItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentItems and returns the data updated in the database.
     * @param {ContentItemUpdateManyAndReturnArgs} args - Arguments to update many ContentItems.
     * @example
     * // Update many ContentItems
     * const contentItem = await prisma.contentItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContentItems and only return the `id`
     * const contentItemWithIdOnly = await prisma.contentItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContentItemUpdateManyAndReturnArgs>(args: SelectSubset<T, ContentItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentItemPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one ContentItem.
     * @param {ContentItemUpsertArgs} args - Arguments to update or create a ContentItem.
     * @example
     * // Update or create a ContentItem
     * const contentItem = await prisma.contentItem.upsert({
     *   create: {
     *     // ... data to create a ContentItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContentItem we want to update
     *   }
     * })
     */
    upsert<T extends ContentItemUpsertArgs>(args: SelectSubset<T, ContentItemUpsertArgs<ExtArgs>>): Prisma__ContentItemClient<$Result.GetResult<Prisma.$ContentItemPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ContentItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentItemCountArgs} args - Arguments to filter ContentItems to count.
     * @example
     * // Count the number of ContentItems
     * const count = await prisma.contentItem.count({
     *   where: {
     *     // ... the filter for the ContentItems we want to count
     *   }
     * })
    **/
    count<T extends ContentItemCountArgs>(
      args?: Subset<T, ContentItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContentItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContentItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContentItemAggregateArgs>(args: Subset<T, ContentItemAggregateArgs>): Prisma.PrismaPromise<GetContentItemAggregateType<T>>

    /**
     * Group by ContentItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContentItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContentItemGroupByArgs['orderBy'] }
        : { orderBy?: ContentItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContentItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContentItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContentItem model
   */
  readonly fields: ContentItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContentItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContentItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    topic<T extends TopicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TopicDefaultArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    bookmarks<T extends ContentItem$bookmarksArgs<ExtArgs> = {}>(args?: Subset<T, ContentItem$bookmarksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookmarkPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    quizAttempts<T extends ContentItem$quizAttemptsArgs<ExtArgs> = {}>(args?: Subset<T, ContentItem$quizAttemptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    reviewItems<T extends ContentItem$reviewItemsArgs<ExtArgs> = {}>(args?: Subset<T, ContentItem$reviewItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewItemPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    ratings<T extends ContentItem$ratingsArgs<ExtArgs> = {}>(args?: Subset<T, ContentItem$ratingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentRatingPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    aiPlaylistItems<T extends ContentItem$aiPlaylistItemsArgs<ExtArgs> = {}>(args?: Subset<T, ContentItem$aiPlaylistItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIPlaylistItemPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContentItem model
   */ 
  interface ContentItemFieldRefs {
    readonly id: FieldRef<"ContentItem", 'String'>
    readonly title: FieldRef<"ContentItem", 'String'>
    readonly description: FieldRef<"ContentItem", 'String'>
    readonly content: FieldRef<"ContentItem", 'String'>
    readonly type: FieldRef<"ContentItem", 'String'>
    readonly difficulty: FieldRef<"ContentItem", 'String'>
    readonly topicId: FieldRef<"ContentItem", 'String'>
    readonly createdAt: FieldRef<"ContentItem", 'DateTime'>
    readonly updatedAt: FieldRef<"ContentItem", 'DateTime'>
    readonly version: FieldRef<"ContentItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ContentItem findUnique
   */
  export type ContentItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentItem
     */
    select?: ContentItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentItem
     */
    omit?: ContentItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentItemInclude<ExtArgs> | null
    /**
     * Filter, which ContentItem to fetch.
     */
    where: ContentItemWhereUniqueInput
  }

  /**
   * ContentItem findUniqueOrThrow
   */
  export type ContentItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentItem
     */
    select?: ContentItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentItem
     */
    omit?: ContentItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentItemInclude<ExtArgs> | null
    /**
     * Filter, which ContentItem to fetch.
     */
    where: ContentItemWhereUniqueInput
  }

  /**
   * ContentItem findFirst
   */
  export type ContentItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentItem
     */
    select?: ContentItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentItem
     */
    omit?: ContentItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentItemInclude<ExtArgs> | null
    /**
     * Filter, which ContentItem to fetch.
     */
    where?: ContentItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentItems to fetch.
     */
    orderBy?: ContentItemOrderByWithRelationInput | ContentItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentItems.
     */
    cursor?: ContentItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentItems.
     */
    distinct?: ContentItemScalarFieldEnum | ContentItemScalarFieldEnum[]
  }

  /**
   * ContentItem findFirstOrThrow
   */
  export type ContentItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentItem
     */
    select?: ContentItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentItem
     */
    omit?: ContentItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentItemInclude<ExtArgs> | null
    /**
     * Filter, which ContentItem to fetch.
     */
    where?: ContentItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentItems to fetch.
     */
    orderBy?: ContentItemOrderByWithRelationInput | ContentItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentItems.
     */
    cursor?: ContentItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentItems.
     */
    distinct?: ContentItemScalarFieldEnum | ContentItemScalarFieldEnum[]
  }

  /**
   * ContentItem findMany
   */
  export type ContentItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentItem
     */
    select?: ContentItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentItem
     */
    omit?: ContentItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentItemInclude<ExtArgs> | null
    /**
     * Filter, which ContentItems to fetch.
     */
    where?: ContentItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentItems to fetch.
     */
    orderBy?: ContentItemOrderByWithRelationInput | ContentItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContentItems.
     */
    cursor?: ContentItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentItems.
     */
    skip?: number
    distinct?: ContentItemScalarFieldEnum | ContentItemScalarFieldEnum[]
  }

  /**
   * ContentItem create
   */
  export type ContentItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentItem
     */
    select?: ContentItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentItem
     */
    omit?: ContentItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentItemInclude<ExtArgs> | null
    /**
     * The data needed to create a ContentItem.
     */
    data: XOR<ContentItemCreateInput, ContentItemUncheckedCreateInput>
  }

  /**
   * ContentItem createMany
   */
  export type ContentItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContentItems.
     */
    data: ContentItemCreateManyInput | ContentItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContentItem createManyAndReturn
   */
  export type ContentItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentItem
     */
    select?: ContentItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContentItem
     */
    omit?: ContentItemOmit<ExtArgs> | null
    /**
     * The data used to create many ContentItems.
     */
    data: ContentItemCreateManyInput | ContentItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContentItem update
   */
  export type ContentItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentItem
     */
    select?: ContentItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentItem
     */
    omit?: ContentItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentItemInclude<ExtArgs> | null
    /**
     * The data needed to update a ContentItem.
     */
    data: XOR<ContentItemUpdateInput, ContentItemUncheckedUpdateInput>
    /**
     * Choose, which ContentItem to update.
     */
    where: ContentItemWhereUniqueInput
  }

  /**
   * ContentItem updateMany
   */
  export type ContentItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContentItems.
     */
    data: XOR<ContentItemUpdateManyMutationInput, ContentItemUncheckedUpdateManyInput>
    /**
     * Filter which ContentItems to update
     */
    where?: ContentItemWhereInput
    /**
     * Limit how many ContentItems to update.
     */
    limit?: number
  }

  /**
   * ContentItem updateManyAndReturn
   */
  export type ContentItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentItem
     */
    select?: ContentItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContentItem
     */
    omit?: ContentItemOmit<ExtArgs> | null
    /**
     * The data used to update ContentItems.
     */
    data: XOR<ContentItemUpdateManyMutationInput, ContentItemUncheckedUpdateManyInput>
    /**
     * Filter which ContentItems to update
     */
    where?: ContentItemWhereInput
    /**
     * Limit how many ContentItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContentItem upsert
   */
  export type ContentItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentItem
     */
    select?: ContentItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentItem
     */
    omit?: ContentItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentItemInclude<ExtArgs> | null
    /**
     * The filter to search for the ContentItem to update in case it exists.
     */
    where: ContentItemWhereUniqueInput
    /**
     * In case the ContentItem found by the `where` argument doesn't exist, create a new ContentItem with this data.
     */
    create: XOR<ContentItemCreateInput, ContentItemUncheckedCreateInput>
    /**
     * In case the ContentItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContentItemUpdateInput, ContentItemUncheckedUpdateInput>
  }

  /**
   * ContentItem delete
   */
  export type ContentItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentItem
     */
    select?: ContentItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentItem
     */
    omit?: ContentItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentItemInclude<ExtArgs> | null
    /**
     * Filter which ContentItem to delete.
     */
    where: ContentItemWhereUniqueInput
  }

  /**
   * ContentItem deleteMany
   */
  export type ContentItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentItems to delete
     */
    where?: ContentItemWhereInput
    /**
     * Limit how many ContentItems to delete.
     */
    limit?: number
  }

  /**
   * ContentItem.bookmarks
   */
  export type ContentItem$bookmarksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookmark
     */
    omit?: BookmarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkInclude<ExtArgs> | null
    where?: BookmarkWhereInput
    orderBy?: BookmarkOrderByWithRelationInput | BookmarkOrderByWithRelationInput[]
    cursor?: BookmarkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookmarkScalarFieldEnum | BookmarkScalarFieldEnum[]
  }

  /**
   * ContentItem.quizAttempts
   */
  export type ContentItem$quizAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    where?: QuizAttemptWhereInput
    orderBy?: QuizAttemptOrderByWithRelationInput | QuizAttemptOrderByWithRelationInput[]
    cursor?: QuizAttemptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizAttemptScalarFieldEnum | QuizAttemptScalarFieldEnum[]
  }

  /**
   * ContentItem.reviewItems
   */
  export type ContentItem$reviewItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewItem
     */
    select?: ReviewItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewItem
     */
    omit?: ReviewItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewItemInclude<ExtArgs> | null
    where?: ReviewItemWhereInput
    orderBy?: ReviewItemOrderByWithRelationInput | ReviewItemOrderByWithRelationInput[]
    cursor?: ReviewItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewItemScalarFieldEnum | ReviewItemScalarFieldEnum[]
  }

  /**
   * ContentItem.ratings
   */
  export type ContentItem$ratingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentRating
     */
    select?: ContentRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentRating
     */
    omit?: ContentRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentRatingInclude<ExtArgs> | null
    where?: ContentRatingWhereInput
    orderBy?: ContentRatingOrderByWithRelationInput | ContentRatingOrderByWithRelationInput[]
    cursor?: ContentRatingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentRatingScalarFieldEnum | ContentRatingScalarFieldEnum[]
  }

  /**
   * ContentItem.aiPlaylistItems
   */
  export type ContentItem$aiPlaylistItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIPlaylistItem
     */
    select?: AIPlaylistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIPlaylistItem
     */
    omit?: AIPlaylistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIPlaylistItemInclude<ExtArgs> | null
    where?: AIPlaylistItemWhereInput
    orderBy?: AIPlaylistItemOrderByWithRelationInput | AIPlaylistItemOrderByWithRelationInput[]
    cursor?: AIPlaylistItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AIPlaylistItemScalarFieldEnum | AIPlaylistItemScalarFieldEnum[]
  }

  /**
   * ContentItem without action
   */
  export type ContentItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentItem
     */
    select?: ContentItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentItem
     */
    omit?: ContentItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentItemInclude<ExtArgs> | null
  }


  /**
   * Model ContentRating
   */

  export type AggregateContentRating = {
    _count: ContentRatingCountAggregateOutputType | null
    _avg: ContentRatingAvgAggregateOutputType | null
    _sum: ContentRatingSumAggregateOutputType | null
    _min: ContentRatingMinAggregateOutputType | null
    _max: ContentRatingMaxAggregateOutputType | null
  }

  export type ContentRatingAvgAggregateOutputType = {
    rating: number | null
  }

  export type ContentRatingSumAggregateOutputType = {
    rating: number | null
  }

  export type ContentRatingMinAggregateOutputType = {
    id: string | null
    userId: string | null
    contentItemId: string | null
    rating: number | null
    createdAt: Date | null
  }

  export type ContentRatingMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    contentItemId: string | null
    rating: number | null
    createdAt: Date | null
  }

  export type ContentRatingCountAggregateOutputType = {
    id: number
    userId: number
    contentItemId: number
    rating: number
    createdAt: number
    _all: number
  }


  export type ContentRatingAvgAggregateInputType = {
    rating?: true
  }

  export type ContentRatingSumAggregateInputType = {
    rating?: true
  }

  export type ContentRatingMinAggregateInputType = {
    id?: true
    userId?: true
    contentItemId?: true
    rating?: true
    createdAt?: true
  }

  export type ContentRatingMaxAggregateInputType = {
    id?: true
    userId?: true
    contentItemId?: true
    rating?: true
    createdAt?: true
  }

  export type ContentRatingCountAggregateInputType = {
    id?: true
    userId?: true
    contentItemId?: true
    rating?: true
    createdAt?: true
    _all?: true
  }

  export type ContentRatingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentRating to aggregate.
     */
    where?: ContentRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentRatings to fetch.
     */
    orderBy?: ContentRatingOrderByWithRelationInput | ContentRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContentRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContentRatings
    **/
    _count?: true | ContentRatingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContentRatingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContentRatingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContentRatingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContentRatingMaxAggregateInputType
  }

  export type GetContentRatingAggregateType<T extends ContentRatingAggregateArgs> = {
        [P in keyof T & keyof AggregateContentRating]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContentRating[P]>
      : GetScalarType<T[P], AggregateContentRating[P]>
  }




  export type ContentRatingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentRatingWhereInput
    orderBy?: ContentRatingOrderByWithAggregationInput | ContentRatingOrderByWithAggregationInput[]
    by: ContentRatingScalarFieldEnum[] | ContentRatingScalarFieldEnum
    having?: ContentRatingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContentRatingCountAggregateInputType | true
    _avg?: ContentRatingAvgAggregateInputType
    _sum?: ContentRatingSumAggregateInputType
    _min?: ContentRatingMinAggregateInputType
    _max?: ContentRatingMaxAggregateInputType
  }

  export type ContentRatingGroupByOutputType = {
    id: string
    userId: string
    contentItemId: string
    rating: number
    createdAt: Date
    _count: ContentRatingCountAggregateOutputType | null
    _avg: ContentRatingAvgAggregateOutputType | null
    _sum: ContentRatingSumAggregateOutputType | null
    _min: ContentRatingMinAggregateOutputType | null
    _max: ContentRatingMaxAggregateOutputType | null
  }

  type GetContentRatingGroupByPayload<T extends ContentRatingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContentRatingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContentRatingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContentRatingGroupByOutputType[P]>
            : GetScalarType<T[P], ContentRatingGroupByOutputType[P]>
        }
      >
    >


  export type ContentRatingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    contentItemId?: boolean
    rating?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    contentItem?: boolean | ContentItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentRating"]>

  export type ContentRatingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    contentItemId?: boolean
    rating?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    contentItem?: boolean | ContentItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentRating"]>

  export type ContentRatingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    contentItemId?: boolean
    rating?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    contentItem?: boolean | ContentItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentRating"]>

  export type ContentRatingSelectScalar = {
    id?: boolean
    userId?: boolean
    contentItemId?: boolean
    rating?: boolean
    createdAt?: boolean
  }

  export type ContentRatingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "contentItemId" | "rating" | "createdAt", ExtArgs["result"]["contentRating"]>
  export type ContentRatingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    contentItem?: boolean | ContentItemDefaultArgs<ExtArgs>
  }
  export type ContentRatingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    contentItem?: boolean | ContentItemDefaultArgs<ExtArgs>
  }
  export type ContentRatingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    contentItem?: boolean | ContentItemDefaultArgs<ExtArgs>
  }

  export type $ContentRatingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContentRating"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      contentItem: Prisma.$ContentItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      contentItemId: string
      rating: number
      createdAt: Date
    }, ExtArgs["result"]["contentRating"]>
    composites: {}
  }

  type ContentRatingGetPayload<S extends boolean | null | undefined | ContentRatingDefaultArgs> = $Result.GetResult<Prisma.$ContentRatingPayload, S>

  type ContentRatingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContentRatingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContentRatingCountAggregateInputType | true
    }

  export interface ContentRatingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContentRating'], meta: { name: 'ContentRating' } }
    /**
     * Find zero or one ContentRating that matches the filter.
     * @param {ContentRatingFindUniqueArgs} args - Arguments to find a ContentRating
     * @example
     * // Get one ContentRating
     * const contentRating = await prisma.contentRating.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContentRatingFindUniqueArgs>(args: SelectSubset<T, ContentRatingFindUniqueArgs<ExtArgs>>): Prisma__ContentRatingClient<$Result.GetResult<Prisma.$ContentRatingPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ContentRating that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContentRatingFindUniqueOrThrowArgs} args - Arguments to find a ContentRating
     * @example
     * // Get one ContentRating
     * const contentRating = await prisma.contentRating.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContentRatingFindUniqueOrThrowArgs>(args: SelectSubset<T, ContentRatingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContentRatingClient<$Result.GetResult<Prisma.$ContentRatingPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ContentRating that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentRatingFindFirstArgs} args - Arguments to find a ContentRating
     * @example
     * // Get one ContentRating
     * const contentRating = await prisma.contentRating.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContentRatingFindFirstArgs>(args?: SelectSubset<T, ContentRatingFindFirstArgs<ExtArgs>>): Prisma__ContentRatingClient<$Result.GetResult<Prisma.$ContentRatingPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ContentRating that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentRatingFindFirstOrThrowArgs} args - Arguments to find a ContentRating
     * @example
     * // Get one ContentRating
     * const contentRating = await prisma.contentRating.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContentRatingFindFirstOrThrowArgs>(args?: SelectSubset<T, ContentRatingFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContentRatingClient<$Result.GetResult<Prisma.$ContentRatingPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ContentRatings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentRatingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContentRatings
     * const contentRatings = await prisma.contentRating.findMany()
     * 
     * // Get first 10 ContentRatings
     * const contentRatings = await prisma.contentRating.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contentRatingWithIdOnly = await prisma.contentRating.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContentRatingFindManyArgs>(args?: SelectSubset<T, ContentRatingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentRatingPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ContentRating.
     * @param {ContentRatingCreateArgs} args - Arguments to create a ContentRating.
     * @example
     * // Create one ContentRating
     * const ContentRating = await prisma.contentRating.create({
     *   data: {
     *     // ... data to create a ContentRating
     *   }
     * })
     * 
     */
    create<T extends ContentRatingCreateArgs>(args: SelectSubset<T, ContentRatingCreateArgs<ExtArgs>>): Prisma__ContentRatingClient<$Result.GetResult<Prisma.$ContentRatingPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ContentRatings.
     * @param {ContentRatingCreateManyArgs} args - Arguments to create many ContentRatings.
     * @example
     * // Create many ContentRatings
     * const contentRating = await prisma.contentRating.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContentRatingCreateManyArgs>(args?: SelectSubset<T, ContentRatingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContentRatings and returns the data saved in the database.
     * @param {ContentRatingCreateManyAndReturnArgs} args - Arguments to create many ContentRatings.
     * @example
     * // Create many ContentRatings
     * const contentRating = await prisma.contentRating.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContentRatings and only return the `id`
     * const contentRatingWithIdOnly = await prisma.contentRating.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContentRatingCreateManyAndReturnArgs>(args?: SelectSubset<T, ContentRatingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentRatingPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a ContentRating.
     * @param {ContentRatingDeleteArgs} args - Arguments to delete one ContentRating.
     * @example
     * // Delete one ContentRating
     * const ContentRating = await prisma.contentRating.delete({
     *   where: {
     *     // ... filter to delete one ContentRating
     *   }
     * })
     * 
     */
    delete<T extends ContentRatingDeleteArgs>(args: SelectSubset<T, ContentRatingDeleteArgs<ExtArgs>>): Prisma__ContentRatingClient<$Result.GetResult<Prisma.$ContentRatingPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ContentRating.
     * @param {ContentRatingUpdateArgs} args - Arguments to update one ContentRating.
     * @example
     * // Update one ContentRating
     * const contentRating = await prisma.contentRating.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContentRatingUpdateArgs>(args: SelectSubset<T, ContentRatingUpdateArgs<ExtArgs>>): Prisma__ContentRatingClient<$Result.GetResult<Prisma.$ContentRatingPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ContentRatings.
     * @param {ContentRatingDeleteManyArgs} args - Arguments to filter ContentRatings to delete.
     * @example
     * // Delete a few ContentRatings
     * const { count } = await prisma.contentRating.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContentRatingDeleteManyArgs>(args?: SelectSubset<T, ContentRatingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentRatings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentRatingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContentRatings
     * const contentRating = await prisma.contentRating.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContentRatingUpdateManyArgs>(args: SelectSubset<T, ContentRatingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentRatings and returns the data updated in the database.
     * @param {ContentRatingUpdateManyAndReturnArgs} args - Arguments to update many ContentRatings.
     * @example
     * // Update many ContentRatings
     * const contentRating = await prisma.contentRating.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContentRatings and only return the `id`
     * const contentRatingWithIdOnly = await prisma.contentRating.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContentRatingUpdateManyAndReturnArgs>(args: SelectSubset<T, ContentRatingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentRatingPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one ContentRating.
     * @param {ContentRatingUpsertArgs} args - Arguments to update or create a ContentRating.
     * @example
     * // Update or create a ContentRating
     * const contentRating = await prisma.contentRating.upsert({
     *   create: {
     *     // ... data to create a ContentRating
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContentRating we want to update
     *   }
     * })
     */
    upsert<T extends ContentRatingUpsertArgs>(args: SelectSubset<T, ContentRatingUpsertArgs<ExtArgs>>): Prisma__ContentRatingClient<$Result.GetResult<Prisma.$ContentRatingPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ContentRatings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentRatingCountArgs} args - Arguments to filter ContentRatings to count.
     * @example
     * // Count the number of ContentRatings
     * const count = await prisma.contentRating.count({
     *   where: {
     *     // ... the filter for the ContentRatings we want to count
     *   }
     * })
    **/
    count<T extends ContentRatingCountArgs>(
      args?: Subset<T, ContentRatingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContentRatingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContentRating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentRatingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContentRatingAggregateArgs>(args: Subset<T, ContentRatingAggregateArgs>): Prisma.PrismaPromise<GetContentRatingAggregateType<T>>

    /**
     * Group by ContentRating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentRatingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContentRatingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContentRatingGroupByArgs['orderBy'] }
        : { orderBy?: ContentRatingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContentRatingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContentRatingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContentRating model
   */
  readonly fields: ContentRatingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContentRating.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContentRatingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    contentItem<T extends ContentItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContentItemDefaultArgs<ExtArgs>>): Prisma__ContentItemClient<$Result.GetResult<Prisma.$ContentItemPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContentRating model
   */ 
  interface ContentRatingFieldRefs {
    readonly id: FieldRef<"ContentRating", 'String'>
    readonly userId: FieldRef<"ContentRating", 'String'>
    readonly contentItemId: FieldRef<"ContentRating", 'String'>
    readonly rating: FieldRef<"ContentRating", 'Int'>
    readonly createdAt: FieldRef<"ContentRating", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContentRating findUnique
   */
  export type ContentRatingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentRating
     */
    select?: ContentRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentRating
     */
    omit?: ContentRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentRatingInclude<ExtArgs> | null
    /**
     * Filter, which ContentRating to fetch.
     */
    where: ContentRatingWhereUniqueInput
  }

  /**
   * ContentRating findUniqueOrThrow
   */
  export type ContentRatingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentRating
     */
    select?: ContentRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentRating
     */
    omit?: ContentRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentRatingInclude<ExtArgs> | null
    /**
     * Filter, which ContentRating to fetch.
     */
    where: ContentRatingWhereUniqueInput
  }

  /**
   * ContentRating findFirst
   */
  export type ContentRatingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentRating
     */
    select?: ContentRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentRating
     */
    omit?: ContentRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentRatingInclude<ExtArgs> | null
    /**
     * Filter, which ContentRating to fetch.
     */
    where?: ContentRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentRatings to fetch.
     */
    orderBy?: ContentRatingOrderByWithRelationInput | ContentRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentRatings.
     */
    cursor?: ContentRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentRatings.
     */
    distinct?: ContentRatingScalarFieldEnum | ContentRatingScalarFieldEnum[]
  }

  /**
   * ContentRating findFirstOrThrow
   */
  export type ContentRatingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentRating
     */
    select?: ContentRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentRating
     */
    omit?: ContentRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentRatingInclude<ExtArgs> | null
    /**
     * Filter, which ContentRating to fetch.
     */
    where?: ContentRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentRatings to fetch.
     */
    orderBy?: ContentRatingOrderByWithRelationInput | ContentRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentRatings.
     */
    cursor?: ContentRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentRatings.
     */
    distinct?: ContentRatingScalarFieldEnum | ContentRatingScalarFieldEnum[]
  }

  /**
   * ContentRating findMany
   */
  export type ContentRatingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentRating
     */
    select?: ContentRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentRating
     */
    omit?: ContentRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentRatingInclude<ExtArgs> | null
    /**
     * Filter, which ContentRatings to fetch.
     */
    where?: ContentRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentRatings to fetch.
     */
    orderBy?: ContentRatingOrderByWithRelationInput | ContentRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContentRatings.
     */
    cursor?: ContentRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentRatings.
     */
    skip?: number
    distinct?: ContentRatingScalarFieldEnum | ContentRatingScalarFieldEnum[]
  }

  /**
   * ContentRating create
   */
  export type ContentRatingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentRating
     */
    select?: ContentRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentRating
     */
    omit?: ContentRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentRatingInclude<ExtArgs> | null
    /**
     * The data needed to create a ContentRating.
     */
    data: XOR<ContentRatingCreateInput, ContentRatingUncheckedCreateInput>
  }

  /**
   * ContentRating createMany
   */
  export type ContentRatingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContentRatings.
     */
    data: ContentRatingCreateManyInput | ContentRatingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContentRating createManyAndReturn
   */
  export type ContentRatingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentRating
     */
    select?: ContentRatingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContentRating
     */
    omit?: ContentRatingOmit<ExtArgs> | null
    /**
     * The data used to create many ContentRatings.
     */
    data: ContentRatingCreateManyInput | ContentRatingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentRatingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContentRating update
   */
  export type ContentRatingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentRating
     */
    select?: ContentRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentRating
     */
    omit?: ContentRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentRatingInclude<ExtArgs> | null
    /**
     * The data needed to update a ContentRating.
     */
    data: XOR<ContentRatingUpdateInput, ContentRatingUncheckedUpdateInput>
    /**
     * Choose, which ContentRating to update.
     */
    where: ContentRatingWhereUniqueInput
  }

  /**
   * ContentRating updateMany
   */
  export type ContentRatingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContentRatings.
     */
    data: XOR<ContentRatingUpdateManyMutationInput, ContentRatingUncheckedUpdateManyInput>
    /**
     * Filter which ContentRatings to update
     */
    where?: ContentRatingWhereInput
    /**
     * Limit how many ContentRatings to update.
     */
    limit?: number
  }

  /**
   * ContentRating updateManyAndReturn
   */
  export type ContentRatingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentRating
     */
    select?: ContentRatingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContentRating
     */
    omit?: ContentRatingOmit<ExtArgs> | null
    /**
     * The data used to update ContentRatings.
     */
    data: XOR<ContentRatingUpdateManyMutationInput, ContentRatingUncheckedUpdateManyInput>
    /**
     * Filter which ContentRatings to update
     */
    where?: ContentRatingWhereInput
    /**
     * Limit how many ContentRatings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentRatingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContentRating upsert
   */
  export type ContentRatingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentRating
     */
    select?: ContentRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentRating
     */
    omit?: ContentRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentRatingInclude<ExtArgs> | null
    /**
     * The filter to search for the ContentRating to update in case it exists.
     */
    where: ContentRatingWhereUniqueInput
    /**
     * In case the ContentRating found by the `where` argument doesn't exist, create a new ContentRating with this data.
     */
    create: XOR<ContentRatingCreateInput, ContentRatingUncheckedCreateInput>
    /**
     * In case the ContentRating was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContentRatingUpdateInput, ContentRatingUncheckedUpdateInput>
  }

  /**
   * ContentRating delete
   */
  export type ContentRatingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentRating
     */
    select?: ContentRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentRating
     */
    omit?: ContentRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentRatingInclude<ExtArgs> | null
    /**
     * Filter which ContentRating to delete.
     */
    where: ContentRatingWhereUniqueInput
  }

  /**
   * ContentRating deleteMany
   */
  export type ContentRatingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentRatings to delete
     */
    where?: ContentRatingWhereInput
    /**
     * Limit how many ContentRatings to delete.
     */
    limit?: number
  }

  /**
   * ContentRating without action
   */
  export type ContentRatingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentRating
     */
    select?: ContentRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentRating
     */
    omit?: ContentRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentRatingInclude<ExtArgs> | null
  }


  /**
   * Model Bookmark
   */

  export type AggregateBookmark = {
    _count: BookmarkCountAggregateOutputType | null
    _min: BookmarkMinAggregateOutputType | null
    _max: BookmarkMaxAggregateOutputType | null
  }

  export type BookmarkMinAggregateOutputType = {
    id: string | null
    userId: string | null
    contentItemId: string | null
    createdAt: Date | null
  }

  export type BookmarkMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    contentItemId: string | null
    createdAt: Date | null
  }

  export type BookmarkCountAggregateOutputType = {
    id: number
    userId: number
    contentItemId: number
    createdAt: number
    _all: number
  }


  export type BookmarkMinAggregateInputType = {
    id?: true
    userId?: true
    contentItemId?: true
    createdAt?: true
  }

  export type BookmarkMaxAggregateInputType = {
    id?: true
    userId?: true
    contentItemId?: true
    createdAt?: true
  }

  export type BookmarkCountAggregateInputType = {
    id?: true
    userId?: true
    contentItemId?: true
    createdAt?: true
    _all?: true
  }

  export type BookmarkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bookmark to aggregate.
     */
    where?: BookmarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookmarks to fetch.
     */
    orderBy?: BookmarkOrderByWithRelationInput | BookmarkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookmarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookmarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookmarks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bookmarks
    **/
    _count?: true | BookmarkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookmarkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookmarkMaxAggregateInputType
  }

  export type GetBookmarkAggregateType<T extends BookmarkAggregateArgs> = {
        [P in keyof T & keyof AggregateBookmark]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookmark[P]>
      : GetScalarType<T[P], AggregateBookmark[P]>
  }




  export type BookmarkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookmarkWhereInput
    orderBy?: BookmarkOrderByWithAggregationInput | BookmarkOrderByWithAggregationInput[]
    by: BookmarkScalarFieldEnum[] | BookmarkScalarFieldEnum
    having?: BookmarkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookmarkCountAggregateInputType | true
    _min?: BookmarkMinAggregateInputType
    _max?: BookmarkMaxAggregateInputType
  }

  export type BookmarkGroupByOutputType = {
    id: string
    userId: string
    contentItemId: string
    createdAt: Date
    _count: BookmarkCountAggregateOutputType | null
    _min: BookmarkMinAggregateOutputType | null
    _max: BookmarkMaxAggregateOutputType | null
  }

  type GetBookmarkGroupByPayload<T extends BookmarkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookmarkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookmarkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookmarkGroupByOutputType[P]>
            : GetScalarType<T[P], BookmarkGroupByOutputType[P]>
        }
      >
    >


  export type BookmarkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    contentItemId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    contentItem?: boolean | ContentItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookmark"]>

  export type BookmarkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    contentItemId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    contentItem?: boolean | ContentItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookmark"]>

  export type BookmarkSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    contentItemId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    contentItem?: boolean | ContentItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookmark"]>

  export type BookmarkSelectScalar = {
    id?: boolean
    userId?: boolean
    contentItemId?: boolean
    createdAt?: boolean
  }

  export type BookmarkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "contentItemId" | "createdAt", ExtArgs["result"]["bookmark"]>
  export type BookmarkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    contentItem?: boolean | ContentItemDefaultArgs<ExtArgs>
  }
  export type BookmarkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    contentItem?: boolean | ContentItemDefaultArgs<ExtArgs>
  }
  export type BookmarkIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    contentItem?: boolean | ContentItemDefaultArgs<ExtArgs>
  }

  export type $BookmarkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Bookmark"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      contentItem: Prisma.$ContentItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      contentItemId: string
      createdAt: Date
    }, ExtArgs["result"]["bookmark"]>
    composites: {}
  }

  type BookmarkGetPayload<S extends boolean | null | undefined | BookmarkDefaultArgs> = $Result.GetResult<Prisma.$BookmarkPayload, S>

  type BookmarkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookmarkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookmarkCountAggregateInputType | true
    }

  export interface BookmarkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bookmark'], meta: { name: 'Bookmark' } }
    /**
     * Find zero or one Bookmark that matches the filter.
     * @param {BookmarkFindUniqueArgs} args - Arguments to find a Bookmark
     * @example
     * // Get one Bookmark
     * const bookmark = await prisma.bookmark.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookmarkFindUniqueArgs>(args: SelectSubset<T, BookmarkFindUniqueArgs<ExtArgs>>): Prisma__BookmarkClient<$Result.GetResult<Prisma.$BookmarkPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Bookmark that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookmarkFindUniqueOrThrowArgs} args - Arguments to find a Bookmark
     * @example
     * // Get one Bookmark
     * const bookmark = await prisma.bookmark.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookmarkFindUniqueOrThrowArgs>(args: SelectSubset<T, BookmarkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookmarkClient<$Result.GetResult<Prisma.$BookmarkPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Bookmark that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookmarkFindFirstArgs} args - Arguments to find a Bookmark
     * @example
     * // Get one Bookmark
     * const bookmark = await prisma.bookmark.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookmarkFindFirstArgs>(args?: SelectSubset<T, BookmarkFindFirstArgs<ExtArgs>>): Prisma__BookmarkClient<$Result.GetResult<Prisma.$BookmarkPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Bookmark that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookmarkFindFirstOrThrowArgs} args - Arguments to find a Bookmark
     * @example
     * // Get one Bookmark
     * const bookmark = await prisma.bookmark.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookmarkFindFirstOrThrowArgs>(args?: SelectSubset<T, BookmarkFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookmarkClient<$Result.GetResult<Prisma.$BookmarkPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Bookmarks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookmarkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bookmarks
     * const bookmarks = await prisma.bookmark.findMany()
     * 
     * // Get first 10 Bookmarks
     * const bookmarks = await prisma.bookmark.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookmarkWithIdOnly = await prisma.bookmark.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookmarkFindManyArgs>(args?: SelectSubset<T, BookmarkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookmarkPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Bookmark.
     * @param {BookmarkCreateArgs} args - Arguments to create a Bookmark.
     * @example
     * // Create one Bookmark
     * const Bookmark = await prisma.bookmark.create({
     *   data: {
     *     // ... data to create a Bookmark
     *   }
     * })
     * 
     */
    create<T extends BookmarkCreateArgs>(args: SelectSubset<T, BookmarkCreateArgs<ExtArgs>>): Prisma__BookmarkClient<$Result.GetResult<Prisma.$BookmarkPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Bookmarks.
     * @param {BookmarkCreateManyArgs} args - Arguments to create many Bookmarks.
     * @example
     * // Create many Bookmarks
     * const bookmark = await prisma.bookmark.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookmarkCreateManyArgs>(args?: SelectSubset<T, BookmarkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bookmarks and returns the data saved in the database.
     * @param {BookmarkCreateManyAndReturnArgs} args - Arguments to create many Bookmarks.
     * @example
     * // Create many Bookmarks
     * const bookmark = await prisma.bookmark.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bookmarks and only return the `id`
     * const bookmarkWithIdOnly = await prisma.bookmark.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookmarkCreateManyAndReturnArgs>(args?: SelectSubset<T, BookmarkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookmarkPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Bookmark.
     * @param {BookmarkDeleteArgs} args - Arguments to delete one Bookmark.
     * @example
     * // Delete one Bookmark
     * const Bookmark = await prisma.bookmark.delete({
     *   where: {
     *     // ... filter to delete one Bookmark
     *   }
     * })
     * 
     */
    delete<T extends BookmarkDeleteArgs>(args: SelectSubset<T, BookmarkDeleteArgs<ExtArgs>>): Prisma__BookmarkClient<$Result.GetResult<Prisma.$BookmarkPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Bookmark.
     * @param {BookmarkUpdateArgs} args - Arguments to update one Bookmark.
     * @example
     * // Update one Bookmark
     * const bookmark = await prisma.bookmark.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookmarkUpdateArgs>(args: SelectSubset<T, BookmarkUpdateArgs<ExtArgs>>): Prisma__BookmarkClient<$Result.GetResult<Prisma.$BookmarkPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Bookmarks.
     * @param {BookmarkDeleteManyArgs} args - Arguments to filter Bookmarks to delete.
     * @example
     * // Delete a few Bookmarks
     * const { count } = await prisma.bookmark.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookmarkDeleteManyArgs>(args?: SelectSubset<T, BookmarkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookmarks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookmarkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bookmarks
     * const bookmark = await prisma.bookmark.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookmarkUpdateManyArgs>(args: SelectSubset<T, BookmarkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookmarks and returns the data updated in the database.
     * @param {BookmarkUpdateManyAndReturnArgs} args - Arguments to update many Bookmarks.
     * @example
     * // Update many Bookmarks
     * const bookmark = await prisma.bookmark.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Bookmarks and only return the `id`
     * const bookmarkWithIdOnly = await prisma.bookmark.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BookmarkUpdateManyAndReturnArgs>(args: SelectSubset<T, BookmarkUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookmarkPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Bookmark.
     * @param {BookmarkUpsertArgs} args - Arguments to update or create a Bookmark.
     * @example
     * // Update or create a Bookmark
     * const bookmark = await prisma.bookmark.upsert({
     *   create: {
     *     // ... data to create a Bookmark
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bookmark we want to update
     *   }
     * })
     */
    upsert<T extends BookmarkUpsertArgs>(args: SelectSubset<T, BookmarkUpsertArgs<ExtArgs>>): Prisma__BookmarkClient<$Result.GetResult<Prisma.$BookmarkPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Bookmarks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookmarkCountArgs} args - Arguments to filter Bookmarks to count.
     * @example
     * // Count the number of Bookmarks
     * const count = await prisma.bookmark.count({
     *   where: {
     *     // ... the filter for the Bookmarks we want to count
     *   }
     * })
    **/
    count<T extends BookmarkCountArgs>(
      args?: Subset<T, BookmarkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookmarkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bookmark.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookmarkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookmarkAggregateArgs>(args: Subset<T, BookmarkAggregateArgs>): Prisma.PrismaPromise<GetBookmarkAggregateType<T>>

    /**
     * Group by Bookmark.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookmarkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookmarkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookmarkGroupByArgs['orderBy'] }
        : { orderBy?: BookmarkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookmarkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookmarkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Bookmark model
   */
  readonly fields: BookmarkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bookmark.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookmarkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    contentItem<T extends ContentItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContentItemDefaultArgs<ExtArgs>>): Prisma__ContentItemClient<$Result.GetResult<Prisma.$ContentItemPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Bookmark model
   */ 
  interface BookmarkFieldRefs {
    readonly id: FieldRef<"Bookmark", 'String'>
    readonly userId: FieldRef<"Bookmark", 'String'>
    readonly contentItemId: FieldRef<"Bookmark", 'String'>
    readonly createdAt: FieldRef<"Bookmark", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Bookmark findUnique
   */
  export type BookmarkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookmark
     */
    omit?: BookmarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkInclude<ExtArgs> | null
    /**
     * Filter, which Bookmark to fetch.
     */
    where: BookmarkWhereUniqueInput
  }

  /**
   * Bookmark findUniqueOrThrow
   */
  export type BookmarkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookmark
     */
    omit?: BookmarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkInclude<ExtArgs> | null
    /**
     * Filter, which Bookmark to fetch.
     */
    where: BookmarkWhereUniqueInput
  }

  /**
   * Bookmark findFirst
   */
  export type BookmarkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookmark
     */
    omit?: BookmarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkInclude<ExtArgs> | null
    /**
     * Filter, which Bookmark to fetch.
     */
    where?: BookmarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookmarks to fetch.
     */
    orderBy?: BookmarkOrderByWithRelationInput | BookmarkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookmarks.
     */
    cursor?: BookmarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookmarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookmarks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookmarks.
     */
    distinct?: BookmarkScalarFieldEnum | BookmarkScalarFieldEnum[]
  }

  /**
   * Bookmark findFirstOrThrow
   */
  export type BookmarkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookmark
     */
    omit?: BookmarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkInclude<ExtArgs> | null
    /**
     * Filter, which Bookmark to fetch.
     */
    where?: BookmarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookmarks to fetch.
     */
    orderBy?: BookmarkOrderByWithRelationInput | BookmarkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookmarks.
     */
    cursor?: BookmarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookmarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookmarks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookmarks.
     */
    distinct?: BookmarkScalarFieldEnum | BookmarkScalarFieldEnum[]
  }

  /**
   * Bookmark findMany
   */
  export type BookmarkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookmark
     */
    omit?: BookmarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkInclude<ExtArgs> | null
    /**
     * Filter, which Bookmarks to fetch.
     */
    where?: BookmarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookmarks to fetch.
     */
    orderBy?: BookmarkOrderByWithRelationInput | BookmarkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bookmarks.
     */
    cursor?: BookmarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookmarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookmarks.
     */
    skip?: number
    distinct?: BookmarkScalarFieldEnum | BookmarkScalarFieldEnum[]
  }

  /**
   * Bookmark create
   */
  export type BookmarkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookmark
     */
    omit?: BookmarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkInclude<ExtArgs> | null
    /**
     * The data needed to create a Bookmark.
     */
    data: XOR<BookmarkCreateInput, BookmarkUncheckedCreateInput>
  }

  /**
   * Bookmark createMany
   */
  export type BookmarkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bookmarks.
     */
    data: BookmarkCreateManyInput | BookmarkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Bookmark createManyAndReturn
   */
  export type BookmarkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Bookmark
     */
    omit?: BookmarkOmit<ExtArgs> | null
    /**
     * The data used to create many Bookmarks.
     */
    data: BookmarkCreateManyInput | BookmarkCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bookmark update
   */
  export type BookmarkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookmark
     */
    omit?: BookmarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkInclude<ExtArgs> | null
    /**
     * The data needed to update a Bookmark.
     */
    data: XOR<BookmarkUpdateInput, BookmarkUncheckedUpdateInput>
    /**
     * Choose, which Bookmark to update.
     */
    where: BookmarkWhereUniqueInput
  }

  /**
   * Bookmark updateMany
   */
  export type BookmarkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bookmarks.
     */
    data: XOR<BookmarkUpdateManyMutationInput, BookmarkUncheckedUpdateManyInput>
    /**
     * Filter which Bookmarks to update
     */
    where?: BookmarkWhereInput
    /**
     * Limit how many Bookmarks to update.
     */
    limit?: number
  }

  /**
   * Bookmark updateManyAndReturn
   */
  export type BookmarkUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Bookmark
     */
    omit?: BookmarkOmit<ExtArgs> | null
    /**
     * The data used to update Bookmarks.
     */
    data: XOR<BookmarkUpdateManyMutationInput, BookmarkUncheckedUpdateManyInput>
    /**
     * Filter which Bookmarks to update
     */
    where?: BookmarkWhereInput
    /**
     * Limit how many Bookmarks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bookmark upsert
   */
  export type BookmarkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookmark
     */
    omit?: BookmarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkInclude<ExtArgs> | null
    /**
     * The filter to search for the Bookmark to update in case it exists.
     */
    where: BookmarkWhereUniqueInput
    /**
     * In case the Bookmark found by the `where` argument doesn't exist, create a new Bookmark with this data.
     */
    create: XOR<BookmarkCreateInput, BookmarkUncheckedCreateInput>
    /**
     * In case the Bookmark was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookmarkUpdateInput, BookmarkUncheckedUpdateInput>
  }

  /**
   * Bookmark delete
   */
  export type BookmarkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookmark
     */
    omit?: BookmarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkInclude<ExtArgs> | null
    /**
     * Filter which Bookmark to delete.
     */
    where: BookmarkWhereUniqueInput
  }

  /**
   * Bookmark deleteMany
   */
  export type BookmarkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bookmarks to delete
     */
    where?: BookmarkWhereInput
    /**
     * Limit how many Bookmarks to delete.
     */
    limit?: number
  }

  /**
   * Bookmark without action
   */
  export type BookmarkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookmark
     */
    omit?: BookmarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkInclude<ExtArgs> | null
  }


  /**
   * Model QuizAttempt
   */

  export type AggregateQuizAttempt = {
    _count: QuizAttemptCountAggregateOutputType | null
    _avg: QuizAttemptAvgAggregateOutputType | null
    _sum: QuizAttemptSumAggregateOutputType | null
    _min: QuizAttemptMinAggregateOutputType | null
    _max: QuizAttemptMaxAggregateOutputType | null
  }

  export type QuizAttemptAvgAggregateOutputType = {
    score: number | null
  }

  export type QuizAttemptSumAggregateOutputType = {
    score: number | null
  }

  export type QuizAttemptMinAggregateOutputType = {
    id: string | null
    userId: string | null
    contentItemId: string | null
    score: number | null
    startedAt: Date | null
    completedAt: Date | null
  }

  export type QuizAttemptMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    contentItemId: string | null
    score: number | null
    startedAt: Date | null
    completedAt: Date | null
  }

  export type QuizAttemptCountAggregateOutputType = {
    id: number
    userId: number
    contentItemId: number
    score: number
    startedAt: number
    completedAt: number
    answers: number
    _all: number
  }


  export type QuizAttemptAvgAggregateInputType = {
    score?: true
  }

  export type QuizAttemptSumAggregateInputType = {
    score?: true
  }

  export type QuizAttemptMinAggregateInputType = {
    id?: true
    userId?: true
    contentItemId?: true
    score?: true
    startedAt?: true
    completedAt?: true
  }

  export type QuizAttemptMaxAggregateInputType = {
    id?: true
    userId?: true
    contentItemId?: true
    score?: true
    startedAt?: true
    completedAt?: true
  }

  export type QuizAttemptCountAggregateInputType = {
    id?: true
    userId?: true
    contentItemId?: true
    score?: true
    startedAt?: true
    completedAt?: true
    answers?: true
    _all?: true
  }

  export type QuizAttemptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizAttempt to aggregate.
     */
    where?: QuizAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizAttempts to fetch.
     */
    orderBy?: QuizAttemptOrderByWithRelationInput | QuizAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizAttempts
    **/
    _count?: true | QuizAttemptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizAttemptAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizAttemptSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizAttemptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizAttemptMaxAggregateInputType
  }

  export type GetQuizAttemptAggregateType<T extends QuizAttemptAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizAttempt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizAttempt[P]>
      : GetScalarType<T[P], AggregateQuizAttempt[P]>
  }




  export type QuizAttemptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizAttemptWhereInput
    orderBy?: QuizAttemptOrderByWithAggregationInput | QuizAttemptOrderByWithAggregationInput[]
    by: QuizAttemptScalarFieldEnum[] | QuizAttemptScalarFieldEnum
    having?: QuizAttemptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizAttemptCountAggregateInputType | true
    _avg?: QuizAttemptAvgAggregateInputType
    _sum?: QuizAttemptSumAggregateInputType
    _min?: QuizAttemptMinAggregateInputType
    _max?: QuizAttemptMaxAggregateInputType
  }

  export type QuizAttemptGroupByOutputType = {
    id: string
    userId: string
    contentItemId: string
    score: number
    startedAt: Date
    completedAt: Date | null
    answers: JsonValue | null
    _count: QuizAttemptCountAggregateOutputType | null
    _avg: QuizAttemptAvgAggregateOutputType | null
    _sum: QuizAttemptSumAggregateOutputType | null
    _min: QuizAttemptMinAggregateOutputType | null
    _max: QuizAttemptMaxAggregateOutputType | null
  }

  type GetQuizAttemptGroupByPayload<T extends QuizAttemptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizAttemptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizAttemptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizAttemptGroupByOutputType[P]>
            : GetScalarType<T[P], QuizAttemptGroupByOutputType[P]>
        }
      >
    >


  export type QuizAttemptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    contentItemId?: boolean
    score?: boolean
    startedAt?: boolean
    completedAt?: boolean
    answers?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    contentItem?: boolean | ContentItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizAttempt"]>

  export type QuizAttemptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    contentItemId?: boolean
    score?: boolean
    startedAt?: boolean
    completedAt?: boolean
    answers?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    contentItem?: boolean | ContentItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizAttempt"]>

  export type QuizAttemptSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    contentItemId?: boolean
    score?: boolean
    startedAt?: boolean
    completedAt?: boolean
    answers?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    contentItem?: boolean | ContentItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizAttempt"]>

  export type QuizAttemptSelectScalar = {
    id?: boolean
    userId?: boolean
    contentItemId?: boolean
    score?: boolean
    startedAt?: boolean
    completedAt?: boolean
    answers?: boolean
  }

  export type QuizAttemptOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "contentItemId" | "score" | "startedAt" | "completedAt" | "answers", ExtArgs["result"]["quizAttempt"]>
  export type QuizAttemptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    contentItem?: boolean | ContentItemDefaultArgs<ExtArgs>
  }
  export type QuizAttemptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    contentItem?: boolean | ContentItemDefaultArgs<ExtArgs>
  }
  export type QuizAttemptIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    contentItem?: boolean | ContentItemDefaultArgs<ExtArgs>
  }

  export type $QuizAttemptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuizAttempt"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      contentItem: Prisma.$ContentItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      contentItemId: string
      score: number
      startedAt: Date
      completedAt: Date | null
      answers: Prisma.JsonValue | null
    }, ExtArgs["result"]["quizAttempt"]>
    composites: {}
  }

  type QuizAttemptGetPayload<S extends boolean | null | undefined | QuizAttemptDefaultArgs> = $Result.GetResult<Prisma.$QuizAttemptPayload, S>

  type QuizAttemptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuizAttemptFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuizAttemptCountAggregateInputType | true
    }

  export interface QuizAttemptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuizAttempt'], meta: { name: 'QuizAttempt' } }
    /**
     * Find zero or one QuizAttempt that matches the filter.
     * @param {QuizAttemptFindUniqueArgs} args - Arguments to find a QuizAttempt
     * @example
     * // Get one QuizAttempt
     * const quizAttempt = await prisma.quizAttempt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuizAttemptFindUniqueArgs>(args: SelectSubset<T, QuizAttemptFindUniqueArgs<ExtArgs>>): Prisma__QuizAttemptClient<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one QuizAttempt that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuizAttemptFindUniqueOrThrowArgs} args - Arguments to find a QuizAttempt
     * @example
     * // Get one QuizAttempt
     * const quizAttempt = await prisma.quizAttempt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuizAttemptFindUniqueOrThrowArgs>(args: SelectSubset<T, QuizAttemptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuizAttemptClient<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first QuizAttempt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAttemptFindFirstArgs} args - Arguments to find a QuizAttempt
     * @example
     * // Get one QuizAttempt
     * const quizAttempt = await prisma.quizAttempt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuizAttemptFindFirstArgs>(args?: SelectSubset<T, QuizAttemptFindFirstArgs<ExtArgs>>): Prisma__QuizAttemptClient<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first QuizAttempt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAttemptFindFirstOrThrowArgs} args - Arguments to find a QuizAttempt
     * @example
     * // Get one QuizAttempt
     * const quizAttempt = await prisma.quizAttempt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuizAttemptFindFirstOrThrowArgs>(args?: SelectSubset<T, QuizAttemptFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuizAttemptClient<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more QuizAttempts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAttemptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizAttempts
     * const quizAttempts = await prisma.quizAttempt.findMany()
     * 
     * // Get first 10 QuizAttempts
     * const quizAttempts = await prisma.quizAttempt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizAttemptWithIdOnly = await prisma.quizAttempt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuizAttemptFindManyArgs>(args?: SelectSubset<T, QuizAttemptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a QuizAttempt.
     * @param {QuizAttemptCreateArgs} args - Arguments to create a QuizAttempt.
     * @example
     * // Create one QuizAttempt
     * const QuizAttempt = await prisma.quizAttempt.create({
     *   data: {
     *     // ... data to create a QuizAttempt
     *   }
     * })
     * 
     */
    create<T extends QuizAttemptCreateArgs>(args: SelectSubset<T, QuizAttemptCreateArgs<ExtArgs>>): Prisma__QuizAttemptClient<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many QuizAttempts.
     * @param {QuizAttemptCreateManyArgs} args - Arguments to create many QuizAttempts.
     * @example
     * // Create many QuizAttempts
     * const quizAttempt = await prisma.quizAttempt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuizAttemptCreateManyArgs>(args?: SelectSubset<T, QuizAttemptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuizAttempts and returns the data saved in the database.
     * @param {QuizAttemptCreateManyAndReturnArgs} args - Arguments to create many QuizAttempts.
     * @example
     * // Create many QuizAttempts
     * const quizAttempt = await prisma.quizAttempt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuizAttempts and only return the `id`
     * const quizAttemptWithIdOnly = await prisma.quizAttempt.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuizAttemptCreateManyAndReturnArgs>(args?: SelectSubset<T, QuizAttemptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a QuizAttempt.
     * @param {QuizAttemptDeleteArgs} args - Arguments to delete one QuizAttempt.
     * @example
     * // Delete one QuizAttempt
     * const QuizAttempt = await prisma.quizAttempt.delete({
     *   where: {
     *     // ... filter to delete one QuizAttempt
     *   }
     * })
     * 
     */
    delete<T extends QuizAttemptDeleteArgs>(args: SelectSubset<T, QuizAttemptDeleteArgs<ExtArgs>>): Prisma__QuizAttemptClient<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one QuizAttempt.
     * @param {QuizAttemptUpdateArgs} args - Arguments to update one QuizAttempt.
     * @example
     * // Update one QuizAttempt
     * const quizAttempt = await prisma.quizAttempt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuizAttemptUpdateArgs>(args: SelectSubset<T, QuizAttemptUpdateArgs<ExtArgs>>): Prisma__QuizAttemptClient<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more QuizAttempts.
     * @param {QuizAttemptDeleteManyArgs} args - Arguments to filter QuizAttempts to delete.
     * @example
     * // Delete a few QuizAttempts
     * const { count } = await prisma.quizAttempt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuizAttemptDeleteManyArgs>(args?: SelectSubset<T, QuizAttemptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAttemptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizAttempts
     * const quizAttempt = await prisma.quizAttempt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuizAttemptUpdateManyArgs>(args: SelectSubset<T, QuizAttemptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizAttempts and returns the data updated in the database.
     * @param {QuizAttemptUpdateManyAndReturnArgs} args - Arguments to update many QuizAttempts.
     * @example
     * // Update many QuizAttempts
     * const quizAttempt = await prisma.quizAttempt.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuizAttempts and only return the `id`
     * const quizAttemptWithIdOnly = await prisma.quizAttempt.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuizAttemptUpdateManyAndReturnArgs>(args: SelectSubset<T, QuizAttemptUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one QuizAttempt.
     * @param {QuizAttemptUpsertArgs} args - Arguments to update or create a QuizAttempt.
     * @example
     * // Update or create a QuizAttempt
     * const quizAttempt = await prisma.quizAttempt.upsert({
     *   create: {
     *     // ... data to create a QuizAttempt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizAttempt we want to update
     *   }
     * })
     */
    upsert<T extends QuizAttemptUpsertArgs>(args: SelectSubset<T, QuizAttemptUpsertArgs<ExtArgs>>): Prisma__QuizAttemptClient<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of QuizAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAttemptCountArgs} args - Arguments to filter QuizAttempts to count.
     * @example
     * // Count the number of QuizAttempts
     * const count = await prisma.quizAttempt.count({
     *   where: {
     *     // ... the filter for the QuizAttempts we want to count
     *   }
     * })
    **/
    count<T extends QuizAttemptCountArgs>(
      args?: Subset<T, QuizAttemptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizAttemptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAttemptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizAttemptAggregateArgs>(args: Subset<T, QuizAttemptAggregateArgs>): Prisma.PrismaPromise<GetQuizAttemptAggregateType<T>>

    /**
     * Group by QuizAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAttemptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizAttemptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizAttemptGroupByArgs['orderBy'] }
        : { orderBy?: QuizAttemptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizAttemptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizAttemptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuizAttempt model
   */
  readonly fields: QuizAttemptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizAttempt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuizAttemptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    contentItem<T extends ContentItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContentItemDefaultArgs<ExtArgs>>): Prisma__ContentItemClient<$Result.GetResult<Prisma.$ContentItemPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuizAttempt model
   */ 
  interface QuizAttemptFieldRefs {
    readonly id: FieldRef<"QuizAttempt", 'String'>
    readonly userId: FieldRef<"QuizAttempt", 'String'>
    readonly contentItemId: FieldRef<"QuizAttempt", 'String'>
    readonly score: FieldRef<"QuizAttempt", 'Float'>
    readonly startedAt: FieldRef<"QuizAttempt", 'DateTime'>
    readonly completedAt: FieldRef<"QuizAttempt", 'DateTime'>
    readonly answers: FieldRef<"QuizAttempt", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * QuizAttempt findUnique
   */
  export type QuizAttemptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    /**
     * Filter, which QuizAttempt to fetch.
     */
    where: QuizAttemptWhereUniqueInput
  }

  /**
   * QuizAttempt findUniqueOrThrow
   */
  export type QuizAttemptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    /**
     * Filter, which QuizAttempt to fetch.
     */
    where: QuizAttemptWhereUniqueInput
  }

  /**
   * QuizAttempt findFirst
   */
  export type QuizAttemptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    /**
     * Filter, which QuizAttempt to fetch.
     */
    where?: QuizAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizAttempts to fetch.
     */
    orderBy?: QuizAttemptOrderByWithRelationInput | QuizAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizAttempts.
     */
    cursor?: QuizAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizAttempts.
     */
    distinct?: QuizAttemptScalarFieldEnum | QuizAttemptScalarFieldEnum[]
  }

  /**
   * QuizAttempt findFirstOrThrow
   */
  export type QuizAttemptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    /**
     * Filter, which QuizAttempt to fetch.
     */
    where?: QuizAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizAttempts to fetch.
     */
    orderBy?: QuizAttemptOrderByWithRelationInput | QuizAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizAttempts.
     */
    cursor?: QuizAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizAttempts.
     */
    distinct?: QuizAttemptScalarFieldEnum | QuizAttemptScalarFieldEnum[]
  }

  /**
   * QuizAttempt findMany
   */
  export type QuizAttemptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    /**
     * Filter, which QuizAttempts to fetch.
     */
    where?: QuizAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizAttempts to fetch.
     */
    orderBy?: QuizAttemptOrderByWithRelationInput | QuizAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizAttempts.
     */
    cursor?: QuizAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizAttempts.
     */
    skip?: number
    distinct?: QuizAttemptScalarFieldEnum | QuizAttemptScalarFieldEnum[]
  }

  /**
   * QuizAttempt create
   */
  export type QuizAttemptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    /**
     * The data needed to create a QuizAttempt.
     */
    data: XOR<QuizAttemptCreateInput, QuizAttemptUncheckedCreateInput>
  }

  /**
   * QuizAttempt createMany
   */
  export type QuizAttemptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuizAttempts.
     */
    data: QuizAttemptCreateManyInput | QuizAttemptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuizAttempt createManyAndReturn
   */
  export type QuizAttemptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * The data used to create many QuizAttempts.
     */
    data: QuizAttemptCreateManyInput | QuizAttemptCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizAttempt update
   */
  export type QuizAttemptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    /**
     * The data needed to update a QuizAttempt.
     */
    data: XOR<QuizAttemptUpdateInput, QuizAttemptUncheckedUpdateInput>
    /**
     * Choose, which QuizAttempt to update.
     */
    where: QuizAttemptWhereUniqueInput
  }

  /**
   * QuizAttempt updateMany
   */
  export type QuizAttemptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuizAttempts.
     */
    data: XOR<QuizAttemptUpdateManyMutationInput, QuizAttemptUncheckedUpdateManyInput>
    /**
     * Filter which QuizAttempts to update
     */
    where?: QuizAttemptWhereInput
    /**
     * Limit how many QuizAttempts to update.
     */
    limit?: number
  }

  /**
   * QuizAttempt updateManyAndReturn
   */
  export type QuizAttemptUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * The data used to update QuizAttempts.
     */
    data: XOR<QuizAttemptUpdateManyMutationInput, QuizAttemptUncheckedUpdateManyInput>
    /**
     * Filter which QuizAttempts to update
     */
    where?: QuizAttemptWhereInput
    /**
     * Limit how many QuizAttempts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizAttempt upsert
   */
  export type QuizAttemptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    /**
     * The filter to search for the QuizAttempt to update in case it exists.
     */
    where: QuizAttemptWhereUniqueInput
    /**
     * In case the QuizAttempt found by the `where` argument doesn't exist, create a new QuizAttempt with this data.
     */
    create: XOR<QuizAttemptCreateInput, QuizAttemptUncheckedCreateInput>
    /**
     * In case the QuizAttempt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizAttemptUpdateInput, QuizAttemptUncheckedUpdateInput>
  }

  /**
   * QuizAttempt delete
   */
  export type QuizAttemptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    /**
     * Filter which QuizAttempt to delete.
     */
    where: QuizAttemptWhereUniqueInput
  }

  /**
   * QuizAttempt deleteMany
   */
  export type QuizAttemptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizAttempts to delete
     */
    where?: QuizAttemptWhereInput
    /**
     * Limit how many QuizAttempts to delete.
     */
    limit?: number
  }

  /**
   * QuizAttempt without action
   */
  export type QuizAttemptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
  }


  /**
   * Model KnowledgeNode
   */

  export type AggregateKnowledgeNode = {
    _count: KnowledgeNodeCountAggregateOutputType | null
    _min: KnowledgeNodeMinAggregateOutputType | null
    _max: KnowledgeNodeMaxAggregateOutputType | null
  }

  export type KnowledgeNodeMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    userId: string | null
    parentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KnowledgeNodeMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    userId: string | null
    parentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KnowledgeNodeCountAggregateOutputType = {
    id: number
    title: number
    description: number
    userId: number
    parentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type KnowledgeNodeMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    userId?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KnowledgeNodeMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    userId?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KnowledgeNodeCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    userId?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type KnowledgeNodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KnowledgeNode to aggregate.
     */
    where?: KnowledgeNodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeNodes to fetch.
     */
    orderBy?: KnowledgeNodeOrderByWithRelationInput | KnowledgeNodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KnowledgeNodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeNodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeNodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KnowledgeNodes
    **/
    _count?: true | KnowledgeNodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KnowledgeNodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KnowledgeNodeMaxAggregateInputType
  }

  export type GetKnowledgeNodeAggregateType<T extends KnowledgeNodeAggregateArgs> = {
        [P in keyof T & keyof AggregateKnowledgeNode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKnowledgeNode[P]>
      : GetScalarType<T[P], AggregateKnowledgeNode[P]>
  }




  export type KnowledgeNodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KnowledgeNodeWhereInput
    orderBy?: KnowledgeNodeOrderByWithAggregationInput | KnowledgeNodeOrderByWithAggregationInput[]
    by: KnowledgeNodeScalarFieldEnum[] | KnowledgeNodeScalarFieldEnum
    having?: KnowledgeNodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KnowledgeNodeCountAggregateInputType | true
    _min?: KnowledgeNodeMinAggregateInputType
    _max?: KnowledgeNodeMaxAggregateInputType
  }

  export type KnowledgeNodeGroupByOutputType = {
    id: string
    title: string
    description: string | null
    userId: string
    parentId: string | null
    createdAt: Date
    updatedAt: Date
    _count: KnowledgeNodeCountAggregateOutputType | null
    _min: KnowledgeNodeMinAggregateOutputType | null
    _max: KnowledgeNodeMaxAggregateOutputType | null
  }

  type GetKnowledgeNodeGroupByPayload<T extends KnowledgeNodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KnowledgeNodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KnowledgeNodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KnowledgeNodeGroupByOutputType[P]>
            : GetScalarType<T[P], KnowledgeNodeGroupByOutputType[P]>
        }
      >
    >


  export type KnowledgeNodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    userId?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | KnowledgeNode$parentArgs<ExtArgs>
    children?: boolean | KnowledgeNode$childrenArgs<ExtArgs>
    _count?: boolean | KnowledgeNodeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["knowledgeNode"]>

  export type KnowledgeNodeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    userId?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | KnowledgeNode$parentArgs<ExtArgs>
  }, ExtArgs["result"]["knowledgeNode"]>

  export type KnowledgeNodeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    userId?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | KnowledgeNode$parentArgs<ExtArgs>
  }, ExtArgs["result"]["knowledgeNode"]>

  export type KnowledgeNodeSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    userId?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type KnowledgeNodeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "userId" | "parentId" | "createdAt" | "updatedAt", ExtArgs["result"]["knowledgeNode"]>
  export type KnowledgeNodeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | KnowledgeNode$parentArgs<ExtArgs>
    children?: boolean | KnowledgeNode$childrenArgs<ExtArgs>
    _count?: boolean | KnowledgeNodeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type KnowledgeNodeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | KnowledgeNode$parentArgs<ExtArgs>
  }
  export type KnowledgeNodeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | KnowledgeNode$parentArgs<ExtArgs>
  }

  export type $KnowledgeNodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KnowledgeNode"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      parent: Prisma.$KnowledgeNodePayload<ExtArgs> | null
      children: Prisma.$KnowledgeNodePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      userId: string
      parentId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["knowledgeNode"]>
    composites: {}
  }

  type KnowledgeNodeGetPayload<S extends boolean | null | undefined | KnowledgeNodeDefaultArgs> = $Result.GetResult<Prisma.$KnowledgeNodePayload, S>

  type KnowledgeNodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KnowledgeNodeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KnowledgeNodeCountAggregateInputType | true
    }

  export interface KnowledgeNodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KnowledgeNode'], meta: { name: 'KnowledgeNode' } }
    /**
     * Find zero or one KnowledgeNode that matches the filter.
     * @param {KnowledgeNodeFindUniqueArgs} args - Arguments to find a KnowledgeNode
     * @example
     * // Get one KnowledgeNode
     * const knowledgeNode = await prisma.knowledgeNode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KnowledgeNodeFindUniqueArgs>(args: SelectSubset<T, KnowledgeNodeFindUniqueArgs<ExtArgs>>): Prisma__KnowledgeNodeClient<$Result.GetResult<Prisma.$KnowledgeNodePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one KnowledgeNode that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KnowledgeNodeFindUniqueOrThrowArgs} args - Arguments to find a KnowledgeNode
     * @example
     * // Get one KnowledgeNode
     * const knowledgeNode = await prisma.knowledgeNode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KnowledgeNodeFindUniqueOrThrowArgs>(args: SelectSubset<T, KnowledgeNodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KnowledgeNodeClient<$Result.GetResult<Prisma.$KnowledgeNodePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first KnowledgeNode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeNodeFindFirstArgs} args - Arguments to find a KnowledgeNode
     * @example
     * // Get one KnowledgeNode
     * const knowledgeNode = await prisma.knowledgeNode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KnowledgeNodeFindFirstArgs>(args?: SelectSubset<T, KnowledgeNodeFindFirstArgs<ExtArgs>>): Prisma__KnowledgeNodeClient<$Result.GetResult<Prisma.$KnowledgeNodePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first KnowledgeNode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeNodeFindFirstOrThrowArgs} args - Arguments to find a KnowledgeNode
     * @example
     * // Get one KnowledgeNode
     * const knowledgeNode = await prisma.knowledgeNode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KnowledgeNodeFindFirstOrThrowArgs>(args?: SelectSubset<T, KnowledgeNodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__KnowledgeNodeClient<$Result.GetResult<Prisma.$KnowledgeNodePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more KnowledgeNodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeNodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KnowledgeNodes
     * const knowledgeNodes = await prisma.knowledgeNode.findMany()
     * 
     * // Get first 10 KnowledgeNodes
     * const knowledgeNodes = await prisma.knowledgeNode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const knowledgeNodeWithIdOnly = await prisma.knowledgeNode.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KnowledgeNodeFindManyArgs>(args?: SelectSubset<T, KnowledgeNodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeNodePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a KnowledgeNode.
     * @param {KnowledgeNodeCreateArgs} args - Arguments to create a KnowledgeNode.
     * @example
     * // Create one KnowledgeNode
     * const KnowledgeNode = await prisma.knowledgeNode.create({
     *   data: {
     *     // ... data to create a KnowledgeNode
     *   }
     * })
     * 
     */
    create<T extends KnowledgeNodeCreateArgs>(args: SelectSubset<T, KnowledgeNodeCreateArgs<ExtArgs>>): Prisma__KnowledgeNodeClient<$Result.GetResult<Prisma.$KnowledgeNodePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many KnowledgeNodes.
     * @param {KnowledgeNodeCreateManyArgs} args - Arguments to create many KnowledgeNodes.
     * @example
     * // Create many KnowledgeNodes
     * const knowledgeNode = await prisma.knowledgeNode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KnowledgeNodeCreateManyArgs>(args?: SelectSubset<T, KnowledgeNodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KnowledgeNodes and returns the data saved in the database.
     * @param {KnowledgeNodeCreateManyAndReturnArgs} args - Arguments to create many KnowledgeNodes.
     * @example
     * // Create many KnowledgeNodes
     * const knowledgeNode = await prisma.knowledgeNode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KnowledgeNodes and only return the `id`
     * const knowledgeNodeWithIdOnly = await prisma.knowledgeNode.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KnowledgeNodeCreateManyAndReturnArgs>(args?: SelectSubset<T, KnowledgeNodeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeNodePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a KnowledgeNode.
     * @param {KnowledgeNodeDeleteArgs} args - Arguments to delete one KnowledgeNode.
     * @example
     * // Delete one KnowledgeNode
     * const KnowledgeNode = await prisma.knowledgeNode.delete({
     *   where: {
     *     // ... filter to delete one KnowledgeNode
     *   }
     * })
     * 
     */
    delete<T extends KnowledgeNodeDeleteArgs>(args: SelectSubset<T, KnowledgeNodeDeleteArgs<ExtArgs>>): Prisma__KnowledgeNodeClient<$Result.GetResult<Prisma.$KnowledgeNodePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one KnowledgeNode.
     * @param {KnowledgeNodeUpdateArgs} args - Arguments to update one KnowledgeNode.
     * @example
     * // Update one KnowledgeNode
     * const knowledgeNode = await prisma.knowledgeNode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KnowledgeNodeUpdateArgs>(args: SelectSubset<T, KnowledgeNodeUpdateArgs<ExtArgs>>): Prisma__KnowledgeNodeClient<$Result.GetResult<Prisma.$KnowledgeNodePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more KnowledgeNodes.
     * @param {KnowledgeNodeDeleteManyArgs} args - Arguments to filter KnowledgeNodes to delete.
     * @example
     * // Delete a few KnowledgeNodes
     * const { count } = await prisma.knowledgeNode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KnowledgeNodeDeleteManyArgs>(args?: SelectSubset<T, KnowledgeNodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KnowledgeNodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeNodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KnowledgeNodes
     * const knowledgeNode = await prisma.knowledgeNode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KnowledgeNodeUpdateManyArgs>(args: SelectSubset<T, KnowledgeNodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KnowledgeNodes and returns the data updated in the database.
     * @param {KnowledgeNodeUpdateManyAndReturnArgs} args - Arguments to update many KnowledgeNodes.
     * @example
     * // Update many KnowledgeNodes
     * const knowledgeNode = await prisma.knowledgeNode.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more KnowledgeNodes and only return the `id`
     * const knowledgeNodeWithIdOnly = await prisma.knowledgeNode.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends KnowledgeNodeUpdateManyAndReturnArgs>(args: SelectSubset<T, KnowledgeNodeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeNodePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one KnowledgeNode.
     * @param {KnowledgeNodeUpsertArgs} args - Arguments to update or create a KnowledgeNode.
     * @example
     * // Update or create a KnowledgeNode
     * const knowledgeNode = await prisma.knowledgeNode.upsert({
     *   create: {
     *     // ... data to create a KnowledgeNode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KnowledgeNode we want to update
     *   }
     * })
     */
    upsert<T extends KnowledgeNodeUpsertArgs>(args: SelectSubset<T, KnowledgeNodeUpsertArgs<ExtArgs>>): Prisma__KnowledgeNodeClient<$Result.GetResult<Prisma.$KnowledgeNodePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of KnowledgeNodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeNodeCountArgs} args - Arguments to filter KnowledgeNodes to count.
     * @example
     * // Count the number of KnowledgeNodes
     * const count = await prisma.knowledgeNode.count({
     *   where: {
     *     // ... the filter for the KnowledgeNodes we want to count
     *   }
     * })
    **/
    count<T extends KnowledgeNodeCountArgs>(
      args?: Subset<T, KnowledgeNodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KnowledgeNodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KnowledgeNode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeNodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KnowledgeNodeAggregateArgs>(args: Subset<T, KnowledgeNodeAggregateArgs>): Prisma.PrismaPromise<GetKnowledgeNodeAggregateType<T>>

    /**
     * Group by KnowledgeNode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeNodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KnowledgeNodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KnowledgeNodeGroupByArgs['orderBy'] }
        : { orderBy?: KnowledgeNodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KnowledgeNodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKnowledgeNodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KnowledgeNode model
   */
  readonly fields: KnowledgeNodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KnowledgeNode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KnowledgeNodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    parent<T extends KnowledgeNode$parentArgs<ExtArgs> = {}>(args?: Subset<T, KnowledgeNode$parentArgs<ExtArgs>>): Prisma__KnowledgeNodeClient<$Result.GetResult<Prisma.$KnowledgeNodePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    children<T extends KnowledgeNode$childrenArgs<ExtArgs> = {}>(args?: Subset<T, KnowledgeNode$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeNodePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KnowledgeNode model
   */ 
  interface KnowledgeNodeFieldRefs {
    readonly id: FieldRef<"KnowledgeNode", 'String'>
    readonly title: FieldRef<"KnowledgeNode", 'String'>
    readonly description: FieldRef<"KnowledgeNode", 'String'>
    readonly userId: FieldRef<"KnowledgeNode", 'String'>
    readonly parentId: FieldRef<"KnowledgeNode", 'String'>
    readonly createdAt: FieldRef<"KnowledgeNode", 'DateTime'>
    readonly updatedAt: FieldRef<"KnowledgeNode", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * KnowledgeNode findUnique
   */
  export type KnowledgeNodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeNode
     */
    select?: KnowledgeNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeNode
     */
    omit?: KnowledgeNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeNodeInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeNode to fetch.
     */
    where: KnowledgeNodeWhereUniqueInput
  }

  /**
   * KnowledgeNode findUniqueOrThrow
   */
  export type KnowledgeNodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeNode
     */
    select?: KnowledgeNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeNode
     */
    omit?: KnowledgeNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeNodeInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeNode to fetch.
     */
    where: KnowledgeNodeWhereUniqueInput
  }

  /**
   * KnowledgeNode findFirst
   */
  export type KnowledgeNodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeNode
     */
    select?: KnowledgeNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeNode
     */
    omit?: KnowledgeNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeNodeInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeNode to fetch.
     */
    where?: KnowledgeNodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeNodes to fetch.
     */
    orderBy?: KnowledgeNodeOrderByWithRelationInput | KnowledgeNodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KnowledgeNodes.
     */
    cursor?: KnowledgeNodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeNodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeNodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KnowledgeNodes.
     */
    distinct?: KnowledgeNodeScalarFieldEnum | KnowledgeNodeScalarFieldEnum[]
  }

  /**
   * KnowledgeNode findFirstOrThrow
   */
  export type KnowledgeNodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeNode
     */
    select?: KnowledgeNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeNode
     */
    omit?: KnowledgeNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeNodeInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeNode to fetch.
     */
    where?: KnowledgeNodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeNodes to fetch.
     */
    orderBy?: KnowledgeNodeOrderByWithRelationInput | KnowledgeNodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KnowledgeNodes.
     */
    cursor?: KnowledgeNodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeNodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeNodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KnowledgeNodes.
     */
    distinct?: KnowledgeNodeScalarFieldEnum | KnowledgeNodeScalarFieldEnum[]
  }

  /**
   * KnowledgeNode findMany
   */
  export type KnowledgeNodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeNode
     */
    select?: KnowledgeNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeNode
     */
    omit?: KnowledgeNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeNodeInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeNodes to fetch.
     */
    where?: KnowledgeNodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeNodes to fetch.
     */
    orderBy?: KnowledgeNodeOrderByWithRelationInput | KnowledgeNodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KnowledgeNodes.
     */
    cursor?: KnowledgeNodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeNodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeNodes.
     */
    skip?: number
    distinct?: KnowledgeNodeScalarFieldEnum | KnowledgeNodeScalarFieldEnum[]
  }

  /**
   * KnowledgeNode create
   */
  export type KnowledgeNodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeNode
     */
    select?: KnowledgeNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeNode
     */
    omit?: KnowledgeNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeNodeInclude<ExtArgs> | null
    /**
     * The data needed to create a KnowledgeNode.
     */
    data: XOR<KnowledgeNodeCreateInput, KnowledgeNodeUncheckedCreateInput>
  }

  /**
   * KnowledgeNode createMany
   */
  export type KnowledgeNodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KnowledgeNodes.
     */
    data: KnowledgeNodeCreateManyInput | KnowledgeNodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KnowledgeNode createManyAndReturn
   */
  export type KnowledgeNodeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeNode
     */
    select?: KnowledgeNodeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeNode
     */
    omit?: KnowledgeNodeOmit<ExtArgs> | null
    /**
     * The data used to create many KnowledgeNodes.
     */
    data: KnowledgeNodeCreateManyInput | KnowledgeNodeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeNodeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * KnowledgeNode update
   */
  export type KnowledgeNodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeNode
     */
    select?: KnowledgeNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeNode
     */
    omit?: KnowledgeNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeNodeInclude<ExtArgs> | null
    /**
     * The data needed to update a KnowledgeNode.
     */
    data: XOR<KnowledgeNodeUpdateInput, KnowledgeNodeUncheckedUpdateInput>
    /**
     * Choose, which KnowledgeNode to update.
     */
    where: KnowledgeNodeWhereUniqueInput
  }

  /**
   * KnowledgeNode updateMany
   */
  export type KnowledgeNodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KnowledgeNodes.
     */
    data: XOR<KnowledgeNodeUpdateManyMutationInput, KnowledgeNodeUncheckedUpdateManyInput>
    /**
     * Filter which KnowledgeNodes to update
     */
    where?: KnowledgeNodeWhereInput
    /**
     * Limit how many KnowledgeNodes to update.
     */
    limit?: number
  }

  /**
   * KnowledgeNode updateManyAndReturn
   */
  export type KnowledgeNodeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeNode
     */
    select?: KnowledgeNodeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeNode
     */
    omit?: KnowledgeNodeOmit<ExtArgs> | null
    /**
     * The data used to update KnowledgeNodes.
     */
    data: XOR<KnowledgeNodeUpdateManyMutationInput, KnowledgeNodeUncheckedUpdateManyInput>
    /**
     * Filter which KnowledgeNodes to update
     */
    where?: KnowledgeNodeWhereInput
    /**
     * Limit how many KnowledgeNodes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeNodeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * KnowledgeNode upsert
   */
  export type KnowledgeNodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeNode
     */
    select?: KnowledgeNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeNode
     */
    omit?: KnowledgeNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeNodeInclude<ExtArgs> | null
    /**
     * The filter to search for the KnowledgeNode to update in case it exists.
     */
    where: KnowledgeNodeWhereUniqueInput
    /**
     * In case the KnowledgeNode found by the `where` argument doesn't exist, create a new KnowledgeNode with this data.
     */
    create: XOR<KnowledgeNodeCreateInput, KnowledgeNodeUncheckedCreateInput>
    /**
     * In case the KnowledgeNode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KnowledgeNodeUpdateInput, KnowledgeNodeUncheckedUpdateInput>
  }

  /**
   * KnowledgeNode delete
   */
  export type KnowledgeNodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeNode
     */
    select?: KnowledgeNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeNode
     */
    omit?: KnowledgeNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeNodeInclude<ExtArgs> | null
    /**
     * Filter which KnowledgeNode to delete.
     */
    where: KnowledgeNodeWhereUniqueInput
  }

  /**
   * KnowledgeNode deleteMany
   */
  export type KnowledgeNodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KnowledgeNodes to delete
     */
    where?: KnowledgeNodeWhereInput
    /**
     * Limit how many KnowledgeNodes to delete.
     */
    limit?: number
  }

  /**
   * KnowledgeNode.parent
   */
  export type KnowledgeNode$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeNode
     */
    select?: KnowledgeNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeNode
     */
    omit?: KnowledgeNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeNodeInclude<ExtArgs> | null
    where?: KnowledgeNodeWhereInput
  }

  /**
   * KnowledgeNode.children
   */
  export type KnowledgeNode$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeNode
     */
    select?: KnowledgeNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeNode
     */
    omit?: KnowledgeNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeNodeInclude<ExtArgs> | null
    where?: KnowledgeNodeWhereInput
    orderBy?: KnowledgeNodeOrderByWithRelationInput | KnowledgeNodeOrderByWithRelationInput[]
    cursor?: KnowledgeNodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KnowledgeNodeScalarFieldEnum | KnowledgeNodeScalarFieldEnum[]
  }

  /**
   * KnowledgeNode without action
   */
  export type KnowledgeNodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeNode
     */
    select?: KnowledgeNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeNode
     */
    omit?: KnowledgeNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeNodeInclude<ExtArgs> | null
  }


  /**
   * Model LeaderboardEntry
   */

  export type AggregateLeaderboardEntry = {
    _count: LeaderboardEntryCountAggregateOutputType | null
    _avg: LeaderboardEntryAvgAggregateOutputType | null
    _sum: LeaderboardEntrySumAggregateOutputType | null
    _min: LeaderboardEntryMinAggregateOutputType | null
    _max: LeaderboardEntryMaxAggregateOutputType | null
  }

  export type LeaderboardEntryAvgAggregateOutputType = {
    score: number | null
  }

  export type LeaderboardEntrySumAggregateOutputType = {
    score: number | null
  }

  export type LeaderboardEntryMinAggregateOutputType = {
    id: string | null
    userId: string | null
    score: number | null
    type: string | null
    startDate: Date | null
    endDate: Date | null
  }

  export type LeaderboardEntryMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    score: number | null
    type: string | null
    startDate: Date | null
    endDate: Date | null
  }

  export type LeaderboardEntryCountAggregateOutputType = {
    id: number
    userId: number
    score: number
    type: number
    startDate: number
    endDate: number
    _all: number
  }


  export type LeaderboardEntryAvgAggregateInputType = {
    score?: true
  }

  export type LeaderboardEntrySumAggregateInputType = {
    score?: true
  }

  export type LeaderboardEntryMinAggregateInputType = {
    id?: true
    userId?: true
    score?: true
    type?: true
    startDate?: true
    endDate?: true
  }

  export type LeaderboardEntryMaxAggregateInputType = {
    id?: true
    userId?: true
    score?: true
    type?: true
    startDate?: true
    endDate?: true
  }

  export type LeaderboardEntryCountAggregateInputType = {
    id?: true
    userId?: true
    score?: true
    type?: true
    startDate?: true
    endDate?: true
    _all?: true
  }

  export type LeaderboardEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaderboardEntry to aggregate.
     */
    where?: LeaderboardEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaderboardEntries to fetch.
     */
    orderBy?: LeaderboardEntryOrderByWithRelationInput | LeaderboardEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeaderboardEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaderboardEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaderboardEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LeaderboardEntries
    **/
    _count?: true | LeaderboardEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeaderboardEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeaderboardEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeaderboardEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeaderboardEntryMaxAggregateInputType
  }

  export type GetLeaderboardEntryAggregateType<T extends LeaderboardEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateLeaderboardEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeaderboardEntry[P]>
      : GetScalarType<T[P], AggregateLeaderboardEntry[P]>
  }




  export type LeaderboardEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaderboardEntryWhereInput
    orderBy?: LeaderboardEntryOrderByWithAggregationInput | LeaderboardEntryOrderByWithAggregationInput[]
    by: LeaderboardEntryScalarFieldEnum[] | LeaderboardEntryScalarFieldEnum
    having?: LeaderboardEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeaderboardEntryCountAggregateInputType | true
    _avg?: LeaderboardEntryAvgAggregateInputType
    _sum?: LeaderboardEntrySumAggregateInputType
    _min?: LeaderboardEntryMinAggregateInputType
    _max?: LeaderboardEntryMaxAggregateInputType
  }

  export type LeaderboardEntryGroupByOutputType = {
    id: string
    userId: string
    score: number
    type: string
    startDate: Date
    endDate: Date
    _count: LeaderboardEntryCountAggregateOutputType | null
    _avg: LeaderboardEntryAvgAggregateOutputType | null
    _sum: LeaderboardEntrySumAggregateOutputType | null
    _min: LeaderboardEntryMinAggregateOutputType | null
    _max: LeaderboardEntryMaxAggregateOutputType | null
  }

  type GetLeaderboardEntryGroupByPayload<T extends LeaderboardEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeaderboardEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeaderboardEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeaderboardEntryGroupByOutputType[P]>
            : GetScalarType<T[P], LeaderboardEntryGroupByOutputType[P]>
        }
      >
    >


  export type LeaderboardEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    score?: boolean
    type?: boolean
    startDate?: boolean
    endDate?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leaderboardEntry"]>

  export type LeaderboardEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    score?: boolean
    type?: boolean
    startDate?: boolean
    endDate?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leaderboardEntry"]>

  export type LeaderboardEntrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    score?: boolean
    type?: boolean
    startDate?: boolean
    endDate?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leaderboardEntry"]>

  export type LeaderboardEntrySelectScalar = {
    id?: boolean
    userId?: boolean
    score?: boolean
    type?: boolean
    startDate?: boolean
    endDate?: boolean
  }

  export type LeaderboardEntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "score" | "type" | "startDate" | "endDate", ExtArgs["result"]["leaderboardEntry"]>
  export type LeaderboardEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LeaderboardEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LeaderboardEntryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LeaderboardEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LeaderboardEntry"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      score: number
      type: string
      startDate: Date
      endDate: Date
    }, ExtArgs["result"]["leaderboardEntry"]>
    composites: {}
  }

  type LeaderboardEntryGetPayload<S extends boolean | null | undefined | LeaderboardEntryDefaultArgs> = $Result.GetResult<Prisma.$LeaderboardEntryPayload, S>

  type LeaderboardEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeaderboardEntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeaderboardEntryCountAggregateInputType | true
    }

  export interface LeaderboardEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LeaderboardEntry'], meta: { name: 'LeaderboardEntry' } }
    /**
     * Find zero or one LeaderboardEntry that matches the filter.
     * @param {LeaderboardEntryFindUniqueArgs} args - Arguments to find a LeaderboardEntry
     * @example
     * // Get one LeaderboardEntry
     * const leaderboardEntry = await prisma.leaderboardEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeaderboardEntryFindUniqueArgs>(args: SelectSubset<T, LeaderboardEntryFindUniqueArgs<ExtArgs>>): Prisma__LeaderboardEntryClient<$Result.GetResult<Prisma.$LeaderboardEntryPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one LeaderboardEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeaderboardEntryFindUniqueOrThrowArgs} args - Arguments to find a LeaderboardEntry
     * @example
     * // Get one LeaderboardEntry
     * const leaderboardEntry = await prisma.leaderboardEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeaderboardEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, LeaderboardEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeaderboardEntryClient<$Result.GetResult<Prisma.$LeaderboardEntryPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first LeaderboardEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardEntryFindFirstArgs} args - Arguments to find a LeaderboardEntry
     * @example
     * // Get one LeaderboardEntry
     * const leaderboardEntry = await prisma.leaderboardEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeaderboardEntryFindFirstArgs>(args?: SelectSubset<T, LeaderboardEntryFindFirstArgs<ExtArgs>>): Prisma__LeaderboardEntryClient<$Result.GetResult<Prisma.$LeaderboardEntryPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first LeaderboardEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardEntryFindFirstOrThrowArgs} args - Arguments to find a LeaderboardEntry
     * @example
     * // Get one LeaderboardEntry
     * const leaderboardEntry = await prisma.leaderboardEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeaderboardEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, LeaderboardEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeaderboardEntryClient<$Result.GetResult<Prisma.$LeaderboardEntryPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more LeaderboardEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LeaderboardEntries
     * const leaderboardEntries = await prisma.leaderboardEntry.findMany()
     * 
     * // Get first 10 LeaderboardEntries
     * const leaderboardEntries = await prisma.leaderboardEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leaderboardEntryWithIdOnly = await prisma.leaderboardEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeaderboardEntryFindManyArgs>(args?: SelectSubset<T, LeaderboardEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaderboardEntryPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a LeaderboardEntry.
     * @param {LeaderboardEntryCreateArgs} args - Arguments to create a LeaderboardEntry.
     * @example
     * // Create one LeaderboardEntry
     * const LeaderboardEntry = await prisma.leaderboardEntry.create({
     *   data: {
     *     // ... data to create a LeaderboardEntry
     *   }
     * })
     * 
     */
    create<T extends LeaderboardEntryCreateArgs>(args: SelectSubset<T, LeaderboardEntryCreateArgs<ExtArgs>>): Prisma__LeaderboardEntryClient<$Result.GetResult<Prisma.$LeaderboardEntryPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many LeaderboardEntries.
     * @param {LeaderboardEntryCreateManyArgs} args - Arguments to create many LeaderboardEntries.
     * @example
     * // Create many LeaderboardEntries
     * const leaderboardEntry = await prisma.leaderboardEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeaderboardEntryCreateManyArgs>(args?: SelectSubset<T, LeaderboardEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LeaderboardEntries and returns the data saved in the database.
     * @param {LeaderboardEntryCreateManyAndReturnArgs} args - Arguments to create many LeaderboardEntries.
     * @example
     * // Create many LeaderboardEntries
     * const leaderboardEntry = await prisma.leaderboardEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LeaderboardEntries and only return the `id`
     * const leaderboardEntryWithIdOnly = await prisma.leaderboardEntry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeaderboardEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, LeaderboardEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaderboardEntryPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a LeaderboardEntry.
     * @param {LeaderboardEntryDeleteArgs} args - Arguments to delete one LeaderboardEntry.
     * @example
     * // Delete one LeaderboardEntry
     * const LeaderboardEntry = await prisma.leaderboardEntry.delete({
     *   where: {
     *     // ... filter to delete one LeaderboardEntry
     *   }
     * })
     * 
     */
    delete<T extends LeaderboardEntryDeleteArgs>(args: SelectSubset<T, LeaderboardEntryDeleteArgs<ExtArgs>>): Prisma__LeaderboardEntryClient<$Result.GetResult<Prisma.$LeaderboardEntryPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one LeaderboardEntry.
     * @param {LeaderboardEntryUpdateArgs} args - Arguments to update one LeaderboardEntry.
     * @example
     * // Update one LeaderboardEntry
     * const leaderboardEntry = await prisma.leaderboardEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeaderboardEntryUpdateArgs>(args: SelectSubset<T, LeaderboardEntryUpdateArgs<ExtArgs>>): Prisma__LeaderboardEntryClient<$Result.GetResult<Prisma.$LeaderboardEntryPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more LeaderboardEntries.
     * @param {LeaderboardEntryDeleteManyArgs} args - Arguments to filter LeaderboardEntries to delete.
     * @example
     * // Delete a few LeaderboardEntries
     * const { count } = await prisma.leaderboardEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeaderboardEntryDeleteManyArgs>(args?: SelectSubset<T, LeaderboardEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeaderboardEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LeaderboardEntries
     * const leaderboardEntry = await prisma.leaderboardEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeaderboardEntryUpdateManyArgs>(args: SelectSubset<T, LeaderboardEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeaderboardEntries and returns the data updated in the database.
     * @param {LeaderboardEntryUpdateManyAndReturnArgs} args - Arguments to update many LeaderboardEntries.
     * @example
     * // Update many LeaderboardEntries
     * const leaderboardEntry = await prisma.leaderboardEntry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LeaderboardEntries and only return the `id`
     * const leaderboardEntryWithIdOnly = await prisma.leaderboardEntry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LeaderboardEntryUpdateManyAndReturnArgs>(args: SelectSubset<T, LeaderboardEntryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaderboardEntryPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one LeaderboardEntry.
     * @param {LeaderboardEntryUpsertArgs} args - Arguments to update or create a LeaderboardEntry.
     * @example
     * // Update or create a LeaderboardEntry
     * const leaderboardEntry = await prisma.leaderboardEntry.upsert({
     *   create: {
     *     // ... data to create a LeaderboardEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LeaderboardEntry we want to update
     *   }
     * })
     */
    upsert<T extends LeaderboardEntryUpsertArgs>(args: SelectSubset<T, LeaderboardEntryUpsertArgs<ExtArgs>>): Prisma__LeaderboardEntryClient<$Result.GetResult<Prisma.$LeaderboardEntryPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of LeaderboardEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardEntryCountArgs} args - Arguments to filter LeaderboardEntries to count.
     * @example
     * // Count the number of LeaderboardEntries
     * const count = await prisma.leaderboardEntry.count({
     *   where: {
     *     // ... the filter for the LeaderboardEntries we want to count
     *   }
     * })
    **/
    count<T extends LeaderboardEntryCountArgs>(
      args?: Subset<T, LeaderboardEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeaderboardEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LeaderboardEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeaderboardEntryAggregateArgs>(args: Subset<T, LeaderboardEntryAggregateArgs>): Prisma.PrismaPromise<GetLeaderboardEntryAggregateType<T>>

    /**
     * Group by LeaderboardEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeaderboardEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeaderboardEntryGroupByArgs['orderBy'] }
        : { orderBy?: LeaderboardEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeaderboardEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeaderboardEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LeaderboardEntry model
   */
  readonly fields: LeaderboardEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LeaderboardEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeaderboardEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LeaderboardEntry model
   */ 
  interface LeaderboardEntryFieldRefs {
    readonly id: FieldRef<"LeaderboardEntry", 'String'>
    readonly userId: FieldRef<"LeaderboardEntry", 'String'>
    readonly score: FieldRef<"LeaderboardEntry", 'Int'>
    readonly type: FieldRef<"LeaderboardEntry", 'String'>
    readonly startDate: FieldRef<"LeaderboardEntry", 'DateTime'>
    readonly endDate: FieldRef<"LeaderboardEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LeaderboardEntry findUnique
   */
  export type LeaderboardEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaderboardEntry
     */
    omit?: LeaderboardEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null
    /**
     * Filter, which LeaderboardEntry to fetch.
     */
    where: LeaderboardEntryWhereUniqueInput
  }

  /**
   * LeaderboardEntry findUniqueOrThrow
   */
  export type LeaderboardEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaderboardEntry
     */
    omit?: LeaderboardEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null
    /**
     * Filter, which LeaderboardEntry to fetch.
     */
    where: LeaderboardEntryWhereUniqueInput
  }

  /**
   * LeaderboardEntry findFirst
   */
  export type LeaderboardEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaderboardEntry
     */
    omit?: LeaderboardEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null
    /**
     * Filter, which LeaderboardEntry to fetch.
     */
    where?: LeaderboardEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaderboardEntries to fetch.
     */
    orderBy?: LeaderboardEntryOrderByWithRelationInput | LeaderboardEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaderboardEntries.
     */
    cursor?: LeaderboardEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaderboardEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaderboardEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaderboardEntries.
     */
    distinct?: LeaderboardEntryScalarFieldEnum | LeaderboardEntryScalarFieldEnum[]
  }

  /**
   * LeaderboardEntry findFirstOrThrow
   */
  export type LeaderboardEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaderboardEntry
     */
    omit?: LeaderboardEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null
    /**
     * Filter, which LeaderboardEntry to fetch.
     */
    where?: LeaderboardEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaderboardEntries to fetch.
     */
    orderBy?: LeaderboardEntryOrderByWithRelationInput | LeaderboardEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaderboardEntries.
     */
    cursor?: LeaderboardEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaderboardEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaderboardEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaderboardEntries.
     */
    distinct?: LeaderboardEntryScalarFieldEnum | LeaderboardEntryScalarFieldEnum[]
  }

  /**
   * LeaderboardEntry findMany
   */
  export type LeaderboardEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaderboardEntry
     */
    omit?: LeaderboardEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null
    /**
     * Filter, which LeaderboardEntries to fetch.
     */
    where?: LeaderboardEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaderboardEntries to fetch.
     */
    orderBy?: LeaderboardEntryOrderByWithRelationInput | LeaderboardEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LeaderboardEntries.
     */
    cursor?: LeaderboardEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaderboardEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaderboardEntries.
     */
    skip?: number
    distinct?: LeaderboardEntryScalarFieldEnum | LeaderboardEntryScalarFieldEnum[]
  }

  /**
   * LeaderboardEntry create
   */
  export type LeaderboardEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaderboardEntry
     */
    omit?: LeaderboardEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a LeaderboardEntry.
     */
    data: XOR<LeaderboardEntryCreateInput, LeaderboardEntryUncheckedCreateInput>
  }

  /**
   * LeaderboardEntry createMany
   */
  export type LeaderboardEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LeaderboardEntries.
     */
    data: LeaderboardEntryCreateManyInput | LeaderboardEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LeaderboardEntry createManyAndReturn
   */
  export type LeaderboardEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeaderboardEntry
     */
    omit?: LeaderboardEntryOmit<ExtArgs> | null
    /**
     * The data used to create many LeaderboardEntries.
     */
    data: LeaderboardEntryCreateManyInput | LeaderboardEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeaderboardEntry update
   */
  export type LeaderboardEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaderboardEntry
     */
    omit?: LeaderboardEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a LeaderboardEntry.
     */
    data: XOR<LeaderboardEntryUpdateInput, LeaderboardEntryUncheckedUpdateInput>
    /**
     * Choose, which LeaderboardEntry to update.
     */
    where: LeaderboardEntryWhereUniqueInput
  }

  /**
   * LeaderboardEntry updateMany
   */
  export type LeaderboardEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LeaderboardEntries.
     */
    data: XOR<LeaderboardEntryUpdateManyMutationInput, LeaderboardEntryUncheckedUpdateManyInput>
    /**
     * Filter which LeaderboardEntries to update
     */
    where?: LeaderboardEntryWhereInput
    /**
     * Limit how many LeaderboardEntries to update.
     */
    limit?: number
  }

  /**
   * LeaderboardEntry updateManyAndReturn
   */
  export type LeaderboardEntryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeaderboardEntry
     */
    omit?: LeaderboardEntryOmit<ExtArgs> | null
    /**
     * The data used to update LeaderboardEntries.
     */
    data: XOR<LeaderboardEntryUpdateManyMutationInput, LeaderboardEntryUncheckedUpdateManyInput>
    /**
     * Filter which LeaderboardEntries to update
     */
    where?: LeaderboardEntryWhereInput
    /**
     * Limit how many LeaderboardEntries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeaderboardEntry upsert
   */
  export type LeaderboardEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaderboardEntry
     */
    omit?: LeaderboardEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the LeaderboardEntry to update in case it exists.
     */
    where: LeaderboardEntryWhereUniqueInput
    /**
     * In case the LeaderboardEntry found by the `where` argument doesn't exist, create a new LeaderboardEntry with this data.
     */
    create: XOR<LeaderboardEntryCreateInput, LeaderboardEntryUncheckedCreateInput>
    /**
     * In case the LeaderboardEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeaderboardEntryUpdateInput, LeaderboardEntryUncheckedUpdateInput>
  }

  /**
   * LeaderboardEntry delete
   */
  export type LeaderboardEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaderboardEntry
     */
    omit?: LeaderboardEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null
    /**
     * Filter which LeaderboardEntry to delete.
     */
    where: LeaderboardEntryWhereUniqueInput
  }

  /**
   * LeaderboardEntry deleteMany
   */
  export type LeaderboardEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaderboardEntries to delete
     */
    where?: LeaderboardEntryWhereInput
    /**
     * Limit how many LeaderboardEntries to delete.
     */
    limit?: number
  }

  /**
   * LeaderboardEntry without action
   */
  export type LeaderboardEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaderboardEntry
     */
    omit?: LeaderboardEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null
  }


  /**
   * Model ReviewSession
   */

  export type AggregateReviewSession = {
    _count: ReviewSessionCountAggregateOutputType | null
    _min: ReviewSessionMinAggregateOutputType | null
    _max: ReviewSessionMaxAggregateOutputType | null
  }

  export type ReviewSessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    dueDate: Date | null
    completed: boolean | null
    isUrgent: boolean | null
  }

  export type ReviewSessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    dueDate: Date | null
    completed: boolean | null
    isUrgent: boolean | null
  }

  export type ReviewSessionCountAggregateOutputType = {
    id: number
    userId: number
    dueDate: number
    completed: number
    isUrgent: number
    _all: number
  }


  export type ReviewSessionMinAggregateInputType = {
    id?: true
    userId?: true
    dueDate?: true
    completed?: true
    isUrgent?: true
  }

  export type ReviewSessionMaxAggregateInputType = {
    id?: true
    userId?: true
    dueDate?: true
    completed?: true
    isUrgent?: true
  }

  export type ReviewSessionCountAggregateInputType = {
    id?: true
    userId?: true
    dueDate?: true
    completed?: true
    isUrgent?: true
    _all?: true
  }

  export type ReviewSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReviewSession to aggregate.
     */
    where?: ReviewSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewSessions to fetch.
     */
    orderBy?: ReviewSessionOrderByWithRelationInput | ReviewSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReviewSessions
    **/
    _count?: true | ReviewSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewSessionMaxAggregateInputType
  }

  export type GetReviewSessionAggregateType<T extends ReviewSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateReviewSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReviewSession[P]>
      : GetScalarType<T[P], AggregateReviewSession[P]>
  }




  export type ReviewSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewSessionWhereInput
    orderBy?: ReviewSessionOrderByWithAggregationInput | ReviewSessionOrderByWithAggregationInput[]
    by: ReviewSessionScalarFieldEnum[] | ReviewSessionScalarFieldEnum
    having?: ReviewSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewSessionCountAggregateInputType | true
    _min?: ReviewSessionMinAggregateInputType
    _max?: ReviewSessionMaxAggregateInputType
  }

  export type ReviewSessionGroupByOutputType = {
    id: string
    userId: string
    dueDate: Date
    completed: boolean
    isUrgent: boolean
    _count: ReviewSessionCountAggregateOutputType | null
    _min: ReviewSessionMinAggregateOutputType | null
    _max: ReviewSessionMaxAggregateOutputType | null
  }

  type GetReviewSessionGroupByPayload<T extends ReviewSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewSessionGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewSessionGroupByOutputType[P]>
        }
      >
    >


  export type ReviewSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    dueDate?: boolean
    completed?: boolean
    isUrgent?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    items?: boolean | ReviewSession$itemsArgs<ExtArgs>
    _count?: boolean | ReviewSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewSession"]>

  export type ReviewSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    dueDate?: boolean
    completed?: boolean
    isUrgent?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewSession"]>

  export type ReviewSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    dueDate?: boolean
    completed?: boolean
    isUrgent?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewSession"]>

  export type ReviewSessionSelectScalar = {
    id?: boolean
    userId?: boolean
    dueDate?: boolean
    completed?: boolean
    isUrgent?: boolean
  }

  export type ReviewSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "dueDate" | "completed" | "isUrgent", ExtArgs["result"]["reviewSession"]>
  export type ReviewSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    items?: boolean | ReviewSession$itemsArgs<ExtArgs>
    _count?: boolean | ReviewSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ReviewSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReviewSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ReviewSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReviewSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      items: Prisma.$ReviewItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      dueDate: Date
      completed: boolean
      isUrgent: boolean
    }, ExtArgs["result"]["reviewSession"]>
    composites: {}
  }

  type ReviewSessionGetPayload<S extends boolean | null | undefined | ReviewSessionDefaultArgs> = $Result.GetResult<Prisma.$ReviewSessionPayload, S>

  type ReviewSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReviewSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewSessionCountAggregateInputType | true
    }

  export interface ReviewSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReviewSession'], meta: { name: 'ReviewSession' } }
    /**
     * Find zero or one ReviewSession that matches the filter.
     * @param {ReviewSessionFindUniqueArgs} args - Arguments to find a ReviewSession
     * @example
     * // Get one ReviewSession
     * const reviewSession = await prisma.reviewSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewSessionFindUniqueArgs>(args: SelectSubset<T, ReviewSessionFindUniqueArgs<ExtArgs>>): Prisma__ReviewSessionClient<$Result.GetResult<Prisma.$ReviewSessionPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ReviewSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReviewSessionFindUniqueOrThrowArgs} args - Arguments to find a ReviewSession
     * @example
     * // Get one ReviewSession
     * const reviewSession = await prisma.reviewSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewSessionClient<$Result.GetResult<Prisma.$ReviewSessionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ReviewSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewSessionFindFirstArgs} args - Arguments to find a ReviewSession
     * @example
     * // Get one ReviewSession
     * const reviewSession = await prisma.reviewSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewSessionFindFirstArgs>(args?: SelectSubset<T, ReviewSessionFindFirstArgs<ExtArgs>>): Prisma__ReviewSessionClient<$Result.GetResult<Prisma.$ReviewSessionPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ReviewSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewSessionFindFirstOrThrowArgs} args - Arguments to find a ReviewSession
     * @example
     * // Get one ReviewSession
     * const reviewSession = await prisma.reviewSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewSessionClient<$Result.GetResult<Prisma.$ReviewSessionPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ReviewSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReviewSessions
     * const reviewSessions = await prisma.reviewSession.findMany()
     * 
     * // Get first 10 ReviewSessions
     * const reviewSessions = await prisma.reviewSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewSessionWithIdOnly = await prisma.reviewSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewSessionFindManyArgs>(args?: SelectSubset<T, ReviewSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewSessionPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ReviewSession.
     * @param {ReviewSessionCreateArgs} args - Arguments to create a ReviewSession.
     * @example
     * // Create one ReviewSession
     * const ReviewSession = await prisma.reviewSession.create({
     *   data: {
     *     // ... data to create a ReviewSession
     *   }
     * })
     * 
     */
    create<T extends ReviewSessionCreateArgs>(args: SelectSubset<T, ReviewSessionCreateArgs<ExtArgs>>): Prisma__ReviewSessionClient<$Result.GetResult<Prisma.$ReviewSessionPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ReviewSessions.
     * @param {ReviewSessionCreateManyArgs} args - Arguments to create many ReviewSessions.
     * @example
     * // Create many ReviewSessions
     * const reviewSession = await prisma.reviewSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewSessionCreateManyArgs>(args?: SelectSubset<T, ReviewSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReviewSessions and returns the data saved in the database.
     * @param {ReviewSessionCreateManyAndReturnArgs} args - Arguments to create many ReviewSessions.
     * @example
     * // Create many ReviewSessions
     * const reviewSession = await prisma.reviewSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReviewSessions and only return the `id`
     * const reviewSessionWithIdOnly = await prisma.reviewSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewSessionPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a ReviewSession.
     * @param {ReviewSessionDeleteArgs} args - Arguments to delete one ReviewSession.
     * @example
     * // Delete one ReviewSession
     * const ReviewSession = await prisma.reviewSession.delete({
     *   where: {
     *     // ... filter to delete one ReviewSession
     *   }
     * })
     * 
     */
    delete<T extends ReviewSessionDeleteArgs>(args: SelectSubset<T, ReviewSessionDeleteArgs<ExtArgs>>): Prisma__ReviewSessionClient<$Result.GetResult<Prisma.$ReviewSessionPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ReviewSession.
     * @param {ReviewSessionUpdateArgs} args - Arguments to update one ReviewSession.
     * @example
     * // Update one ReviewSession
     * const reviewSession = await prisma.reviewSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewSessionUpdateArgs>(args: SelectSubset<T, ReviewSessionUpdateArgs<ExtArgs>>): Prisma__ReviewSessionClient<$Result.GetResult<Prisma.$ReviewSessionPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ReviewSessions.
     * @param {ReviewSessionDeleteManyArgs} args - Arguments to filter ReviewSessions to delete.
     * @example
     * // Delete a few ReviewSessions
     * const { count } = await prisma.reviewSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewSessionDeleteManyArgs>(args?: SelectSubset<T, ReviewSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReviewSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReviewSessions
     * const reviewSession = await prisma.reviewSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewSessionUpdateManyArgs>(args: SelectSubset<T, ReviewSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReviewSessions and returns the data updated in the database.
     * @param {ReviewSessionUpdateManyAndReturnArgs} args - Arguments to update many ReviewSessions.
     * @example
     * // Update many ReviewSessions
     * const reviewSession = await prisma.reviewSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReviewSessions and only return the `id`
     * const reviewSessionWithIdOnly = await prisma.reviewSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReviewSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, ReviewSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewSessionPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one ReviewSession.
     * @param {ReviewSessionUpsertArgs} args - Arguments to update or create a ReviewSession.
     * @example
     * // Update or create a ReviewSession
     * const reviewSession = await prisma.reviewSession.upsert({
     *   create: {
     *     // ... data to create a ReviewSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReviewSession we want to update
     *   }
     * })
     */
    upsert<T extends ReviewSessionUpsertArgs>(args: SelectSubset<T, ReviewSessionUpsertArgs<ExtArgs>>): Prisma__ReviewSessionClient<$Result.GetResult<Prisma.$ReviewSessionPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ReviewSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewSessionCountArgs} args - Arguments to filter ReviewSessions to count.
     * @example
     * // Count the number of ReviewSessions
     * const count = await prisma.reviewSession.count({
     *   where: {
     *     // ... the filter for the ReviewSessions we want to count
     *   }
     * })
    **/
    count<T extends ReviewSessionCountArgs>(
      args?: Subset<T, ReviewSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReviewSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewSessionAggregateArgs>(args: Subset<T, ReviewSessionAggregateArgs>): Prisma.PrismaPromise<GetReviewSessionAggregateType<T>>

    /**
     * Group by ReviewSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewSessionGroupByArgs['orderBy'] }
        : { orderBy?: ReviewSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReviewSession model
   */
  readonly fields: ReviewSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReviewSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    items<T extends ReviewSession$itemsArgs<ExtArgs> = {}>(args?: Subset<T, ReviewSession$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewItemPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReviewSession model
   */ 
  interface ReviewSessionFieldRefs {
    readonly id: FieldRef<"ReviewSession", 'String'>
    readonly userId: FieldRef<"ReviewSession", 'String'>
    readonly dueDate: FieldRef<"ReviewSession", 'DateTime'>
    readonly completed: FieldRef<"ReviewSession", 'Boolean'>
    readonly isUrgent: FieldRef<"ReviewSession", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * ReviewSession findUnique
   */
  export type ReviewSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewSession
     */
    select?: ReviewSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewSession
     */
    omit?: ReviewSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewSessionInclude<ExtArgs> | null
    /**
     * Filter, which ReviewSession to fetch.
     */
    where: ReviewSessionWhereUniqueInput
  }

  /**
   * ReviewSession findUniqueOrThrow
   */
  export type ReviewSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewSession
     */
    select?: ReviewSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewSession
     */
    omit?: ReviewSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewSessionInclude<ExtArgs> | null
    /**
     * Filter, which ReviewSession to fetch.
     */
    where: ReviewSessionWhereUniqueInput
  }

  /**
   * ReviewSession findFirst
   */
  export type ReviewSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewSession
     */
    select?: ReviewSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewSession
     */
    omit?: ReviewSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewSessionInclude<ExtArgs> | null
    /**
     * Filter, which ReviewSession to fetch.
     */
    where?: ReviewSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewSessions to fetch.
     */
    orderBy?: ReviewSessionOrderByWithRelationInput | ReviewSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReviewSessions.
     */
    cursor?: ReviewSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReviewSessions.
     */
    distinct?: ReviewSessionScalarFieldEnum | ReviewSessionScalarFieldEnum[]
  }

  /**
   * ReviewSession findFirstOrThrow
   */
  export type ReviewSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewSession
     */
    select?: ReviewSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewSession
     */
    omit?: ReviewSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewSessionInclude<ExtArgs> | null
    /**
     * Filter, which ReviewSession to fetch.
     */
    where?: ReviewSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewSessions to fetch.
     */
    orderBy?: ReviewSessionOrderByWithRelationInput | ReviewSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReviewSessions.
     */
    cursor?: ReviewSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReviewSessions.
     */
    distinct?: ReviewSessionScalarFieldEnum | ReviewSessionScalarFieldEnum[]
  }

  /**
   * ReviewSession findMany
   */
  export type ReviewSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewSession
     */
    select?: ReviewSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewSession
     */
    omit?: ReviewSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewSessionInclude<ExtArgs> | null
    /**
     * Filter, which ReviewSessions to fetch.
     */
    where?: ReviewSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewSessions to fetch.
     */
    orderBy?: ReviewSessionOrderByWithRelationInput | ReviewSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReviewSessions.
     */
    cursor?: ReviewSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewSessions.
     */
    skip?: number
    distinct?: ReviewSessionScalarFieldEnum | ReviewSessionScalarFieldEnum[]
  }

  /**
   * ReviewSession create
   */
  export type ReviewSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewSession
     */
    select?: ReviewSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewSession
     */
    omit?: ReviewSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a ReviewSession.
     */
    data: XOR<ReviewSessionCreateInput, ReviewSessionUncheckedCreateInput>
  }

  /**
   * ReviewSession createMany
   */
  export type ReviewSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReviewSessions.
     */
    data: ReviewSessionCreateManyInput | ReviewSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReviewSession createManyAndReturn
   */
  export type ReviewSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewSession
     */
    select?: ReviewSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewSession
     */
    omit?: ReviewSessionOmit<ExtArgs> | null
    /**
     * The data used to create many ReviewSessions.
     */
    data: ReviewSessionCreateManyInput | ReviewSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReviewSession update
   */
  export type ReviewSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewSession
     */
    select?: ReviewSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewSession
     */
    omit?: ReviewSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a ReviewSession.
     */
    data: XOR<ReviewSessionUpdateInput, ReviewSessionUncheckedUpdateInput>
    /**
     * Choose, which ReviewSession to update.
     */
    where: ReviewSessionWhereUniqueInput
  }

  /**
   * ReviewSession updateMany
   */
  export type ReviewSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReviewSessions.
     */
    data: XOR<ReviewSessionUpdateManyMutationInput, ReviewSessionUncheckedUpdateManyInput>
    /**
     * Filter which ReviewSessions to update
     */
    where?: ReviewSessionWhereInput
    /**
     * Limit how many ReviewSessions to update.
     */
    limit?: number
  }

  /**
   * ReviewSession updateManyAndReturn
   */
  export type ReviewSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewSession
     */
    select?: ReviewSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewSession
     */
    omit?: ReviewSessionOmit<ExtArgs> | null
    /**
     * The data used to update ReviewSessions.
     */
    data: XOR<ReviewSessionUpdateManyMutationInput, ReviewSessionUncheckedUpdateManyInput>
    /**
     * Filter which ReviewSessions to update
     */
    where?: ReviewSessionWhereInput
    /**
     * Limit how many ReviewSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReviewSession upsert
   */
  export type ReviewSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewSession
     */
    select?: ReviewSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewSession
     */
    omit?: ReviewSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the ReviewSession to update in case it exists.
     */
    where: ReviewSessionWhereUniqueInput
    /**
     * In case the ReviewSession found by the `where` argument doesn't exist, create a new ReviewSession with this data.
     */
    create: XOR<ReviewSessionCreateInput, ReviewSessionUncheckedCreateInput>
    /**
     * In case the ReviewSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewSessionUpdateInput, ReviewSessionUncheckedUpdateInput>
  }

  /**
   * ReviewSession delete
   */
  export type ReviewSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewSession
     */
    select?: ReviewSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewSession
     */
    omit?: ReviewSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewSessionInclude<ExtArgs> | null
    /**
     * Filter which ReviewSession to delete.
     */
    where: ReviewSessionWhereUniqueInput
  }

  /**
   * ReviewSession deleteMany
   */
  export type ReviewSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReviewSessions to delete
     */
    where?: ReviewSessionWhereInput
    /**
     * Limit how many ReviewSessions to delete.
     */
    limit?: number
  }

  /**
   * ReviewSession.items
   */
  export type ReviewSession$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewItem
     */
    select?: ReviewItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewItem
     */
    omit?: ReviewItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewItemInclude<ExtArgs> | null
    where?: ReviewItemWhereInput
    orderBy?: ReviewItemOrderByWithRelationInput | ReviewItemOrderByWithRelationInput[]
    cursor?: ReviewItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewItemScalarFieldEnum | ReviewItemScalarFieldEnum[]
  }

  /**
   * ReviewSession without action
   */
  export type ReviewSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewSession
     */
    select?: ReviewSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewSession
     */
    omit?: ReviewSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewSessionInclude<ExtArgs> | null
  }


  /**
   * Model ReviewItem
   */

  export type AggregateReviewItem = {
    _count: ReviewItemCountAggregateOutputType | null
    _min: ReviewItemMinAggregateOutputType | null
    _max: ReviewItemMaxAggregateOutputType | null
  }

  export type ReviewItemMinAggregateOutputType = {
    id: string | null
    reviewSessionId: string | null
    contentItemId: string | null
    type: string | null
    question: string | null
    answer: string | null
    userAnswer: string | null
    isCorrect: boolean | null
    answeredAt: Date | null
  }

  export type ReviewItemMaxAggregateOutputType = {
    id: string | null
    reviewSessionId: string | null
    contentItemId: string | null
    type: string | null
    question: string | null
    answer: string | null
    userAnswer: string | null
    isCorrect: boolean | null
    answeredAt: Date | null
  }

  export type ReviewItemCountAggregateOutputType = {
    id: number
    reviewSessionId: number
    contentItemId: number
    type: number
    question: number
    answer: number
    userAnswer: number
    isCorrect: number
    answeredAt: number
    _all: number
  }


  export type ReviewItemMinAggregateInputType = {
    id?: true
    reviewSessionId?: true
    contentItemId?: true
    type?: true
    question?: true
    answer?: true
    userAnswer?: true
    isCorrect?: true
    answeredAt?: true
  }

  export type ReviewItemMaxAggregateInputType = {
    id?: true
    reviewSessionId?: true
    contentItemId?: true
    type?: true
    question?: true
    answer?: true
    userAnswer?: true
    isCorrect?: true
    answeredAt?: true
  }

  export type ReviewItemCountAggregateInputType = {
    id?: true
    reviewSessionId?: true
    contentItemId?: true
    type?: true
    question?: true
    answer?: true
    userAnswer?: true
    isCorrect?: true
    answeredAt?: true
    _all?: true
  }

  export type ReviewItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReviewItem to aggregate.
     */
    where?: ReviewItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewItems to fetch.
     */
    orderBy?: ReviewItemOrderByWithRelationInput | ReviewItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReviewItems
    **/
    _count?: true | ReviewItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewItemMaxAggregateInputType
  }

  export type GetReviewItemAggregateType<T extends ReviewItemAggregateArgs> = {
        [P in keyof T & keyof AggregateReviewItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReviewItem[P]>
      : GetScalarType<T[P], AggregateReviewItem[P]>
  }




  export type ReviewItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewItemWhereInput
    orderBy?: ReviewItemOrderByWithAggregationInput | ReviewItemOrderByWithAggregationInput[]
    by: ReviewItemScalarFieldEnum[] | ReviewItemScalarFieldEnum
    having?: ReviewItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewItemCountAggregateInputType | true
    _min?: ReviewItemMinAggregateInputType
    _max?: ReviewItemMaxAggregateInputType
  }

  export type ReviewItemGroupByOutputType = {
    id: string
    reviewSessionId: string
    contentItemId: string
    type: string
    question: string
    answer: string
    userAnswer: string | null
    isCorrect: boolean | null
    answeredAt: Date | null
    _count: ReviewItemCountAggregateOutputType | null
    _min: ReviewItemMinAggregateOutputType | null
    _max: ReviewItemMaxAggregateOutputType | null
  }

  type GetReviewItemGroupByPayload<T extends ReviewItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewItemGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewItemGroupByOutputType[P]>
        }
      >
    >


  export type ReviewItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reviewSessionId?: boolean
    contentItemId?: boolean
    type?: boolean
    question?: boolean
    answer?: boolean
    userAnswer?: boolean
    isCorrect?: boolean
    answeredAt?: boolean
    reviewSession?: boolean | ReviewSessionDefaultArgs<ExtArgs>
    contentItem?: boolean | ContentItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewItem"]>

  export type ReviewItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reviewSessionId?: boolean
    contentItemId?: boolean
    type?: boolean
    question?: boolean
    answer?: boolean
    userAnswer?: boolean
    isCorrect?: boolean
    answeredAt?: boolean
    reviewSession?: boolean | ReviewSessionDefaultArgs<ExtArgs>
    contentItem?: boolean | ContentItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewItem"]>

  export type ReviewItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reviewSessionId?: boolean
    contentItemId?: boolean
    type?: boolean
    question?: boolean
    answer?: boolean
    userAnswer?: boolean
    isCorrect?: boolean
    answeredAt?: boolean
    reviewSession?: boolean | ReviewSessionDefaultArgs<ExtArgs>
    contentItem?: boolean | ContentItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewItem"]>

  export type ReviewItemSelectScalar = {
    id?: boolean
    reviewSessionId?: boolean
    contentItemId?: boolean
    type?: boolean
    question?: boolean
    answer?: boolean
    userAnswer?: boolean
    isCorrect?: boolean
    answeredAt?: boolean
  }

  export type ReviewItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "reviewSessionId" | "contentItemId" | "type" | "question" | "answer" | "userAnswer" | "isCorrect" | "answeredAt", ExtArgs["result"]["reviewItem"]>
  export type ReviewItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reviewSession?: boolean | ReviewSessionDefaultArgs<ExtArgs>
    contentItem?: boolean | ContentItemDefaultArgs<ExtArgs>
  }
  export type ReviewItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reviewSession?: boolean | ReviewSessionDefaultArgs<ExtArgs>
    contentItem?: boolean | ContentItemDefaultArgs<ExtArgs>
  }
  export type ReviewItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reviewSession?: boolean | ReviewSessionDefaultArgs<ExtArgs>
    contentItem?: boolean | ContentItemDefaultArgs<ExtArgs>
  }

  export type $ReviewItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReviewItem"
    objects: {
      reviewSession: Prisma.$ReviewSessionPayload<ExtArgs>
      contentItem: Prisma.$ContentItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      reviewSessionId: string
      contentItemId: string
      type: string
      question: string
      answer: string
      userAnswer: string | null
      isCorrect: boolean | null
      answeredAt: Date | null
    }, ExtArgs["result"]["reviewItem"]>
    composites: {}
  }

  type ReviewItemGetPayload<S extends boolean | null | undefined | ReviewItemDefaultArgs> = $Result.GetResult<Prisma.$ReviewItemPayload, S>

  type ReviewItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReviewItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewItemCountAggregateInputType | true
    }

  export interface ReviewItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReviewItem'], meta: { name: 'ReviewItem' } }
    /**
     * Find zero or one ReviewItem that matches the filter.
     * @param {ReviewItemFindUniqueArgs} args - Arguments to find a ReviewItem
     * @example
     * // Get one ReviewItem
     * const reviewItem = await prisma.reviewItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewItemFindUniqueArgs>(args: SelectSubset<T, ReviewItemFindUniqueArgs<ExtArgs>>): Prisma__ReviewItemClient<$Result.GetResult<Prisma.$ReviewItemPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ReviewItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReviewItemFindUniqueOrThrowArgs} args - Arguments to find a ReviewItem
     * @example
     * // Get one ReviewItem
     * const reviewItem = await prisma.reviewItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewItemClient<$Result.GetResult<Prisma.$ReviewItemPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ReviewItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewItemFindFirstArgs} args - Arguments to find a ReviewItem
     * @example
     * // Get one ReviewItem
     * const reviewItem = await prisma.reviewItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewItemFindFirstArgs>(args?: SelectSubset<T, ReviewItemFindFirstArgs<ExtArgs>>): Prisma__ReviewItemClient<$Result.GetResult<Prisma.$ReviewItemPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ReviewItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewItemFindFirstOrThrowArgs} args - Arguments to find a ReviewItem
     * @example
     * // Get one ReviewItem
     * const reviewItem = await prisma.reviewItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewItemClient<$Result.GetResult<Prisma.$ReviewItemPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ReviewItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReviewItems
     * const reviewItems = await prisma.reviewItem.findMany()
     * 
     * // Get first 10 ReviewItems
     * const reviewItems = await prisma.reviewItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewItemWithIdOnly = await prisma.reviewItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewItemFindManyArgs>(args?: SelectSubset<T, ReviewItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewItemPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ReviewItem.
     * @param {ReviewItemCreateArgs} args - Arguments to create a ReviewItem.
     * @example
     * // Create one ReviewItem
     * const ReviewItem = await prisma.reviewItem.create({
     *   data: {
     *     // ... data to create a ReviewItem
     *   }
     * })
     * 
     */
    create<T extends ReviewItemCreateArgs>(args: SelectSubset<T, ReviewItemCreateArgs<ExtArgs>>): Prisma__ReviewItemClient<$Result.GetResult<Prisma.$ReviewItemPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ReviewItems.
     * @param {ReviewItemCreateManyArgs} args - Arguments to create many ReviewItems.
     * @example
     * // Create many ReviewItems
     * const reviewItem = await prisma.reviewItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewItemCreateManyArgs>(args?: SelectSubset<T, ReviewItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReviewItems and returns the data saved in the database.
     * @param {ReviewItemCreateManyAndReturnArgs} args - Arguments to create many ReviewItems.
     * @example
     * // Create many ReviewItems
     * const reviewItem = await prisma.reviewItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReviewItems and only return the `id`
     * const reviewItemWithIdOnly = await prisma.reviewItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewItemCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewItemPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a ReviewItem.
     * @param {ReviewItemDeleteArgs} args - Arguments to delete one ReviewItem.
     * @example
     * // Delete one ReviewItem
     * const ReviewItem = await prisma.reviewItem.delete({
     *   where: {
     *     // ... filter to delete one ReviewItem
     *   }
     * })
     * 
     */
    delete<T extends ReviewItemDeleteArgs>(args: SelectSubset<T, ReviewItemDeleteArgs<ExtArgs>>): Prisma__ReviewItemClient<$Result.GetResult<Prisma.$ReviewItemPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ReviewItem.
     * @param {ReviewItemUpdateArgs} args - Arguments to update one ReviewItem.
     * @example
     * // Update one ReviewItem
     * const reviewItem = await prisma.reviewItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewItemUpdateArgs>(args: SelectSubset<T, ReviewItemUpdateArgs<ExtArgs>>): Prisma__ReviewItemClient<$Result.GetResult<Prisma.$ReviewItemPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ReviewItems.
     * @param {ReviewItemDeleteManyArgs} args - Arguments to filter ReviewItems to delete.
     * @example
     * // Delete a few ReviewItems
     * const { count } = await prisma.reviewItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewItemDeleteManyArgs>(args?: SelectSubset<T, ReviewItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReviewItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReviewItems
     * const reviewItem = await prisma.reviewItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewItemUpdateManyArgs>(args: SelectSubset<T, ReviewItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReviewItems and returns the data updated in the database.
     * @param {ReviewItemUpdateManyAndReturnArgs} args - Arguments to update many ReviewItems.
     * @example
     * // Update many ReviewItems
     * const reviewItem = await prisma.reviewItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReviewItems and only return the `id`
     * const reviewItemWithIdOnly = await prisma.reviewItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReviewItemUpdateManyAndReturnArgs>(args: SelectSubset<T, ReviewItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewItemPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one ReviewItem.
     * @param {ReviewItemUpsertArgs} args - Arguments to update or create a ReviewItem.
     * @example
     * // Update or create a ReviewItem
     * const reviewItem = await prisma.reviewItem.upsert({
     *   create: {
     *     // ... data to create a ReviewItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReviewItem we want to update
     *   }
     * })
     */
    upsert<T extends ReviewItemUpsertArgs>(args: SelectSubset<T, ReviewItemUpsertArgs<ExtArgs>>): Prisma__ReviewItemClient<$Result.GetResult<Prisma.$ReviewItemPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ReviewItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewItemCountArgs} args - Arguments to filter ReviewItems to count.
     * @example
     * // Count the number of ReviewItems
     * const count = await prisma.reviewItem.count({
     *   where: {
     *     // ... the filter for the ReviewItems we want to count
     *   }
     * })
    **/
    count<T extends ReviewItemCountArgs>(
      args?: Subset<T, ReviewItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReviewItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewItemAggregateArgs>(args: Subset<T, ReviewItemAggregateArgs>): Prisma.PrismaPromise<GetReviewItemAggregateType<T>>

    /**
     * Group by ReviewItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewItemGroupByArgs['orderBy'] }
        : { orderBy?: ReviewItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReviewItem model
   */
  readonly fields: ReviewItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReviewItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reviewSession<T extends ReviewSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReviewSessionDefaultArgs<ExtArgs>>): Prisma__ReviewSessionClient<$Result.GetResult<Prisma.$ReviewSessionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    contentItem<T extends ContentItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContentItemDefaultArgs<ExtArgs>>): Prisma__ContentItemClient<$Result.GetResult<Prisma.$ContentItemPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReviewItem model
   */ 
  interface ReviewItemFieldRefs {
    readonly id: FieldRef<"ReviewItem", 'String'>
    readonly reviewSessionId: FieldRef<"ReviewItem", 'String'>
    readonly contentItemId: FieldRef<"ReviewItem", 'String'>
    readonly type: FieldRef<"ReviewItem", 'String'>
    readonly question: FieldRef<"ReviewItem", 'String'>
    readonly answer: FieldRef<"ReviewItem", 'String'>
    readonly userAnswer: FieldRef<"ReviewItem", 'String'>
    readonly isCorrect: FieldRef<"ReviewItem", 'Boolean'>
    readonly answeredAt: FieldRef<"ReviewItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReviewItem findUnique
   */
  export type ReviewItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewItem
     */
    select?: ReviewItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewItem
     */
    omit?: ReviewItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewItemInclude<ExtArgs> | null
    /**
     * Filter, which ReviewItem to fetch.
     */
    where: ReviewItemWhereUniqueInput
  }

  /**
   * ReviewItem findUniqueOrThrow
   */
  export type ReviewItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewItem
     */
    select?: ReviewItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewItem
     */
    omit?: ReviewItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewItemInclude<ExtArgs> | null
    /**
     * Filter, which ReviewItem to fetch.
     */
    where: ReviewItemWhereUniqueInput
  }

  /**
   * ReviewItem findFirst
   */
  export type ReviewItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewItem
     */
    select?: ReviewItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewItem
     */
    omit?: ReviewItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewItemInclude<ExtArgs> | null
    /**
     * Filter, which ReviewItem to fetch.
     */
    where?: ReviewItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewItems to fetch.
     */
    orderBy?: ReviewItemOrderByWithRelationInput | ReviewItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReviewItems.
     */
    cursor?: ReviewItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReviewItems.
     */
    distinct?: ReviewItemScalarFieldEnum | ReviewItemScalarFieldEnum[]
  }

  /**
   * ReviewItem findFirstOrThrow
   */
  export type ReviewItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewItem
     */
    select?: ReviewItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewItem
     */
    omit?: ReviewItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewItemInclude<ExtArgs> | null
    /**
     * Filter, which ReviewItem to fetch.
     */
    where?: ReviewItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewItems to fetch.
     */
    orderBy?: ReviewItemOrderByWithRelationInput | ReviewItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReviewItems.
     */
    cursor?: ReviewItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReviewItems.
     */
    distinct?: ReviewItemScalarFieldEnum | ReviewItemScalarFieldEnum[]
  }

  /**
   * ReviewItem findMany
   */
  export type ReviewItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewItem
     */
    select?: ReviewItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewItem
     */
    omit?: ReviewItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewItemInclude<ExtArgs> | null
    /**
     * Filter, which ReviewItems to fetch.
     */
    where?: ReviewItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewItems to fetch.
     */
    orderBy?: ReviewItemOrderByWithRelationInput | ReviewItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReviewItems.
     */
    cursor?: ReviewItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewItems.
     */
    skip?: number
    distinct?: ReviewItemScalarFieldEnum | ReviewItemScalarFieldEnum[]
  }

  /**
   * ReviewItem create
   */
  export type ReviewItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewItem
     */
    select?: ReviewItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewItem
     */
    omit?: ReviewItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewItemInclude<ExtArgs> | null
    /**
     * The data needed to create a ReviewItem.
     */
    data: XOR<ReviewItemCreateInput, ReviewItemUncheckedCreateInput>
  }

  /**
   * ReviewItem createMany
   */
  export type ReviewItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReviewItems.
     */
    data: ReviewItemCreateManyInput | ReviewItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReviewItem createManyAndReturn
   */
  export type ReviewItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewItem
     */
    select?: ReviewItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewItem
     */
    omit?: ReviewItemOmit<ExtArgs> | null
    /**
     * The data used to create many ReviewItems.
     */
    data: ReviewItemCreateManyInput | ReviewItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReviewItem update
   */
  export type ReviewItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewItem
     */
    select?: ReviewItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewItem
     */
    omit?: ReviewItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewItemInclude<ExtArgs> | null
    /**
     * The data needed to update a ReviewItem.
     */
    data: XOR<ReviewItemUpdateInput, ReviewItemUncheckedUpdateInput>
    /**
     * Choose, which ReviewItem to update.
     */
    where: ReviewItemWhereUniqueInput
  }

  /**
   * ReviewItem updateMany
   */
  export type ReviewItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReviewItems.
     */
    data: XOR<ReviewItemUpdateManyMutationInput, ReviewItemUncheckedUpdateManyInput>
    /**
     * Filter which ReviewItems to update
     */
    where?: ReviewItemWhereInput
    /**
     * Limit how many ReviewItems to update.
     */
    limit?: number
  }

  /**
   * ReviewItem updateManyAndReturn
   */
  export type ReviewItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewItem
     */
    select?: ReviewItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewItem
     */
    omit?: ReviewItemOmit<ExtArgs> | null
    /**
     * The data used to update ReviewItems.
     */
    data: XOR<ReviewItemUpdateManyMutationInput, ReviewItemUncheckedUpdateManyInput>
    /**
     * Filter which ReviewItems to update
     */
    where?: ReviewItemWhereInput
    /**
     * Limit how many ReviewItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReviewItem upsert
   */
  export type ReviewItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewItem
     */
    select?: ReviewItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewItem
     */
    omit?: ReviewItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewItemInclude<ExtArgs> | null
    /**
     * The filter to search for the ReviewItem to update in case it exists.
     */
    where: ReviewItemWhereUniqueInput
    /**
     * In case the ReviewItem found by the `where` argument doesn't exist, create a new ReviewItem with this data.
     */
    create: XOR<ReviewItemCreateInput, ReviewItemUncheckedCreateInput>
    /**
     * In case the ReviewItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewItemUpdateInput, ReviewItemUncheckedUpdateInput>
  }

  /**
   * ReviewItem delete
   */
  export type ReviewItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewItem
     */
    select?: ReviewItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewItem
     */
    omit?: ReviewItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewItemInclude<ExtArgs> | null
    /**
     * Filter which ReviewItem to delete.
     */
    where: ReviewItemWhereUniqueInput
  }

  /**
   * ReviewItem deleteMany
   */
  export type ReviewItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReviewItems to delete
     */
    where?: ReviewItemWhereInput
    /**
     * Limit how many ReviewItems to delete.
     */
    limit?: number
  }

  /**
   * ReviewItem without action
   */
  export type ReviewItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewItem
     */
    select?: ReviewItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewItem
     */
    omit?: ReviewItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewItemInclude<ExtArgs> | null
  }


  /**
   * Model Workspace
   */

  export type AggregateWorkspace = {
    _count: WorkspaceCountAggregateOutputType | null
    _min: WorkspaceMinAggregateOutputType | null
    _max: WorkspaceMaxAggregateOutputType | null
  }

  export type WorkspaceMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    ownerId: string | null
  }

  export type WorkspaceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    ownerId: string | null
  }

  export type WorkspaceCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    ownerId: number
    _all: number
  }


  export type WorkspaceMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    ownerId?: true
  }

  export type WorkspaceMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    ownerId?: true
  }

  export type WorkspaceCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    ownerId?: true
    _all?: true
  }

  export type WorkspaceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workspace to aggregate.
     */
    where?: WorkspaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workspaces to fetch.
     */
    orderBy?: WorkspaceOrderByWithRelationInput | WorkspaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkspaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workspaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workspaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Workspaces
    **/
    _count?: true | WorkspaceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkspaceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkspaceMaxAggregateInputType
  }

  export type GetWorkspaceAggregateType<T extends WorkspaceAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkspace]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkspace[P]>
      : GetScalarType<T[P], AggregateWorkspace[P]>
  }




  export type WorkspaceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceWhereInput
    orderBy?: WorkspaceOrderByWithAggregationInput | WorkspaceOrderByWithAggregationInput[]
    by: WorkspaceScalarFieldEnum[] | WorkspaceScalarFieldEnum
    having?: WorkspaceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkspaceCountAggregateInputType | true
    _min?: WorkspaceMinAggregateInputType
    _max?: WorkspaceMaxAggregateInputType
  }

  export type WorkspaceGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    ownerId: string
    _count: WorkspaceCountAggregateOutputType | null
    _min: WorkspaceMinAggregateOutputType | null
    _max: WorkspaceMaxAggregateOutputType | null
  }

  type GetWorkspaceGroupByPayload<T extends WorkspaceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkspaceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkspaceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkspaceGroupByOutputType[P]>
            : GetScalarType<T[P], WorkspaceGroupByOutputType[P]>
        }
      >
    >


  export type WorkspaceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ownerId?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    members?: boolean | Workspace$membersArgs<ExtArgs>
    whiteboards?: boolean | Workspace$whiteboardsArgs<ExtArgs>
    chats?: boolean | Workspace$chatsArgs<ExtArgs>
    breakoutRooms?: boolean | Workspace$breakoutRoomsArgs<ExtArgs>
    livePolls?: boolean | Workspace$livePollsArgs<ExtArgs>
    sessionSummaries?: boolean | Workspace$sessionSummariesArgs<ExtArgs>
    _count?: boolean | WorkspaceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspace"]>

  export type WorkspaceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ownerId?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspace"]>

  export type WorkspaceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ownerId?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspace"]>

  export type WorkspaceSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ownerId?: boolean
  }

  export type WorkspaceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "updatedAt" | "ownerId", ExtArgs["result"]["workspace"]>
  export type WorkspaceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    members?: boolean | Workspace$membersArgs<ExtArgs>
    whiteboards?: boolean | Workspace$whiteboardsArgs<ExtArgs>
    chats?: boolean | Workspace$chatsArgs<ExtArgs>
    breakoutRooms?: boolean | Workspace$breakoutRoomsArgs<ExtArgs>
    livePolls?: boolean | Workspace$livePollsArgs<ExtArgs>
    sessionSummaries?: boolean | Workspace$sessionSummariesArgs<ExtArgs>
    _count?: boolean | WorkspaceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorkspaceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WorkspaceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WorkspacePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Workspace"
    objects: {
      owner: Prisma.$UserPayload<ExtArgs>
      members: Prisma.$WorkspaceMemberPayload<ExtArgs>[]
      whiteboards: Prisma.$WhiteboardPayload<ExtArgs>[]
      chats: Prisma.$ChatPayload<ExtArgs>[]
      breakoutRooms: Prisma.$BreakoutRoomPayload<ExtArgs>[]
      livePolls: Prisma.$LivePollPayload<ExtArgs>[]
      sessionSummaries: Prisma.$SessionSummaryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date
      ownerId: string
    }, ExtArgs["result"]["workspace"]>
    composites: {}
  }

  type WorkspaceGetPayload<S extends boolean | null | undefined | WorkspaceDefaultArgs> = $Result.GetResult<Prisma.$WorkspacePayload, S>

  type WorkspaceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkspaceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkspaceCountAggregateInputType | true
    }

  export interface WorkspaceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Workspace'], meta: { name: 'Workspace' } }
    /**
     * Find zero or one Workspace that matches the filter.
     * @param {WorkspaceFindUniqueArgs} args - Arguments to find a Workspace
     * @example
     * // Get one Workspace
     * const workspace = await prisma.workspace.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkspaceFindUniqueArgs>(args: SelectSubset<T, WorkspaceFindUniqueArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Workspace that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkspaceFindUniqueOrThrowArgs} args - Arguments to find a Workspace
     * @example
     * // Get one Workspace
     * const workspace = await prisma.workspace.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkspaceFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkspaceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Workspace that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceFindFirstArgs} args - Arguments to find a Workspace
     * @example
     * // Get one Workspace
     * const workspace = await prisma.workspace.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkspaceFindFirstArgs>(args?: SelectSubset<T, WorkspaceFindFirstArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Workspace that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceFindFirstOrThrowArgs} args - Arguments to find a Workspace
     * @example
     * // Get one Workspace
     * const workspace = await prisma.workspace.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkspaceFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkspaceFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Workspaces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Workspaces
     * const workspaces = await prisma.workspace.findMany()
     * 
     * // Get first 10 Workspaces
     * const workspaces = await prisma.workspace.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workspaceWithIdOnly = await prisma.workspace.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkspaceFindManyArgs>(args?: SelectSubset<T, WorkspaceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Workspace.
     * @param {WorkspaceCreateArgs} args - Arguments to create a Workspace.
     * @example
     * // Create one Workspace
     * const Workspace = await prisma.workspace.create({
     *   data: {
     *     // ... data to create a Workspace
     *   }
     * })
     * 
     */
    create<T extends WorkspaceCreateArgs>(args: SelectSubset<T, WorkspaceCreateArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Workspaces.
     * @param {WorkspaceCreateManyArgs} args - Arguments to create many Workspaces.
     * @example
     * // Create many Workspaces
     * const workspace = await prisma.workspace.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkspaceCreateManyArgs>(args?: SelectSubset<T, WorkspaceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Workspaces and returns the data saved in the database.
     * @param {WorkspaceCreateManyAndReturnArgs} args - Arguments to create many Workspaces.
     * @example
     * // Create many Workspaces
     * const workspace = await prisma.workspace.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Workspaces and only return the `id`
     * const workspaceWithIdOnly = await prisma.workspace.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkspaceCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkspaceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Workspace.
     * @param {WorkspaceDeleteArgs} args - Arguments to delete one Workspace.
     * @example
     * // Delete one Workspace
     * const Workspace = await prisma.workspace.delete({
     *   where: {
     *     // ... filter to delete one Workspace
     *   }
     * })
     * 
     */
    delete<T extends WorkspaceDeleteArgs>(args: SelectSubset<T, WorkspaceDeleteArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Workspace.
     * @param {WorkspaceUpdateArgs} args - Arguments to update one Workspace.
     * @example
     * // Update one Workspace
     * const workspace = await prisma.workspace.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkspaceUpdateArgs>(args: SelectSubset<T, WorkspaceUpdateArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Workspaces.
     * @param {WorkspaceDeleteManyArgs} args - Arguments to filter Workspaces to delete.
     * @example
     * // Delete a few Workspaces
     * const { count } = await prisma.workspace.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkspaceDeleteManyArgs>(args?: SelectSubset<T, WorkspaceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workspaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Workspaces
     * const workspace = await prisma.workspace.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkspaceUpdateManyArgs>(args: SelectSubset<T, WorkspaceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workspaces and returns the data updated in the database.
     * @param {WorkspaceUpdateManyAndReturnArgs} args - Arguments to update many Workspaces.
     * @example
     * // Update many Workspaces
     * const workspace = await prisma.workspace.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Workspaces and only return the `id`
     * const workspaceWithIdOnly = await prisma.workspace.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkspaceUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkspaceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Workspace.
     * @param {WorkspaceUpsertArgs} args - Arguments to update or create a Workspace.
     * @example
     * // Update or create a Workspace
     * const workspace = await prisma.workspace.upsert({
     *   create: {
     *     // ... data to create a Workspace
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Workspace we want to update
     *   }
     * })
     */
    upsert<T extends WorkspaceUpsertArgs>(args: SelectSubset<T, WorkspaceUpsertArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Workspaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceCountArgs} args - Arguments to filter Workspaces to count.
     * @example
     * // Count the number of Workspaces
     * const count = await prisma.workspace.count({
     *   where: {
     *     // ... the filter for the Workspaces we want to count
     *   }
     * })
    **/
    count<T extends WorkspaceCountArgs>(
      args?: Subset<T, WorkspaceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkspaceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Workspace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkspaceAggregateArgs>(args: Subset<T, WorkspaceAggregateArgs>): Prisma.PrismaPromise<GetWorkspaceAggregateType<T>>

    /**
     * Group by Workspace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkspaceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkspaceGroupByArgs['orderBy'] }
        : { orderBy?: WorkspaceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkspaceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkspaceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Workspace model
   */
  readonly fields: WorkspaceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Workspace.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkspaceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    members<T extends Workspace$membersArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceMemberPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    whiteboards<T extends Workspace$whiteboardsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$whiteboardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhiteboardPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    chats<T extends Workspace$chatsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$chatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    breakoutRooms<T extends Workspace$breakoutRoomsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$breakoutRoomsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BreakoutRoomPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    livePolls<T extends Workspace$livePollsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$livePollsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LivePollPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    sessionSummaries<T extends Workspace$sessionSummariesArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$sessionSummariesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionSummaryPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Workspace model
   */ 
  interface WorkspaceFieldRefs {
    readonly id: FieldRef<"Workspace", 'String'>
    readonly name: FieldRef<"Workspace", 'String'>
    readonly description: FieldRef<"Workspace", 'String'>
    readonly createdAt: FieldRef<"Workspace", 'DateTime'>
    readonly updatedAt: FieldRef<"Workspace", 'DateTime'>
    readonly ownerId: FieldRef<"Workspace", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Workspace findUnique
   */
  export type WorkspaceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which Workspace to fetch.
     */
    where: WorkspaceWhereUniqueInput
  }

  /**
   * Workspace findUniqueOrThrow
   */
  export type WorkspaceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which Workspace to fetch.
     */
    where: WorkspaceWhereUniqueInput
  }

  /**
   * Workspace findFirst
   */
  export type WorkspaceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which Workspace to fetch.
     */
    where?: WorkspaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workspaces to fetch.
     */
    orderBy?: WorkspaceOrderByWithRelationInput | WorkspaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workspaces.
     */
    cursor?: WorkspaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workspaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workspaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workspaces.
     */
    distinct?: WorkspaceScalarFieldEnum | WorkspaceScalarFieldEnum[]
  }

  /**
   * Workspace findFirstOrThrow
   */
  export type WorkspaceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which Workspace to fetch.
     */
    where?: WorkspaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workspaces to fetch.
     */
    orderBy?: WorkspaceOrderByWithRelationInput | WorkspaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workspaces.
     */
    cursor?: WorkspaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workspaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workspaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workspaces.
     */
    distinct?: WorkspaceScalarFieldEnum | WorkspaceScalarFieldEnum[]
  }

  /**
   * Workspace findMany
   */
  export type WorkspaceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which Workspaces to fetch.
     */
    where?: WorkspaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workspaces to fetch.
     */
    orderBy?: WorkspaceOrderByWithRelationInput | WorkspaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Workspaces.
     */
    cursor?: WorkspaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workspaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workspaces.
     */
    skip?: number
    distinct?: WorkspaceScalarFieldEnum | WorkspaceScalarFieldEnum[]
  }

  /**
   * Workspace create
   */
  export type WorkspaceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * The data needed to create a Workspace.
     */
    data: XOR<WorkspaceCreateInput, WorkspaceUncheckedCreateInput>
  }

  /**
   * Workspace createMany
   */
  export type WorkspaceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Workspaces.
     */
    data: WorkspaceCreateManyInput | WorkspaceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Workspace createManyAndReturn
   */
  export type WorkspaceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * The data used to create many Workspaces.
     */
    data: WorkspaceCreateManyInput | WorkspaceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Workspace update
   */
  export type WorkspaceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * The data needed to update a Workspace.
     */
    data: XOR<WorkspaceUpdateInput, WorkspaceUncheckedUpdateInput>
    /**
     * Choose, which Workspace to update.
     */
    where: WorkspaceWhereUniqueInput
  }

  /**
   * Workspace updateMany
   */
  export type WorkspaceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Workspaces.
     */
    data: XOR<WorkspaceUpdateManyMutationInput, WorkspaceUncheckedUpdateManyInput>
    /**
     * Filter which Workspaces to update
     */
    where?: WorkspaceWhereInput
    /**
     * Limit how many Workspaces to update.
     */
    limit?: number
  }

  /**
   * Workspace updateManyAndReturn
   */
  export type WorkspaceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * The data used to update Workspaces.
     */
    data: XOR<WorkspaceUpdateManyMutationInput, WorkspaceUncheckedUpdateManyInput>
    /**
     * Filter which Workspaces to update
     */
    where?: WorkspaceWhereInput
    /**
     * Limit how many Workspaces to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Workspace upsert
   */
  export type WorkspaceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * The filter to search for the Workspace to update in case it exists.
     */
    where: WorkspaceWhereUniqueInput
    /**
     * In case the Workspace found by the `where` argument doesn't exist, create a new Workspace with this data.
     */
    create: XOR<WorkspaceCreateInput, WorkspaceUncheckedCreateInput>
    /**
     * In case the Workspace was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkspaceUpdateInput, WorkspaceUncheckedUpdateInput>
  }

  /**
   * Workspace delete
   */
  export type WorkspaceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter which Workspace to delete.
     */
    where: WorkspaceWhereUniqueInput
  }

  /**
   * Workspace deleteMany
   */
  export type WorkspaceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workspaces to delete
     */
    where?: WorkspaceWhereInput
    /**
     * Limit how many Workspaces to delete.
     */
    limit?: number
  }

  /**
   * Workspace.members
   */
  export type Workspace$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceMember
     */
    select?: WorkspaceMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceMember
     */
    omit?: WorkspaceMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceMemberInclude<ExtArgs> | null
    where?: WorkspaceMemberWhereInput
    orderBy?: WorkspaceMemberOrderByWithRelationInput | WorkspaceMemberOrderByWithRelationInput[]
    cursor?: WorkspaceMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkspaceMemberScalarFieldEnum | WorkspaceMemberScalarFieldEnum[]
  }

  /**
   * Workspace.whiteboards
   */
  export type Workspace$whiteboardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whiteboard
     */
    select?: WhiteboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Whiteboard
     */
    omit?: WhiteboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhiteboardInclude<ExtArgs> | null
    where?: WhiteboardWhereInput
    orderBy?: WhiteboardOrderByWithRelationInput | WhiteboardOrderByWithRelationInput[]
    cursor?: WhiteboardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WhiteboardScalarFieldEnum | WhiteboardScalarFieldEnum[]
  }

  /**
   * Workspace.chats
   */
  export type Workspace$chatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    where?: ChatWhereInput
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    cursor?: ChatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Workspace.breakoutRooms
   */
  export type Workspace$breakoutRoomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreakoutRoom
     */
    select?: BreakoutRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BreakoutRoom
     */
    omit?: BreakoutRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreakoutRoomInclude<ExtArgs> | null
    where?: BreakoutRoomWhereInput
    orderBy?: BreakoutRoomOrderByWithRelationInput | BreakoutRoomOrderByWithRelationInput[]
    cursor?: BreakoutRoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BreakoutRoomScalarFieldEnum | BreakoutRoomScalarFieldEnum[]
  }

  /**
   * Workspace.livePolls
   */
  export type Workspace$livePollsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LivePoll
     */
    select?: LivePollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LivePoll
     */
    omit?: LivePollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivePollInclude<ExtArgs> | null
    where?: LivePollWhereInput
    orderBy?: LivePollOrderByWithRelationInput | LivePollOrderByWithRelationInput[]
    cursor?: LivePollWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LivePollScalarFieldEnum | LivePollScalarFieldEnum[]
  }

  /**
   * Workspace.sessionSummaries
   */
  export type Workspace$sessionSummariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionSummary
     */
    select?: SessionSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionSummary
     */
    omit?: SessionSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionSummaryInclude<ExtArgs> | null
    where?: SessionSummaryWhereInput
    orderBy?: SessionSummaryOrderByWithRelationInput | SessionSummaryOrderByWithRelationInput[]
    cursor?: SessionSummaryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionSummaryScalarFieldEnum | SessionSummaryScalarFieldEnum[]
  }

  /**
   * Workspace without action
   */
  export type WorkspaceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
  }


  /**
   * Model WorkspaceMember
   */

  export type AggregateWorkspaceMember = {
    _count: WorkspaceMemberCountAggregateOutputType | null
    _min: WorkspaceMemberMinAggregateOutputType | null
    _max: WorkspaceMemberMaxAggregateOutputType | null
  }

  export type WorkspaceMemberMinAggregateOutputType = {
    id: string | null
    userId: string | null
    workspaceId: string | null
    role: string | null
    joinedAt: Date | null
  }

  export type WorkspaceMemberMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    workspaceId: string | null
    role: string | null
    joinedAt: Date | null
  }

  export type WorkspaceMemberCountAggregateOutputType = {
    id: number
    userId: number
    workspaceId: number
    role: number
    joinedAt: number
    _all: number
  }


  export type WorkspaceMemberMinAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    role?: true
    joinedAt?: true
  }

  export type WorkspaceMemberMaxAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    role?: true
    joinedAt?: true
  }

  export type WorkspaceMemberCountAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    role?: true
    joinedAt?: true
    _all?: true
  }

  export type WorkspaceMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkspaceMember to aggregate.
     */
    where?: WorkspaceMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceMembers to fetch.
     */
    orderBy?: WorkspaceMemberOrderByWithRelationInput | WorkspaceMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkspaceMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkspaceMembers
    **/
    _count?: true | WorkspaceMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkspaceMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkspaceMemberMaxAggregateInputType
  }

  export type GetWorkspaceMemberAggregateType<T extends WorkspaceMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkspaceMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkspaceMember[P]>
      : GetScalarType<T[P], AggregateWorkspaceMember[P]>
  }




  export type WorkspaceMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceMemberWhereInput
    orderBy?: WorkspaceMemberOrderByWithAggregationInput | WorkspaceMemberOrderByWithAggregationInput[]
    by: WorkspaceMemberScalarFieldEnum[] | WorkspaceMemberScalarFieldEnum
    having?: WorkspaceMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkspaceMemberCountAggregateInputType | true
    _min?: WorkspaceMemberMinAggregateInputType
    _max?: WorkspaceMemberMaxAggregateInputType
  }

  export type WorkspaceMemberGroupByOutputType = {
    id: string
    userId: string
    workspaceId: string
    role: string
    joinedAt: Date
    _count: WorkspaceMemberCountAggregateOutputType | null
    _min: WorkspaceMemberMinAggregateOutputType | null
    _max: WorkspaceMemberMaxAggregateOutputType | null
  }

  type GetWorkspaceMemberGroupByPayload<T extends WorkspaceMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkspaceMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkspaceMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkspaceMemberGroupByOutputType[P]>
            : GetScalarType<T[P], WorkspaceMemberGroupByOutputType[P]>
        }
      >
    >


  export type WorkspaceMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    role?: boolean
    joinedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    breakoutRooms?: boolean | WorkspaceMember$breakoutRoomsArgs<ExtArgs>
    _count?: boolean | WorkspaceMemberCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspaceMember"]>

  export type WorkspaceMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    role?: boolean
    joinedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspaceMember"]>

  export type WorkspaceMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    role?: boolean
    joinedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspaceMember"]>

  export type WorkspaceMemberSelectScalar = {
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    role?: boolean
    joinedAt?: boolean
  }

  export type WorkspaceMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "workspaceId" | "role" | "joinedAt", ExtArgs["result"]["workspaceMember"]>
  export type WorkspaceMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    breakoutRooms?: boolean | WorkspaceMember$breakoutRoomsArgs<ExtArgs>
    _count?: boolean | WorkspaceMemberCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorkspaceMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type WorkspaceMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $WorkspaceMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkspaceMember"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      breakoutRooms: Prisma.$BreakoutRoomPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      workspaceId: string
      role: string
      joinedAt: Date
    }, ExtArgs["result"]["workspaceMember"]>
    composites: {}
  }

  type WorkspaceMemberGetPayload<S extends boolean | null | undefined | WorkspaceMemberDefaultArgs> = $Result.GetResult<Prisma.$WorkspaceMemberPayload, S>

  type WorkspaceMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkspaceMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkspaceMemberCountAggregateInputType | true
    }

  export interface WorkspaceMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkspaceMember'], meta: { name: 'WorkspaceMember' } }
    /**
     * Find zero or one WorkspaceMember that matches the filter.
     * @param {WorkspaceMemberFindUniqueArgs} args - Arguments to find a WorkspaceMember
     * @example
     * // Get one WorkspaceMember
     * const workspaceMember = await prisma.workspaceMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkspaceMemberFindUniqueArgs>(args: SelectSubset<T, WorkspaceMemberFindUniqueArgs<ExtArgs>>): Prisma__WorkspaceMemberClient<$Result.GetResult<Prisma.$WorkspaceMemberPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one WorkspaceMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkspaceMemberFindUniqueOrThrowArgs} args - Arguments to find a WorkspaceMember
     * @example
     * // Get one WorkspaceMember
     * const workspaceMember = await prisma.workspaceMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkspaceMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkspaceMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkspaceMemberClient<$Result.GetResult<Prisma.$WorkspaceMemberPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first WorkspaceMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceMemberFindFirstArgs} args - Arguments to find a WorkspaceMember
     * @example
     * // Get one WorkspaceMember
     * const workspaceMember = await prisma.workspaceMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkspaceMemberFindFirstArgs>(args?: SelectSubset<T, WorkspaceMemberFindFirstArgs<ExtArgs>>): Prisma__WorkspaceMemberClient<$Result.GetResult<Prisma.$WorkspaceMemberPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first WorkspaceMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceMemberFindFirstOrThrowArgs} args - Arguments to find a WorkspaceMember
     * @example
     * // Get one WorkspaceMember
     * const workspaceMember = await prisma.workspaceMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkspaceMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkspaceMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkspaceMemberClient<$Result.GetResult<Prisma.$WorkspaceMemberPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more WorkspaceMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkspaceMembers
     * const workspaceMembers = await prisma.workspaceMember.findMany()
     * 
     * // Get first 10 WorkspaceMembers
     * const workspaceMembers = await prisma.workspaceMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workspaceMemberWithIdOnly = await prisma.workspaceMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkspaceMemberFindManyArgs>(args?: SelectSubset<T, WorkspaceMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceMemberPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a WorkspaceMember.
     * @param {WorkspaceMemberCreateArgs} args - Arguments to create a WorkspaceMember.
     * @example
     * // Create one WorkspaceMember
     * const WorkspaceMember = await prisma.workspaceMember.create({
     *   data: {
     *     // ... data to create a WorkspaceMember
     *   }
     * })
     * 
     */
    create<T extends WorkspaceMemberCreateArgs>(args: SelectSubset<T, WorkspaceMemberCreateArgs<ExtArgs>>): Prisma__WorkspaceMemberClient<$Result.GetResult<Prisma.$WorkspaceMemberPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many WorkspaceMembers.
     * @param {WorkspaceMemberCreateManyArgs} args - Arguments to create many WorkspaceMembers.
     * @example
     * // Create many WorkspaceMembers
     * const workspaceMember = await prisma.workspaceMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkspaceMemberCreateManyArgs>(args?: SelectSubset<T, WorkspaceMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkspaceMembers and returns the data saved in the database.
     * @param {WorkspaceMemberCreateManyAndReturnArgs} args - Arguments to create many WorkspaceMembers.
     * @example
     * // Create many WorkspaceMembers
     * const workspaceMember = await prisma.workspaceMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkspaceMembers and only return the `id`
     * const workspaceMemberWithIdOnly = await prisma.workspaceMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkspaceMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkspaceMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceMemberPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a WorkspaceMember.
     * @param {WorkspaceMemberDeleteArgs} args - Arguments to delete one WorkspaceMember.
     * @example
     * // Delete one WorkspaceMember
     * const WorkspaceMember = await prisma.workspaceMember.delete({
     *   where: {
     *     // ... filter to delete one WorkspaceMember
     *   }
     * })
     * 
     */
    delete<T extends WorkspaceMemberDeleteArgs>(args: SelectSubset<T, WorkspaceMemberDeleteArgs<ExtArgs>>): Prisma__WorkspaceMemberClient<$Result.GetResult<Prisma.$WorkspaceMemberPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one WorkspaceMember.
     * @param {WorkspaceMemberUpdateArgs} args - Arguments to update one WorkspaceMember.
     * @example
     * // Update one WorkspaceMember
     * const workspaceMember = await prisma.workspaceMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkspaceMemberUpdateArgs>(args: SelectSubset<T, WorkspaceMemberUpdateArgs<ExtArgs>>): Prisma__WorkspaceMemberClient<$Result.GetResult<Prisma.$WorkspaceMemberPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more WorkspaceMembers.
     * @param {WorkspaceMemberDeleteManyArgs} args - Arguments to filter WorkspaceMembers to delete.
     * @example
     * // Delete a few WorkspaceMembers
     * const { count } = await prisma.workspaceMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkspaceMemberDeleteManyArgs>(args?: SelectSubset<T, WorkspaceMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkspaceMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkspaceMembers
     * const workspaceMember = await prisma.workspaceMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkspaceMemberUpdateManyArgs>(args: SelectSubset<T, WorkspaceMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkspaceMembers and returns the data updated in the database.
     * @param {WorkspaceMemberUpdateManyAndReturnArgs} args - Arguments to update many WorkspaceMembers.
     * @example
     * // Update many WorkspaceMembers
     * const workspaceMember = await prisma.workspaceMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkspaceMembers and only return the `id`
     * const workspaceMemberWithIdOnly = await prisma.workspaceMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkspaceMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkspaceMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceMemberPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one WorkspaceMember.
     * @param {WorkspaceMemberUpsertArgs} args - Arguments to update or create a WorkspaceMember.
     * @example
     * // Update or create a WorkspaceMember
     * const workspaceMember = await prisma.workspaceMember.upsert({
     *   create: {
     *     // ... data to create a WorkspaceMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkspaceMember we want to update
     *   }
     * })
     */
    upsert<T extends WorkspaceMemberUpsertArgs>(args: SelectSubset<T, WorkspaceMemberUpsertArgs<ExtArgs>>): Prisma__WorkspaceMemberClient<$Result.GetResult<Prisma.$WorkspaceMemberPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of WorkspaceMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceMemberCountArgs} args - Arguments to filter WorkspaceMembers to count.
     * @example
     * // Count the number of WorkspaceMembers
     * const count = await prisma.workspaceMember.count({
     *   where: {
     *     // ... the filter for the WorkspaceMembers we want to count
     *   }
     * })
    **/
    count<T extends WorkspaceMemberCountArgs>(
      args?: Subset<T, WorkspaceMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkspaceMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkspaceMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkspaceMemberAggregateArgs>(args: Subset<T, WorkspaceMemberAggregateArgs>): Prisma.PrismaPromise<GetWorkspaceMemberAggregateType<T>>

    /**
     * Group by WorkspaceMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkspaceMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkspaceMemberGroupByArgs['orderBy'] }
        : { orderBy?: WorkspaceMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkspaceMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkspaceMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkspaceMember model
   */
  readonly fields: WorkspaceMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkspaceMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkspaceMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    breakoutRooms<T extends WorkspaceMember$breakoutRoomsArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceMember$breakoutRoomsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BreakoutRoomPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkspaceMember model
   */ 
  interface WorkspaceMemberFieldRefs {
    readonly id: FieldRef<"WorkspaceMember", 'String'>
    readonly userId: FieldRef<"WorkspaceMember", 'String'>
    readonly workspaceId: FieldRef<"WorkspaceMember", 'String'>
    readonly role: FieldRef<"WorkspaceMember", 'String'>
    readonly joinedAt: FieldRef<"WorkspaceMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkspaceMember findUnique
   */
  export type WorkspaceMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceMember
     */
    select?: WorkspaceMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceMember
     */
    omit?: WorkspaceMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceMemberInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceMember to fetch.
     */
    where: WorkspaceMemberWhereUniqueInput
  }

  /**
   * WorkspaceMember findUniqueOrThrow
   */
  export type WorkspaceMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceMember
     */
    select?: WorkspaceMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceMember
     */
    omit?: WorkspaceMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceMemberInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceMember to fetch.
     */
    where: WorkspaceMemberWhereUniqueInput
  }

  /**
   * WorkspaceMember findFirst
   */
  export type WorkspaceMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceMember
     */
    select?: WorkspaceMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceMember
     */
    omit?: WorkspaceMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceMemberInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceMember to fetch.
     */
    where?: WorkspaceMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceMembers to fetch.
     */
    orderBy?: WorkspaceMemberOrderByWithRelationInput | WorkspaceMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkspaceMembers.
     */
    cursor?: WorkspaceMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkspaceMembers.
     */
    distinct?: WorkspaceMemberScalarFieldEnum | WorkspaceMemberScalarFieldEnum[]
  }

  /**
   * WorkspaceMember findFirstOrThrow
   */
  export type WorkspaceMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceMember
     */
    select?: WorkspaceMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceMember
     */
    omit?: WorkspaceMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceMemberInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceMember to fetch.
     */
    where?: WorkspaceMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceMembers to fetch.
     */
    orderBy?: WorkspaceMemberOrderByWithRelationInput | WorkspaceMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkspaceMembers.
     */
    cursor?: WorkspaceMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkspaceMembers.
     */
    distinct?: WorkspaceMemberScalarFieldEnum | WorkspaceMemberScalarFieldEnum[]
  }

  /**
   * WorkspaceMember findMany
   */
  export type WorkspaceMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceMember
     */
    select?: WorkspaceMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceMember
     */
    omit?: WorkspaceMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceMemberInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceMembers to fetch.
     */
    where?: WorkspaceMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceMembers to fetch.
     */
    orderBy?: WorkspaceMemberOrderByWithRelationInput | WorkspaceMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkspaceMembers.
     */
    cursor?: WorkspaceMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceMembers.
     */
    skip?: number
    distinct?: WorkspaceMemberScalarFieldEnum | WorkspaceMemberScalarFieldEnum[]
  }

  /**
   * WorkspaceMember create
   */
  export type WorkspaceMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceMember
     */
    select?: WorkspaceMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceMember
     */
    omit?: WorkspaceMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkspaceMember.
     */
    data: XOR<WorkspaceMemberCreateInput, WorkspaceMemberUncheckedCreateInput>
  }

  /**
   * WorkspaceMember createMany
   */
  export type WorkspaceMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkspaceMembers.
     */
    data: WorkspaceMemberCreateManyInput | WorkspaceMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkspaceMember createManyAndReturn
   */
  export type WorkspaceMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceMember
     */
    select?: WorkspaceMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceMember
     */
    omit?: WorkspaceMemberOmit<ExtArgs> | null
    /**
     * The data used to create many WorkspaceMembers.
     */
    data: WorkspaceMemberCreateManyInput | WorkspaceMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkspaceMember update
   */
  export type WorkspaceMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceMember
     */
    select?: WorkspaceMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceMember
     */
    omit?: WorkspaceMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkspaceMember.
     */
    data: XOR<WorkspaceMemberUpdateInput, WorkspaceMemberUncheckedUpdateInput>
    /**
     * Choose, which WorkspaceMember to update.
     */
    where: WorkspaceMemberWhereUniqueInput
  }

  /**
   * WorkspaceMember updateMany
   */
  export type WorkspaceMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkspaceMembers.
     */
    data: XOR<WorkspaceMemberUpdateManyMutationInput, WorkspaceMemberUncheckedUpdateManyInput>
    /**
     * Filter which WorkspaceMembers to update
     */
    where?: WorkspaceMemberWhereInput
    /**
     * Limit how many WorkspaceMembers to update.
     */
    limit?: number
  }

  /**
   * WorkspaceMember updateManyAndReturn
   */
  export type WorkspaceMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceMember
     */
    select?: WorkspaceMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceMember
     */
    omit?: WorkspaceMemberOmit<ExtArgs> | null
    /**
     * The data used to update WorkspaceMembers.
     */
    data: XOR<WorkspaceMemberUpdateManyMutationInput, WorkspaceMemberUncheckedUpdateManyInput>
    /**
     * Filter which WorkspaceMembers to update
     */
    where?: WorkspaceMemberWhereInput
    /**
     * Limit how many WorkspaceMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkspaceMember upsert
   */
  export type WorkspaceMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceMember
     */
    select?: WorkspaceMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceMember
     */
    omit?: WorkspaceMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkspaceMember to update in case it exists.
     */
    where: WorkspaceMemberWhereUniqueInput
    /**
     * In case the WorkspaceMember found by the `where` argument doesn't exist, create a new WorkspaceMember with this data.
     */
    create: XOR<WorkspaceMemberCreateInput, WorkspaceMemberUncheckedCreateInput>
    /**
     * In case the WorkspaceMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkspaceMemberUpdateInput, WorkspaceMemberUncheckedUpdateInput>
  }

  /**
   * WorkspaceMember delete
   */
  export type WorkspaceMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceMember
     */
    select?: WorkspaceMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceMember
     */
    omit?: WorkspaceMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceMemberInclude<ExtArgs> | null
    /**
     * Filter which WorkspaceMember to delete.
     */
    where: WorkspaceMemberWhereUniqueInput
  }

  /**
   * WorkspaceMember deleteMany
   */
  export type WorkspaceMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkspaceMembers to delete
     */
    where?: WorkspaceMemberWhereInput
    /**
     * Limit how many WorkspaceMembers to delete.
     */
    limit?: number
  }

  /**
   * WorkspaceMember.breakoutRooms
   */
  export type WorkspaceMember$breakoutRoomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreakoutRoom
     */
    select?: BreakoutRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BreakoutRoom
     */
    omit?: BreakoutRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreakoutRoomInclude<ExtArgs> | null
    where?: BreakoutRoomWhereInput
    orderBy?: BreakoutRoomOrderByWithRelationInput | BreakoutRoomOrderByWithRelationInput[]
    cursor?: BreakoutRoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BreakoutRoomScalarFieldEnum | BreakoutRoomScalarFieldEnum[]
  }

  /**
   * WorkspaceMember without action
   */
  export type WorkspaceMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceMember
     */
    select?: WorkspaceMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceMember
     */
    omit?: WorkspaceMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceMemberInclude<ExtArgs> | null
  }


  /**
   * Model Whiteboard
   */

  export type AggregateWhiteboard = {
    _count: WhiteboardCountAggregateOutputType | null
    _min: WhiteboardMinAggregateOutputType | null
    _max: WhiteboardMaxAggregateOutputType | null
  }

  export type WhiteboardMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WhiteboardMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WhiteboardCountAggregateOutputType = {
    id: number
    workspaceId: number
    content: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WhiteboardMinAggregateInputType = {
    id?: true
    workspaceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WhiteboardMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WhiteboardCountAggregateInputType = {
    id?: true
    workspaceId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WhiteboardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Whiteboard to aggregate.
     */
    where?: WhiteboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Whiteboards to fetch.
     */
    orderBy?: WhiteboardOrderByWithRelationInput | WhiteboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WhiteboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Whiteboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Whiteboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Whiteboards
    **/
    _count?: true | WhiteboardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WhiteboardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WhiteboardMaxAggregateInputType
  }

  export type GetWhiteboardAggregateType<T extends WhiteboardAggregateArgs> = {
        [P in keyof T & keyof AggregateWhiteboard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWhiteboard[P]>
      : GetScalarType<T[P], AggregateWhiteboard[P]>
  }




  export type WhiteboardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhiteboardWhereInput
    orderBy?: WhiteboardOrderByWithAggregationInput | WhiteboardOrderByWithAggregationInput[]
    by: WhiteboardScalarFieldEnum[] | WhiteboardScalarFieldEnum
    having?: WhiteboardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WhiteboardCountAggregateInputType | true
    _min?: WhiteboardMinAggregateInputType
    _max?: WhiteboardMaxAggregateInputType
  }

  export type WhiteboardGroupByOutputType = {
    id: string
    workspaceId: string
    content: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: WhiteboardCountAggregateOutputType | null
    _min: WhiteboardMinAggregateOutputType | null
    _max: WhiteboardMaxAggregateOutputType | null
  }

  type GetWhiteboardGroupByPayload<T extends WhiteboardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WhiteboardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WhiteboardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WhiteboardGroupByOutputType[P]>
            : GetScalarType<T[P], WhiteboardGroupByOutputType[P]>
        }
      >
    >


  export type WhiteboardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    versions?: boolean | Whiteboard$versionsArgs<ExtArgs>
    _count?: boolean | WhiteboardCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whiteboard"]>

  export type WhiteboardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whiteboard"]>

  export type WhiteboardSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whiteboard"]>

  export type WhiteboardSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WhiteboardOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workspaceId" | "content" | "createdAt" | "updatedAt", ExtArgs["result"]["whiteboard"]>
  export type WhiteboardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    versions?: boolean | Whiteboard$versionsArgs<ExtArgs>
    _count?: boolean | WhiteboardCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WhiteboardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type WhiteboardIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $WhiteboardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Whiteboard"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      versions: Prisma.$WhiteboardVersionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      content: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["whiteboard"]>
    composites: {}
  }

  type WhiteboardGetPayload<S extends boolean | null | undefined | WhiteboardDefaultArgs> = $Result.GetResult<Prisma.$WhiteboardPayload, S>

  type WhiteboardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WhiteboardFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WhiteboardCountAggregateInputType | true
    }

  export interface WhiteboardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Whiteboard'], meta: { name: 'Whiteboard' } }
    /**
     * Find zero or one Whiteboard that matches the filter.
     * @param {WhiteboardFindUniqueArgs} args - Arguments to find a Whiteboard
     * @example
     * // Get one Whiteboard
     * const whiteboard = await prisma.whiteboard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WhiteboardFindUniqueArgs>(args: SelectSubset<T, WhiteboardFindUniqueArgs<ExtArgs>>): Prisma__WhiteboardClient<$Result.GetResult<Prisma.$WhiteboardPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Whiteboard that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WhiteboardFindUniqueOrThrowArgs} args - Arguments to find a Whiteboard
     * @example
     * // Get one Whiteboard
     * const whiteboard = await prisma.whiteboard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WhiteboardFindUniqueOrThrowArgs>(args: SelectSubset<T, WhiteboardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WhiteboardClient<$Result.GetResult<Prisma.$WhiteboardPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Whiteboard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhiteboardFindFirstArgs} args - Arguments to find a Whiteboard
     * @example
     * // Get one Whiteboard
     * const whiteboard = await prisma.whiteboard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WhiteboardFindFirstArgs>(args?: SelectSubset<T, WhiteboardFindFirstArgs<ExtArgs>>): Prisma__WhiteboardClient<$Result.GetResult<Prisma.$WhiteboardPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Whiteboard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhiteboardFindFirstOrThrowArgs} args - Arguments to find a Whiteboard
     * @example
     * // Get one Whiteboard
     * const whiteboard = await prisma.whiteboard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WhiteboardFindFirstOrThrowArgs>(args?: SelectSubset<T, WhiteboardFindFirstOrThrowArgs<ExtArgs>>): Prisma__WhiteboardClient<$Result.GetResult<Prisma.$WhiteboardPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Whiteboards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhiteboardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Whiteboards
     * const whiteboards = await prisma.whiteboard.findMany()
     * 
     * // Get first 10 Whiteboards
     * const whiteboards = await prisma.whiteboard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const whiteboardWithIdOnly = await prisma.whiteboard.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WhiteboardFindManyArgs>(args?: SelectSubset<T, WhiteboardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhiteboardPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Whiteboard.
     * @param {WhiteboardCreateArgs} args - Arguments to create a Whiteboard.
     * @example
     * // Create one Whiteboard
     * const Whiteboard = await prisma.whiteboard.create({
     *   data: {
     *     // ... data to create a Whiteboard
     *   }
     * })
     * 
     */
    create<T extends WhiteboardCreateArgs>(args: SelectSubset<T, WhiteboardCreateArgs<ExtArgs>>): Prisma__WhiteboardClient<$Result.GetResult<Prisma.$WhiteboardPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Whiteboards.
     * @param {WhiteboardCreateManyArgs} args - Arguments to create many Whiteboards.
     * @example
     * // Create many Whiteboards
     * const whiteboard = await prisma.whiteboard.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WhiteboardCreateManyArgs>(args?: SelectSubset<T, WhiteboardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Whiteboards and returns the data saved in the database.
     * @param {WhiteboardCreateManyAndReturnArgs} args - Arguments to create many Whiteboards.
     * @example
     * // Create many Whiteboards
     * const whiteboard = await prisma.whiteboard.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Whiteboards and only return the `id`
     * const whiteboardWithIdOnly = await prisma.whiteboard.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WhiteboardCreateManyAndReturnArgs>(args?: SelectSubset<T, WhiteboardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhiteboardPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Whiteboard.
     * @param {WhiteboardDeleteArgs} args - Arguments to delete one Whiteboard.
     * @example
     * // Delete one Whiteboard
     * const Whiteboard = await prisma.whiteboard.delete({
     *   where: {
     *     // ... filter to delete one Whiteboard
     *   }
     * })
     * 
     */
    delete<T extends WhiteboardDeleteArgs>(args: SelectSubset<T, WhiteboardDeleteArgs<ExtArgs>>): Prisma__WhiteboardClient<$Result.GetResult<Prisma.$WhiteboardPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Whiteboard.
     * @param {WhiteboardUpdateArgs} args - Arguments to update one Whiteboard.
     * @example
     * // Update one Whiteboard
     * const whiteboard = await prisma.whiteboard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WhiteboardUpdateArgs>(args: SelectSubset<T, WhiteboardUpdateArgs<ExtArgs>>): Prisma__WhiteboardClient<$Result.GetResult<Prisma.$WhiteboardPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Whiteboards.
     * @param {WhiteboardDeleteManyArgs} args - Arguments to filter Whiteboards to delete.
     * @example
     * // Delete a few Whiteboards
     * const { count } = await prisma.whiteboard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WhiteboardDeleteManyArgs>(args?: SelectSubset<T, WhiteboardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Whiteboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhiteboardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Whiteboards
     * const whiteboard = await prisma.whiteboard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WhiteboardUpdateManyArgs>(args: SelectSubset<T, WhiteboardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Whiteboards and returns the data updated in the database.
     * @param {WhiteboardUpdateManyAndReturnArgs} args - Arguments to update many Whiteboards.
     * @example
     * // Update many Whiteboards
     * const whiteboard = await prisma.whiteboard.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Whiteboards and only return the `id`
     * const whiteboardWithIdOnly = await prisma.whiteboard.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WhiteboardUpdateManyAndReturnArgs>(args: SelectSubset<T, WhiteboardUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhiteboardPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Whiteboard.
     * @param {WhiteboardUpsertArgs} args - Arguments to update or create a Whiteboard.
     * @example
     * // Update or create a Whiteboard
     * const whiteboard = await prisma.whiteboard.upsert({
     *   create: {
     *     // ... data to create a Whiteboard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Whiteboard we want to update
     *   }
     * })
     */
    upsert<T extends WhiteboardUpsertArgs>(args: SelectSubset<T, WhiteboardUpsertArgs<ExtArgs>>): Prisma__WhiteboardClient<$Result.GetResult<Prisma.$WhiteboardPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Whiteboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhiteboardCountArgs} args - Arguments to filter Whiteboards to count.
     * @example
     * // Count the number of Whiteboards
     * const count = await prisma.whiteboard.count({
     *   where: {
     *     // ... the filter for the Whiteboards we want to count
     *   }
     * })
    **/
    count<T extends WhiteboardCountArgs>(
      args?: Subset<T, WhiteboardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WhiteboardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Whiteboard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhiteboardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WhiteboardAggregateArgs>(args: Subset<T, WhiteboardAggregateArgs>): Prisma.PrismaPromise<GetWhiteboardAggregateType<T>>

    /**
     * Group by Whiteboard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhiteboardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WhiteboardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WhiteboardGroupByArgs['orderBy'] }
        : { orderBy?: WhiteboardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WhiteboardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWhiteboardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Whiteboard model
   */
  readonly fields: WhiteboardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Whiteboard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WhiteboardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    versions<T extends Whiteboard$versionsArgs<ExtArgs> = {}>(args?: Subset<T, Whiteboard$versionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhiteboardVersionPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Whiteboard model
   */ 
  interface WhiteboardFieldRefs {
    readonly id: FieldRef<"Whiteboard", 'String'>
    readonly workspaceId: FieldRef<"Whiteboard", 'String'>
    readonly content: FieldRef<"Whiteboard", 'Json'>
    readonly createdAt: FieldRef<"Whiteboard", 'DateTime'>
    readonly updatedAt: FieldRef<"Whiteboard", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Whiteboard findUnique
   */
  export type WhiteboardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whiteboard
     */
    select?: WhiteboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Whiteboard
     */
    omit?: WhiteboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhiteboardInclude<ExtArgs> | null
    /**
     * Filter, which Whiteboard to fetch.
     */
    where: WhiteboardWhereUniqueInput
  }

  /**
   * Whiteboard findUniqueOrThrow
   */
  export type WhiteboardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whiteboard
     */
    select?: WhiteboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Whiteboard
     */
    omit?: WhiteboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhiteboardInclude<ExtArgs> | null
    /**
     * Filter, which Whiteboard to fetch.
     */
    where: WhiteboardWhereUniqueInput
  }

  /**
   * Whiteboard findFirst
   */
  export type WhiteboardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whiteboard
     */
    select?: WhiteboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Whiteboard
     */
    omit?: WhiteboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhiteboardInclude<ExtArgs> | null
    /**
     * Filter, which Whiteboard to fetch.
     */
    where?: WhiteboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Whiteboards to fetch.
     */
    orderBy?: WhiteboardOrderByWithRelationInput | WhiteboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Whiteboards.
     */
    cursor?: WhiteboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Whiteboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Whiteboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Whiteboards.
     */
    distinct?: WhiteboardScalarFieldEnum | WhiteboardScalarFieldEnum[]
  }

  /**
   * Whiteboard findFirstOrThrow
   */
  export type WhiteboardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whiteboard
     */
    select?: WhiteboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Whiteboard
     */
    omit?: WhiteboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhiteboardInclude<ExtArgs> | null
    /**
     * Filter, which Whiteboard to fetch.
     */
    where?: WhiteboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Whiteboards to fetch.
     */
    orderBy?: WhiteboardOrderByWithRelationInput | WhiteboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Whiteboards.
     */
    cursor?: WhiteboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Whiteboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Whiteboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Whiteboards.
     */
    distinct?: WhiteboardScalarFieldEnum | WhiteboardScalarFieldEnum[]
  }

  /**
   * Whiteboard findMany
   */
  export type WhiteboardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whiteboard
     */
    select?: WhiteboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Whiteboard
     */
    omit?: WhiteboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhiteboardInclude<ExtArgs> | null
    /**
     * Filter, which Whiteboards to fetch.
     */
    where?: WhiteboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Whiteboards to fetch.
     */
    orderBy?: WhiteboardOrderByWithRelationInput | WhiteboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Whiteboards.
     */
    cursor?: WhiteboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Whiteboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Whiteboards.
     */
    skip?: number
    distinct?: WhiteboardScalarFieldEnum | WhiteboardScalarFieldEnum[]
  }

  /**
   * Whiteboard create
   */
  export type WhiteboardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whiteboard
     */
    select?: WhiteboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Whiteboard
     */
    omit?: WhiteboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhiteboardInclude<ExtArgs> | null
    /**
     * The data needed to create a Whiteboard.
     */
    data: XOR<WhiteboardCreateInput, WhiteboardUncheckedCreateInput>
  }

  /**
   * Whiteboard createMany
   */
  export type WhiteboardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Whiteboards.
     */
    data: WhiteboardCreateManyInput | WhiteboardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Whiteboard createManyAndReturn
   */
  export type WhiteboardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whiteboard
     */
    select?: WhiteboardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Whiteboard
     */
    omit?: WhiteboardOmit<ExtArgs> | null
    /**
     * The data used to create many Whiteboards.
     */
    data: WhiteboardCreateManyInput | WhiteboardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhiteboardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Whiteboard update
   */
  export type WhiteboardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whiteboard
     */
    select?: WhiteboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Whiteboard
     */
    omit?: WhiteboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhiteboardInclude<ExtArgs> | null
    /**
     * The data needed to update a Whiteboard.
     */
    data: XOR<WhiteboardUpdateInput, WhiteboardUncheckedUpdateInput>
    /**
     * Choose, which Whiteboard to update.
     */
    where: WhiteboardWhereUniqueInput
  }

  /**
   * Whiteboard updateMany
   */
  export type WhiteboardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Whiteboards.
     */
    data: XOR<WhiteboardUpdateManyMutationInput, WhiteboardUncheckedUpdateManyInput>
    /**
     * Filter which Whiteboards to update
     */
    where?: WhiteboardWhereInput
    /**
     * Limit how many Whiteboards to update.
     */
    limit?: number
  }

  /**
   * Whiteboard updateManyAndReturn
   */
  export type WhiteboardUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whiteboard
     */
    select?: WhiteboardSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Whiteboard
     */
    omit?: WhiteboardOmit<ExtArgs> | null
    /**
     * The data used to update Whiteboards.
     */
    data: XOR<WhiteboardUpdateManyMutationInput, WhiteboardUncheckedUpdateManyInput>
    /**
     * Filter which Whiteboards to update
     */
    where?: WhiteboardWhereInput
    /**
     * Limit how many Whiteboards to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhiteboardIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Whiteboard upsert
   */
  export type WhiteboardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whiteboard
     */
    select?: WhiteboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Whiteboard
     */
    omit?: WhiteboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhiteboardInclude<ExtArgs> | null
    /**
     * The filter to search for the Whiteboard to update in case it exists.
     */
    where: WhiteboardWhereUniqueInput
    /**
     * In case the Whiteboard found by the `where` argument doesn't exist, create a new Whiteboard with this data.
     */
    create: XOR<WhiteboardCreateInput, WhiteboardUncheckedCreateInput>
    /**
     * In case the Whiteboard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WhiteboardUpdateInput, WhiteboardUncheckedUpdateInput>
  }

  /**
   * Whiteboard delete
   */
  export type WhiteboardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whiteboard
     */
    select?: WhiteboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Whiteboard
     */
    omit?: WhiteboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhiteboardInclude<ExtArgs> | null
    /**
     * Filter which Whiteboard to delete.
     */
    where: WhiteboardWhereUniqueInput
  }

  /**
   * Whiteboard deleteMany
   */
  export type WhiteboardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Whiteboards to delete
     */
    where?: WhiteboardWhereInput
    /**
     * Limit how many Whiteboards to delete.
     */
    limit?: number
  }

  /**
   * Whiteboard.versions
   */
  export type Whiteboard$versionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhiteboardVersion
     */
    select?: WhiteboardVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhiteboardVersion
     */
    omit?: WhiteboardVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhiteboardVersionInclude<ExtArgs> | null
    where?: WhiteboardVersionWhereInput
    orderBy?: WhiteboardVersionOrderByWithRelationInput | WhiteboardVersionOrderByWithRelationInput[]
    cursor?: WhiteboardVersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WhiteboardVersionScalarFieldEnum | WhiteboardVersionScalarFieldEnum[]
  }

  /**
   * Whiteboard without action
   */
  export type WhiteboardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whiteboard
     */
    select?: WhiteboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Whiteboard
     */
    omit?: WhiteboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhiteboardInclude<ExtArgs> | null
  }


  /**
   * Model WhiteboardVersion
   */

  export type AggregateWhiteboardVersion = {
    _count: WhiteboardVersionCountAggregateOutputType | null
    _avg: WhiteboardVersionAvgAggregateOutputType | null
    _sum: WhiteboardVersionSumAggregateOutputType | null
    _min: WhiteboardVersionMinAggregateOutputType | null
    _max: WhiteboardVersionMaxAggregateOutputType | null
  }

  export type WhiteboardVersionAvgAggregateOutputType = {
    versionNumber: number | null
  }

  export type WhiteboardVersionSumAggregateOutputType = {
    versionNumber: number | null
  }

  export type WhiteboardVersionMinAggregateOutputType = {
    id: string | null
    whiteboardId: string | null
    createdAt: Date | null
    createdBy: string | null
    versionNumber: number | null
  }

  export type WhiteboardVersionMaxAggregateOutputType = {
    id: string | null
    whiteboardId: string | null
    createdAt: Date | null
    createdBy: string | null
    versionNumber: number | null
  }

  export type WhiteboardVersionCountAggregateOutputType = {
    id: number
    whiteboardId: number
    content: number
    createdAt: number
    createdBy: number
    versionNumber: number
    _all: number
  }


  export type WhiteboardVersionAvgAggregateInputType = {
    versionNumber?: true
  }

  export type WhiteboardVersionSumAggregateInputType = {
    versionNumber?: true
  }

  export type WhiteboardVersionMinAggregateInputType = {
    id?: true
    whiteboardId?: true
    createdAt?: true
    createdBy?: true
    versionNumber?: true
  }

  export type WhiteboardVersionMaxAggregateInputType = {
    id?: true
    whiteboardId?: true
    createdAt?: true
    createdBy?: true
    versionNumber?: true
  }

  export type WhiteboardVersionCountAggregateInputType = {
    id?: true
    whiteboardId?: true
    content?: true
    createdAt?: true
    createdBy?: true
    versionNumber?: true
    _all?: true
  }

  export type WhiteboardVersionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhiteboardVersion to aggregate.
     */
    where?: WhiteboardVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhiteboardVersions to fetch.
     */
    orderBy?: WhiteboardVersionOrderByWithRelationInput | WhiteboardVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WhiteboardVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhiteboardVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhiteboardVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WhiteboardVersions
    **/
    _count?: true | WhiteboardVersionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WhiteboardVersionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WhiteboardVersionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WhiteboardVersionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WhiteboardVersionMaxAggregateInputType
  }

  export type GetWhiteboardVersionAggregateType<T extends WhiteboardVersionAggregateArgs> = {
        [P in keyof T & keyof AggregateWhiteboardVersion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWhiteboardVersion[P]>
      : GetScalarType<T[P], AggregateWhiteboardVersion[P]>
  }




  export type WhiteboardVersionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhiteboardVersionWhereInput
    orderBy?: WhiteboardVersionOrderByWithAggregationInput | WhiteboardVersionOrderByWithAggregationInput[]
    by: WhiteboardVersionScalarFieldEnum[] | WhiteboardVersionScalarFieldEnum
    having?: WhiteboardVersionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WhiteboardVersionCountAggregateInputType | true
    _avg?: WhiteboardVersionAvgAggregateInputType
    _sum?: WhiteboardVersionSumAggregateInputType
    _min?: WhiteboardVersionMinAggregateInputType
    _max?: WhiteboardVersionMaxAggregateInputType
  }

  export type WhiteboardVersionGroupByOutputType = {
    id: string
    whiteboardId: string
    content: JsonValue
    createdAt: Date
    createdBy: string
    versionNumber: number
    _count: WhiteboardVersionCountAggregateOutputType | null
    _avg: WhiteboardVersionAvgAggregateOutputType | null
    _sum: WhiteboardVersionSumAggregateOutputType | null
    _min: WhiteboardVersionMinAggregateOutputType | null
    _max: WhiteboardVersionMaxAggregateOutputType | null
  }

  type GetWhiteboardVersionGroupByPayload<T extends WhiteboardVersionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WhiteboardVersionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WhiteboardVersionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WhiteboardVersionGroupByOutputType[P]>
            : GetScalarType<T[P], WhiteboardVersionGroupByOutputType[P]>
        }
      >
    >


  export type WhiteboardVersionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    whiteboardId?: boolean
    content?: boolean
    createdAt?: boolean
    createdBy?: boolean
    versionNumber?: boolean
    whiteboard?: boolean | WhiteboardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whiteboardVersion"]>

  export type WhiteboardVersionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    whiteboardId?: boolean
    content?: boolean
    createdAt?: boolean
    createdBy?: boolean
    versionNumber?: boolean
    whiteboard?: boolean | WhiteboardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whiteboardVersion"]>

  export type WhiteboardVersionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    whiteboardId?: boolean
    content?: boolean
    createdAt?: boolean
    createdBy?: boolean
    versionNumber?: boolean
    whiteboard?: boolean | WhiteboardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whiteboardVersion"]>

  export type WhiteboardVersionSelectScalar = {
    id?: boolean
    whiteboardId?: boolean
    content?: boolean
    createdAt?: boolean
    createdBy?: boolean
    versionNumber?: boolean
  }

  export type WhiteboardVersionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "whiteboardId" | "content" | "createdAt" | "createdBy" | "versionNumber", ExtArgs["result"]["whiteboardVersion"]>
  export type WhiteboardVersionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    whiteboard?: boolean | WhiteboardDefaultArgs<ExtArgs>
  }
  export type WhiteboardVersionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    whiteboard?: boolean | WhiteboardDefaultArgs<ExtArgs>
  }
  export type WhiteboardVersionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    whiteboard?: boolean | WhiteboardDefaultArgs<ExtArgs>
  }

  export type $WhiteboardVersionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WhiteboardVersion"
    objects: {
      whiteboard: Prisma.$WhiteboardPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      whiteboardId: string
      content: Prisma.JsonValue
      createdAt: Date
      createdBy: string
      versionNumber: number
    }, ExtArgs["result"]["whiteboardVersion"]>
    composites: {}
  }

  type WhiteboardVersionGetPayload<S extends boolean | null | undefined | WhiteboardVersionDefaultArgs> = $Result.GetResult<Prisma.$WhiteboardVersionPayload, S>

  type WhiteboardVersionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WhiteboardVersionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WhiteboardVersionCountAggregateInputType | true
    }

  export interface WhiteboardVersionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WhiteboardVersion'], meta: { name: 'WhiteboardVersion' } }
    /**
     * Find zero or one WhiteboardVersion that matches the filter.
     * @param {WhiteboardVersionFindUniqueArgs} args - Arguments to find a WhiteboardVersion
     * @example
     * // Get one WhiteboardVersion
     * const whiteboardVersion = await prisma.whiteboardVersion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WhiteboardVersionFindUniqueArgs>(args: SelectSubset<T, WhiteboardVersionFindUniqueArgs<ExtArgs>>): Prisma__WhiteboardVersionClient<$Result.GetResult<Prisma.$WhiteboardVersionPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one WhiteboardVersion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WhiteboardVersionFindUniqueOrThrowArgs} args - Arguments to find a WhiteboardVersion
     * @example
     * // Get one WhiteboardVersion
     * const whiteboardVersion = await prisma.whiteboardVersion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WhiteboardVersionFindUniqueOrThrowArgs>(args: SelectSubset<T, WhiteboardVersionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WhiteboardVersionClient<$Result.GetResult<Prisma.$WhiteboardVersionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first WhiteboardVersion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhiteboardVersionFindFirstArgs} args - Arguments to find a WhiteboardVersion
     * @example
     * // Get one WhiteboardVersion
     * const whiteboardVersion = await prisma.whiteboardVersion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WhiteboardVersionFindFirstArgs>(args?: SelectSubset<T, WhiteboardVersionFindFirstArgs<ExtArgs>>): Prisma__WhiteboardVersionClient<$Result.GetResult<Prisma.$WhiteboardVersionPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first WhiteboardVersion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhiteboardVersionFindFirstOrThrowArgs} args - Arguments to find a WhiteboardVersion
     * @example
     * // Get one WhiteboardVersion
     * const whiteboardVersion = await prisma.whiteboardVersion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WhiteboardVersionFindFirstOrThrowArgs>(args?: SelectSubset<T, WhiteboardVersionFindFirstOrThrowArgs<ExtArgs>>): Prisma__WhiteboardVersionClient<$Result.GetResult<Prisma.$WhiteboardVersionPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more WhiteboardVersions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhiteboardVersionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WhiteboardVersions
     * const whiteboardVersions = await prisma.whiteboardVersion.findMany()
     * 
     * // Get first 10 WhiteboardVersions
     * const whiteboardVersions = await prisma.whiteboardVersion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const whiteboardVersionWithIdOnly = await prisma.whiteboardVersion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WhiteboardVersionFindManyArgs>(args?: SelectSubset<T, WhiteboardVersionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhiteboardVersionPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a WhiteboardVersion.
     * @param {WhiteboardVersionCreateArgs} args - Arguments to create a WhiteboardVersion.
     * @example
     * // Create one WhiteboardVersion
     * const WhiteboardVersion = await prisma.whiteboardVersion.create({
     *   data: {
     *     // ... data to create a WhiteboardVersion
     *   }
     * })
     * 
     */
    create<T extends WhiteboardVersionCreateArgs>(args: SelectSubset<T, WhiteboardVersionCreateArgs<ExtArgs>>): Prisma__WhiteboardVersionClient<$Result.GetResult<Prisma.$WhiteboardVersionPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many WhiteboardVersions.
     * @param {WhiteboardVersionCreateManyArgs} args - Arguments to create many WhiteboardVersions.
     * @example
     * // Create many WhiteboardVersions
     * const whiteboardVersion = await prisma.whiteboardVersion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WhiteboardVersionCreateManyArgs>(args?: SelectSubset<T, WhiteboardVersionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WhiteboardVersions and returns the data saved in the database.
     * @param {WhiteboardVersionCreateManyAndReturnArgs} args - Arguments to create many WhiteboardVersions.
     * @example
     * // Create many WhiteboardVersions
     * const whiteboardVersion = await prisma.whiteboardVersion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WhiteboardVersions and only return the `id`
     * const whiteboardVersionWithIdOnly = await prisma.whiteboardVersion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WhiteboardVersionCreateManyAndReturnArgs>(args?: SelectSubset<T, WhiteboardVersionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhiteboardVersionPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a WhiteboardVersion.
     * @param {WhiteboardVersionDeleteArgs} args - Arguments to delete one WhiteboardVersion.
     * @example
     * // Delete one WhiteboardVersion
     * const WhiteboardVersion = await prisma.whiteboardVersion.delete({
     *   where: {
     *     // ... filter to delete one WhiteboardVersion
     *   }
     * })
     * 
     */
    delete<T extends WhiteboardVersionDeleteArgs>(args: SelectSubset<T, WhiteboardVersionDeleteArgs<ExtArgs>>): Prisma__WhiteboardVersionClient<$Result.GetResult<Prisma.$WhiteboardVersionPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one WhiteboardVersion.
     * @param {WhiteboardVersionUpdateArgs} args - Arguments to update one WhiteboardVersion.
     * @example
     * // Update one WhiteboardVersion
     * const whiteboardVersion = await prisma.whiteboardVersion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WhiteboardVersionUpdateArgs>(args: SelectSubset<T, WhiteboardVersionUpdateArgs<ExtArgs>>): Prisma__WhiteboardVersionClient<$Result.GetResult<Prisma.$WhiteboardVersionPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more WhiteboardVersions.
     * @param {WhiteboardVersionDeleteManyArgs} args - Arguments to filter WhiteboardVersions to delete.
     * @example
     * // Delete a few WhiteboardVersions
     * const { count } = await prisma.whiteboardVersion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WhiteboardVersionDeleteManyArgs>(args?: SelectSubset<T, WhiteboardVersionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WhiteboardVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhiteboardVersionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WhiteboardVersions
     * const whiteboardVersion = await prisma.whiteboardVersion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WhiteboardVersionUpdateManyArgs>(args: SelectSubset<T, WhiteboardVersionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WhiteboardVersions and returns the data updated in the database.
     * @param {WhiteboardVersionUpdateManyAndReturnArgs} args - Arguments to update many WhiteboardVersions.
     * @example
     * // Update many WhiteboardVersions
     * const whiteboardVersion = await prisma.whiteboardVersion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WhiteboardVersions and only return the `id`
     * const whiteboardVersionWithIdOnly = await prisma.whiteboardVersion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WhiteboardVersionUpdateManyAndReturnArgs>(args: SelectSubset<T, WhiteboardVersionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhiteboardVersionPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one WhiteboardVersion.
     * @param {WhiteboardVersionUpsertArgs} args - Arguments to update or create a WhiteboardVersion.
     * @example
     * // Update or create a WhiteboardVersion
     * const whiteboardVersion = await prisma.whiteboardVersion.upsert({
     *   create: {
     *     // ... data to create a WhiteboardVersion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WhiteboardVersion we want to update
     *   }
     * })
     */
    upsert<T extends WhiteboardVersionUpsertArgs>(args: SelectSubset<T, WhiteboardVersionUpsertArgs<ExtArgs>>): Prisma__WhiteboardVersionClient<$Result.GetResult<Prisma.$WhiteboardVersionPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of WhiteboardVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhiteboardVersionCountArgs} args - Arguments to filter WhiteboardVersions to count.
     * @example
     * // Count the number of WhiteboardVersions
     * const count = await prisma.whiteboardVersion.count({
     *   where: {
     *     // ... the filter for the WhiteboardVersions we want to count
     *   }
     * })
    **/
    count<T extends WhiteboardVersionCountArgs>(
      args?: Subset<T, WhiteboardVersionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WhiteboardVersionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WhiteboardVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhiteboardVersionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WhiteboardVersionAggregateArgs>(args: Subset<T, WhiteboardVersionAggregateArgs>): Prisma.PrismaPromise<GetWhiteboardVersionAggregateType<T>>

    /**
     * Group by WhiteboardVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhiteboardVersionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WhiteboardVersionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WhiteboardVersionGroupByArgs['orderBy'] }
        : { orderBy?: WhiteboardVersionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WhiteboardVersionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWhiteboardVersionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WhiteboardVersion model
   */
  readonly fields: WhiteboardVersionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WhiteboardVersion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WhiteboardVersionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    whiteboard<T extends WhiteboardDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WhiteboardDefaultArgs<ExtArgs>>): Prisma__WhiteboardClient<$Result.GetResult<Prisma.$WhiteboardPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WhiteboardVersion model
   */ 
  interface WhiteboardVersionFieldRefs {
    readonly id: FieldRef<"WhiteboardVersion", 'String'>
    readonly whiteboardId: FieldRef<"WhiteboardVersion", 'String'>
    readonly content: FieldRef<"WhiteboardVersion", 'Json'>
    readonly createdAt: FieldRef<"WhiteboardVersion", 'DateTime'>
    readonly createdBy: FieldRef<"WhiteboardVersion", 'String'>
    readonly versionNumber: FieldRef<"WhiteboardVersion", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * WhiteboardVersion findUnique
   */
  export type WhiteboardVersionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhiteboardVersion
     */
    select?: WhiteboardVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhiteboardVersion
     */
    omit?: WhiteboardVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhiteboardVersionInclude<ExtArgs> | null
    /**
     * Filter, which WhiteboardVersion to fetch.
     */
    where: WhiteboardVersionWhereUniqueInput
  }

  /**
   * WhiteboardVersion findUniqueOrThrow
   */
  export type WhiteboardVersionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhiteboardVersion
     */
    select?: WhiteboardVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhiteboardVersion
     */
    omit?: WhiteboardVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhiteboardVersionInclude<ExtArgs> | null
    /**
     * Filter, which WhiteboardVersion to fetch.
     */
    where: WhiteboardVersionWhereUniqueInput
  }

  /**
   * WhiteboardVersion findFirst
   */
  export type WhiteboardVersionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhiteboardVersion
     */
    select?: WhiteboardVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhiteboardVersion
     */
    omit?: WhiteboardVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhiteboardVersionInclude<ExtArgs> | null
    /**
     * Filter, which WhiteboardVersion to fetch.
     */
    where?: WhiteboardVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhiteboardVersions to fetch.
     */
    orderBy?: WhiteboardVersionOrderByWithRelationInput | WhiteboardVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhiteboardVersions.
     */
    cursor?: WhiteboardVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhiteboardVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhiteboardVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhiteboardVersions.
     */
    distinct?: WhiteboardVersionScalarFieldEnum | WhiteboardVersionScalarFieldEnum[]
  }

  /**
   * WhiteboardVersion findFirstOrThrow
   */
  export type WhiteboardVersionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhiteboardVersion
     */
    select?: WhiteboardVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhiteboardVersion
     */
    omit?: WhiteboardVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhiteboardVersionInclude<ExtArgs> | null
    /**
     * Filter, which WhiteboardVersion to fetch.
     */
    where?: WhiteboardVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhiteboardVersions to fetch.
     */
    orderBy?: WhiteboardVersionOrderByWithRelationInput | WhiteboardVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhiteboardVersions.
     */
    cursor?: WhiteboardVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhiteboardVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhiteboardVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhiteboardVersions.
     */
    distinct?: WhiteboardVersionScalarFieldEnum | WhiteboardVersionScalarFieldEnum[]
  }

  /**
   * WhiteboardVersion findMany
   */
  export type WhiteboardVersionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhiteboardVersion
     */
    select?: WhiteboardVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhiteboardVersion
     */
    omit?: WhiteboardVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhiteboardVersionInclude<ExtArgs> | null
    /**
     * Filter, which WhiteboardVersions to fetch.
     */
    where?: WhiteboardVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhiteboardVersions to fetch.
     */
    orderBy?: WhiteboardVersionOrderByWithRelationInput | WhiteboardVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WhiteboardVersions.
     */
    cursor?: WhiteboardVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhiteboardVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhiteboardVersions.
     */
    skip?: number
    distinct?: WhiteboardVersionScalarFieldEnum | WhiteboardVersionScalarFieldEnum[]
  }

  /**
   * WhiteboardVersion create
   */
  export type WhiteboardVersionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhiteboardVersion
     */
    select?: WhiteboardVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhiteboardVersion
     */
    omit?: WhiteboardVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhiteboardVersionInclude<ExtArgs> | null
    /**
     * The data needed to create a WhiteboardVersion.
     */
    data: XOR<WhiteboardVersionCreateInput, WhiteboardVersionUncheckedCreateInput>
  }

  /**
   * WhiteboardVersion createMany
   */
  export type WhiteboardVersionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WhiteboardVersions.
     */
    data: WhiteboardVersionCreateManyInput | WhiteboardVersionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WhiteboardVersion createManyAndReturn
   */
  export type WhiteboardVersionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhiteboardVersion
     */
    select?: WhiteboardVersionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WhiteboardVersion
     */
    omit?: WhiteboardVersionOmit<ExtArgs> | null
    /**
     * The data used to create many WhiteboardVersions.
     */
    data: WhiteboardVersionCreateManyInput | WhiteboardVersionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhiteboardVersionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WhiteboardVersion update
   */
  export type WhiteboardVersionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhiteboardVersion
     */
    select?: WhiteboardVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhiteboardVersion
     */
    omit?: WhiteboardVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhiteboardVersionInclude<ExtArgs> | null
    /**
     * The data needed to update a WhiteboardVersion.
     */
    data: XOR<WhiteboardVersionUpdateInput, WhiteboardVersionUncheckedUpdateInput>
    /**
     * Choose, which WhiteboardVersion to update.
     */
    where: WhiteboardVersionWhereUniqueInput
  }

  /**
   * WhiteboardVersion updateMany
   */
  export type WhiteboardVersionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WhiteboardVersions.
     */
    data: XOR<WhiteboardVersionUpdateManyMutationInput, WhiteboardVersionUncheckedUpdateManyInput>
    /**
     * Filter which WhiteboardVersions to update
     */
    where?: WhiteboardVersionWhereInput
    /**
     * Limit how many WhiteboardVersions to update.
     */
    limit?: number
  }

  /**
   * WhiteboardVersion updateManyAndReturn
   */
  export type WhiteboardVersionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhiteboardVersion
     */
    select?: WhiteboardVersionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WhiteboardVersion
     */
    omit?: WhiteboardVersionOmit<ExtArgs> | null
    /**
     * The data used to update WhiteboardVersions.
     */
    data: XOR<WhiteboardVersionUpdateManyMutationInput, WhiteboardVersionUncheckedUpdateManyInput>
    /**
     * Filter which WhiteboardVersions to update
     */
    where?: WhiteboardVersionWhereInput
    /**
     * Limit how many WhiteboardVersions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhiteboardVersionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WhiteboardVersion upsert
   */
  export type WhiteboardVersionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhiteboardVersion
     */
    select?: WhiteboardVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhiteboardVersion
     */
    omit?: WhiteboardVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhiteboardVersionInclude<ExtArgs> | null
    /**
     * The filter to search for the WhiteboardVersion to update in case it exists.
     */
    where: WhiteboardVersionWhereUniqueInput
    /**
     * In case the WhiteboardVersion found by the `where` argument doesn't exist, create a new WhiteboardVersion with this data.
     */
    create: XOR<WhiteboardVersionCreateInput, WhiteboardVersionUncheckedCreateInput>
    /**
     * In case the WhiteboardVersion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WhiteboardVersionUpdateInput, WhiteboardVersionUncheckedUpdateInput>
  }

  /**
   * WhiteboardVersion delete
   */
  export type WhiteboardVersionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhiteboardVersion
     */
    select?: WhiteboardVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhiteboardVersion
     */
    omit?: WhiteboardVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhiteboardVersionInclude<ExtArgs> | null
    /**
     * Filter which WhiteboardVersion to delete.
     */
    where: WhiteboardVersionWhereUniqueInput
  }

  /**
   * WhiteboardVersion deleteMany
   */
  export type WhiteboardVersionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhiteboardVersions to delete
     */
    where?: WhiteboardVersionWhereInput
    /**
     * Limit how many WhiteboardVersions to delete.
     */
    limit?: number
  }

  /**
   * WhiteboardVersion without action
   */
  export type WhiteboardVersionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhiteboardVersion
     */
    select?: WhiteboardVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhiteboardVersion
     */
    omit?: WhiteboardVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhiteboardVersionInclude<ExtArgs> | null
  }


  /**
   * Model BreakoutRoom
   */

  export type AggregateBreakoutRoom = {
    _count: BreakoutRoomCountAggregateOutputType | null
    _min: BreakoutRoomMinAggregateOutputType | null
    _max: BreakoutRoomMaxAggregateOutputType | null
  }

  export type BreakoutRoomMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    name: string | null
    createdAt: Date | null
    endedAt: Date | null
  }

  export type BreakoutRoomMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    name: string | null
    createdAt: Date | null
    endedAt: Date | null
  }

  export type BreakoutRoomCountAggregateOutputType = {
    id: number
    workspaceId: number
    name: number
    createdAt: number
    endedAt: number
    _all: number
  }


  export type BreakoutRoomMinAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    createdAt?: true
    endedAt?: true
  }

  export type BreakoutRoomMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    createdAt?: true
    endedAt?: true
  }

  export type BreakoutRoomCountAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    createdAt?: true
    endedAt?: true
    _all?: true
  }

  export type BreakoutRoomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BreakoutRoom to aggregate.
     */
    where?: BreakoutRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BreakoutRooms to fetch.
     */
    orderBy?: BreakoutRoomOrderByWithRelationInput | BreakoutRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BreakoutRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BreakoutRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BreakoutRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BreakoutRooms
    **/
    _count?: true | BreakoutRoomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BreakoutRoomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BreakoutRoomMaxAggregateInputType
  }

  export type GetBreakoutRoomAggregateType<T extends BreakoutRoomAggregateArgs> = {
        [P in keyof T & keyof AggregateBreakoutRoom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBreakoutRoom[P]>
      : GetScalarType<T[P], AggregateBreakoutRoom[P]>
  }




  export type BreakoutRoomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BreakoutRoomWhereInput
    orderBy?: BreakoutRoomOrderByWithAggregationInput | BreakoutRoomOrderByWithAggregationInput[]
    by: BreakoutRoomScalarFieldEnum[] | BreakoutRoomScalarFieldEnum
    having?: BreakoutRoomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BreakoutRoomCountAggregateInputType | true
    _min?: BreakoutRoomMinAggregateInputType
    _max?: BreakoutRoomMaxAggregateInputType
  }

  export type BreakoutRoomGroupByOutputType = {
    id: string
    workspaceId: string
    name: string
    createdAt: Date
    endedAt: Date | null
    _count: BreakoutRoomCountAggregateOutputType | null
    _min: BreakoutRoomMinAggregateOutputType | null
    _max: BreakoutRoomMaxAggregateOutputType | null
  }

  type GetBreakoutRoomGroupByPayload<T extends BreakoutRoomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BreakoutRoomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BreakoutRoomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BreakoutRoomGroupByOutputType[P]>
            : GetScalarType<T[P], BreakoutRoomGroupByOutputType[P]>
        }
      >
    >


  export type BreakoutRoomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    createdAt?: boolean
    endedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    participants?: boolean | BreakoutRoom$participantsArgs<ExtArgs>
    _count?: boolean | BreakoutRoomCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["breakoutRoom"]>

  export type BreakoutRoomSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    createdAt?: boolean
    endedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["breakoutRoom"]>

  export type BreakoutRoomSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    createdAt?: boolean
    endedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["breakoutRoom"]>

  export type BreakoutRoomSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    createdAt?: boolean
    endedAt?: boolean
  }

  export type BreakoutRoomOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workspaceId" | "name" | "createdAt" | "endedAt", ExtArgs["result"]["breakoutRoom"]>
  export type BreakoutRoomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    participants?: boolean | BreakoutRoom$participantsArgs<ExtArgs>
    _count?: boolean | BreakoutRoomCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BreakoutRoomIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type BreakoutRoomIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $BreakoutRoomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BreakoutRoom"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      participants: Prisma.$WorkspaceMemberPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      name: string
      createdAt: Date
      endedAt: Date | null
    }, ExtArgs["result"]["breakoutRoom"]>
    composites: {}
  }

  type BreakoutRoomGetPayload<S extends boolean | null | undefined | BreakoutRoomDefaultArgs> = $Result.GetResult<Prisma.$BreakoutRoomPayload, S>

  type BreakoutRoomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BreakoutRoomFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BreakoutRoomCountAggregateInputType | true
    }

  export interface BreakoutRoomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BreakoutRoom'], meta: { name: 'BreakoutRoom' } }
    /**
     * Find zero or one BreakoutRoom that matches the filter.
     * @param {BreakoutRoomFindUniqueArgs} args - Arguments to find a BreakoutRoom
     * @example
     * // Get one BreakoutRoom
     * const breakoutRoom = await prisma.breakoutRoom.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BreakoutRoomFindUniqueArgs>(args: SelectSubset<T, BreakoutRoomFindUniqueArgs<ExtArgs>>): Prisma__BreakoutRoomClient<$Result.GetResult<Prisma.$BreakoutRoomPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one BreakoutRoom that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BreakoutRoomFindUniqueOrThrowArgs} args - Arguments to find a BreakoutRoom
     * @example
     * // Get one BreakoutRoom
     * const breakoutRoom = await prisma.breakoutRoom.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BreakoutRoomFindUniqueOrThrowArgs>(args: SelectSubset<T, BreakoutRoomFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BreakoutRoomClient<$Result.GetResult<Prisma.$BreakoutRoomPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first BreakoutRoom that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreakoutRoomFindFirstArgs} args - Arguments to find a BreakoutRoom
     * @example
     * // Get one BreakoutRoom
     * const breakoutRoom = await prisma.breakoutRoom.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BreakoutRoomFindFirstArgs>(args?: SelectSubset<T, BreakoutRoomFindFirstArgs<ExtArgs>>): Prisma__BreakoutRoomClient<$Result.GetResult<Prisma.$BreakoutRoomPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first BreakoutRoom that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreakoutRoomFindFirstOrThrowArgs} args - Arguments to find a BreakoutRoom
     * @example
     * // Get one BreakoutRoom
     * const breakoutRoom = await prisma.breakoutRoom.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BreakoutRoomFindFirstOrThrowArgs>(args?: SelectSubset<T, BreakoutRoomFindFirstOrThrowArgs<ExtArgs>>): Prisma__BreakoutRoomClient<$Result.GetResult<Prisma.$BreakoutRoomPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more BreakoutRooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreakoutRoomFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BreakoutRooms
     * const breakoutRooms = await prisma.breakoutRoom.findMany()
     * 
     * // Get first 10 BreakoutRooms
     * const breakoutRooms = await prisma.breakoutRoom.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const breakoutRoomWithIdOnly = await prisma.breakoutRoom.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BreakoutRoomFindManyArgs>(args?: SelectSubset<T, BreakoutRoomFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BreakoutRoomPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a BreakoutRoom.
     * @param {BreakoutRoomCreateArgs} args - Arguments to create a BreakoutRoom.
     * @example
     * // Create one BreakoutRoom
     * const BreakoutRoom = await prisma.breakoutRoom.create({
     *   data: {
     *     // ... data to create a BreakoutRoom
     *   }
     * })
     * 
     */
    create<T extends BreakoutRoomCreateArgs>(args: SelectSubset<T, BreakoutRoomCreateArgs<ExtArgs>>): Prisma__BreakoutRoomClient<$Result.GetResult<Prisma.$BreakoutRoomPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many BreakoutRooms.
     * @param {BreakoutRoomCreateManyArgs} args - Arguments to create many BreakoutRooms.
     * @example
     * // Create many BreakoutRooms
     * const breakoutRoom = await prisma.breakoutRoom.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BreakoutRoomCreateManyArgs>(args?: SelectSubset<T, BreakoutRoomCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BreakoutRooms and returns the data saved in the database.
     * @param {BreakoutRoomCreateManyAndReturnArgs} args - Arguments to create many BreakoutRooms.
     * @example
     * // Create many BreakoutRooms
     * const breakoutRoom = await prisma.breakoutRoom.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BreakoutRooms and only return the `id`
     * const breakoutRoomWithIdOnly = await prisma.breakoutRoom.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BreakoutRoomCreateManyAndReturnArgs>(args?: SelectSubset<T, BreakoutRoomCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BreakoutRoomPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a BreakoutRoom.
     * @param {BreakoutRoomDeleteArgs} args - Arguments to delete one BreakoutRoom.
     * @example
     * // Delete one BreakoutRoom
     * const BreakoutRoom = await prisma.breakoutRoom.delete({
     *   where: {
     *     // ... filter to delete one BreakoutRoom
     *   }
     * })
     * 
     */
    delete<T extends BreakoutRoomDeleteArgs>(args: SelectSubset<T, BreakoutRoomDeleteArgs<ExtArgs>>): Prisma__BreakoutRoomClient<$Result.GetResult<Prisma.$BreakoutRoomPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one BreakoutRoom.
     * @param {BreakoutRoomUpdateArgs} args - Arguments to update one BreakoutRoom.
     * @example
     * // Update one BreakoutRoom
     * const breakoutRoom = await prisma.breakoutRoom.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BreakoutRoomUpdateArgs>(args: SelectSubset<T, BreakoutRoomUpdateArgs<ExtArgs>>): Prisma__BreakoutRoomClient<$Result.GetResult<Prisma.$BreakoutRoomPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more BreakoutRooms.
     * @param {BreakoutRoomDeleteManyArgs} args - Arguments to filter BreakoutRooms to delete.
     * @example
     * // Delete a few BreakoutRooms
     * const { count } = await prisma.breakoutRoom.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BreakoutRoomDeleteManyArgs>(args?: SelectSubset<T, BreakoutRoomDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BreakoutRooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreakoutRoomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BreakoutRooms
     * const breakoutRoom = await prisma.breakoutRoom.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BreakoutRoomUpdateManyArgs>(args: SelectSubset<T, BreakoutRoomUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BreakoutRooms and returns the data updated in the database.
     * @param {BreakoutRoomUpdateManyAndReturnArgs} args - Arguments to update many BreakoutRooms.
     * @example
     * // Update many BreakoutRooms
     * const breakoutRoom = await prisma.breakoutRoom.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BreakoutRooms and only return the `id`
     * const breakoutRoomWithIdOnly = await prisma.breakoutRoom.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BreakoutRoomUpdateManyAndReturnArgs>(args: SelectSubset<T, BreakoutRoomUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BreakoutRoomPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one BreakoutRoom.
     * @param {BreakoutRoomUpsertArgs} args - Arguments to update or create a BreakoutRoom.
     * @example
     * // Update or create a BreakoutRoom
     * const breakoutRoom = await prisma.breakoutRoom.upsert({
     *   create: {
     *     // ... data to create a BreakoutRoom
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BreakoutRoom we want to update
     *   }
     * })
     */
    upsert<T extends BreakoutRoomUpsertArgs>(args: SelectSubset<T, BreakoutRoomUpsertArgs<ExtArgs>>): Prisma__BreakoutRoomClient<$Result.GetResult<Prisma.$BreakoutRoomPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of BreakoutRooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreakoutRoomCountArgs} args - Arguments to filter BreakoutRooms to count.
     * @example
     * // Count the number of BreakoutRooms
     * const count = await prisma.breakoutRoom.count({
     *   where: {
     *     // ... the filter for the BreakoutRooms we want to count
     *   }
     * })
    **/
    count<T extends BreakoutRoomCountArgs>(
      args?: Subset<T, BreakoutRoomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BreakoutRoomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BreakoutRoom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreakoutRoomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BreakoutRoomAggregateArgs>(args: Subset<T, BreakoutRoomAggregateArgs>): Prisma.PrismaPromise<GetBreakoutRoomAggregateType<T>>

    /**
     * Group by BreakoutRoom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreakoutRoomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BreakoutRoomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BreakoutRoomGroupByArgs['orderBy'] }
        : { orderBy?: BreakoutRoomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BreakoutRoomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBreakoutRoomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BreakoutRoom model
   */
  readonly fields: BreakoutRoomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BreakoutRoom.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BreakoutRoomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    participants<T extends BreakoutRoom$participantsArgs<ExtArgs> = {}>(args?: Subset<T, BreakoutRoom$participantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceMemberPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BreakoutRoom model
   */ 
  interface BreakoutRoomFieldRefs {
    readonly id: FieldRef<"BreakoutRoom", 'String'>
    readonly workspaceId: FieldRef<"BreakoutRoom", 'String'>
    readonly name: FieldRef<"BreakoutRoom", 'String'>
    readonly createdAt: FieldRef<"BreakoutRoom", 'DateTime'>
    readonly endedAt: FieldRef<"BreakoutRoom", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BreakoutRoom findUnique
   */
  export type BreakoutRoomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreakoutRoom
     */
    select?: BreakoutRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BreakoutRoom
     */
    omit?: BreakoutRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreakoutRoomInclude<ExtArgs> | null
    /**
     * Filter, which BreakoutRoom to fetch.
     */
    where: BreakoutRoomWhereUniqueInput
  }

  /**
   * BreakoutRoom findUniqueOrThrow
   */
  export type BreakoutRoomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreakoutRoom
     */
    select?: BreakoutRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BreakoutRoom
     */
    omit?: BreakoutRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreakoutRoomInclude<ExtArgs> | null
    /**
     * Filter, which BreakoutRoom to fetch.
     */
    where: BreakoutRoomWhereUniqueInput
  }

  /**
   * BreakoutRoom findFirst
   */
  export type BreakoutRoomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreakoutRoom
     */
    select?: BreakoutRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BreakoutRoom
     */
    omit?: BreakoutRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreakoutRoomInclude<ExtArgs> | null
    /**
     * Filter, which BreakoutRoom to fetch.
     */
    where?: BreakoutRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BreakoutRooms to fetch.
     */
    orderBy?: BreakoutRoomOrderByWithRelationInput | BreakoutRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BreakoutRooms.
     */
    cursor?: BreakoutRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BreakoutRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BreakoutRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BreakoutRooms.
     */
    distinct?: BreakoutRoomScalarFieldEnum | BreakoutRoomScalarFieldEnum[]
  }

  /**
   * BreakoutRoom findFirstOrThrow
   */
  export type BreakoutRoomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreakoutRoom
     */
    select?: BreakoutRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BreakoutRoom
     */
    omit?: BreakoutRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreakoutRoomInclude<ExtArgs> | null
    /**
     * Filter, which BreakoutRoom to fetch.
     */
    where?: BreakoutRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BreakoutRooms to fetch.
     */
    orderBy?: BreakoutRoomOrderByWithRelationInput | BreakoutRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BreakoutRooms.
     */
    cursor?: BreakoutRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BreakoutRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BreakoutRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BreakoutRooms.
     */
    distinct?: BreakoutRoomScalarFieldEnum | BreakoutRoomScalarFieldEnum[]
  }

  /**
   * BreakoutRoom findMany
   */
  export type BreakoutRoomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreakoutRoom
     */
    select?: BreakoutRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BreakoutRoom
     */
    omit?: BreakoutRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreakoutRoomInclude<ExtArgs> | null
    /**
     * Filter, which BreakoutRooms to fetch.
     */
    where?: BreakoutRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BreakoutRooms to fetch.
     */
    orderBy?: BreakoutRoomOrderByWithRelationInput | BreakoutRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BreakoutRooms.
     */
    cursor?: BreakoutRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BreakoutRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BreakoutRooms.
     */
    skip?: number
    distinct?: BreakoutRoomScalarFieldEnum | BreakoutRoomScalarFieldEnum[]
  }

  /**
   * BreakoutRoom create
   */
  export type BreakoutRoomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreakoutRoom
     */
    select?: BreakoutRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BreakoutRoom
     */
    omit?: BreakoutRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreakoutRoomInclude<ExtArgs> | null
    /**
     * The data needed to create a BreakoutRoom.
     */
    data: XOR<BreakoutRoomCreateInput, BreakoutRoomUncheckedCreateInput>
  }

  /**
   * BreakoutRoom createMany
   */
  export type BreakoutRoomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BreakoutRooms.
     */
    data: BreakoutRoomCreateManyInput | BreakoutRoomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BreakoutRoom createManyAndReturn
   */
  export type BreakoutRoomCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreakoutRoom
     */
    select?: BreakoutRoomSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BreakoutRoom
     */
    omit?: BreakoutRoomOmit<ExtArgs> | null
    /**
     * The data used to create many BreakoutRooms.
     */
    data: BreakoutRoomCreateManyInput | BreakoutRoomCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreakoutRoomIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BreakoutRoom update
   */
  export type BreakoutRoomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreakoutRoom
     */
    select?: BreakoutRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BreakoutRoom
     */
    omit?: BreakoutRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreakoutRoomInclude<ExtArgs> | null
    /**
     * The data needed to update a BreakoutRoom.
     */
    data: XOR<BreakoutRoomUpdateInput, BreakoutRoomUncheckedUpdateInput>
    /**
     * Choose, which BreakoutRoom to update.
     */
    where: BreakoutRoomWhereUniqueInput
  }

  /**
   * BreakoutRoom updateMany
   */
  export type BreakoutRoomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BreakoutRooms.
     */
    data: XOR<BreakoutRoomUpdateManyMutationInput, BreakoutRoomUncheckedUpdateManyInput>
    /**
     * Filter which BreakoutRooms to update
     */
    where?: BreakoutRoomWhereInput
    /**
     * Limit how many BreakoutRooms to update.
     */
    limit?: number
  }

  /**
   * BreakoutRoom updateManyAndReturn
   */
  export type BreakoutRoomUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreakoutRoom
     */
    select?: BreakoutRoomSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BreakoutRoom
     */
    omit?: BreakoutRoomOmit<ExtArgs> | null
    /**
     * The data used to update BreakoutRooms.
     */
    data: XOR<BreakoutRoomUpdateManyMutationInput, BreakoutRoomUncheckedUpdateManyInput>
    /**
     * Filter which BreakoutRooms to update
     */
    where?: BreakoutRoomWhereInput
    /**
     * Limit how many BreakoutRooms to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreakoutRoomIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BreakoutRoom upsert
   */
  export type BreakoutRoomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreakoutRoom
     */
    select?: BreakoutRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BreakoutRoom
     */
    omit?: BreakoutRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreakoutRoomInclude<ExtArgs> | null
    /**
     * The filter to search for the BreakoutRoom to update in case it exists.
     */
    where: BreakoutRoomWhereUniqueInput
    /**
     * In case the BreakoutRoom found by the `where` argument doesn't exist, create a new BreakoutRoom with this data.
     */
    create: XOR<BreakoutRoomCreateInput, BreakoutRoomUncheckedCreateInput>
    /**
     * In case the BreakoutRoom was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BreakoutRoomUpdateInput, BreakoutRoomUncheckedUpdateInput>
  }

  /**
   * BreakoutRoom delete
   */
  export type BreakoutRoomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreakoutRoom
     */
    select?: BreakoutRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BreakoutRoom
     */
    omit?: BreakoutRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreakoutRoomInclude<ExtArgs> | null
    /**
     * Filter which BreakoutRoom to delete.
     */
    where: BreakoutRoomWhereUniqueInput
  }

  /**
   * BreakoutRoom deleteMany
   */
  export type BreakoutRoomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BreakoutRooms to delete
     */
    where?: BreakoutRoomWhereInput
    /**
     * Limit how many BreakoutRooms to delete.
     */
    limit?: number
  }

  /**
   * BreakoutRoom.participants
   */
  export type BreakoutRoom$participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceMember
     */
    select?: WorkspaceMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceMember
     */
    omit?: WorkspaceMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceMemberInclude<ExtArgs> | null
    where?: WorkspaceMemberWhereInput
    orderBy?: WorkspaceMemberOrderByWithRelationInput | WorkspaceMemberOrderByWithRelationInput[]
    cursor?: WorkspaceMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkspaceMemberScalarFieldEnum | WorkspaceMemberScalarFieldEnum[]
  }

  /**
   * BreakoutRoom without action
   */
  export type BreakoutRoomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreakoutRoom
     */
    select?: BreakoutRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BreakoutRoom
     */
    omit?: BreakoutRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreakoutRoomInclude<ExtArgs> | null
  }


  /**
   * Model LivePoll
   */

  export type AggregateLivePoll = {
    _count: LivePollCountAggregateOutputType | null
    _min: LivePollMinAggregateOutputType | null
    _max: LivePollMaxAggregateOutputType | null
  }

  export type LivePollMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    question: string | null
    createdAt: Date | null
    endedAt: Date | null
  }

  export type LivePollMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    question: string | null
    createdAt: Date | null
    endedAt: Date | null
  }

  export type LivePollCountAggregateOutputType = {
    id: number
    workspaceId: number
    question: number
    options: number
    createdAt: number
    endedAt: number
    _all: number
  }


  export type LivePollMinAggregateInputType = {
    id?: true
    workspaceId?: true
    question?: true
    createdAt?: true
    endedAt?: true
  }

  export type LivePollMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    question?: true
    createdAt?: true
    endedAt?: true
  }

  export type LivePollCountAggregateInputType = {
    id?: true
    workspaceId?: true
    question?: true
    options?: true
    createdAt?: true
    endedAt?: true
    _all?: true
  }

  export type LivePollAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LivePoll to aggregate.
     */
    where?: LivePollWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LivePolls to fetch.
     */
    orderBy?: LivePollOrderByWithRelationInput | LivePollOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LivePollWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LivePolls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LivePolls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LivePolls
    **/
    _count?: true | LivePollCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LivePollMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LivePollMaxAggregateInputType
  }

  export type GetLivePollAggregateType<T extends LivePollAggregateArgs> = {
        [P in keyof T & keyof AggregateLivePoll]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLivePoll[P]>
      : GetScalarType<T[P], AggregateLivePoll[P]>
  }




  export type LivePollGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LivePollWhereInput
    orderBy?: LivePollOrderByWithAggregationInput | LivePollOrderByWithAggregationInput[]
    by: LivePollScalarFieldEnum[] | LivePollScalarFieldEnum
    having?: LivePollScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LivePollCountAggregateInputType | true
    _min?: LivePollMinAggregateInputType
    _max?: LivePollMaxAggregateInputType
  }

  export type LivePollGroupByOutputType = {
    id: string
    workspaceId: string
    question: string
    options: JsonValue
    createdAt: Date
    endedAt: Date | null
    _count: LivePollCountAggregateOutputType | null
    _min: LivePollMinAggregateOutputType | null
    _max: LivePollMaxAggregateOutputType | null
  }

  type GetLivePollGroupByPayload<T extends LivePollGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LivePollGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LivePollGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LivePollGroupByOutputType[P]>
            : GetScalarType<T[P], LivePollGroupByOutputType[P]>
        }
      >
    >


  export type LivePollSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    question?: boolean
    options?: boolean
    createdAt?: boolean
    endedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    votes?: boolean | LivePoll$votesArgs<ExtArgs>
    _count?: boolean | LivePollCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["livePoll"]>

  export type LivePollSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    question?: boolean
    options?: boolean
    createdAt?: boolean
    endedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["livePoll"]>

  export type LivePollSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    question?: boolean
    options?: boolean
    createdAt?: boolean
    endedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["livePoll"]>

  export type LivePollSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    question?: boolean
    options?: boolean
    createdAt?: boolean
    endedAt?: boolean
  }

  export type LivePollOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workspaceId" | "question" | "options" | "createdAt" | "endedAt", ExtArgs["result"]["livePoll"]>
  export type LivePollInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    votes?: boolean | LivePoll$votesArgs<ExtArgs>
    _count?: boolean | LivePollCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LivePollIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type LivePollIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $LivePollPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LivePoll"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      votes: Prisma.$PollVotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      question: string
      options: Prisma.JsonValue
      createdAt: Date
      endedAt: Date | null
    }, ExtArgs["result"]["livePoll"]>
    composites: {}
  }

  type LivePollGetPayload<S extends boolean | null | undefined | LivePollDefaultArgs> = $Result.GetResult<Prisma.$LivePollPayload, S>

  type LivePollCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LivePollFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LivePollCountAggregateInputType | true
    }

  export interface LivePollDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LivePoll'], meta: { name: 'LivePoll' } }
    /**
     * Find zero or one LivePoll that matches the filter.
     * @param {LivePollFindUniqueArgs} args - Arguments to find a LivePoll
     * @example
     * // Get one LivePoll
     * const livePoll = await prisma.livePoll.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LivePollFindUniqueArgs>(args: SelectSubset<T, LivePollFindUniqueArgs<ExtArgs>>): Prisma__LivePollClient<$Result.GetResult<Prisma.$LivePollPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one LivePoll that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LivePollFindUniqueOrThrowArgs} args - Arguments to find a LivePoll
     * @example
     * // Get one LivePoll
     * const livePoll = await prisma.livePoll.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LivePollFindUniqueOrThrowArgs>(args: SelectSubset<T, LivePollFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LivePollClient<$Result.GetResult<Prisma.$LivePollPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first LivePoll that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LivePollFindFirstArgs} args - Arguments to find a LivePoll
     * @example
     * // Get one LivePoll
     * const livePoll = await prisma.livePoll.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LivePollFindFirstArgs>(args?: SelectSubset<T, LivePollFindFirstArgs<ExtArgs>>): Prisma__LivePollClient<$Result.GetResult<Prisma.$LivePollPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first LivePoll that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LivePollFindFirstOrThrowArgs} args - Arguments to find a LivePoll
     * @example
     * // Get one LivePoll
     * const livePoll = await prisma.livePoll.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LivePollFindFirstOrThrowArgs>(args?: SelectSubset<T, LivePollFindFirstOrThrowArgs<ExtArgs>>): Prisma__LivePollClient<$Result.GetResult<Prisma.$LivePollPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more LivePolls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LivePollFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LivePolls
     * const livePolls = await prisma.livePoll.findMany()
     * 
     * // Get first 10 LivePolls
     * const livePolls = await prisma.livePoll.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const livePollWithIdOnly = await prisma.livePoll.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LivePollFindManyArgs>(args?: SelectSubset<T, LivePollFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LivePollPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a LivePoll.
     * @param {LivePollCreateArgs} args - Arguments to create a LivePoll.
     * @example
     * // Create one LivePoll
     * const LivePoll = await prisma.livePoll.create({
     *   data: {
     *     // ... data to create a LivePoll
     *   }
     * })
     * 
     */
    create<T extends LivePollCreateArgs>(args: SelectSubset<T, LivePollCreateArgs<ExtArgs>>): Prisma__LivePollClient<$Result.GetResult<Prisma.$LivePollPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many LivePolls.
     * @param {LivePollCreateManyArgs} args - Arguments to create many LivePolls.
     * @example
     * // Create many LivePolls
     * const livePoll = await prisma.livePoll.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LivePollCreateManyArgs>(args?: SelectSubset<T, LivePollCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LivePolls and returns the data saved in the database.
     * @param {LivePollCreateManyAndReturnArgs} args - Arguments to create many LivePolls.
     * @example
     * // Create many LivePolls
     * const livePoll = await prisma.livePoll.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LivePolls and only return the `id`
     * const livePollWithIdOnly = await prisma.livePoll.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LivePollCreateManyAndReturnArgs>(args?: SelectSubset<T, LivePollCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LivePollPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a LivePoll.
     * @param {LivePollDeleteArgs} args - Arguments to delete one LivePoll.
     * @example
     * // Delete one LivePoll
     * const LivePoll = await prisma.livePoll.delete({
     *   where: {
     *     // ... filter to delete one LivePoll
     *   }
     * })
     * 
     */
    delete<T extends LivePollDeleteArgs>(args: SelectSubset<T, LivePollDeleteArgs<ExtArgs>>): Prisma__LivePollClient<$Result.GetResult<Prisma.$LivePollPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one LivePoll.
     * @param {LivePollUpdateArgs} args - Arguments to update one LivePoll.
     * @example
     * // Update one LivePoll
     * const livePoll = await prisma.livePoll.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LivePollUpdateArgs>(args: SelectSubset<T, LivePollUpdateArgs<ExtArgs>>): Prisma__LivePollClient<$Result.GetResult<Prisma.$LivePollPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more LivePolls.
     * @param {LivePollDeleteManyArgs} args - Arguments to filter LivePolls to delete.
     * @example
     * // Delete a few LivePolls
     * const { count } = await prisma.livePoll.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LivePollDeleteManyArgs>(args?: SelectSubset<T, LivePollDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LivePolls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LivePollUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LivePolls
     * const livePoll = await prisma.livePoll.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LivePollUpdateManyArgs>(args: SelectSubset<T, LivePollUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LivePolls and returns the data updated in the database.
     * @param {LivePollUpdateManyAndReturnArgs} args - Arguments to update many LivePolls.
     * @example
     * // Update many LivePolls
     * const livePoll = await prisma.livePoll.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LivePolls and only return the `id`
     * const livePollWithIdOnly = await prisma.livePoll.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LivePollUpdateManyAndReturnArgs>(args: SelectSubset<T, LivePollUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LivePollPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one LivePoll.
     * @param {LivePollUpsertArgs} args - Arguments to update or create a LivePoll.
     * @example
     * // Update or create a LivePoll
     * const livePoll = await prisma.livePoll.upsert({
     *   create: {
     *     // ... data to create a LivePoll
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LivePoll we want to update
     *   }
     * })
     */
    upsert<T extends LivePollUpsertArgs>(args: SelectSubset<T, LivePollUpsertArgs<ExtArgs>>): Prisma__LivePollClient<$Result.GetResult<Prisma.$LivePollPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of LivePolls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LivePollCountArgs} args - Arguments to filter LivePolls to count.
     * @example
     * // Count the number of LivePolls
     * const count = await prisma.livePoll.count({
     *   where: {
     *     // ... the filter for the LivePolls we want to count
     *   }
     * })
    **/
    count<T extends LivePollCountArgs>(
      args?: Subset<T, LivePollCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LivePollCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LivePoll.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LivePollAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LivePollAggregateArgs>(args: Subset<T, LivePollAggregateArgs>): Prisma.PrismaPromise<GetLivePollAggregateType<T>>

    /**
     * Group by LivePoll.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LivePollGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LivePollGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LivePollGroupByArgs['orderBy'] }
        : { orderBy?: LivePollGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LivePollGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLivePollGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LivePoll model
   */
  readonly fields: LivePollFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LivePoll.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LivePollClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    votes<T extends LivePoll$votesArgs<ExtArgs> = {}>(args?: Subset<T, LivePoll$votesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PollVotePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LivePoll model
   */ 
  interface LivePollFieldRefs {
    readonly id: FieldRef<"LivePoll", 'String'>
    readonly workspaceId: FieldRef<"LivePoll", 'String'>
    readonly question: FieldRef<"LivePoll", 'String'>
    readonly options: FieldRef<"LivePoll", 'Json'>
    readonly createdAt: FieldRef<"LivePoll", 'DateTime'>
    readonly endedAt: FieldRef<"LivePoll", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LivePoll findUnique
   */
  export type LivePollFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LivePoll
     */
    select?: LivePollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LivePoll
     */
    omit?: LivePollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivePollInclude<ExtArgs> | null
    /**
     * Filter, which LivePoll to fetch.
     */
    where: LivePollWhereUniqueInput
  }

  /**
   * LivePoll findUniqueOrThrow
   */
  export type LivePollFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LivePoll
     */
    select?: LivePollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LivePoll
     */
    omit?: LivePollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivePollInclude<ExtArgs> | null
    /**
     * Filter, which LivePoll to fetch.
     */
    where: LivePollWhereUniqueInput
  }

  /**
   * LivePoll findFirst
   */
  export type LivePollFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LivePoll
     */
    select?: LivePollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LivePoll
     */
    omit?: LivePollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivePollInclude<ExtArgs> | null
    /**
     * Filter, which LivePoll to fetch.
     */
    where?: LivePollWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LivePolls to fetch.
     */
    orderBy?: LivePollOrderByWithRelationInput | LivePollOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LivePolls.
     */
    cursor?: LivePollWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LivePolls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LivePolls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LivePolls.
     */
    distinct?: LivePollScalarFieldEnum | LivePollScalarFieldEnum[]
  }

  /**
   * LivePoll findFirstOrThrow
   */
  export type LivePollFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LivePoll
     */
    select?: LivePollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LivePoll
     */
    omit?: LivePollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivePollInclude<ExtArgs> | null
    /**
     * Filter, which LivePoll to fetch.
     */
    where?: LivePollWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LivePolls to fetch.
     */
    orderBy?: LivePollOrderByWithRelationInput | LivePollOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LivePolls.
     */
    cursor?: LivePollWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LivePolls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LivePolls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LivePolls.
     */
    distinct?: LivePollScalarFieldEnum | LivePollScalarFieldEnum[]
  }

  /**
   * LivePoll findMany
   */
  export type LivePollFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LivePoll
     */
    select?: LivePollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LivePoll
     */
    omit?: LivePollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivePollInclude<ExtArgs> | null
    /**
     * Filter, which LivePolls to fetch.
     */
    where?: LivePollWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LivePolls to fetch.
     */
    orderBy?: LivePollOrderByWithRelationInput | LivePollOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LivePolls.
     */
    cursor?: LivePollWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LivePolls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LivePolls.
     */
    skip?: number
    distinct?: LivePollScalarFieldEnum | LivePollScalarFieldEnum[]
  }

  /**
   * LivePoll create
   */
  export type LivePollCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LivePoll
     */
    select?: LivePollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LivePoll
     */
    omit?: LivePollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivePollInclude<ExtArgs> | null
    /**
     * The data needed to create a LivePoll.
     */
    data: XOR<LivePollCreateInput, LivePollUncheckedCreateInput>
  }

  /**
   * LivePoll createMany
   */
  export type LivePollCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LivePolls.
     */
    data: LivePollCreateManyInput | LivePollCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LivePoll createManyAndReturn
   */
  export type LivePollCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LivePoll
     */
    select?: LivePollSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LivePoll
     */
    omit?: LivePollOmit<ExtArgs> | null
    /**
     * The data used to create many LivePolls.
     */
    data: LivePollCreateManyInput | LivePollCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivePollIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LivePoll update
   */
  export type LivePollUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LivePoll
     */
    select?: LivePollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LivePoll
     */
    omit?: LivePollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivePollInclude<ExtArgs> | null
    /**
     * The data needed to update a LivePoll.
     */
    data: XOR<LivePollUpdateInput, LivePollUncheckedUpdateInput>
    /**
     * Choose, which LivePoll to update.
     */
    where: LivePollWhereUniqueInput
  }

  /**
   * LivePoll updateMany
   */
  export type LivePollUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LivePolls.
     */
    data: XOR<LivePollUpdateManyMutationInput, LivePollUncheckedUpdateManyInput>
    /**
     * Filter which LivePolls to update
     */
    where?: LivePollWhereInput
    /**
     * Limit how many LivePolls to update.
     */
    limit?: number
  }

  /**
   * LivePoll updateManyAndReturn
   */
  export type LivePollUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LivePoll
     */
    select?: LivePollSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LivePoll
     */
    omit?: LivePollOmit<ExtArgs> | null
    /**
     * The data used to update LivePolls.
     */
    data: XOR<LivePollUpdateManyMutationInput, LivePollUncheckedUpdateManyInput>
    /**
     * Filter which LivePolls to update
     */
    where?: LivePollWhereInput
    /**
     * Limit how many LivePolls to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivePollIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LivePoll upsert
   */
  export type LivePollUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LivePoll
     */
    select?: LivePollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LivePoll
     */
    omit?: LivePollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivePollInclude<ExtArgs> | null
    /**
     * The filter to search for the LivePoll to update in case it exists.
     */
    where: LivePollWhereUniqueInput
    /**
     * In case the LivePoll found by the `where` argument doesn't exist, create a new LivePoll with this data.
     */
    create: XOR<LivePollCreateInput, LivePollUncheckedCreateInput>
    /**
     * In case the LivePoll was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LivePollUpdateInput, LivePollUncheckedUpdateInput>
  }

  /**
   * LivePoll delete
   */
  export type LivePollDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LivePoll
     */
    select?: LivePollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LivePoll
     */
    omit?: LivePollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivePollInclude<ExtArgs> | null
    /**
     * Filter which LivePoll to delete.
     */
    where: LivePollWhereUniqueInput
  }

  /**
   * LivePoll deleteMany
   */
  export type LivePollDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LivePolls to delete
     */
    where?: LivePollWhereInput
    /**
     * Limit how many LivePolls to delete.
     */
    limit?: number
  }

  /**
   * LivePoll.votes
   */
  export type LivePoll$votesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollVote
     */
    select?: PollVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PollVote
     */
    omit?: PollVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollVoteInclude<ExtArgs> | null
    where?: PollVoteWhereInput
    orderBy?: PollVoteOrderByWithRelationInput | PollVoteOrderByWithRelationInput[]
    cursor?: PollVoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PollVoteScalarFieldEnum | PollVoteScalarFieldEnum[]
  }

  /**
   * LivePoll without action
   */
  export type LivePollDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LivePoll
     */
    select?: LivePollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LivePoll
     */
    omit?: LivePollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivePollInclude<ExtArgs> | null
  }


  /**
   * Model PollVote
   */

  export type AggregatePollVote = {
    _count: PollVoteCountAggregateOutputType | null
    _min: PollVoteMinAggregateOutputType | null
    _max: PollVoteMaxAggregateOutputType | null
  }

  export type PollVoteMinAggregateOutputType = {
    id: string | null
    livePoolId: string | null
    userId: string | null
    option: string | null
    createdAt: Date | null
  }

  export type PollVoteMaxAggregateOutputType = {
    id: string | null
    livePoolId: string | null
    userId: string | null
    option: string | null
    createdAt: Date | null
  }

  export type PollVoteCountAggregateOutputType = {
    id: number
    livePoolId: number
    userId: number
    option: number
    createdAt: number
    _all: number
  }


  export type PollVoteMinAggregateInputType = {
    id?: true
    livePoolId?: true
    userId?: true
    option?: true
    createdAt?: true
  }

  export type PollVoteMaxAggregateInputType = {
    id?: true
    livePoolId?: true
    userId?: true
    option?: true
    createdAt?: true
  }

  export type PollVoteCountAggregateInputType = {
    id?: true
    livePoolId?: true
    userId?: true
    option?: true
    createdAt?: true
    _all?: true
  }

  export type PollVoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PollVote to aggregate.
     */
    where?: PollVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PollVotes to fetch.
     */
    orderBy?: PollVoteOrderByWithRelationInput | PollVoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PollVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PollVotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PollVotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PollVotes
    **/
    _count?: true | PollVoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PollVoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PollVoteMaxAggregateInputType
  }

  export type GetPollVoteAggregateType<T extends PollVoteAggregateArgs> = {
        [P in keyof T & keyof AggregatePollVote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePollVote[P]>
      : GetScalarType<T[P], AggregatePollVote[P]>
  }




  export type PollVoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PollVoteWhereInput
    orderBy?: PollVoteOrderByWithAggregationInput | PollVoteOrderByWithAggregationInput[]
    by: PollVoteScalarFieldEnum[] | PollVoteScalarFieldEnum
    having?: PollVoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PollVoteCountAggregateInputType | true
    _min?: PollVoteMinAggregateInputType
    _max?: PollVoteMaxAggregateInputType
  }

  export type PollVoteGroupByOutputType = {
    id: string
    livePoolId: string
    userId: string
    option: string
    createdAt: Date
    _count: PollVoteCountAggregateOutputType | null
    _min: PollVoteMinAggregateOutputType | null
    _max: PollVoteMaxAggregateOutputType | null
  }

  type GetPollVoteGroupByPayload<T extends PollVoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PollVoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PollVoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PollVoteGroupByOutputType[P]>
            : GetScalarType<T[P], PollVoteGroupByOutputType[P]>
        }
      >
    >


  export type PollVoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    livePoolId?: boolean
    userId?: boolean
    option?: boolean
    createdAt?: boolean
    livePoll?: boolean | LivePollDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pollVote"]>

  export type PollVoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    livePoolId?: boolean
    userId?: boolean
    option?: boolean
    createdAt?: boolean
    livePoll?: boolean | LivePollDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pollVote"]>

  export type PollVoteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    livePoolId?: boolean
    userId?: boolean
    option?: boolean
    createdAt?: boolean
    livePoll?: boolean | LivePollDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pollVote"]>

  export type PollVoteSelectScalar = {
    id?: boolean
    livePoolId?: boolean
    userId?: boolean
    option?: boolean
    createdAt?: boolean
  }

  export type PollVoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "livePoolId" | "userId" | "option" | "createdAt", ExtArgs["result"]["pollVote"]>
  export type PollVoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    livePoll?: boolean | LivePollDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PollVoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    livePoll?: boolean | LivePollDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PollVoteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    livePoll?: boolean | LivePollDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PollVotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PollVote"
    objects: {
      livePoll: Prisma.$LivePollPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      livePoolId: string
      userId: string
      option: string
      createdAt: Date
    }, ExtArgs["result"]["pollVote"]>
    composites: {}
  }

  type PollVoteGetPayload<S extends boolean | null | undefined | PollVoteDefaultArgs> = $Result.GetResult<Prisma.$PollVotePayload, S>

  type PollVoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PollVoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PollVoteCountAggregateInputType | true
    }

  export interface PollVoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PollVote'], meta: { name: 'PollVote' } }
    /**
     * Find zero or one PollVote that matches the filter.
     * @param {PollVoteFindUniqueArgs} args - Arguments to find a PollVote
     * @example
     * // Get one PollVote
     * const pollVote = await prisma.pollVote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PollVoteFindUniqueArgs>(args: SelectSubset<T, PollVoteFindUniqueArgs<ExtArgs>>): Prisma__PollVoteClient<$Result.GetResult<Prisma.$PollVotePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one PollVote that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PollVoteFindUniqueOrThrowArgs} args - Arguments to find a PollVote
     * @example
     * // Get one PollVote
     * const pollVote = await prisma.pollVote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PollVoteFindUniqueOrThrowArgs>(args: SelectSubset<T, PollVoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PollVoteClient<$Result.GetResult<Prisma.$PollVotePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first PollVote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollVoteFindFirstArgs} args - Arguments to find a PollVote
     * @example
     * // Get one PollVote
     * const pollVote = await prisma.pollVote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PollVoteFindFirstArgs>(args?: SelectSubset<T, PollVoteFindFirstArgs<ExtArgs>>): Prisma__PollVoteClient<$Result.GetResult<Prisma.$PollVotePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first PollVote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollVoteFindFirstOrThrowArgs} args - Arguments to find a PollVote
     * @example
     * // Get one PollVote
     * const pollVote = await prisma.pollVote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PollVoteFindFirstOrThrowArgs>(args?: SelectSubset<T, PollVoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__PollVoteClient<$Result.GetResult<Prisma.$PollVotePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more PollVotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollVoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PollVotes
     * const pollVotes = await prisma.pollVote.findMany()
     * 
     * // Get first 10 PollVotes
     * const pollVotes = await prisma.pollVote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pollVoteWithIdOnly = await prisma.pollVote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PollVoteFindManyArgs>(args?: SelectSubset<T, PollVoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PollVotePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a PollVote.
     * @param {PollVoteCreateArgs} args - Arguments to create a PollVote.
     * @example
     * // Create one PollVote
     * const PollVote = await prisma.pollVote.create({
     *   data: {
     *     // ... data to create a PollVote
     *   }
     * })
     * 
     */
    create<T extends PollVoteCreateArgs>(args: SelectSubset<T, PollVoteCreateArgs<ExtArgs>>): Prisma__PollVoteClient<$Result.GetResult<Prisma.$PollVotePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many PollVotes.
     * @param {PollVoteCreateManyArgs} args - Arguments to create many PollVotes.
     * @example
     * // Create many PollVotes
     * const pollVote = await prisma.pollVote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PollVoteCreateManyArgs>(args?: SelectSubset<T, PollVoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PollVotes and returns the data saved in the database.
     * @param {PollVoteCreateManyAndReturnArgs} args - Arguments to create many PollVotes.
     * @example
     * // Create many PollVotes
     * const pollVote = await prisma.pollVote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PollVotes and only return the `id`
     * const pollVoteWithIdOnly = await prisma.pollVote.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PollVoteCreateManyAndReturnArgs>(args?: SelectSubset<T, PollVoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PollVotePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a PollVote.
     * @param {PollVoteDeleteArgs} args - Arguments to delete one PollVote.
     * @example
     * // Delete one PollVote
     * const PollVote = await prisma.pollVote.delete({
     *   where: {
     *     // ... filter to delete one PollVote
     *   }
     * })
     * 
     */
    delete<T extends PollVoteDeleteArgs>(args: SelectSubset<T, PollVoteDeleteArgs<ExtArgs>>): Prisma__PollVoteClient<$Result.GetResult<Prisma.$PollVotePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one PollVote.
     * @param {PollVoteUpdateArgs} args - Arguments to update one PollVote.
     * @example
     * // Update one PollVote
     * const pollVote = await prisma.pollVote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PollVoteUpdateArgs>(args: SelectSubset<T, PollVoteUpdateArgs<ExtArgs>>): Prisma__PollVoteClient<$Result.GetResult<Prisma.$PollVotePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more PollVotes.
     * @param {PollVoteDeleteManyArgs} args - Arguments to filter PollVotes to delete.
     * @example
     * // Delete a few PollVotes
     * const { count } = await prisma.pollVote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PollVoteDeleteManyArgs>(args?: SelectSubset<T, PollVoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PollVotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollVoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PollVotes
     * const pollVote = await prisma.pollVote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PollVoteUpdateManyArgs>(args: SelectSubset<T, PollVoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PollVotes and returns the data updated in the database.
     * @param {PollVoteUpdateManyAndReturnArgs} args - Arguments to update many PollVotes.
     * @example
     * // Update many PollVotes
     * const pollVote = await prisma.pollVote.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PollVotes and only return the `id`
     * const pollVoteWithIdOnly = await prisma.pollVote.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PollVoteUpdateManyAndReturnArgs>(args: SelectSubset<T, PollVoteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PollVotePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one PollVote.
     * @param {PollVoteUpsertArgs} args - Arguments to update or create a PollVote.
     * @example
     * // Update or create a PollVote
     * const pollVote = await prisma.pollVote.upsert({
     *   create: {
     *     // ... data to create a PollVote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PollVote we want to update
     *   }
     * })
     */
    upsert<T extends PollVoteUpsertArgs>(args: SelectSubset<T, PollVoteUpsertArgs<ExtArgs>>): Prisma__PollVoteClient<$Result.GetResult<Prisma.$PollVotePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of PollVotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollVoteCountArgs} args - Arguments to filter PollVotes to count.
     * @example
     * // Count the number of PollVotes
     * const count = await prisma.pollVote.count({
     *   where: {
     *     // ... the filter for the PollVotes we want to count
     *   }
     * })
    **/
    count<T extends PollVoteCountArgs>(
      args?: Subset<T, PollVoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PollVoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PollVote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollVoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PollVoteAggregateArgs>(args: Subset<T, PollVoteAggregateArgs>): Prisma.PrismaPromise<GetPollVoteAggregateType<T>>

    /**
     * Group by PollVote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollVoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PollVoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PollVoteGroupByArgs['orderBy'] }
        : { orderBy?: PollVoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PollVoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPollVoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PollVote model
   */
  readonly fields: PollVoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PollVote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PollVoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    livePoll<T extends LivePollDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LivePollDefaultArgs<ExtArgs>>): Prisma__LivePollClient<$Result.GetResult<Prisma.$LivePollPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PollVote model
   */ 
  interface PollVoteFieldRefs {
    readonly id: FieldRef<"PollVote", 'String'>
    readonly livePoolId: FieldRef<"PollVote", 'String'>
    readonly userId: FieldRef<"PollVote", 'String'>
    readonly option: FieldRef<"PollVote", 'String'>
    readonly createdAt: FieldRef<"PollVote", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PollVote findUnique
   */
  export type PollVoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollVote
     */
    select?: PollVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PollVote
     */
    omit?: PollVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollVoteInclude<ExtArgs> | null
    /**
     * Filter, which PollVote to fetch.
     */
    where: PollVoteWhereUniqueInput
  }

  /**
   * PollVote findUniqueOrThrow
   */
  export type PollVoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollVote
     */
    select?: PollVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PollVote
     */
    omit?: PollVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollVoteInclude<ExtArgs> | null
    /**
     * Filter, which PollVote to fetch.
     */
    where: PollVoteWhereUniqueInput
  }

  /**
   * PollVote findFirst
   */
  export type PollVoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollVote
     */
    select?: PollVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PollVote
     */
    omit?: PollVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollVoteInclude<ExtArgs> | null
    /**
     * Filter, which PollVote to fetch.
     */
    where?: PollVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PollVotes to fetch.
     */
    orderBy?: PollVoteOrderByWithRelationInput | PollVoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PollVotes.
     */
    cursor?: PollVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PollVotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PollVotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PollVotes.
     */
    distinct?: PollVoteScalarFieldEnum | PollVoteScalarFieldEnum[]
  }

  /**
   * PollVote findFirstOrThrow
   */
  export type PollVoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollVote
     */
    select?: PollVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PollVote
     */
    omit?: PollVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollVoteInclude<ExtArgs> | null
    /**
     * Filter, which PollVote to fetch.
     */
    where?: PollVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PollVotes to fetch.
     */
    orderBy?: PollVoteOrderByWithRelationInput | PollVoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PollVotes.
     */
    cursor?: PollVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PollVotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PollVotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PollVotes.
     */
    distinct?: PollVoteScalarFieldEnum | PollVoteScalarFieldEnum[]
  }

  /**
   * PollVote findMany
   */
  export type PollVoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollVote
     */
    select?: PollVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PollVote
     */
    omit?: PollVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollVoteInclude<ExtArgs> | null
    /**
     * Filter, which PollVotes to fetch.
     */
    where?: PollVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PollVotes to fetch.
     */
    orderBy?: PollVoteOrderByWithRelationInput | PollVoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PollVotes.
     */
    cursor?: PollVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PollVotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PollVotes.
     */
    skip?: number
    distinct?: PollVoteScalarFieldEnum | PollVoteScalarFieldEnum[]
  }

  /**
   * PollVote create
   */
  export type PollVoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollVote
     */
    select?: PollVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PollVote
     */
    omit?: PollVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollVoteInclude<ExtArgs> | null
    /**
     * The data needed to create a PollVote.
     */
    data: XOR<PollVoteCreateInput, PollVoteUncheckedCreateInput>
  }

  /**
   * PollVote createMany
   */
  export type PollVoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PollVotes.
     */
    data: PollVoteCreateManyInput | PollVoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PollVote createManyAndReturn
   */
  export type PollVoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollVote
     */
    select?: PollVoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PollVote
     */
    omit?: PollVoteOmit<ExtArgs> | null
    /**
     * The data used to create many PollVotes.
     */
    data: PollVoteCreateManyInput | PollVoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollVoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PollVote update
   */
  export type PollVoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollVote
     */
    select?: PollVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PollVote
     */
    omit?: PollVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollVoteInclude<ExtArgs> | null
    /**
     * The data needed to update a PollVote.
     */
    data: XOR<PollVoteUpdateInput, PollVoteUncheckedUpdateInput>
    /**
     * Choose, which PollVote to update.
     */
    where: PollVoteWhereUniqueInput
  }

  /**
   * PollVote updateMany
   */
  export type PollVoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PollVotes.
     */
    data: XOR<PollVoteUpdateManyMutationInput, PollVoteUncheckedUpdateManyInput>
    /**
     * Filter which PollVotes to update
     */
    where?: PollVoteWhereInput
    /**
     * Limit how many PollVotes to update.
     */
    limit?: number
  }

  /**
   * PollVote updateManyAndReturn
   */
  export type PollVoteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollVote
     */
    select?: PollVoteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PollVote
     */
    omit?: PollVoteOmit<ExtArgs> | null
    /**
     * The data used to update PollVotes.
     */
    data: XOR<PollVoteUpdateManyMutationInput, PollVoteUncheckedUpdateManyInput>
    /**
     * Filter which PollVotes to update
     */
    where?: PollVoteWhereInput
    /**
     * Limit how many PollVotes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollVoteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PollVote upsert
   */
  export type PollVoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollVote
     */
    select?: PollVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PollVote
     */
    omit?: PollVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollVoteInclude<ExtArgs> | null
    /**
     * The filter to search for the PollVote to update in case it exists.
     */
    where: PollVoteWhereUniqueInput
    /**
     * In case the PollVote found by the `where` argument doesn't exist, create a new PollVote with this data.
     */
    create: XOR<PollVoteCreateInput, PollVoteUncheckedCreateInput>
    /**
     * In case the PollVote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PollVoteUpdateInput, PollVoteUncheckedUpdateInput>
  }

  /**
   * PollVote delete
   */
  export type PollVoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollVote
     */
    select?: PollVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PollVote
     */
    omit?: PollVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollVoteInclude<ExtArgs> | null
    /**
     * Filter which PollVote to delete.
     */
    where: PollVoteWhereUniqueInput
  }

  /**
   * PollVote deleteMany
   */
  export type PollVoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PollVotes to delete
     */
    where?: PollVoteWhereInput
    /**
     * Limit how many PollVotes to delete.
     */
    limit?: number
  }

  /**
   * PollVote without action
   */
  export type PollVoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollVote
     */
    select?: PollVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PollVote
     */
    omit?: PollVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollVoteInclude<ExtArgs> | null
  }


  /**
   * Model SessionSummary
   */

  export type AggregateSessionSummary = {
    _count: SessionSummaryCountAggregateOutputType | null
    _min: SessionSummaryMinAggregateOutputType | null
    _max: SessionSummaryMaxAggregateOutputType | null
  }

  export type SessionSummaryMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    content: string | null
    createdAt: Date | null
    createdBy: string | null
  }

  export type SessionSummaryMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    content: string | null
    createdAt: Date | null
    createdBy: string | null
  }

  export type SessionSummaryCountAggregateOutputType = {
    id: number
    workspaceId: number
    content: number
    createdAt: number
    createdBy: number
    _all: number
  }


  export type SessionSummaryMinAggregateInputType = {
    id?: true
    workspaceId?: true
    content?: true
    createdAt?: true
    createdBy?: true
  }

  export type SessionSummaryMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    content?: true
    createdAt?: true
    createdBy?: true
  }

  export type SessionSummaryCountAggregateInputType = {
    id?: true
    workspaceId?: true
    content?: true
    createdAt?: true
    createdBy?: true
    _all?: true
  }

  export type SessionSummaryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionSummary to aggregate.
     */
    where?: SessionSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionSummaries to fetch.
     */
    orderBy?: SessionSummaryOrderByWithRelationInput | SessionSummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionSummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SessionSummaries
    **/
    _count?: true | SessionSummaryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionSummaryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionSummaryMaxAggregateInputType
  }

  export type GetSessionSummaryAggregateType<T extends SessionSummaryAggregateArgs> = {
        [P in keyof T & keyof AggregateSessionSummary]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSessionSummary[P]>
      : GetScalarType<T[P], AggregateSessionSummary[P]>
  }




  export type SessionSummaryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionSummaryWhereInput
    orderBy?: SessionSummaryOrderByWithAggregationInput | SessionSummaryOrderByWithAggregationInput[]
    by: SessionSummaryScalarFieldEnum[] | SessionSummaryScalarFieldEnum
    having?: SessionSummaryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionSummaryCountAggregateInputType | true
    _min?: SessionSummaryMinAggregateInputType
    _max?: SessionSummaryMaxAggregateInputType
  }

  export type SessionSummaryGroupByOutputType = {
    id: string
    workspaceId: string
    content: string
    createdAt: Date
    createdBy: string
    _count: SessionSummaryCountAggregateOutputType | null
    _min: SessionSummaryMinAggregateOutputType | null
    _max: SessionSummaryMaxAggregateOutputType | null
  }

  type GetSessionSummaryGroupByPayload<T extends SessionSummaryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionSummaryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionSummaryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionSummaryGroupByOutputType[P]>
            : GetScalarType<T[P], SessionSummaryGroupByOutputType[P]>
        }
      >
    >


  export type SessionSummarySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    content?: boolean
    createdAt?: boolean
    createdBy?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionSummary"]>

  export type SessionSummarySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    content?: boolean
    createdAt?: boolean
    createdBy?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionSummary"]>

  export type SessionSummarySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    content?: boolean
    createdAt?: boolean
    createdBy?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionSummary"]>

  export type SessionSummarySelectScalar = {
    id?: boolean
    workspaceId?: boolean
    content?: boolean
    createdAt?: boolean
    createdBy?: boolean
  }

  export type SessionSummaryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workspaceId" | "content" | "createdAt" | "createdBy", ExtArgs["result"]["sessionSummary"]>
  export type SessionSummaryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type SessionSummaryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type SessionSummaryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $SessionSummaryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SessionSummary"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      content: string
      createdAt: Date
      createdBy: string
    }, ExtArgs["result"]["sessionSummary"]>
    composites: {}
  }

  type SessionSummaryGetPayload<S extends boolean | null | undefined | SessionSummaryDefaultArgs> = $Result.GetResult<Prisma.$SessionSummaryPayload, S>

  type SessionSummaryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionSummaryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionSummaryCountAggregateInputType | true
    }

  export interface SessionSummaryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SessionSummary'], meta: { name: 'SessionSummary' } }
    /**
     * Find zero or one SessionSummary that matches the filter.
     * @param {SessionSummaryFindUniqueArgs} args - Arguments to find a SessionSummary
     * @example
     * // Get one SessionSummary
     * const sessionSummary = await prisma.sessionSummary.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionSummaryFindUniqueArgs>(args: SelectSubset<T, SessionSummaryFindUniqueArgs<ExtArgs>>): Prisma__SessionSummaryClient<$Result.GetResult<Prisma.$SessionSummaryPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one SessionSummary that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionSummaryFindUniqueOrThrowArgs} args - Arguments to find a SessionSummary
     * @example
     * // Get one SessionSummary
     * const sessionSummary = await prisma.sessionSummary.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionSummaryFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionSummaryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionSummaryClient<$Result.GetResult<Prisma.$SessionSummaryPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first SessionSummary that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionSummaryFindFirstArgs} args - Arguments to find a SessionSummary
     * @example
     * // Get one SessionSummary
     * const sessionSummary = await prisma.sessionSummary.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionSummaryFindFirstArgs>(args?: SelectSubset<T, SessionSummaryFindFirstArgs<ExtArgs>>): Prisma__SessionSummaryClient<$Result.GetResult<Prisma.$SessionSummaryPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first SessionSummary that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionSummaryFindFirstOrThrowArgs} args - Arguments to find a SessionSummary
     * @example
     * // Get one SessionSummary
     * const sessionSummary = await prisma.sessionSummary.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionSummaryFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionSummaryFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionSummaryClient<$Result.GetResult<Prisma.$SessionSummaryPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more SessionSummaries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionSummaryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SessionSummaries
     * const sessionSummaries = await prisma.sessionSummary.findMany()
     * 
     * // Get first 10 SessionSummaries
     * const sessionSummaries = await prisma.sessionSummary.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionSummaryWithIdOnly = await prisma.sessionSummary.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionSummaryFindManyArgs>(args?: SelectSubset<T, SessionSummaryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionSummaryPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a SessionSummary.
     * @param {SessionSummaryCreateArgs} args - Arguments to create a SessionSummary.
     * @example
     * // Create one SessionSummary
     * const SessionSummary = await prisma.sessionSummary.create({
     *   data: {
     *     // ... data to create a SessionSummary
     *   }
     * })
     * 
     */
    create<T extends SessionSummaryCreateArgs>(args: SelectSubset<T, SessionSummaryCreateArgs<ExtArgs>>): Prisma__SessionSummaryClient<$Result.GetResult<Prisma.$SessionSummaryPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many SessionSummaries.
     * @param {SessionSummaryCreateManyArgs} args - Arguments to create many SessionSummaries.
     * @example
     * // Create many SessionSummaries
     * const sessionSummary = await prisma.sessionSummary.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionSummaryCreateManyArgs>(args?: SelectSubset<T, SessionSummaryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SessionSummaries and returns the data saved in the database.
     * @param {SessionSummaryCreateManyAndReturnArgs} args - Arguments to create many SessionSummaries.
     * @example
     * // Create many SessionSummaries
     * const sessionSummary = await prisma.sessionSummary.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SessionSummaries and only return the `id`
     * const sessionSummaryWithIdOnly = await prisma.sessionSummary.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionSummaryCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionSummaryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionSummaryPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a SessionSummary.
     * @param {SessionSummaryDeleteArgs} args - Arguments to delete one SessionSummary.
     * @example
     * // Delete one SessionSummary
     * const SessionSummary = await prisma.sessionSummary.delete({
     *   where: {
     *     // ... filter to delete one SessionSummary
     *   }
     * })
     * 
     */
    delete<T extends SessionSummaryDeleteArgs>(args: SelectSubset<T, SessionSummaryDeleteArgs<ExtArgs>>): Prisma__SessionSummaryClient<$Result.GetResult<Prisma.$SessionSummaryPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one SessionSummary.
     * @param {SessionSummaryUpdateArgs} args - Arguments to update one SessionSummary.
     * @example
     * // Update one SessionSummary
     * const sessionSummary = await prisma.sessionSummary.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionSummaryUpdateArgs>(args: SelectSubset<T, SessionSummaryUpdateArgs<ExtArgs>>): Prisma__SessionSummaryClient<$Result.GetResult<Prisma.$SessionSummaryPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more SessionSummaries.
     * @param {SessionSummaryDeleteManyArgs} args - Arguments to filter SessionSummaries to delete.
     * @example
     * // Delete a few SessionSummaries
     * const { count } = await prisma.sessionSummary.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionSummaryDeleteManyArgs>(args?: SelectSubset<T, SessionSummaryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SessionSummaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionSummaryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SessionSummaries
     * const sessionSummary = await prisma.sessionSummary.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionSummaryUpdateManyArgs>(args: SelectSubset<T, SessionSummaryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SessionSummaries and returns the data updated in the database.
     * @param {SessionSummaryUpdateManyAndReturnArgs} args - Arguments to update many SessionSummaries.
     * @example
     * // Update many SessionSummaries
     * const sessionSummary = await prisma.sessionSummary.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SessionSummaries and only return the `id`
     * const sessionSummaryWithIdOnly = await prisma.sessionSummary.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionSummaryUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionSummaryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionSummaryPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one SessionSummary.
     * @param {SessionSummaryUpsertArgs} args - Arguments to update or create a SessionSummary.
     * @example
     * // Update or create a SessionSummary
     * const sessionSummary = await prisma.sessionSummary.upsert({
     *   create: {
     *     // ... data to create a SessionSummary
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SessionSummary we want to update
     *   }
     * })
     */
    upsert<T extends SessionSummaryUpsertArgs>(args: SelectSubset<T, SessionSummaryUpsertArgs<ExtArgs>>): Prisma__SessionSummaryClient<$Result.GetResult<Prisma.$SessionSummaryPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of SessionSummaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionSummaryCountArgs} args - Arguments to filter SessionSummaries to count.
     * @example
     * // Count the number of SessionSummaries
     * const count = await prisma.sessionSummary.count({
     *   where: {
     *     // ... the filter for the SessionSummaries we want to count
     *   }
     * })
    **/
    count<T extends SessionSummaryCountArgs>(
      args?: Subset<T, SessionSummaryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionSummaryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SessionSummary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionSummaryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionSummaryAggregateArgs>(args: Subset<T, SessionSummaryAggregateArgs>): Prisma.PrismaPromise<GetSessionSummaryAggregateType<T>>

    /**
     * Group by SessionSummary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionSummaryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionSummaryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionSummaryGroupByArgs['orderBy'] }
        : { orderBy?: SessionSummaryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionSummaryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionSummaryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SessionSummary model
   */
  readonly fields: SessionSummaryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SessionSummary.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionSummaryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SessionSummary model
   */ 
  interface SessionSummaryFieldRefs {
    readonly id: FieldRef<"SessionSummary", 'String'>
    readonly workspaceId: FieldRef<"SessionSummary", 'String'>
    readonly content: FieldRef<"SessionSummary", 'String'>
    readonly createdAt: FieldRef<"SessionSummary", 'DateTime'>
    readonly createdBy: FieldRef<"SessionSummary", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SessionSummary findUnique
   */
  export type SessionSummaryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionSummary
     */
    select?: SessionSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionSummary
     */
    omit?: SessionSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionSummaryInclude<ExtArgs> | null
    /**
     * Filter, which SessionSummary to fetch.
     */
    where: SessionSummaryWhereUniqueInput
  }

  /**
   * SessionSummary findUniqueOrThrow
   */
  export type SessionSummaryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionSummary
     */
    select?: SessionSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionSummary
     */
    omit?: SessionSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionSummaryInclude<ExtArgs> | null
    /**
     * Filter, which SessionSummary to fetch.
     */
    where: SessionSummaryWhereUniqueInput
  }

  /**
   * SessionSummary findFirst
   */
  export type SessionSummaryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionSummary
     */
    select?: SessionSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionSummary
     */
    omit?: SessionSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionSummaryInclude<ExtArgs> | null
    /**
     * Filter, which SessionSummary to fetch.
     */
    where?: SessionSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionSummaries to fetch.
     */
    orderBy?: SessionSummaryOrderByWithRelationInput | SessionSummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionSummaries.
     */
    cursor?: SessionSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionSummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionSummaries.
     */
    distinct?: SessionSummaryScalarFieldEnum | SessionSummaryScalarFieldEnum[]
  }

  /**
   * SessionSummary findFirstOrThrow
   */
  export type SessionSummaryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionSummary
     */
    select?: SessionSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionSummary
     */
    omit?: SessionSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionSummaryInclude<ExtArgs> | null
    /**
     * Filter, which SessionSummary to fetch.
     */
    where?: SessionSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionSummaries to fetch.
     */
    orderBy?: SessionSummaryOrderByWithRelationInput | SessionSummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionSummaries.
     */
    cursor?: SessionSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionSummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionSummaries.
     */
    distinct?: SessionSummaryScalarFieldEnum | SessionSummaryScalarFieldEnum[]
  }

  /**
   * SessionSummary findMany
   */
  export type SessionSummaryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionSummary
     */
    select?: SessionSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionSummary
     */
    omit?: SessionSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionSummaryInclude<ExtArgs> | null
    /**
     * Filter, which SessionSummaries to fetch.
     */
    where?: SessionSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionSummaries to fetch.
     */
    orderBy?: SessionSummaryOrderByWithRelationInput | SessionSummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SessionSummaries.
     */
    cursor?: SessionSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionSummaries.
     */
    skip?: number
    distinct?: SessionSummaryScalarFieldEnum | SessionSummaryScalarFieldEnum[]
  }

  /**
   * SessionSummary create
   */
  export type SessionSummaryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionSummary
     */
    select?: SessionSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionSummary
     */
    omit?: SessionSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionSummaryInclude<ExtArgs> | null
    /**
     * The data needed to create a SessionSummary.
     */
    data: XOR<SessionSummaryCreateInput, SessionSummaryUncheckedCreateInput>
  }

  /**
   * SessionSummary createMany
   */
  export type SessionSummaryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SessionSummaries.
     */
    data: SessionSummaryCreateManyInput | SessionSummaryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SessionSummary createManyAndReturn
   */
  export type SessionSummaryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionSummary
     */
    select?: SessionSummarySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SessionSummary
     */
    omit?: SessionSummaryOmit<ExtArgs> | null
    /**
     * The data used to create many SessionSummaries.
     */
    data: SessionSummaryCreateManyInput | SessionSummaryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionSummaryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SessionSummary update
   */
  export type SessionSummaryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionSummary
     */
    select?: SessionSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionSummary
     */
    omit?: SessionSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionSummaryInclude<ExtArgs> | null
    /**
     * The data needed to update a SessionSummary.
     */
    data: XOR<SessionSummaryUpdateInput, SessionSummaryUncheckedUpdateInput>
    /**
     * Choose, which SessionSummary to update.
     */
    where: SessionSummaryWhereUniqueInput
  }

  /**
   * SessionSummary updateMany
   */
  export type SessionSummaryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SessionSummaries.
     */
    data: XOR<SessionSummaryUpdateManyMutationInput, SessionSummaryUncheckedUpdateManyInput>
    /**
     * Filter which SessionSummaries to update
     */
    where?: SessionSummaryWhereInput
    /**
     * Limit how many SessionSummaries to update.
     */
    limit?: number
  }

  /**
   * SessionSummary updateManyAndReturn
   */
  export type SessionSummaryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionSummary
     */
    select?: SessionSummarySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SessionSummary
     */
    omit?: SessionSummaryOmit<ExtArgs> | null
    /**
     * The data used to update SessionSummaries.
     */
    data: XOR<SessionSummaryUpdateManyMutationInput, SessionSummaryUncheckedUpdateManyInput>
    /**
     * Filter which SessionSummaries to update
     */
    where?: SessionSummaryWhereInput
    /**
     * Limit how many SessionSummaries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionSummaryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SessionSummary upsert
   */
  export type SessionSummaryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionSummary
     */
    select?: SessionSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionSummary
     */
    omit?: SessionSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionSummaryInclude<ExtArgs> | null
    /**
     * The filter to search for the SessionSummary to update in case it exists.
     */
    where: SessionSummaryWhereUniqueInput
    /**
     * In case the SessionSummary found by the `where` argument doesn't exist, create a new SessionSummary with this data.
     */
    create: XOR<SessionSummaryCreateInput, SessionSummaryUncheckedCreateInput>
    /**
     * In case the SessionSummary was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionSummaryUpdateInput, SessionSummaryUncheckedUpdateInput>
  }

  /**
   * SessionSummary delete
   */
  export type SessionSummaryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionSummary
     */
    select?: SessionSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionSummary
     */
    omit?: SessionSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionSummaryInclude<ExtArgs> | null
    /**
     * Filter which SessionSummary to delete.
     */
    where: SessionSummaryWhereUniqueInput
  }

  /**
   * SessionSummary deleteMany
   */
  export type SessionSummaryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionSummaries to delete
     */
    where?: SessionSummaryWhereInput
    /**
     * Limit how many SessionSummaries to delete.
     */
    limit?: number
  }

  /**
   * SessionSummary without action
   */
  export type SessionSummaryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionSummary
     */
    select?: SessionSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionSummary
     */
    omit?: SessionSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionSummaryInclude<ExtArgs> | null
  }


  /**
   * Model Chat
   */

  export type AggregateChat = {
    _count: ChatCountAggregateOutputType | null
    _min: ChatMinAggregateOutputType | null
    _max: ChatMaxAggregateOutputType | null
  }

  export type ChatMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
  }

  export type ChatMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
  }

  export type ChatCountAggregateOutputType = {
    id: number
    workspaceId: number
    _all: number
  }


  export type ChatMinAggregateInputType = {
    id?: true
    workspaceId?: true
  }

  export type ChatMaxAggregateInputType = {
    id?: true
    workspaceId?: true
  }

  export type ChatCountAggregateInputType = {
    id?: true
    workspaceId?: true
    _all?: true
  }

  export type ChatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chat to aggregate.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Chats
    **/
    _count?: true | ChatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatMaxAggregateInputType
  }

  export type GetChatAggregateType<T extends ChatAggregateArgs> = {
        [P in keyof T & keyof AggregateChat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChat[P]>
      : GetScalarType<T[P], AggregateChat[P]>
  }




  export type ChatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatWhereInput
    orderBy?: ChatOrderByWithAggregationInput | ChatOrderByWithAggregationInput[]
    by: ChatScalarFieldEnum[] | ChatScalarFieldEnum
    having?: ChatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatCountAggregateInputType | true
    _min?: ChatMinAggregateInputType
    _max?: ChatMaxAggregateInputType
  }

  export type ChatGroupByOutputType = {
    id: string
    workspaceId: string
    _count: ChatCountAggregateOutputType | null
    _min: ChatMinAggregateOutputType | null
    _max: ChatMaxAggregateOutputType | null
  }

  type GetChatGroupByPayload<T extends ChatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatGroupByOutputType[P]>
            : GetScalarType<T[P], ChatGroupByOutputType[P]>
        }
      >
    >


  export type ChatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    messages?: boolean | Chat$messagesArgs<ExtArgs>
    _count?: boolean | ChatCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chat"]>

  export type ChatSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chat"]>

  export type ChatSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chat"]>

  export type ChatSelectScalar = {
    id?: boolean
    workspaceId?: boolean
  }

  export type ChatOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workspaceId", ExtArgs["result"]["chat"]>
  export type ChatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    messages?: boolean | Chat$messagesArgs<ExtArgs>
    _count?: boolean | ChatCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChatIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type ChatIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $ChatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Chat"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      messages: Prisma.$ChatMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
    }, ExtArgs["result"]["chat"]>
    composites: {}
  }

  type ChatGetPayload<S extends boolean | null | undefined | ChatDefaultArgs> = $Result.GetResult<Prisma.$ChatPayload, S>

  type ChatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChatFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatCountAggregateInputType | true
    }

  export interface ChatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Chat'], meta: { name: 'Chat' } }
    /**
     * Find zero or one Chat that matches the filter.
     * @param {ChatFindUniqueArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatFindUniqueArgs>(args: SelectSubset<T, ChatFindUniqueArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Chat that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChatFindUniqueOrThrowArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Chat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatFindFirstArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatFindFirstArgs>(args?: SelectSubset<T, ChatFindFirstArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Chat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatFindFirstOrThrowArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Chats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chats
     * const chats = await prisma.chat.findMany()
     * 
     * // Get first 10 Chats
     * const chats = await prisma.chat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatWithIdOnly = await prisma.chat.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatFindManyArgs>(args?: SelectSubset<T, ChatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Chat.
     * @param {ChatCreateArgs} args - Arguments to create a Chat.
     * @example
     * // Create one Chat
     * const Chat = await prisma.chat.create({
     *   data: {
     *     // ... data to create a Chat
     *   }
     * })
     * 
     */
    create<T extends ChatCreateArgs>(args: SelectSubset<T, ChatCreateArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Chats.
     * @param {ChatCreateManyArgs} args - Arguments to create many Chats.
     * @example
     * // Create many Chats
     * const chat = await prisma.chat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatCreateManyArgs>(args?: SelectSubset<T, ChatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Chats and returns the data saved in the database.
     * @param {ChatCreateManyAndReturnArgs} args - Arguments to create many Chats.
     * @example
     * // Create many Chats
     * const chat = await prisma.chat.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Chats and only return the `id`
     * const chatWithIdOnly = await prisma.chat.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChatCreateManyAndReturnArgs>(args?: SelectSubset<T, ChatCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Chat.
     * @param {ChatDeleteArgs} args - Arguments to delete one Chat.
     * @example
     * // Delete one Chat
     * const Chat = await prisma.chat.delete({
     *   where: {
     *     // ... filter to delete one Chat
     *   }
     * })
     * 
     */
    delete<T extends ChatDeleteArgs>(args: SelectSubset<T, ChatDeleteArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Chat.
     * @param {ChatUpdateArgs} args - Arguments to update one Chat.
     * @example
     * // Update one Chat
     * const chat = await prisma.chat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatUpdateArgs>(args: SelectSubset<T, ChatUpdateArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Chats.
     * @param {ChatDeleteManyArgs} args - Arguments to filter Chats to delete.
     * @example
     * // Delete a few Chats
     * const { count } = await prisma.chat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatDeleteManyArgs>(args?: SelectSubset<T, ChatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chats
     * const chat = await prisma.chat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatUpdateManyArgs>(args: SelectSubset<T, ChatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chats and returns the data updated in the database.
     * @param {ChatUpdateManyAndReturnArgs} args - Arguments to update many Chats.
     * @example
     * // Update many Chats
     * const chat = await prisma.chat.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Chats and only return the `id`
     * const chatWithIdOnly = await prisma.chat.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChatUpdateManyAndReturnArgs>(args: SelectSubset<T, ChatUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Chat.
     * @param {ChatUpsertArgs} args - Arguments to update or create a Chat.
     * @example
     * // Update or create a Chat
     * const chat = await prisma.chat.upsert({
     *   create: {
     *     // ... data to create a Chat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chat we want to update
     *   }
     * })
     */
    upsert<T extends ChatUpsertArgs>(args: SelectSubset<T, ChatUpsertArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Chats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatCountArgs} args - Arguments to filter Chats to count.
     * @example
     * // Count the number of Chats
     * const count = await prisma.chat.count({
     *   where: {
     *     // ... the filter for the Chats we want to count
     *   }
     * })
    **/
    count<T extends ChatCountArgs>(
      args?: Subset<T, ChatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatAggregateArgs>(args: Subset<T, ChatAggregateArgs>): Prisma.PrismaPromise<GetChatAggregateType<T>>

    /**
     * Group by Chat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatGroupByArgs['orderBy'] }
        : { orderBy?: ChatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Chat model
   */
  readonly fields: ChatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Chat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    messages<T extends Chat$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Chat$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Chat model
   */ 
  interface ChatFieldRefs {
    readonly id: FieldRef<"Chat", 'String'>
    readonly workspaceId: FieldRef<"Chat", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Chat findUnique
   */
  export type ChatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat findUniqueOrThrow
   */
  export type ChatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat findFirst
   */
  export type ChatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chats.
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chats.
     */
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Chat findFirstOrThrow
   */
  export type ChatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chats.
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chats.
     */
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Chat findMany
   */
  export type ChatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chats to fetch.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Chats.
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Chat create
   */
  export type ChatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * The data needed to create a Chat.
     */
    data: XOR<ChatCreateInput, ChatUncheckedCreateInput>
  }

  /**
   * Chat createMany
   */
  export type ChatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Chats.
     */
    data: ChatCreateManyInput | ChatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Chat createManyAndReturn
   */
  export type ChatCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * The data used to create many Chats.
     */
    data: ChatCreateManyInput | ChatCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Chat update
   */
  export type ChatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * The data needed to update a Chat.
     */
    data: XOR<ChatUpdateInput, ChatUncheckedUpdateInput>
    /**
     * Choose, which Chat to update.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat updateMany
   */
  export type ChatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Chats.
     */
    data: XOR<ChatUpdateManyMutationInput, ChatUncheckedUpdateManyInput>
    /**
     * Filter which Chats to update
     */
    where?: ChatWhereInput
    /**
     * Limit how many Chats to update.
     */
    limit?: number
  }

  /**
   * Chat updateManyAndReturn
   */
  export type ChatUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * The data used to update Chats.
     */
    data: XOR<ChatUpdateManyMutationInput, ChatUncheckedUpdateManyInput>
    /**
     * Filter which Chats to update
     */
    where?: ChatWhereInput
    /**
     * Limit how many Chats to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Chat upsert
   */
  export type ChatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * The filter to search for the Chat to update in case it exists.
     */
    where: ChatWhereUniqueInput
    /**
     * In case the Chat found by the `where` argument doesn't exist, create a new Chat with this data.
     */
    create: XOR<ChatCreateInput, ChatUncheckedCreateInput>
    /**
     * In case the Chat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatUpdateInput, ChatUncheckedUpdateInput>
  }

  /**
   * Chat delete
   */
  export type ChatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter which Chat to delete.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat deleteMany
   */
  export type ChatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chats to delete
     */
    where?: ChatWhereInput
    /**
     * Limit how many Chats to delete.
     */
    limit?: number
  }

  /**
   * Chat.messages
   */
  export type Chat$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    where?: ChatMessageWhereInput
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    cursor?: ChatMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * Chat without action
   */
  export type ChatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
  }


  /**
   * Model ChatMessage
   */

  export type AggregateChatMessage = {
    _count: ChatMessageCountAggregateOutputType | null
    _min: ChatMessageMinAggregateOutputType | null
    _max: ChatMessageMaxAggregateOutputType | null
  }

  export type ChatMessageMinAggregateOutputType = {
    id: string | null
    chatId: string | null
    userId: string | null
    content: string | null
    createdAt: Date | null
  }

  export type ChatMessageMaxAggregateOutputType = {
    id: string | null
    chatId: string | null
    userId: string | null
    content: string | null
    createdAt: Date | null
  }

  export type ChatMessageCountAggregateOutputType = {
    id: number
    chatId: number
    userId: number
    content: number
    createdAt: number
    _all: number
  }


  export type ChatMessageMinAggregateInputType = {
    id?: true
    chatId?: true
    userId?: true
    content?: true
    createdAt?: true
  }

  export type ChatMessageMaxAggregateInputType = {
    id?: true
    chatId?: true
    userId?: true
    content?: true
    createdAt?: true
  }

  export type ChatMessageCountAggregateInputType = {
    id?: true
    chatId?: true
    userId?: true
    content?: true
    createdAt?: true
    _all?: true
  }

  export type ChatMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatMessage to aggregate.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChatMessages
    **/
    _count?: true | ChatMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatMessageMaxAggregateInputType
  }

  export type GetChatMessageAggregateType<T extends ChatMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateChatMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatMessage[P]>
      : GetScalarType<T[P], AggregateChatMessage[P]>
  }




  export type ChatMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatMessageWhereInput
    orderBy?: ChatMessageOrderByWithAggregationInput | ChatMessageOrderByWithAggregationInput[]
    by: ChatMessageScalarFieldEnum[] | ChatMessageScalarFieldEnum
    having?: ChatMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatMessageCountAggregateInputType | true
    _min?: ChatMessageMinAggregateInputType
    _max?: ChatMessageMaxAggregateInputType
  }

  export type ChatMessageGroupByOutputType = {
    id: string
    chatId: string
    userId: string
    content: string
    createdAt: Date
    _count: ChatMessageCountAggregateOutputType | null
    _min: ChatMessageMinAggregateOutputType | null
    _max: ChatMessageMaxAggregateOutputType | null
  }

  type GetChatMessageGroupByPayload<T extends ChatMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatMessageGroupByOutputType[P]>
            : GetScalarType<T[P], ChatMessageGroupByOutputType[P]>
        }
      >
    >


  export type ChatMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chatId?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    chat?: boolean | ChatDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatMessage"]>

  export type ChatMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chatId?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    chat?: boolean | ChatDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatMessage"]>

  export type ChatMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chatId?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    chat?: boolean | ChatDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatMessage"]>

  export type ChatMessageSelectScalar = {
    id?: boolean
    chatId?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
  }

  export type ChatMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "chatId" | "userId" | "content" | "createdAt", ExtArgs["result"]["chatMessage"]>
  export type ChatMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chat?: boolean | ChatDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ChatMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chat?: boolean | ChatDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ChatMessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chat?: boolean | ChatDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ChatMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChatMessage"
    objects: {
      chat: Prisma.$ChatPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      chatId: string
      userId: string
      content: string
      createdAt: Date
    }, ExtArgs["result"]["chatMessage"]>
    composites: {}
  }

  type ChatMessageGetPayload<S extends boolean | null | undefined | ChatMessageDefaultArgs> = $Result.GetResult<Prisma.$ChatMessagePayload, S>

  type ChatMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChatMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatMessageCountAggregateInputType | true
    }

  export interface ChatMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChatMessage'], meta: { name: 'ChatMessage' } }
    /**
     * Find zero or one ChatMessage that matches the filter.
     * @param {ChatMessageFindUniqueArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatMessageFindUniqueArgs>(args: SelectSubset<T, ChatMessageFindUniqueArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ChatMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChatMessageFindUniqueOrThrowArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ChatMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindFirstArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatMessageFindFirstArgs>(args?: SelectSubset<T, ChatMessageFindFirstArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ChatMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindFirstOrThrowArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ChatMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChatMessages
     * const chatMessages = await prisma.chatMessage.findMany()
     * 
     * // Get first 10 ChatMessages
     * const chatMessages = await prisma.chatMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatMessageWithIdOnly = await prisma.chatMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatMessageFindManyArgs>(args?: SelectSubset<T, ChatMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ChatMessage.
     * @param {ChatMessageCreateArgs} args - Arguments to create a ChatMessage.
     * @example
     * // Create one ChatMessage
     * const ChatMessage = await prisma.chatMessage.create({
     *   data: {
     *     // ... data to create a ChatMessage
     *   }
     * })
     * 
     */
    create<T extends ChatMessageCreateArgs>(args: SelectSubset<T, ChatMessageCreateArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ChatMessages.
     * @param {ChatMessageCreateManyArgs} args - Arguments to create many ChatMessages.
     * @example
     * // Create many ChatMessages
     * const chatMessage = await prisma.chatMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatMessageCreateManyArgs>(args?: SelectSubset<T, ChatMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChatMessages and returns the data saved in the database.
     * @param {ChatMessageCreateManyAndReturnArgs} args - Arguments to create many ChatMessages.
     * @example
     * // Create many ChatMessages
     * const chatMessage = await prisma.chatMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChatMessages and only return the `id`
     * const chatMessageWithIdOnly = await prisma.chatMessage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChatMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, ChatMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a ChatMessage.
     * @param {ChatMessageDeleteArgs} args - Arguments to delete one ChatMessage.
     * @example
     * // Delete one ChatMessage
     * const ChatMessage = await prisma.chatMessage.delete({
     *   where: {
     *     // ... filter to delete one ChatMessage
     *   }
     * })
     * 
     */
    delete<T extends ChatMessageDeleteArgs>(args: SelectSubset<T, ChatMessageDeleteArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ChatMessage.
     * @param {ChatMessageUpdateArgs} args - Arguments to update one ChatMessage.
     * @example
     * // Update one ChatMessage
     * const chatMessage = await prisma.chatMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatMessageUpdateArgs>(args: SelectSubset<T, ChatMessageUpdateArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ChatMessages.
     * @param {ChatMessageDeleteManyArgs} args - Arguments to filter ChatMessages to delete.
     * @example
     * // Delete a few ChatMessages
     * const { count } = await prisma.chatMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatMessageDeleteManyArgs>(args?: SelectSubset<T, ChatMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChatMessages
     * const chatMessage = await prisma.chatMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatMessageUpdateManyArgs>(args: SelectSubset<T, ChatMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatMessages and returns the data updated in the database.
     * @param {ChatMessageUpdateManyAndReturnArgs} args - Arguments to update many ChatMessages.
     * @example
     * // Update many ChatMessages
     * const chatMessage = await prisma.chatMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChatMessages and only return the `id`
     * const chatMessageWithIdOnly = await prisma.chatMessage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChatMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, ChatMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one ChatMessage.
     * @param {ChatMessageUpsertArgs} args - Arguments to update or create a ChatMessage.
     * @example
     * // Update or create a ChatMessage
     * const chatMessage = await prisma.chatMessage.upsert({
     *   create: {
     *     // ... data to create a ChatMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChatMessage we want to update
     *   }
     * })
     */
    upsert<T extends ChatMessageUpsertArgs>(args: SelectSubset<T, ChatMessageUpsertArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ChatMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageCountArgs} args - Arguments to filter ChatMessages to count.
     * @example
     * // Count the number of ChatMessages
     * const count = await prisma.chatMessage.count({
     *   where: {
     *     // ... the filter for the ChatMessages we want to count
     *   }
     * })
    **/
    count<T extends ChatMessageCountArgs>(
      args?: Subset<T, ChatMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChatMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatMessageAggregateArgs>(args: Subset<T, ChatMessageAggregateArgs>): Prisma.PrismaPromise<GetChatMessageAggregateType<T>>

    /**
     * Group by ChatMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatMessageGroupByArgs['orderBy'] }
        : { orderBy?: ChatMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChatMessage model
   */
  readonly fields: ChatMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChatMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chat<T extends ChatDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChatDefaultArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChatMessage model
   */ 
  interface ChatMessageFieldRefs {
    readonly id: FieldRef<"ChatMessage", 'String'>
    readonly chatId: FieldRef<"ChatMessage", 'String'>
    readonly userId: FieldRef<"ChatMessage", 'String'>
    readonly content: FieldRef<"ChatMessage", 'String'>
    readonly createdAt: FieldRef<"ChatMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChatMessage findUnique
   */
  export type ChatMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage findUniqueOrThrow
   */
  export type ChatMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage findFirst
   */
  export type ChatMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatMessages.
     */
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage findFirstOrThrow
   */
  export type ChatMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatMessages.
     */
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage findMany
   */
  export type ChatMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessages to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage create
   */
  export type ChatMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a ChatMessage.
     */
    data: XOR<ChatMessageCreateInput, ChatMessageUncheckedCreateInput>
  }

  /**
   * ChatMessage createMany
   */
  export type ChatMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChatMessages.
     */
    data: ChatMessageCreateManyInput | ChatMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChatMessage createManyAndReturn
   */
  export type ChatMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * The data used to create many ChatMessages.
     */
    data: ChatMessageCreateManyInput | ChatMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatMessage update
   */
  export type ChatMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a ChatMessage.
     */
    data: XOR<ChatMessageUpdateInput, ChatMessageUncheckedUpdateInput>
    /**
     * Choose, which ChatMessage to update.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage updateMany
   */
  export type ChatMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChatMessages.
     */
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyInput>
    /**
     * Filter which ChatMessages to update
     */
    where?: ChatMessageWhereInput
    /**
     * Limit how many ChatMessages to update.
     */
    limit?: number
  }

  /**
   * ChatMessage updateManyAndReturn
   */
  export type ChatMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * The data used to update ChatMessages.
     */
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyInput>
    /**
     * Filter which ChatMessages to update
     */
    where?: ChatMessageWhereInput
    /**
     * Limit how many ChatMessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatMessage upsert
   */
  export type ChatMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the ChatMessage to update in case it exists.
     */
    where: ChatMessageWhereUniqueInput
    /**
     * In case the ChatMessage found by the `where` argument doesn't exist, create a new ChatMessage with this data.
     */
    create: XOR<ChatMessageCreateInput, ChatMessageUncheckedCreateInput>
    /**
     * In case the ChatMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatMessageUpdateInput, ChatMessageUncheckedUpdateInput>
  }

  /**
   * ChatMessage delete
   */
  export type ChatMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter which ChatMessage to delete.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage deleteMany
   */
  export type ChatMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatMessages to delete
     */
    where?: ChatMessageWhereInput
    /**
     * Limit how many ChatMessages to delete.
     */
    limit?: number
  }

  /**
   * ChatMessage without action
   */
  export type ChatMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
  }


  /**
   * Model UserSettings
   */

  export type AggregateUserSettings = {
    _count: UserSettingsCountAggregateOutputType | null
    _min: UserSettingsMinAggregateOutputType | null
    _max: UserSettingsMaxAggregateOutputType | null
  }

  export type UserSettingsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserSettingsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserSettingsCountAggregateOutputType = {
    id: number
    userId: number
    notificationPreferences: number
    voiceSettings: number
    privacySettings: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserSettingsMinAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserSettingsMaxAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserSettingsCountAggregateInputType = {
    id?: true
    userId?: true
    notificationPreferences?: true
    voiceSettings?: true
    privacySettings?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSettings to aggregate.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSettings
    **/
    _count?: true | UserSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSettingsMaxAggregateInputType
  }

  export type GetUserSettingsAggregateType<T extends UserSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSettings[P]>
      : GetScalarType<T[P], AggregateUserSettings[P]>
  }




  export type UserSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSettingsWhereInput
    orderBy?: UserSettingsOrderByWithAggregationInput | UserSettingsOrderByWithAggregationInput[]
    by: UserSettingsScalarFieldEnum[] | UserSettingsScalarFieldEnum
    having?: UserSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSettingsCountAggregateInputType | true
    _min?: UserSettingsMinAggregateInputType
    _max?: UserSettingsMaxAggregateInputType
  }

  export type UserSettingsGroupByOutputType = {
    id: string
    userId: string
    notificationPreferences: JsonValue
    voiceSettings: JsonValue
    privacySettings: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: UserSettingsCountAggregateOutputType | null
    _min: UserSettingsMinAggregateOutputType | null
    _max: UserSettingsMaxAggregateOutputType | null
  }

  type GetUserSettingsGroupByPayload<T extends UserSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], UserSettingsGroupByOutputType[P]>
        }
      >
    >


  export type UserSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    notificationPreferences?: boolean
    voiceSettings?: boolean
    privacySettings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSettings"]>

  export type UserSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    notificationPreferences?: boolean
    voiceSettings?: boolean
    privacySettings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSettings"]>

  export type UserSettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    notificationPreferences?: boolean
    voiceSettings?: boolean
    privacySettings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSettings"]>

  export type UserSettingsSelectScalar = {
    id?: boolean
    userId?: boolean
    notificationPreferences?: boolean
    voiceSettings?: boolean
    privacySettings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "notificationPreferences" | "voiceSettings" | "privacySettings" | "createdAt" | "updatedAt", ExtArgs["result"]["userSettings"]>
  export type UserSettingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSettingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSettingsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSettings"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      notificationPreferences: Prisma.JsonValue
      voiceSettings: Prisma.JsonValue
      privacySettings: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userSettings"]>
    composites: {}
  }

  type UserSettingsGetPayload<S extends boolean | null | undefined | UserSettingsDefaultArgs> = $Result.GetResult<Prisma.$UserSettingsPayload, S>

  type UserSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserSettingsCountAggregateInputType | true
    }

  export interface UserSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSettings'], meta: { name: 'UserSettings' } }
    /**
     * Find zero or one UserSettings that matches the filter.
     * @param {UserSettingsFindUniqueArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSettingsFindUniqueArgs>(args: SelectSubset<T, UserSettingsFindUniqueArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one UserSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserSettingsFindUniqueOrThrowArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first UserSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsFindFirstArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSettingsFindFirstArgs>(args?: SelectSubset<T, UserSettingsFindFirstArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first UserSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsFindFirstOrThrowArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more UserSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSettings
     * const userSettings = await prisma.userSettings.findMany()
     * 
     * // Get first 10 UserSettings
     * const userSettings = await prisma.userSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userSettingsWithIdOnly = await prisma.userSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserSettingsFindManyArgs>(args?: SelectSubset<T, UserSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a UserSettings.
     * @param {UserSettingsCreateArgs} args - Arguments to create a UserSettings.
     * @example
     * // Create one UserSettings
     * const UserSettings = await prisma.userSettings.create({
     *   data: {
     *     // ... data to create a UserSettings
     *   }
     * })
     * 
     */
    create<T extends UserSettingsCreateArgs>(args: SelectSubset<T, UserSettingsCreateArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many UserSettings.
     * @param {UserSettingsCreateManyArgs} args - Arguments to create many UserSettings.
     * @example
     * // Create many UserSettings
     * const userSettings = await prisma.userSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSettingsCreateManyArgs>(args?: SelectSubset<T, UserSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSettings and returns the data saved in the database.
     * @param {UserSettingsCreateManyAndReturnArgs} args - Arguments to create many UserSettings.
     * @example
     * // Create many UserSettings
     * const userSettings = await prisma.userSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSettings and only return the `id`
     * const userSettingsWithIdOnly = await prisma.userSettings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a UserSettings.
     * @param {UserSettingsDeleteArgs} args - Arguments to delete one UserSettings.
     * @example
     * // Delete one UserSettings
     * const UserSettings = await prisma.userSettings.delete({
     *   where: {
     *     // ... filter to delete one UserSettings
     *   }
     * })
     * 
     */
    delete<T extends UserSettingsDeleteArgs>(args: SelectSubset<T, UserSettingsDeleteArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one UserSettings.
     * @param {UserSettingsUpdateArgs} args - Arguments to update one UserSettings.
     * @example
     * // Update one UserSettings
     * const userSettings = await prisma.userSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSettingsUpdateArgs>(args: SelectSubset<T, UserSettingsUpdateArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more UserSettings.
     * @param {UserSettingsDeleteManyArgs} args - Arguments to filter UserSettings to delete.
     * @example
     * // Delete a few UserSettings
     * const { count } = await prisma.userSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSettingsDeleteManyArgs>(args?: SelectSubset<T, UserSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSettings
     * const userSettings = await prisma.userSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSettingsUpdateManyArgs>(args: SelectSubset<T, UserSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSettings and returns the data updated in the database.
     * @param {UserSettingsUpdateManyAndReturnArgs} args - Arguments to update many UserSettings.
     * @example
     * // Update many UserSettings
     * const userSettings = await prisma.userSettings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserSettings and only return the `id`
     * const userSettingsWithIdOnly = await prisma.userSettings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserSettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, UserSettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one UserSettings.
     * @param {UserSettingsUpsertArgs} args - Arguments to update or create a UserSettings.
     * @example
     * // Update or create a UserSettings
     * const userSettings = await prisma.userSettings.upsert({
     *   create: {
     *     // ... data to create a UserSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSettings we want to update
     *   }
     * })
     */
    upsert<T extends UserSettingsUpsertArgs>(args: SelectSubset<T, UserSettingsUpsertArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsCountArgs} args - Arguments to filter UserSettings to count.
     * @example
     * // Count the number of UserSettings
     * const count = await prisma.userSettings.count({
     *   where: {
     *     // ... the filter for the UserSettings we want to count
     *   }
     * })
    **/
    count<T extends UserSettingsCountArgs>(
      args?: Subset<T, UserSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSettingsAggregateArgs>(args: Subset<T, UserSettingsAggregateArgs>): Prisma.PrismaPromise<GetUserSettingsAggregateType<T>>

    /**
     * Group by UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSettingsGroupByArgs['orderBy'] }
        : { orderBy?: UserSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSettings model
   */
  readonly fields: UserSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSettings model
   */ 
  interface UserSettingsFieldRefs {
    readonly id: FieldRef<"UserSettings", 'String'>
    readonly userId: FieldRef<"UserSettings", 'String'>
    readonly notificationPreferences: FieldRef<"UserSettings", 'Json'>
    readonly voiceSettings: FieldRef<"UserSettings", 'Json'>
    readonly privacySettings: FieldRef<"UserSettings", 'Json'>
    readonly createdAt: FieldRef<"UserSettings", 'DateTime'>
    readonly updatedAt: FieldRef<"UserSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserSettings findUnique
   */
  export type UserSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings findUniqueOrThrow
   */
  export type UserSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings findFirst
   */
  export type UserSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSettings.
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSettings.
     */
    distinct?: UserSettingsScalarFieldEnum | UserSettingsScalarFieldEnum[]
  }

  /**
   * UserSettings findFirstOrThrow
   */
  export type UserSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSettings.
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSettings.
     */
    distinct?: UserSettingsScalarFieldEnum | UserSettingsScalarFieldEnum[]
  }

  /**
   * UserSettings findMany
   */
  export type UserSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSettings.
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    distinct?: UserSettingsScalarFieldEnum | UserSettingsScalarFieldEnum[]
  }

  /**
   * UserSettings create
   */
  export type UserSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSettings.
     */
    data: XOR<UserSettingsCreateInput, UserSettingsUncheckedCreateInput>
  }

  /**
   * UserSettings createMany
   */
  export type UserSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSettings.
     */
    data: UserSettingsCreateManyInput | UserSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSettings createManyAndReturn
   */
  export type UserSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * The data used to create many UserSettings.
     */
    data: UserSettingsCreateManyInput | UserSettingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSettings update
   */
  export type UserSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSettings.
     */
    data: XOR<UserSettingsUpdateInput, UserSettingsUncheckedUpdateInput>
    /**
     * Choose, which UserSettings to update.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings updateMany
   */
  export type UserSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSettings.
     */
    data: XOR<UserSettingsUpdateManyMutationInput, UserSettingsUncheckedUpdateManyInput>
    /**
     * Filter which UserSettings to update
     */
    where?: UserSettingsWhereInput
    /**
     * Limit how many UserSettings to update.
     */
    limit?: number
  }

  /**
   * UserSettings updateManyAndReturn
   */
  export type UserSettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * The data used to update UserSettings.
     */
    data: XOR<UserSettingsUpdateManyMutationInput, UserSettingsUncheckedUpdateManyInput>
    /**
     * Filter which UserSettings to update
     */
    where?: UserSettingsWhereInput
    /**
     * Limit how many UserSettings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSettings upsert
   */
  export type UserSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSettings to update in case it exists.
     */
    where: UserSettingsWhereUniqueInput
    /**
     * In case the UserSettings found by the `where` argument doesn't exist, create a new UserSettings with this data.
     */
    create: XOR<UserSettingsCreateInput, UserSettingsUncheckedCreateInput>
    /**
     * In case the UserSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSettingsUpdateInput, UserSettingsUncheckedUpdateInput>
  }

  /**
   * UserSettings delete
   */
  export type UserSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter which UserSettings to delete.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings deleteMany
   */
  export type UserSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSettings to delete
     */
    where?: UserSettingsWhereInput
    /**
     * Limit how many UserSettings to delete.
     */
    limit?: number
  }

  /**
   * UserSettings without action
   */
  export type UserSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
  }


  /**
   * Model AnalyticsEntry
   */

  export type AggregateAnalyticsEntry = {
    _count: AnalyticsEntryCountAggregateOutputType | null
    _avg: AnalyticsEntryAvgAggregateOutputType | null
    _sum: AnalyticsEntrySumAggregateOutputType | null
    _min: AnalyticsEntryMinAggregateOutputType | null
    _max: AnalyticsEntryMaxAggregateOutputType | null
  }

  export type AnalyticsEntryAvgAggregateOutputType = {
    timeSpent: number | null
    score: number | null
  }

  export type AnalyticsEntrySumAggregateOutputType = {
    timeSpent: number | null
    score: number | null
  }

  export type AnalyticsEntryMinAggregateOutputType = {
    id: string | null
    userId: string | null
    topicId: string | null
    timeSpent: number | null
    score: number | null
    date: Date | null
  }

  export type AnalyticsEntryMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    topicId: string | null
    timeSpent: number | null
    score: number | null
    date: Date | null
  }

  export type AnalyticsEntryCountAggregateOutputType = {
    id: number
    userId: number
    topicId: number
    timeSpent: number
    score: number
    date: number
    _all: number
  }


  export type AnalyticsEntryAvgAggregateInputType = {
    timeSpent?: true
    score?: true
  }

  export type AnalyticsEntrySumAggregateInputType = {
    timeSpent?: true
    score?: true
  }

  export type AnalyticsEntryMinAggregateInputType = {
    id?: true
    userId?: true
    topicId?: true
    timeSpent?: true
    score?: true
    date?: true
  }

  export type AnalyticsEntryMaxAggregateInputType = {
    id?: true
    userId?: true
    topicId?: true
    timeSpent?: true
    score?: true
    date?: true
  }

  export type AnalyticsEntryCountAggregateInputType = {
    id?: true
    userId?: true
    topicId?: true
    timeSpent?: true
    score?: true
    date?: true
    _all?: true
  }

  export type AnalyticsEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalyticsEntry to aggregate.
     */
    where?: AnalyticsEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsEntries to fetch.
     */
    orderBy?: AnalyticsEntryOrderByWithRelationInput | AnalyticsEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnalyticsEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AnalyticsEntries
    **/
    _count?: true | AnalyticsEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnalyticsEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnalyticsEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnalyticsEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnalyticsEntryMaxAggregateInputType
  }

  export type GetAnalyticsEntryAggregateType<T extends AnalyticsEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateAnalyticsEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnalyticsEntry[P]>
      : GetScalarType<T[P], AggregateAnalyticsEntry[P]>
  }




  export type AnalyticsEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalyticsEntryWhereInput
    orderBy?: AnalyticsEntryOrderByWithAggregationInput | AnalyticsEntryOrderByWithAggregationInput[]
    by: AnalyticsEntryScalarFieldEnum[] | AnalyticsEntryScalarFieldEnum
    having?: AnalyticsEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnalyticsEntryCountAggregateInputType | true
    _avg?: AnalyticsEntryAvgAggregateInputType
    _sum?: AnalyticsEntrySumAggregateInputType
    _min?: AnalyticsEntryMinAggregateInputType
    _max?: AnalyticsEntryMaxAggregateInputType
  }

  export type AnalyticsEntryGroupByOutputType = {
    id: string
    userId: string
    topicId: string
    timeSpent: number
    score: number | null
    date: Date
    _count: AnalyticsEntryCountAggregateOutputType | null
    _avg: AnalyticsEntryAvgAggregateOutputType | null
    _sum: AnalyticsEntrySumAggregateOutputType | null
    _min: AnalyticsEntryMinAggregateOutputType | null
    _max: AnalyticsEntryMaxAggregateOutputType | null
  }

  type GetAnalyticsEntryGroupByPayload<T extends AnalyticsEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnalyticsEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnalyticsEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnalyticsEntryGroupByOutputType[P]>
            : GetScalarType<T[P], AnalyticsEntryGroupByOutputType[P]>
        }
      >
    >


  export type AnalyticsEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    topicId?: boolean
    timeSpent?: boolean
    score?: boolean
    date?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    topic?: boolean | TopicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["analyticsEntry"]>

  export type AnalyticsEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    topicId?: boolean
    timeSpent?: boolean
    score?: boolean
    date?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    topic?: boolean | TopicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["analyticsEntry"]>

  export type AnalyticsEntrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    topicId?: boolean
    timeSpent?: boolean
    score?: boolean
    date?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    topic?: boolean | TopicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["analyticsEntry"]>

  export type AnalyticsEntrySelectScalar = {
    id?: boolean
    userId?: boolean
    topicId?: boolean
    timeSpent?: boolean
    score?: boolean
    date?: boolean
  }

  export type AnalyticsEntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "topicId" | "timeSpent" | "score" | "date", ExtArgs["result"]["analyticsEntry"]>
  export type AnalyticsEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    topic?: boolean | TopicDefaultArgs<ExtArgs>
  }
  export type AnalyticsEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    topic?: boolean | TopicDefaultArgs<ExtArgs>
  }
  export type AnalyticsEntryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    topic?: boolean | TopicDefaultArgs<ExtArgs>
  }

  export type $AnalyticsEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AnalyticsEntry"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      topic: Prisma.$TopicPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      topicId: string
      timeSpent: number
      score: number | null
      date: Date
    }, ExtArgs["result"]["analyticsEntry"]>
    composites: {}
  }

  type AnalyticsEntryGetPayload<S extends boolean | null | undefined | AnalyticsEntryDefaultArgs> = $Result.GetResult<Prisma.$AnalyticsEntryPayload, S>

  type AnalyticsEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnalyticsEntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnalyticsEntryCountAggregateInputType | true
    }

  export interface AnalyticsEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AnalyticsEntry'], meta: { name: 'AnalyticsEntry' } }
    /**
     * Find zero or one AnalyticsEntry that matches the filter.
     * @param {AnalyticsEntryFindUniqueArgs} args - Arguments to find a AnalyticsEntry
     * @example
     * // Get one AnalyticsEntry
     * const analyticsEntry = await prisma.analyticsEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnalyticsEntryFindUniqueArgs>(args: SelectSubset<T, AnalyticsEntryFindUniqueArgs<ExtArgs>>): Prisma__AnalyticsEntryClient<$Result.GetResult<Prisma.$AnalyticsEntryPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one AnalyticsEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnalyticsEntryFindUniqueOrThrowArgs} args - Arguments to find a AnalyticsEntry
     * @example
     * // Get one AnalyticsEntry
     * const analyticsEntry = await prisma.analyticsEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnalyticsEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, AnalyticsEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnalyticsEntryClient<$Result.GetResult<Prisma.$AnalyticsEntryPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first AnalyticsEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEntryFindFirstArgs} args - Arguments to find a AnalyticsEntry
     * @example
     * // Get one AnalyticsEntry
     * const analyticsEntry = await prisma.analyticsEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnalyticsEntryFindFirstArgs>(args?: SelectSubset<T, AnalyticsEntryFindFirstArgs<ExtArgs>>): Prisma__AnalyticsEntryClient<$Result.GetResult<Prisma.$AnalyticsEntryPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first AnalyticsEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEntryFindFirstOrThrowArgs} args - Arguments to find a AnalyticsEntry
     * @example
     * // Get one AnalyticsEntry
     * const analyticsEntry = await prisma.analyticsEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnalyticsEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, AnalyticsEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnalyticsEntryClient<$Result.GetResult<Prisma.$AnalyticsEntryPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more AnalyticsEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AnalyticsEntries
     * const analyticsEntries = await prisma.analyticsEntry.findMany()
     * 
     * // Get first 10 AnalyticsEntries
     * const analyticsEntries = await prisma.analyticsEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const analyticsEntryWithIdOnly = await prisma.analyticsEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnalyticsEntryFindManyArgs>(args?: SelectSubset<T, AnalyticsEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsEntryPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a AnalyticsEntry.
     * @param {AnalyticsEntryCreateArgs} args - Arguments to create a AnalyticsEntry.
     * @example
     * // Create one AnalyticsEntry
     * const AnalyticsEntry = await prisma.analyticsEntry.create({
     *   data: {
     *     // ... data to create a AnalyticsEntry
     *   }
     * })
     * 
     */
    create<T extends AnalyticsEntryCreateArgs>(args: SelectSubset<T, AnalyticsEntryCreateArgs<ExtArgs>>): Prisma__AnalyticsEntryClient<$Result.GetResult<Prisma.$AnalyticsEntryPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many AnalyticsEntries.
     * @param {AnalyticsEntryCreateManyArgs} args - Arguments to create many AnalyticsEntries.
     * @example
     * // Create many AnalyticsEntries
     * const analyticsEntry = await prisma.analyticsEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnalyticsEntryCreateManyArgs>(args?: SelectSubset<T, AnalyticsEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AnalyticsEntries and returns the data saved in the database.
     * @param {AnalyticsEntryCreateManyAndReturnArgs} args - Arguments to create many AnalyticsEntries.
     * @example
     * // Create many AnalyticsEntries
     * const analyticsEntry = await prisma.analyticsEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AnalyticsEntries and only return the `id`
     * const analyticsEntryWithIdOnly = await prisma.analyticsEntry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnalyticsEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, AnalyticsEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsEntryPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a AnalyticsEntry.
     * @param {AnalyticsEntryDeleteArgs} args - Arguments to delete one AnalyticsEntry.
     * @example
     * // Delete one AnalyticsEntry
     * const AnalyticsEntry = await prisma.analyticsEntry.delete({
     *   where: {
     *     // ... filter to delete one AnalyticsEntry
     *   }
     * })
     * 
     */
    delete<T extends AnalyticsEntryDeleteArgs>(args: SelectSubset<T, AnalyticsEntryDeleteArgs<ExtArgs>>): Prisma__AnalyticsEntryClient<$Result.GetResult<Prisma.$AnalyticsEntryPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one AnalyticsEntry.
     * @param {AnalyticsEntryUpdateArgs} args - Arguments to update one AnalyticsEntry.
     * @example
     * // Update one AnalyticsEntry
     * const analyticsEntry = await prisma.analyticsEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnalyticsEntryUpdateArgs>(args: SelectSubset<T, AnalyticsEntryUpdateArgs<ExtArgs>>): Prisma__AnalyticsEntryClient<$Result.GetResult<Prisma.$AnalyticsEntryPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more AnalyticsEntries.
     * @param {AnalyticsEntryDeleteManyArgs} args - Arguments to filter AnalyticsEntries to delete.
     * @example
     * // Delete a few AnalyticsEntries
     * const { count } = await prisma.analyticsEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnalyticsEntryDeleteManyArgs>(args?: SelectSubset<T, AnalyticsEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnalyticsEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AnalyticsEntries
     * const analyticsEntry = await prisma.analyticsEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnalyticsEntryUpdateManyArgs>(args: SelectSubset<T, AnalyticsEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnalyticsEntries and returns the data updated in the database.
     * @param {AnalyticsEntryUpdateManyAndReturnArgs} args - Arguments to update many AnalyticsEntries.
     * @example
     * // Update many AnalyticsEntries
     * const analyticsEntry = await prisma.analyticsEntry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AnalyticsEntries and only return the `id`
     * const analyticsEntryWithIdOnly = await prisma.analyticsEntry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AnalyticsEntryUpdateManyAndReturnArgs>(args: SelectSubset<T, AnalyticsEntryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsEntryPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one AnalyticsEntry.
     * @param {AnalyticsEntryUpsertArgs} args - Arguments to update or create a AnalyticsEntry.
     * @example
     * // Update or create a AnalyticsEntry
     * const analyticsEntry = await prisma.analyticsEntry.upsert({
     *   create: {
     *     // ... data to create a AnalyticsEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AnalyticsEntry we want to update
     *   }
     * })
     */
    upsert<T extends AnalyticsEntryUpsertArgs>(args: SelectSubset<T, AnalyticsEntryUpsertArgs<ExtArgs>>): Prisma__AnalyticsEntryClient<$Result.GetResult<Prisma.$AnalyticsEntryPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of AnalyticsEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEntryCountArgs} args - Arguments to filter AnalyticsEntries to count.
     * @example
     * // Count the number of AnalyticsEntries
     * const count = await prisma.analyticsEntry.count({
     *   where: {
     *     // ... the filter for the AnalyticsEntries we want to count
     *   }
     * })
    **/
    count<T extends AnalyticsEntryCountArgs>(
      args?: Subset<T, AnalyticsEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnalyticsEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AnalyticsEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnalyticsEntryAggregateArgs>(args: Subset<T, AnalyticsEntryAggregateArgs>): Prisma.PrismaPromise<GetAnalyticsEntryAggregateType<T>>

    /**
     * Group by AnalyticsEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnalyticsEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnalyticsEntryGroupByArgs['orderBy'] }
        : { orderBy?: AnalyticsEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnalyticsEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnalyticsEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AnalyticsEntry model
   */
  readonly fields: AnalyticsEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AnalyticsEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnalyticsEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    topic<T extends TopicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TopicDefaultArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AnalyticsEntry model
   */ 
  interface AnalyticsEntryFieldRefs {
    readonly id: FieldRef<"AnalyticsEntry", 'String'>
    readonly userId: FieldRef<"AnalyticsEntry", 'String'>
    readonly topicId: FieldRef<"AnalyticsEntry", 'String'>
    readonly timeSpent: FieldRef<"AnalyticsEntry", 'Int'>
    readonly score: FieldRef<"AnalyticsEntry", 'Float'>
    readonly date: FieldRef<"AnalyticsEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AnalyticsEntry findUnique
   */
  export type AnalyticsEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEntry
     */
    select?: AnalyticsEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEntry
     */
    omit?: AnalyticsEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEntryInclude<ExtArgs> | null
    /**
     * Filter, which AnalyticsEntry to fetch.
     */
    where: AnalyticsEntryWhereUniqueInput
  }

  /**
   * AnalyticsEntry findUniqueOrThrow
   */
  export type AnalyticsEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEntry
     */
    select?: AnalyticsEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEntry
     */
    omit?: AnalyticsEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEntryInclude<ExtArgs> | null
    /**
     * Filter, which AnalyticsEntry to fetch.
     */
    where: AnalyticsEntryWhereUniqueInput
  }

  /**
   * AnalyticsEntry findFirst
   */
  export type AnalyticsEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEntry
     */
    select?: AnalyticsEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEntry
     */
    omit?: AnalyticsEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEntryInclude<ExtArgs> | null
    /**
     * Filter, which AnalyticsEntry to fetch.
     */
    where?: AnalyticsEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsEntries to fetch.
     */
    orderBy?: AnalyticsEntryOrderByWithRelationInput | AnalyticsEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalyticsEntries.
     */
    cursor?: AnalyticsEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalyticsEntries.
     */
    distinct?: AnalyticsEntryScalarFieldEnum | AnalyticsEntryScalarFieldEnum[]
  }

  /**
   * AnalyticsEntry findFirstOrThrow
   */
  export type AnalyticsEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEntry
     */
    select?: AnalyticsEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEntry
     */
    omit?: AnalyticsEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEntryInclude<ExtArgs> | null
    /**
     * Filter, which AnalyticsEntry to fetch.
     */
    where?: AnalyticsEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsEntries to fetch.
     */
    orderBy?: AnalyticsEntryOrderByWithRelationInput | AnalyticsEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalyticsEntries.
     */
    cursor?: AnalyticsEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalyticsEntries.
     */
    distinct?: AnalyticsEntryScalarFieldEnum | AnalyticsEntryScalarFieldEnum[]
  }

  /**
   * AnalyticsEntry findMany
   */
  export type AnalyticsEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEntry
     */
    select?: AnalyticsEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEntry
     */
    omit?: AnalyticsEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEntryInclude<ExtArgs> | null
    /**
     * Filter, which AnalyticsEntries to fetch.
     */
    where?: AnalyticsEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsEntries to fetch.
     */
    orderBy?: AnalyticsEntryOrderByWithRelationInput | AnalyticsEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AnalyticsEntries.
     */
    cursor?: AnalyticsEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsEntries.
     */
    skip?: number
    distinct?: AnalyticsEntryScalarFieldEnum | AnalyticsEntryScalarFieldEnum[]
  }

  /**
   * AnalyticsEntry create
   */
  export type AnalyticsEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEntry
     */
    select?: AnalyticsEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEntry
     */
    omit?: AnalyticsEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a AnalyticsEntry.
     */
    data: XOR<AnalyticsEntryCreateInput, AnalyticsEntryUncheckedCreateInput>
  }

  /**
   * AnalyticsEntry createMany
   */
  export type AnalyticsEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AnalyticsEntries.
     */
    data: AnalyticsEntryCreateManyInput | AnalyticsEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AnalyticsEntry createManyAndReturn
   */
  export type AnalyticsEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEntry
     */
    select?: AnalyticsEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEntry
     */
    omit?: AnalyticsEntryOmit<ExtArgs> | null
    /**
     * The data used to create many AnalyticsEntries.
     */
    data: AnalyticsEntryCreateManyInput | AnalyticsEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AnalyticsEntry update
   */
  export type AnalyticsEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEntry
     */
    select?: AnalyticsEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEntry
     */
    omit?: AnalyticsEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a AnalyticsEntry.
     */
    data: XOR<AnalyticsEntryUpdateInput, AnalyticsEntryUncheckedUpdateInput>
    /**
     * Choose, which AnalyticsEntry to update.
     */
    where: AnalyticsEntryWhereUniqueInput
  }

  /**
   * AnalyticsEntry updateMany
   */
  export type AnalyticsEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AnalyticsEntries.
     */
    data: XOR<AnalyticsEntryUpdateManyMutationInput, AnalyticsEntryUncheckedUpdateManyInput>
    /**
     * Filter which AnalyticsEntries to update
     */
    where?: AnalyticsEntryWhereInput
    /**
     * Limit how many AnalyticsEntries to update.
     */
    limit?: number
  }

  /**
   * AnalyticsEntry updateManyAndReturn
   */
  export type AnalyticsEntryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEntry
     */
    select?: AnalyticsEntrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEntry
     */
    omit?: AnalyticsEntryOmit<ExtArgs> | null
    /**
     * The data used to update AnalyticsEntries.
     */
    data: XOR<AnalyticsEntryUpdateManyMutationInput, AnalyticsEntryUncheckedUpdateManyInput>
    /**
     * Filter which AnalyticsEntries to update
     */
    where?: AnalyticsEntryWhereInput
    /**
     * Limit how many AnalyticsEntries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEntryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AnalyticsEntry upsert
   */
  export type AnalyticsEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEntry
     */
    select?: AnalyticsEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEntry
     */
    omit?: AnalyticsEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the AnalyticsEntry to update in case it exists.
     */
    where: AnalyticsEntryWhereUniqueInput
    /**
     * In case the AnalyticsEntry found by the `where` argument doesn't exist, create a new AnalyticsEntry with this data.
     */
    create: XOR<AnalyticsEntryCreateInput, AnalyticsEntryUncheckedCreateInput>
    /**
     * In case the AnalyticsEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnalyticsEntryUpdateInput, AnalyticsEntryUncheckedUpdateInput>
  }

  /**
   * AnalyticsEntry delete
   */
  export type AnalyticsEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEntry
     */
    select?: AnalyticsEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEntry
     */
    omit?: AnalyticsEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEntryInclude<ExtArgs> | null
    /**
     * Filter which AnalyticsEntry to delete.
     */
    where: AnalyticsEntryWhereUniqueInput
  }

  /**
   * AnalyticsEntry deleteMany
   */
  export type AnalyticsEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalyticsEntries to delete
     */
    where?: AnalyticsEntryWhereInput
    /**
     * Limit how many AnalyticsEntries to delete.
     */
    limit?: number
  }

  /**
   * AnalyticsEntry without action
   */
  export type AnalyticsEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEntry
     */
    select?: AnalyticsEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEntry
     */
    omit?: AnalyticsEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEntryInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    message: string | null
    read: boolean | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    message: string | null
    read: boolean | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    message: number
    read: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    message?: true
    read?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    message?: true
    read?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    message?: true
    read?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    type: string
    message: string
    read: boolean
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    message?: boolean
    read?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    message?: boolean
    read?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    message?: boolean
    read?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    message?: boolean
    read?: boolean
    createdAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "message" | "read" | "createdAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      message: string
      read: boolean
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly read: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model PasswordlessToken
   */

  export type AggregatePasswordlessToken = {
    _count: PasswordlessTokenCountAggregateOutputType | null
    _min: PasswordlessTokenMinAggregateOutputType | null
    _max: PasswordlessTokenMaxAggregateOutputType | null
  }

  export type PasswordlessTokenMinAggregateOutputType = {
    id: string | null
    token: string | null
    expiresAt: Date | null
    userId: string | null
  }

  export type PasswordlessTokenMaxAggregateOutputType = {
    id: string | null
    token: string | null
    expiresAt: Date | null
    userId: string | null
  }

  export type PasswordlessTokenCountAggregateOutputType = {
    id: number
    token: number
    expiresAt: number
    userId: number
    _all: number
  }


  export type PasswordlessTokenMinAggregateInputType = {
    id?: true
    token?: true
    expiresAt?: true
    userId?: true
  }

  export type PasswordlessTokenMaxAggregateInputType = {
    id?: true
    token?: true
    expiresAt?: true
    userId?: true
  }

  export type PasswordlessTokenCountAggregateInputType = {
    id?: true
    token?: true
    expiresAt?: true
    userId?: true
    _all?: true
  }

  export type PasswordlessTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordlessToken to aggregate.
     */
    where?: PasswordlessTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordlessTokens to fetch.
     */
    orderBy?: PasswordlessTokenOrderByWithRelationInput | PasswordlessTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordlessTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordlessTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordlessTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PasswordlessTokens
    **/
    _count?: true | PasswordlessTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordlessTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordlessTokenMaxAggregateInputType
  }

  export type GetPasswordlessTokenAggregateType<T extends PasswordlessTokenAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordlessToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordlessToken[P]>
      : GetScalarType<T[P], AggregatePasswordlessToken[P]>
  }




  export type PasswordlessTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordlessTokenWhereInput
    orderBy?: PasswordlessTokenOrderByWithAggregationInput | PasswordlessTokenOrderByWithAggregationInput[]
    by: PasswordlessTokenScalarFieldEnum[] | PasswordlessTokenScalarFieldEnum
    having?: PasswordlessTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordlessTokenCountAggregateInputType | true
    _min?: PasswordlessTokenMinAggregateInputType
    _max?: PasswordlessTokenMaxAggregateInputType
  }

  export type PasswordlessTokenGroupByOutputType = {
    id: string
    token: string
    expiresAt: Date
    userId: string
    _count: PasswordlessTokenCountAggregateOutputType | null
    _min: PasswordlessTokenMinAggregateOutputType | null
    _max: PasswordlessTokenMaxAggregateOutputType | null
  }

  type GetPasswordlessTokenGroupByPayload<T extends PasswordlessTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordlessTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordlessTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordlessTokenGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordlessTokenGroupByOutputType[P]>
        }
      >
    >


  export type PasswordlessTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    expiresAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordlessToken"]>

  export type PasswordlessTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    expiresAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordlessToken"]>

  export type PasswordlessTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    expiresAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordlessToken"]>

  export type PasswordlessTokenSelectScalar = {
    id?: boolean
    token?: boolean
    expiresAt?: boolean
    userId?: boolean
  }

  export type PasswordlessTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "token" | "expiresAt" | "userId", ExtArgs["result"]["passwordlessToken"]>
  export type PasswordlessTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasswordlessTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasswordlessTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PasswordlessTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordlessToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      token: string
      expiresAt: Date
      userId: string
    }, ExtArgs["result"]["passwordlessToken"]>
    composites: {}
  }

  type PasswordlessTokenGetPayload<S extends boolean | null | undefined | PasswordlessTokenDefaultArgs> = $Result.GetResult<Prisma.$PasswordlessTokenPayload, S>

  type PasswordlessTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PasswordlessTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PasswordlessTokenCountAggregateInputType | true
    }

  export interface PasswordlessTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordlessToken'], meta: { name: 'PasswordlessToken' } }
    /**
     * Find zero or one PasswordlessToken that matches the filter.
     * @param {PasswordlessTokenFindUniqueArgs} args - Arguments to find a PasswordlessToken
     * @example
     * // Get one PasswordlessToken
     * const passwordlessToken = await prisma.passwordlessToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordlessTokenFindUniqueArgs>(args: SelectSubset<T, PasswordlessTokenFindUniqueArgs<ExtArgs>>): Prisma__PasswordlessTokenClient<$Result.GetResult<Prisma.$PasswordlessTokenPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one PasswordlessToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PasswordlessTokenFindUniqueOrThrowArgs} args - Arguments to find a PasswordlessToken
     * @example
     * // Get one PasswordlessToken
     * const passwordlessToken = await prisma.passwordlessToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordlessTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordlessTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordlessTokenClient<$Result.GetResult<Prisma.$PasswordlessTokenPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first PasswordlessToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordlessTokenFindFirstArgs} args - Arguments to find a PasswordlessToken
     * @example
     * // Get one PasswordlessToken
     * const passwordlessToken = await prisma.passwordlessToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordlessTokenFindFirstArgs>(args?: SelectSubset<T, PasswordlessTokenFindFirstArgs<ExtArgs>>): Prisma__PasswordlessTokenClient<$Result.GetResult<Prisma.$PasswordlessTokenPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first PasswordlessToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordlessTokenFindFirstOrThrowArgs} args - Arguments to find a PasswordlessToken
     * @example
     * // Get one PasswordlessToken
     * const passwordlessToken = await prisma.passwordlessToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordlessTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordlessTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordlessTokenClient<$Result.GetResult<Prisma.$PasswordlessTokenPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more PasswordlessTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordlessTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordlessTokens
     * const passwordlessTokens = await prisma.passwordlessToken.findMany()
     * 
     * // Get first 10 PasswordlessTokens
     * const passwordlessTokens = await prisma.passwordlessToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordlessTokenWithIdOnly = await prisma.passwordlessToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasswordlessTokenFindManyArgs>(args?: SelectSubset<T, PasswordlessTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordlessTokenPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a PasswordlessToken.
     * @param {PasswordlessTokenCreateArgs} args - Arguments to create a PasswordlessToken.
     * @example
     * // Create one PasswordlessToken
     * const PasswordlessToken = await prisma.passwordlessToken.create({
     *   data: {
     *     // ... data to create a PasswordlessToken
     *   }
     * })
     * 
     */
    create<T extends PasswordlessTokenCreateArgs>(args: SelectSubset<T, PasswordlessTokenCreateArgs<ExtArgs>>): Prisma__PasswordlessTokenClient<$Result.GetResult<Prisma.$PasswordlessTokenPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many PasswordlessTokens.
     * @param {PasswordlessTokenCreateManyArgs} args - Arguments to create many PasswordlessTokens.
     * @example
     * // Create many PasswordlessTokens
     * const passwordlessToken = await prisma.passwordlessToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordlessTokenCreateManyArgs>(args?: SelectSubset<T, PasswordlessTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PasswordlessTokens and returns the data saved in the database.
     * @param {PasswordlessTokenCreateManyAndReturnArgs} args - Arguments to create many PasswordlessTokens.
     * @example
     * // Create many PasswordlessTokens
     * const passwordlessToken = await prisma.passwordlessToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PasswordlessTokens and only return the `id`
     * const passwordlessTokenWithIdOnly = await prisma.passwordlessToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PasswordlessTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, PasswordlessTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordlessTokenPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a PasswordlessToken.
     * @param {PasswordlessTokenDeleteArgs} args - Arguments to delete one PasswordlessToken.
     * @example
     * // Delete one PasswordlessToken
     * const PasswordlessToken = await prisma.passwordlessToken.delete({
     *   where: {
     *     // ... filter to delete one PasswordlessToken
     *   }
     * })
     * 
     */
    delete<T extends PasswordlessTokenDeleteArgs>(args: SelectSubset<T, PasswordlessTokenDeleteArgs<ExtArgs>>): Prisma__PasswordlessTokenClient<$Result.GetResult<Prisma.$PasswordlessTokenPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one PasswordlessToken.
     * @param {PasswordlessTokenUpdateArgs} args - Arguments to update one PasswordlessToken.
     * @example
     * // Update one PasswordlessToken
     * const passwordlessToken = await prisma.passwordlessToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordlessTokenUpdateArgs>(args: SelectSubset<T, PasswordlessTokenUpdateArgs<ExtArgs>>): Prisma__PasswordlessTokenClient<$Result.GetResult<Prisma.$PasswordlessTokenPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more PasswordlessTokens.
     * @param {PasswordlessTokenDeleteManyArgs} args - Arguments to filter PasswordlessTokens to delete.
     * @example
     * // Delete a few PasswordlessTokens
     * const { count } = await prisma.passwordlessToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordlessTokenDeleteManyArgs>(args?: SelectSubset<T, PasswordlessTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordlessTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordlessTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordlessTokens
     * const passwordlessToken = await prisma.passwordlessToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordlessTokenUpdateManyArgs>(args: SelectSubset<T, PasswordlessTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordlessTokens and returns the data updated in the database.
     * @param {PasswordlessTokenUpdateManyAndReturnArgs} args - Arguments to update many PasswordlessTokens.
     * @example
     * // Update many PasswordlessTokens
     * const passwordlessToken = await prisma.passwordlessToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PasswordlessTokens and only return the `id`
     * const passwordlessTokenWithIdOnly = await prisma.passwordlessToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PasswordlessTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, PasswordlessTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordlessTokenPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one PasswordlessToken.
     * @param {PasswordlessTokenUpsertArgs} args - Arguments to update or create a PasswordlessToken.
     * @example
     * // Update or create a PasswordlessToken
     * const passwordlessToken = await prisma.passwordlessToken.upsert({
     *   create: {
     *     // ... data to create a PasswordlessToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordlessToken we want to update
     *   }
     * })
     */
    upsert<T extends PasswordlessTokenUpsertArgs>(args: SelectSubset<T, PasswordlessTokenUpsertArgs<ExtArgs>>): Prisma__PasswordlessTokenClient<$Result.GetResult<Prisma.$PasswordlessTokenPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of PasswordlessTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordlessTokenCountArgs} args - Arguments to filter PasswordlessTokens to count.
     * @example
     * // Count the number of PasswordlessTokens
     * const count = await prisma.passwordlessToken.count({
     *   where: {
     *     // ... the filter for the PasswordlessTokens we want to count
     *   }
     * })
    **/
    count<T extends PasswordlessTokenCountArgs>(
      args?: Subset<T, PasswordlessTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordlessTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordlessToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordlessTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordlessTokenAggregateArgs>(args: Subset<T, PasswordlessTokenAggregateArgs>): Prisma.PrismaPromise<GetPasswordlessTokenAggregateType<T>>

    /**
     * Group by PasswordlessToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordlessTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordlessTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordlessTokenGroupByArgs['orderBy'] }
        : { orderBy?: PasswordlessTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordlessTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordlessTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordlessToken model
   */
  readonly fields: PasswordlessTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordlessToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordlessTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PasswordlessToken model
   */ 
  interface PasswordlessTokenFieldRefs {
    readonly id: FieldRef<"PasswordlessToken", 'String'>
    readonly token: FieldRef<"PasswordlessToken", 'String'>
    readonly expiresAt: FieldRef<"PasswordlessToken", 'DateTime'>
    readonly userId: FieldRef<"PasswordlessToken", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PasswordlessToken findUnique
   */
  export type PasswordlessTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordlessToken
     */
    select?: PasswordlessTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordlessToken
     */
    omit?: PasswordlessTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordlessTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordlessToken to fetch.
     */
    where: PasswordlessTokenWhereUniqueInput
  }

  /**
   * PasswordlessToken findUniqueOrThrow
   */
  export type PasswordlessTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordlessToken
     */
    select?: PasswordlessTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordlessToken
     */
    omit?: PasswordlessTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordlessTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordlessToken to fetch.
     */
    where: PasswordlessTokenWhereUniqueInput
  }

  /**
   * PasswordlessToken findFirst
   */
  export type PasswordlessTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordlessToken
     */
    select?: PasswordlessTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordlessToken
     */
    omit?: PasswordlessTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordlessTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordlessToken to fetch.
     */
    where?: PasswordlessTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordlessTokens to fetch.
     */
    orderBy?: PasswordlessTokenOrderByWithRelationInput | PasswordlessTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordlessTokens.
     */
    cursor?: PasswordlessTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordlessTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordlessTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordlessTokens.
     */
    distinct?: PasswordlessTokenScalarFieldEnum | PasswordlessTokenScalarFieldEnum[]
  }

  /**
   * PasswordlessToken findFirstOrThrow
   */
  export type PasswordlessTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordlessToken
     */
    select?: PasswordlessTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordlessToken
     */
    omit?: PasswordlessTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordlessTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordlessToken to fetch.
     */
    where?: PasswordlessTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordlessTokens to fetch.
     */
    orderBy?: PasswordlessTokenOrderByWithRelationInput | PasswordlessTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordlessTokens.
     */
    cursor?: PasswordlessTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordlessTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordlessTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordlessTokens.
     */
    distinct?: PasswordlessTokenScalarFieldEnum | PasswordlessTokenScalarFieldEnum[]
  }

  /**
   * PasswordlessToken findMany
   */
  export type PasswordlessTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordlessToken
     */
    select?: PasswordlessTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordlessToken
     */
    omit?: PasswordlessTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordlessTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordlessTokens to fetch.
     */
    where?: PasswordlessTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordlessTokens to fetch.
     */
    orderBy?: PasswordlessTokenOrderByWithRelationInput | PasswordlessTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PasswordlessTokens.
     */
    cursor?: PasswordlessTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordlessTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordlessTokens.
     */
    skip?: number
    distinct?: PasswordlessTokenScalarFieldEnum | PasswordlessTokenScalarFieldEnum[]
  }

  /**
   * PasswordlessToken create
   */
  export type PasswordlessTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordlessToken
     */
    select?: PasswordlessTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordlessToken
     */
    omit?: PasswordlessTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordlessTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a PasswordlessToken.
     */
    data: XOR<PasswordlessTokenCreateInput, PasswordlessTokenUncheckedCreateInput>
  }

  /**
   * PasswordlessToken createMany
   */
  export type PasswordlessTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordlessTokens.
     */
    data: PasswordlessTokenCreateManyInput | PasswordlessTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordlessToken createManyAndReturn
   */
  export type PasswordlessTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordlessToken
     */
    select?: PasswordlessTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordlessToken
     */
    omit?: PasswordlessTokenOmit<ExtArgs> | null
    /**
     * The data used to create many PasswordlessTokens.
     */
    data: PasswordlessTokenCreateManyInput | PasswordlessTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordlessTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordlessToken update
   */
  export type PasswordlessTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordlessToken
     */
    select?: PasswordlessTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordlessToken
     */
    omit?: PasswordlessTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordlessTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a PasswordlessToken.
     */
    data: XOR<PasswordlessTokenUpdateInput, PasswordlessTokenUncheckedUpdateInput>
    /**
     * Choose, which PasswordlessToken to update.
     */
    where: PasswordlessTokenWhereUniqueInput
  }

  /**
   * PasswordlessToken updateMany
   */
  export type PasswordlessTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordlessTokens.
     */
    data: XOR<PasswordlessTokenUpdateManyMutationInput, PasswordlessTokenUncheckedUpdateManyInput>
    /**
     * Filter which PasswordlessTokens to update
     */
    where?: PasswordlessTokenWhereInput
    /**
     * Limit how many PasswordlessTokens to update.
     */
    limit?: number
  }

  /**
   * PasswordlessToken updateManyAndReturn
   */
  export type PasswordlessTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordlessToken
     */
    select?: PasswordlessTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordlessToken
     */
    omit?: PasswordlessTokenOmit<ExtArgs> | null
    /**
     * The data used to update PasswordlessTokens.
     */
    data: XOR<PasswordlessTokenUpdateManyMutationInput, PasswordlessTokenUncheckedUpdateManyInput>
    /**
     * Filter which PasswordlessTokens to update
     */
    where?: PasswordlessTokenWhereInput
    /**
     * Limit how many PasswordlessTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordlessTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordlessToken upsert
   */
  export type PasswordlessTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordlessToken
     */
    select?: PasswordlessTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordlessToken
     */
    omit?: PasswordlessTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordlessTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the PasswordlessToken to update in case it exists.
     */
    where: PasswordlessTokenWhereUniqueInput
    /**
     * In case the PasswordlessToken found by the `where` argument doesn't exist, create a new PasswordlessToken with this data.
     */
    create: XOR<PasswordlessTokenCreateInput, PasswordlessTokenUncheckedCreateInput>
    /**
     * In case the PasswordlessToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordlessTokenUpdateInput, PasswordlessTokenUncheckedUpdateInput>
  }

  /**
   * PasswordlessToken delete
   */
  export type PasswordlessTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordlessToken
     */
    select?: PasswordlessTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordlessToken
     */
    omit?: PasswordlessTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordlessTokenInclude<ExtArgs> | null
    /**
     * Filter which PasswordlessToken to delete.
     */
    where: PasswordlessTokenWhereUniqueInput
  }

  /**
   * PasswordlessToken deleteMany
   */
  export type PasswordlessTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordlessTokens to delete
     */
    where?: PasswordlessTokenWhereInput
    /**
     * Limit how many PasswordlessTokens to delete.
     */
    limit?: number
  }

  /**
   * PasswordlessToken without action
   */
  export type PasswordlessTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordlessToken
     */
    select?: PasswordlessTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordlessToken
     */
    omit?: PasswordlessTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordlessTokenInclude<ExtArgs> | null
  }


  /**
   * Model DailyChallenge
   */

  export type AggregateDailyChallenge = {
    _count: DailyChallengeCountAggregateOutputType | null
    _min: DailyChallengeMinAggregateOutputType | null
    _max: DailyChallengeMaxAggregateOutputType | null
  }

  export type DailyChallengeMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    description: string | null
    reward: string | null
    completed: boolean | null
    createdAt: Date | null
    completedAt: Date | null
  }

  export type DailyChallengeMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    description: string | null
    reward: string | null
    completed: boolean | null
    createdAt: Date | null
    completedAt: Date | null
  }

  export type DailyChallengeCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    description: number
    reward: number
    completed: number
    createdAt: number
    completedAt: number
    _all: number
  }


  export type DailyChallengeMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    reward?: true
    completed?: true
    createdAt?: true
    completedAt?: true
  }

  export type DailyChallengeMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    reward?: true
    completed?: true
    createdAt?: true
    completedAt?: true
  }

  export type DailyChallengeCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    reward?: true
    completed?: true
    createdAt?: true
    completedAt?: true
    _all?: true
  }

  export type DailyChallengeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyChallenge to aggregate.
     */
    where?: DailyChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyChallenges to fetch.
     */
    orderBy?: DailyChallengeOrderByWithRelationInput | DailyChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DailyChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyChallenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyChallenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DailyChallenges
    **/
    _count?: true | DailyChallengeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DailyChallengeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DailyChallengeMaxAggregateInputType
  }

  export type GetDailyChallengeAggregateType<T extends DailyChallengeAggregateArgs> = {
        [P in keyof T & keyof AggregateDailyChallenge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDailyChallenge[P]>
      : GetScalarType<T[P], AggregateDailyChallenge[P]>
  }




  export type DailyChallengeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyChallengeWhereInput
    orderBy?: DailyChallengeOrderByWithAggregationInput | DailyChallengeOrderByWithAggregationInput[]
    by: DailyChallengeScalarFieldEnum[] | DailyChallengeScalarFieldEnum
    having?: DailyChallengeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DailyChallengeCountAggregateInputType | true
    _min?: DailyChallengeMinAggregateInputType
    _max?: DailyChallengeMaxAggregateInputType
  }

  export type DailyChallengeGroupByOutputType = {
    id: string
    userId: string
    title: string
    description: string
    reward: string
    completed: boolean
    createdAt: Date
    completedAt: Date | null
    _count: DailyChallengeCountAggregateOutputType | null
    _min: DailyChallengeMinAggregateOutputType | null
    _max: DailyChallengeMaxAggregateOutputType | null
  }

  type GetDailyChallengeGroupByPayload<T extends DailyChallengeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DailyChallengeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DailyChallengeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DailyChallengeGroupByOutputType[P]>
            : GetScalarType<T[P], DailyChallengeGroupByOutputType[P]>
        }
      >
    >


  export type DailyChallengeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    reward?: boolean
    completed?: boolean
    createdAt?: boolean
    completedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyChallenge"]>

  export type DailyChallengeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    reward?: boolean
    completed?: boolean
    createdAt?: boolean
    completedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyChallenge"]>

  export type DailyChallengeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    reward?: boolean
    completed?: boolean
    createdAt?: boolean
    completedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyChallenge"]>

  export type DailyChallengeSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    reward?: boolean
    completed?: boolean
    createdAt?: boolean
    completedAt?: boolean
  }

  export type DailyChallengeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "description" | "reward" | "completed" | "createdAt" | "completedAt", ExtArgs["result"]["dailyChallenge"]>
  export type DailyChallengeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DailyChallengeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DailyChallengeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DailyChallengePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DailyChallenge"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      description: string
      reward: string
      completed: boolean
      createdAt: Date
      completedAt: Date | null
    }, ExtArgs["result"]["dailyChallenge"]>
    composites: {}
  }

  type DailyChallengeGetPayload<S extends boolean | null | undefined | DailyChallengeDefaultArgs> = $Result.GetResult<Prisma.$DailyChallengePayload, S>

  type DailyChallengeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DailyChallengeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DailyChallengeCountAggregateInputType | true
    }

  export interface DailyChallengeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DailyChallenge'], meta: { name: 'DailyChallenge' } }
    /**
     * Find zero or one DailyChallenge that matches the filter.
     * @param {DailyChallengeFindUniqueArgs} args - Arguments to find a DailyChallenge
     * @example
     * // Get one DailyChallenge
     * const dailyChallenge = await prisma.dailyChallenge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DailyChallengeFindUniqueArgs>(args: SelectSubset<T, DailyChallengeFindUniqueArgs<ExtArgs>>): Prisma__DailyChallengeClient<$Result.GetResult<Prisma.$DailyChallengePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one DailyChallenge that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DailyChallengeFindUniqueOrThrowArgs} args - Arguments to find a DailyChallenge
     * @example
     * // Get one DailyChallenge
     * const dailyChallenge = await prisma.dailyChallenge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DailyChallengeFindUniqueOrThrowArgs>(args: SelectSubset<T, DailyChallengeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DailyChallengeClient<$Result.GetResult<Prisma.$DailyChallengePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first DailyChallenge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyChallengeFindFirstArgs} args - Arguments to find a DailyChallenge
     * @example
     * // Get one DailyChallenge
     * const dailyChallenge = await prisma.dailyChallenge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DailyChallengeFindFirstArgs>(args?: SelectSubset<T, DailyChallengeFindFirstArgs<ExtArgs>>): Prisma__DailyChallengeClient<$Result.GetResult<Prisma.$DailyChallengePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first DailyChallenge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyChallengeFindFirstOrThrowArgs} args - Arguments to find a DailyChallenge
     * @example
     * // Get one DailyChallenge
     * const dailyChallenge = await prisma.dailyChallenge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DailyChallengeFindFirstOrThrowArgs>(args?: SelectSubset<T, DailyChallengeFindFirstOrThrowArgs<ExtArgs>>): Prisma__DailyChallengeClient<$Result.GetResult<Prisma.$DailyChallengePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more DailyChallenges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyChallengeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DailyChallenges
     * const dailyChallenges = await prisma.dailyChallenge.findMany()
     * 
     * // Get first 10 DailyChallenges
     * const dailyChallenges = await prisma.dailyChallenge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dailyChallengeWithIdOnly = await prisma.dailyChallenge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DailyChallengeFindManyArgs>(args?: SelectSubset<T, DailyChallengeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyChallengePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a DailyChallenge.
     * @param {DailyChallengeCreateArgs} args - Arguments to create a DailyChallenge.
     * @example
     * // Create one DailyChallenge
     * const DailyChallenge = await prisma.dailyChallenge.create({
     *   data: {
     *     // ... data to create a DailyChallenge
     *   }
     * })
     * 
     */
    create<T extends DailyChallengeCreateArgs>(args: SelectSubset<T, DailyChallengeCreateArgs<ExtArgs>>): Prisma__DailyChallengeClient<$Result.GetResult<Prisma.$DailyChallengePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many DailyChallenges.
     * @param {DailyChallengeCreateManyArgs} args - Arguments to create many DailyChallenges.
     * @example
     * // Create many DailyChallenges
     * const dailyChallenge = await prisma.dailyChallenge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DailyChallengeCreateManyArgs>(args?: SelectSubset<T, DailyChallengeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DailyChallenges and returns the data saved in the database.
     * @param {DailyChallengeCreateManyAndReturnArgs} args - Arguments to create many DailyChallenges.
     * @example
     * // Create many DailyChallenges
     * const dailyChallenge = await prisma.dailyChallenge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DailyChallenges and only return the `id`
     * const dailyChallengeWithIdOnly = await prisma.dailyChallenge.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DailyChallengeCreateManyAndReturnArgs>(args?: SelectSubset<T, DailyChallengeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyChallengePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a DailyChallenge.
     * @param {DailyChallengeDeleteArgs} args - Arguments to delete one DailyChallenge.
     * @example
     * // Delete one DailyChallenge
     * const DailyChallenge = await prisma.dailyChallenge.delete({
     *   where: {
     *     // ... filter to delete one DailyChallenge
     *   }
     * })
     * 
     */
    delete<T extends DailyChallengeDeleteArgs>(args: SelectSubset<T, DailyChallengeDeleteArgs<ExtArgs>>): Prisma__DailyChallengeClient<$Result.GetResult<Prisma.$DailyChallengePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one DailyChallenge.
     * @param {DailyChallengeUpdateArgs} args - Arguments to update one DailyChallenge.
     * @example
     * // Update one DailyChallenge
     * const dailyChallenge = await prisma.dailyChallenge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DailyChallengeUpdateArgs>(args: SelectSubset<T, DailyChallengeUpdateArgs<ExtArgs>>): Prisma__DailyChallengeClient<$Result.GetResult<Prisma.$DailyChallengePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more DailyChallenges.
     * @param {DailyChallengeDeleteManyArgs} args - Arguments to filter DailyChallenges to delete.
     * @example
     * // Delete a few DailyChallenges
     * const { count } = await prisma.dailyChallenge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DailyChallengeDeleteManyArgs>(args?: SelectSubset<T, DailyChallengeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyChallenges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyChallengeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DailyChallenges
     * const dailyChallenge = await prisma.dailyChallenge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DailyChallengeUpdateManyArgs>(args: SelectSubset<T, DailyChallengeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyChallenges and returns the data updated in the database.
     * @param {DailyChallengeUpdateManyAndReturnArgs} args - Arguments to update many DailyChallenges.
     * @example
     * // Update many DailyChallenges
     * const dailyChallenge = await prisma.dailyChallenge.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DailyChallenges and only return the `id`
     * const dailyChallengeWithIdOnly = await prisma.dailyChallenge.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DailyChallengeUpdateManyAndReturnArgs>(args: SelectSubset<T, DailyChallengeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyChallengePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one DailyChallenge.
     * @param {DailyChallengeUpsertArgs} args - Arguments to update or create a DailyChallenge.
     * @example
     * // Update or create a DailyChallenge
     * const dailyChallenge = await prisma.dailyChallenge.upsert({
     *   create: {
     *     // ... data to create a DailyChallenge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DailyChallenge we want to update
     *   }
     * })
     */
    upsert<T extends DailyChallengeUpsertArgs>(args: SelectSubset<T, DailyChallengeUpsertArgs<ExtArgs>>): Prisma__DailyChallengeClient<$Result.GetResult<Prisma.$DailyChallengePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of DailyChallenges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyChallengeCountArgs} args - Arguments to filter DailyChallenges to count.
     * @example
     * // Count the number of DailyChallenges
     * const count = await prisma.dailyChallenge.count({
     *   where: {
     *     // ... the filter for the DailyChallenges we want to count
     *   }
     * })
    **/
    count<T extends DailyChallengeCountArgs>(
      args?: Subset<T, DailyChallengeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DailyChallengeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DailyChallenge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyChallengeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DailyChallengeAggregateArgs>(args: Subset<T, DailyChallengeAggregateArgs>): Prisma.PrismaPromise<GetDailyChallengeAggregateType<T>>

    /**
     * Group by DailyChallenge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyChallengeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DailyChallengeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DailyChallengeGroupByArgs['orderBy'] }
        : { orderBy?: DailyChallengeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DailyChallengeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDailyChallengeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DailyChallenge model
   */
  readonly fields: DailyChallengeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DailyChallenge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DailyChallengeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DailyChallenge model
   */ 
  interface DailyChallengeFieldRefs {
    readonly id: FieldRef<"DailyChallenge", 'String'>
    readonly userId: FieldRef<"DailyChallenge", 'String'>
    readonly title: FieldRef<"DailyChallenge", 'String'>
    readonly description: FieldRef<"DailyChallenge", 'String'>
    readonly reward: FieldRef<"DailyChallenge", 'String'>
    readonly completed: FieldRef<"DailyChallenge", 'Boolean'>
    readonly createdAt: FieldRef<"DailyChallenge", 'DateTime'>
    readonly completedAt: FieldRef<"DailyChallenge", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DailyChallenge findUnique
   */
  export type DailyChallengeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyChallenge
     */
    select?: DailyChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyChallenge
     */
    omit?: DailyChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyChallengeInclude<ExtArgs> | null
    /**
     * Filter, which DailyChallenge to fetch.
     */
    where: DailyChallengeWhereUniqueInput
  }

  /**
   * DailyChallenge findUniqueOrThrow
   */
  export type DailyChallengeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyChallenge
     */
    select?: DailyChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyChallenge
     */
    omit?: DailyChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyChallengeInclude<ExtArgs> | null
    /**
     * Filter, which DailyChallenge to fetch.
     */
    where: DailyChallengeWhereUniqueInput
  }

  /**
   * DailyChallenge findFirst
   */
  export type DailyChallengeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyChallenge
     */
    select?: DailyChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyChallenge
     */
    omit?: DailyChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyChallengeInclude<ExtArgs> | null
    /**
     * Filter, which DailyChallenge to fetch.
     */
    where?: DailyChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyChallenges to fetch.
     */
    orderBy?: DailyChallengeOrderByWithRelationInput | DailyChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyChallenges.
     */
    cursor?: DailyChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyChallenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyChallenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyChallenges.
     */
    distinct?: DailyChallengeScalarFieldEnum | DailyChallengeScalarFieldEnum[]
  }

  /**
   * DailyChallenge findFirstOrThrow
   */
  export type DailyChallengeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyChallenge
     */
    select?: DailyChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyChallenge
     */
    omit?: DailyChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyChallengeInclude<ExtArgs> | null
    /**
     * Filter, which DailyChallenge to fetch.
     */
    where?: DailyChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyChallenges to fetch.
     */
    orderBy?: DailyChallengeOrderByWithRelationInput | DailyChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyChallenges.
     */
    cursor?: DailyChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyChallenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyChallenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyChallenges.
     */
    distinct?: DailyChallengeScalarFieldEnum | DailyChallengeScalarFieldEnum[]
  }

  /**
   * DailyChallenge findMany
   */
  export type DailyChallengeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyChallenge
     */
    select?: DailyChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyChallenge
     */
    omit?: DailyChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyChallengeInclude<ExtArgs> | null
    /**
     * Filter, which DailyChallenges to fetch.
     */
    where?: DailyChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyChallenges to fetch.
     */
    orderBy?: DailyChallengeOrderByWithRelationInput | DailyChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DailyChallenges.
     */
    cursor?: DailyChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyChallenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyChallenges.
     */
    skip?: number
    distinct?: DailyChallengeScalarFieldEnum | DailyChallengeScalarFieldEnum[]
  }

  /**
   * DailyChallenge create
   */
  export type DailyChallengeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyChallenge
     */
    select?: DailyChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyChallenge
     */
    omit?: DailyChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyChallengeInclude<ExtArgs> | null
    /**
     * The data needed to create a DailyChallenge.
     */
    data: XOR<DailyChallengeCreateInput, DailyChallengeUncheckedCreateInput>
  }

  /**
   * DailyChallenge createMany
   */
  export type DailyChallengeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DailyChallenges.
     */
    data: DailyChallengeCreateManyInput | DailyChallengeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DailyChallenge createManyAndReturn
   */
  export type DailyChallengeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyChallenge
     */
    select?: DailyChallengeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DailyChallenge
     */
    omit?: DailyChallengeOmit<ExtArgs> | null
    /**
     * The data used to create many DailyChallenges.
     */
    data: DailyChallengeCreateManyInput | DailyChallengeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyChallengeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DailyChallenge update
   */
  export type DailyChallengeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyChallenge
     */
    select?: DailyChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyChallenge
     */
    omit?: DailyChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyChallengeInclude<ExtArgs> | null
    /**
     * The data needed to update a DailyChallenge.
     */
    data: XOR<DailyChallengeUpdateInput, DailyChallengeUncheckedUpdateInput>
    /**
     * Choose, which DailyChallenge to update.
     */
    where: DailyChallengeWhereUniqueInput
  }

  /**
   * DailyChallenge updateMany
   */
  export type DailyChallengeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DailyChallenges.
     */
    data: XOR<DailyChallengeUpdateManyMutationInput, DailyChallengeUncheckedUpdateManyInput>
    /**
     * Filter which DailyChallenges to update
     */
    where?: DailyChallengeWhereInput
    /**
     * Limit how many DailyChallenges to update.
     */
    limit?: number
  }

  /**
   * DailyChallenge updateManyAndReturn
   */
  export type DailyChallengeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyChallenge
     */
    select?: DailyChallengeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DailyChallenge
     */
    omit?: DailyChallengeOmit<ExtArgs> | null
    /**
     * The data used to update DailyChallenges.
     */
    data: XOR<DailyChallengeUpdateManyMutationInput, DailyChallengeUncheckedUpdateManyInput>
    /**
     * Filter which DailyChallenges to update
     */
    where?: DailyChallengeWhereInput
    /**
     * Limit how many DailyChallenges to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyChallengeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DailyChallenge upsert
   */
  export type DailyChallengeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyChallenge
     */
    select?: DailyChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyChallenge
     */
    omit?: DailyChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyChallengeInclude<ExtArgs> | null
    /**
     * The filter to search for the DailyChallenge to update in case it exists.
     */
    where: DailyChallengeWhereUniqueInput
    /**
     * In case the DailyChallenge found by the `where` argument doesn't exist, create a new DailyChallenge with this data.
     */
    create: XOR<DailyChallengeCreateInput, DailyChallengeUncheckedCreateInput>
    /**
     * In case the DailyChallenge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DailyChallengeUpdateInput, DailyChallengeUncheckedUpdateInput>
  }

  /**
   * DailyChallenge delete
   */
  export type DailyChallengeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyChallenge
     */
    select?: DailyChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyChallenge
     */
    omit?: DailyChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyChallengeInclude<ExtArgs> | null
    /**
     * Filter which DailyChallenge to delete.
     */
    where: DailyChallengeWhereUniqueInput
  }

  /**
   * DailyChallenge deleteMany
   */
  export type DailyChallengeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyChallenges to delete
     */
    where?: DailyChallengeWhereInput
    /**
     * Limit how many DailyChallenges to delete.
     */
    limit?: number
  }

  /**
   * DailyChallenge without action
   */
  export type DailyChallengeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyChallenge
     */
    select?: DailyChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyChallenge
     */
    omit?: DailyChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyChallengeInclude<ExtArgs> | null
  }


  /**
   * Model ExternalGoal
   */

  export type AggregateExternalGoal = {
    _count: ExternalGoalCountAggregateOutputType | null
    _avg: ExternalGoalAvgAggregateOutputType | null
    _sum: ExternalGoalSumAggregateOutputType | null
    _min: ExternalGoalMinAggregateOutputType | null
    _max: ExternalGoalMaxAggregateOutputType | null
  }

  export type ExternalGoalAvgAggregateOutputType = {
    progress: number | null
  }

  export type ExternalGoalSumAggregateOutputType = {
    progress: number | null
  }

  export type ExternalGoalMinAggregateOutputType = {
    id: string | null
    userId: string | null
    platform: string | null
    title: string | null
    progress: number | null
    dueDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExternalGoalMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    platform: string | null
    title: string | null
    progress: number | null
    dueDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExternalGoalCountAggregateOutputType = {
    id: number
    userId: number
    platform: number
    title: number
    progress: number
    dueDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExternalGoalAvgAggregateInputType = {
    progress?: true
  }

  export type ExternalGoalSumAggregateInputType = {
    progress?: true
  }

  export type ExternalGoalMinAggregateInputType = {
    id?: true
    userId?: true
    platform?: true
    title?: true
    progress?: true
    dueDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExternalGoalMaxAggregateInputType = {
    id?: true
    userId?: true
    platform?: true
    title?: true
    progress?: true
    dueDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExternalGoalCountAggregateInputType = {
    id?: true
    userId?: true
    platform?: true
    title?: true
    progress?: true
    dueDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExternalGoalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExternalGoal to aggregate.
     */
    where?: ExternalGoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExternalGoals to fetch.
     */
    orderBy?: ExternalGoalOrderByWithRelationInput | ExternalGoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExternalGoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExternalGoals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExternalGoals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExternalGoals
    **/
    _count?: true | ExternalGoalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExternalGoalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExternalGoalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExternalGoalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExternalGoalMaxAggregateInputType
  }

  export type GetExternalGoalAggregateType<T extends ExternalGoalAggregateArgs> = {
        [P in keyof T & keyof AggregateExternalGoal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExternalGoal[P]>
      : GetScalarType<T[P], AggregateExternalGoal[P]>
  }




  export type ExternalGoalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExternalGoalWhereInput
    orderBy?: ExternalGoalOrderByWithAggregationInput | ExternalGoalOrderByWithAggregationInput[]
    by: ExternalGoalScalarFieldEnum[] | ExternalGoalScalarFieldEnum
    having?: ExternalGoalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExternalGoalCountAggregateInputType | true
    _avg?: ExternalGoalAvgAggregateInputType
    _sum?: ExternalGoalSumAggregateInputType
    _min?: ExternalGoalMinAggregateInputType
    _max?: ExternalGoalMaxAggregateInputType
  }

  export type ExternalGoalGroupByOutputType = {
    id: string
    userId: string
    platform: string
    title: string
    progress: number
    dueDate: Date
    createdAt: Date
    updatedAt: Date
    _count: ExternalGoalCountAggregateOutputType | null
    _avg: ExternalGoalAvgAggregateOutputType | null
    _sum: ExternalGoalSumAggregateOutputType | null
    _min: ExternalGoalMinAggregateOutputType | null
    _max: ExternalGoalMaxAggregateOutputType | null
  }

  type GetExternalGoalGroupByPayload<T extends ExternalGoalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExternalGoalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExternalGoalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExternalGoalGroupByOutputType[P]>
            : GetScalarType<T[P], ExternalGoalGroupByOutputType[P]>
        }
      >
    >


  export type ExternalGoalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    platform?: boolean
    title?: boolean
    progress?: boolean
    dueDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["externalGoal"]>

  export type ExternalGoalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    platform?: boolean
    title?: boolean
    progress?: boolean
    dueDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["externalGoal"]>

  export type ExternalGoalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    platform?: boolean
    title?: boolean
    progress?: boolean
    dueDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["externalGoal"]>

  export type ExternalGoalSelectScalar = {
    id?: boolean
    userId?: boolean
    platform?: boolean
    title?: boolean
    progress?: boolean
    dueDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExternalGoalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "platform" | "title" | "progress" | "dueDate" | "createdAt" | "updatedAt", ExtArgs["result"]["externalGoal"]>
  export type ExternalGoalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ExternalGoalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ExternalGoalIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ExternalGoalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExternalGoal"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      platform: string
      title: string
      progress: number
      dueDate: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["externalGoal"]>
    composites: {}
  }

  type ExternalGoalGetPayload<S extends boolean | null | undefined | ExternalGoalDefaultArgs> = $Result.GetResult<Prisma.$ExternalGoalPayload, S>

  type ExternalGoalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExternalGoalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExternalGoalCountAggregateInputType | true
    }

  export interface ExternalGoalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExternalGoal'], meta: { name: 'ExternalGoal' } }
    /**
     * Find zero or one ExternalGoal that matches the filter.
     * @param {ExternalGoalFindUniqueArgs} args - Arguments to find a ExternalGoal
     * @example
     * // Get one ExternalGoal
     * const externalGoal = await prisma.externalGoal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExternalGoalFindUniqueArgs>(args: SelectSubset<T, ExternalGoalFindUniqueArgs<ExtArgs>>): Prisma__ExternalGoalClient<$Result.GetResult<Prisma.$ExternalGoalPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ExternalGoal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExternalGoalFindUniqueOrThrowArgs} args - Arguments to find a ExternalGoal
     * @example
     * // Get one ExternalGoal
     * const externalGoal = await prisma.externalGoal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExternalGoalFindUniqueOrThrowArgs>(args: SelectSubset<T, ExternalGoalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExternalGoalClient<$Result.GetResult<Prisma.$ExternalGoalPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ExternalGoal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalGoalFindFirstArgs} args - Arguments to find a ExternalGoal
     * @example
     * // Get one ExternalGoal
     * const externalGoal = await prisma.externalGoal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExternalGoalFindFirstArgs>(args?: SelectSubset<T, ExternalGoalFindFirstArgs<ExtArgs>>): Prisma__ExternalGoalClient<$Result.GetResult<Prisma.$ExternalGoalPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ExternalGoal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalGoalFindFirstOrThrowArgs} args - Arguments to find a ExternalGoal
     * @example
     * // Get one ExternalGoal
     * const externalGoal = await prisma.externalGoal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExternalGoalFindFirstOrThrowArgs>(args?: SelectSubset<T, ExternalGoalFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExternalGoalClient<$Result.GetResult<Prisma.$ExternalGoalPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ExternalGoals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalGoalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExternalGoals
     * const externalGoals = await prisma.externalGoal.findMany()
     * 
     * // Get first 10 ExternalGoals
     * const externalGoals = await prisma.externalGoal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const externalGoalWithIdOnly = await prisma.externalGoal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExternalGoalFindManyArgs>(args?: SelectSubset<T, ExternalGoalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExternalGoalPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ExternalGoal.
     * @param {ExternalGoalCreateArgs} args - Arguments to create a ExternalGoal.
     * @example
     * // Create one ExternalGoal
     * const ExternalGoal = await prisma.externalGoal.create({
     *   data: {
     *     // ... data to create a ExternalGoal
     *   }
     * })
     * 
     */
    create<T extends ExternalGoalCreateArgs>(args: SelectSubset<T, ExternalGoalCreateArgs<ExtArgs>>): Prisma__ExternalGoalClient<$Result.GetResult<Prisma.$ExternalGoalPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ExternalGoals.
     * @param {ExternalGoalCreateManyArgs} args - Arguments to create many ExternalGoals.
     * @example
     * // Create many ExternalGoals
     * const externalGoal = await prisma.externalGoal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExternalGoalCreateManyArgs>(args?: SelectSubset<T, ExternalGoalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExternalGoals and returns the data saved in the database.
     * @param {ExternalGoalCreateManyAndReturnArgs} args - Arguments to create many ExternalGoals.
     * @example
     * // Create many ExternalGoals
     * const externalGoal = await prisma.externalGoal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExternalGoals and only return the `id`
     * const externalGoalWithIdOnly = await prisma.externalGoal.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExternalGoalCreateManyAndReturnArgs>(args?: SelectSubset<T, ExternalGoalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExternalGoalPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a ExternalGoal.
     * @param {ExternalGoalDeleteArgs} args - Arguments to delete one ExternalGoal.
     * @example
     * // Delete one ExternalGoal
     * const ExternalGoal = await prisma.externalGoal.delete({
     *   where: {
     *     // ... filter to delete one ExternalGoal
     *   }
     * })
     * 
     */
    delete<T extends ExternalGoalDeleteArgs>(args: SelectSubset<T, ExternalGoalDeleteArgs<ExtArgs>>): Prisma__ExternalGoalClient<$Result.GetResult<Prisma.$ExternalGoalPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ExternalGoal.
     * @param {ExternalGoalUpdateArgs} args - Arguments to update one ExternalGoal.
     * @example
     * // Update one ExternalGoal
     * const externalGoal = await prisma.externalGoal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExternalGoalUpdateArgs>(args: SelectSubset<T, ExternalGoalUpdateArgs<ExtArgs>>): Prisma__ExternalGoalClient<$Result.GetResult<Prisma.$ExternalGoalPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ExternalGoals.
     * @param {ExternalGoalDeleteManyArgs} args - Arguments to filter ExternalGoals to delete.
     * @example
     * // Delete a few ExternalGoals
     * const { count } = await prisma.externalGoal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExternalGoalDeleteManyArgs>(args?: SelectSubset<T, ExternalGoalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExternalGoals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalGoalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExternalGoals
     * const externalGoal = await prisma.externalGoal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExternalGoalUpdateManyArgs>(args: SelectSubset<T, ExternalGoalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExternalGoals and returns the data updated in the database.
     * @param {ExternalGoalUpdateManyAndReturnArgs} args - Arguments to update many ExternalGoals.
     * @example
     * // Update many ExternalGoals
     * const externalGoal = await prisma.externalGoal.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExternalGoals and only return the `id`
     * const externalGoalWithIdOnly = await prisma.externalGoal.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExternalGoalUpdateManyAndReturnArgs>(args: SelectSubset<T, ExternalGoalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExternalGoalPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one ExternalGoal.
     * @param {ExternalGoalUpsertArgs} args - Arguments to update or create a ExternalGoal.
     * @example
     * // Update or create a ExternalGoal
     * const externalGoal = await prisma.externalGoal.upsert({
     *   create: {
     *     // ... data to create a ExternalGoal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExternalGoal we want to update
     *   }
     * })
     */
    upsert<T extends ExternalGoalUpsertArgs>(args: SelectSubset<T, ExternalGoalUpsertArgs<ExtArgs>>): Prisma__ExternalGoalClient<$Result.GetResult<Prisma.$ExternalGoalPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ExternalGoals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalGoalCountArgs} args - Arguments to filter ExternalGoals to count.
     * @example
     * // Count the number of ExternalGoals
     * const count = await prisma.externalGoal.count({
     *   where: {
     *     // ... the filter for the ExternalGoals we want to count
     *   }
     * })
    **/
    count<T extends ExternalGoalCountArgs>(
      args?: Subset<T, ExternalGoalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExternalGoalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExternalGoal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalGoalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExternalGoalAggregateArgs>(args: Subset<T, ExternalGoalAggregateArgs>): Prisma.PrismaPromise<GetExternalGoalAggregateType<T>>

    /**
     * Group by ExternalGoal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalGoalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExternalGoalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExternalGoalGroupByArgs['orderBy'] }
        : { orderBy?: ExternalGoalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExternalGoalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExternalGoalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExternalGoal model
   */
  readonly fields: ExternalGoalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExternalGoal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExternalGoalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExternalGoal model
   */ 
  interface ExternalGoalFieldRefs {
    readonly id: FieldRef<"ExternalGoal", 'String'>
    readonly userId: FieldRef<"ExternalGoal", 'String'>
    readonly platform: FieldRef<"ExternalGoal", 'String'>
    readonly title: FieldRef<"ExternalGoal", 'String'>
    readonly progress: FieldRef<"ExternalGoal", 'Float'>
    readonly dueDate: FieldRef<"ExternalGoal", 'DateTime'>
    readonly createdAt: FieldRef<"ExternalGoal", 'DateTime'>
    readonly updatedAt: FieldRef<"ExternalGoal", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExternalGoal findUnique
   */
  export type ExternalGoalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalGoal
     */
    select?: ExternalGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalGoal
     */
    omit?: ExternalGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalGoalInclude<ExtArgs> | null
    /**
     * Filter, which ExternalGoal to fetch.
     */
    where: ExternalGoalWhereUniqueInput
  }

  /**
   * ExternalGoal findUniqueOrThrow
   */
  export type ExternalGoalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalGoal
     */
    select?: ExternalGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalGoal
     */
    omit?: ExternalGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalGoalInclude<ExtArgs> | null
    /**
     * Filter, which ExternalGoal to fetch.
     */
    where: ExternalGoalWhereUniqueInput
  }

  /**
   * ExternalGoal findFirst
   */
  export type ExternalGoalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalGoal
     */
    select?: ExternalGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalGoal
     */
    omit?: ExternalGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalGoalInclude<ExtArgs> | null
    /**
     * Filter, which ExternalGoal to fetch.
     */
    where?: ExternalGoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExternalGoals to fetch.
     */
    orderBy?: ExternalGoalOrderByWithRelationInput | ExternalGoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExternalGoals.
     */
    cursor?: ExternalGoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExternalGoals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExternalGoals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExternalGoals.
     */
    distinct?: ExternalGoalScalarFieldEnum | ExternalGoalScalarFieldEnum[]
  }

  /**
   * ExternalGoal findFirstOrThrow
   */
  export type ExternalGoalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalGoal
     */
    select?: ExternalGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalGoal
     */
    omit?: ExternalGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalGoalInclude<ExtArgs> | null
    /**
     * Filter, which ExternalGoal to fetch.
     */
    where?: ExternalGoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExternalGoals to fetch.
     */
    orderBy?: ExternalGoalOrderByWithRelationInput | ExternalGoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExternalGoals.
     */
    cursor?: ExternalGoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExternalGoals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExternalGoals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExternalGoals.
     */
    distinct?: ExternalGoalScalarFieldEnum | ExternalGoalScalarFieldEnum[]
  }

  /**
   * ExternalGoal findMany
   */
  export type ExternalGoalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalGoal
     */
    select?: ExternalGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalGoal
     */
    omit?: ExternalGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalGoalInclude<ExtArgs> | null
    /**
     * Filter, which ExternalGoals to fetch.
     */
    where?: ExternalGoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExternalGoals to fetch.
     */
    orderBy?: ExternalGoalOrderByWithRelationInput | ExternalGoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExternalGoals.
     */
    cursor?: ExternalGoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExternalGoals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExternalGoals.
     */
    skip?: number
    distinct?: ExternalGoalScalarFieldEnum | ExternalGoalScalarFieldEnum[]
  }

  /**
   * ExternalGoal create
   */
  export type ExternalGoalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalGoal
     */
    select?: ExternalGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalGoal
     */
    omit?: ExternalGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalGoalInclude<ExtArgs> | null
    /**
     * The data needed to create a ExternalGoal.
     */
    data: XOR<ExternalGoalCreateInput, ExternalGoalUncheckedCreateInput>
  }

  /**
   * ExternalGoal createMany
   */
  export type ExternalGoalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExternalGoals.
     */
    data: ExternalGoalCreateManyInput | ExternalGoalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExternalGoal createManyAndReturn
   */
  export type ExternalGoalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalGoal
     */
    select?: ExternalGoalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalGoal
     */
    omit?: ExternalGoalOmit<ExtArgs> | null
    /**
     * The data used to create many ExternalGoals.
     */
    data: ExternalGoalCreateManyInput | ExternalGoalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalGoalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExternalGoal update
   */
  export type ExternalGoalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalGoal
     */
    select?: ExternalGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalGoal
     */
    omit?: ExternalGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalGoalInclude<ExtArgs> | null
    /**
     * The data needed to update a ExternalGoal.
     */
    data: XOR<ExternalGoalUpdateInput, ExternalGoalUncheckedUpdateInput>
    /**
     * Choose, which ExternalGoal to update.
     */
    where: ExternalGoalWhereUniqueInput
  }

  /**
   * ExternalGoal updateMany
   */
  export type ExternalGoalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExternalGoals.
     */
    data: XOR<ExternalGoalUpdateManyMutationInput, ExternalGoalUncheckedUpdateManyInput>
    /**
     * Filter which ExternalGoals to update
     */
    where?: ExternalGoalWhereInput
    /**
     * Limit how many ExternalGoals to update.
     */
    limit?: number
  }

  /**
   * ExternalGoal updateManyAndReturn
   */
  export type ExternalGoalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalGoal
     */
    select?: ExternalGoalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalGoal
     */
    omit?: ExternalGoalOmit<ExtArgs> | null
    /**
     * The data used to update ExternalGoals.
     */
    data: XOR<ExternalGoalUpdateManyMutationInput, ExternalGoalUncheckedUpdateManyInput>
    /**
     * Filter which ExternalGoals to update
     */
    where?: ExternalGoalWhereInput
    /**
     * Limit how many ExternalGoals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalGoalIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExternalGoal upsert
   */
  export type ExternalGoalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalGoal
     */
    select?: ExternalGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalGoal
     */
    omit?: ExternalGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalGoalInclude<ExtArgs> | null
    /**
     * The filter to search for the ExternalGoal to update in case it exists.
     */
    where: ExternalGoalWhereUniqueInput
    /**
     * In case the ExternalGoal found by the `where` argument doesn't exist, create a new ExternalGoal with this data.
     */
    create: XOR<ExternalGoalCreateInput, ExternalGoalUncheckedCreateInput>
    /**
     * In case the ExternalGoal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExternalGoalUpdateInput, ExternalGoalUncheckedUpdateInput>
  }

  /**
   * ExternalGoal delete
   */
  export type ExternalGoalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalGoal
     */
    select?: ExternalGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalGoal
     */
    omit?: ExternalGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalGoalInclude<ExtArgs> | null
    /**
     * Filter which ExternalGoal to delete.
     */
    where: ExternalGoalWhereUniqueInput
  }

  /**
   * ExternalGoal deleteMany
   */
  export type ExternalGoalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExternalGoals to delete
     */
    where?: ExternalGoalWhereInput
    /**
     * Limit how many ExternalGoals to delete.
     */
    limit?: number
  }

  /**
   * ExternalGoal without action
   */
  export type ExternalGoalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalGoal
     */
    select?: ExternalGoalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalGoal
     */
    omit?: ExternalGoalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalGoalInclude<ExtArgs> | null
  }


  /**
   * Model Prerequisite
   */

  export type AggregatePrerequisite = {
    _count: PrerequisiteCountAggregateOutputType | null
    _min: PrerequisiteMinAggregateOutputType | null
    _max: PrerequisiteMaxAggregateOutputType | null
  }

  export type PrerequisiteMinAggregateOutputType = {
    id: string | null
    learningPathId: string | null
    topicId: string | null
    completed: boolean | null
  }

  export type PrerequisiteMaxAggregateOutputType = {
    id: string | null
    learningPathId: string | null
    topicId: string | null
    completed: boolean | null
  }

  export type PrerequisiteCountAggregateOutputType = {
    id: number
    learningPathId: number
    topicId: number
    completed: number
    _all: number
  }


  export type PrerequisiteMinAggregateInputType = {
    id?: true
    learningPathId?: true
    topicId?: true
    completed?: true
  }

  export type PrerequisiteMaxAggregateInputType = {
    id?: true
    learningPathId?: true
    topicId?: true
    completed?: true
  }

  export type PrerequisiteCountAggregateInputType = {
    id?: true
    learningPathId?: true
    topicId?: true
    completed?: true
    _all?: true
  }

  export type PrerequisiteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prerequisite to aggregate.
     */
    where?: PrerequisiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prerequisites to fetch.
     */
    orderBy?: PrerequisiteOrderByWithRelationInput | PrerequisiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PrerequisiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prerequisites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prerequisites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Prerequisites
    **/
    _count?: true | PrerequisiteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrerequisiteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrerequisiteMaxAggregateInputType
  }

  export type GetPrerequisiteAggregateType<T extends PrerequisiteAggregateArgs> = {
        [P in keyof T & keyof AggregatePrerequisite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrerequisite[P]>
      : GetScalarType<T[P], AggregatePrerequisite[P]>
  }




  export type PrerequisiteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrerequisiteWhereInput
    orderBy?: PrerequisiteOrderByWithAggregationInput | PrerequisiteOrderByWithAggregationInput[]
    by: PrerequisiteScalarFieldEnum[] | PrerequisiteScalarFieldEnum
    having?: PrerequisiteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrerequisiteCountAggregateInputType | true
    _min?: PrerequisiteMinAggregateInputType
    _max?: PrerequisiteMaxAggregateInputType
  }

  export type PrerequisiteGroupByOutputType = {
    id: string
    learningPathId: string
    topicId: string
    completed: boolean
    _count: PrerequisiteCountAggregateOutputType | null
    _min: PrerequisiteMinAggregateOutputType | null
    _max: PrerequisiteMaxAggregateOutputType | null
  }

  type GetPrerequisiteGroupByPayload<T extends PrerequisiteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrerequisiteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrerequisiteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrerequisiteGroupByOutputType[P]>
            : GetScalarType<T[P], PrerequisiteGroupByOutputType[P]>
        }
      >
    >


  export type PrerequisiteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    learningPathId?: boolean
    topicId?: boolean
    completed?: boolean
    learningPath?: boolean | LearningPathDefaultArgs<ExtArgs>
    topic?: boolean | TopicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prerequisite"]>

  export type PrerequisiteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    learningPathId?: boolean
    topicId?: boolean
    completed?: boolean
    learningPath?: boolean | LearningPathDefaultArgs<ExtArgs>
    topic?: boolean | TopicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prerequisite"]>

  export type PrerequisiteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    learningPathId?: boolean
    topicId?: boolean
    completed?: boolean
    learningPath?: boolean | LearningPathDefaultArgs<ExtArgs>
    topic?: boolean | TopicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prerequisite"]>

  export type PrerequisiteSelectScalar = {
    id?: boolean
    learningPathId?: boolean
    topicId?: boolean
    completed?: boolean
  }

  export type PrerequisiteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "learningPathId" | "topicId" | "completed", ExtArgs["result"]["prerequisite"]>
  export type PrerequisiteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    learningPath?: boolean | LearningPathDefaultArgs<ExtArgs>
    topic?: boolean | TopicDefaultArgs<ExtArgs>
  }
  export type PrerequisiteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    learningPath?: boolean | LearningPathDefaultArgs<ExtArgs>
    topic?: boolean | TopicDefaultArgs<ExtArgs>
  }
  export type PrerequisiteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    learningPath?: boolean | LearningPathDefaultArgs<ExtArgs>
    topic?: boolean | TopicDefaultArgs<ExtArgs>
  }

  export type $PrerequisitePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Prerequisite"
    objects: {
      learningPath: Prisma.$LearningPathPayload<ExtArgs>
      topic: Prisma.$TopicPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      learningPathId: string
      topicId: string
      completed: boolean
    }, ExtArgs["result"]["prerequisite"]>
    composites: {}
  }

  type PrerequisiteGetPayload<S extends boolean | null | undefined | PrerequisiteDefaultArgs> = $Result.GetResult<Prisma.$PrerequisitePayload, S>

  type PrerequisiteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PrerequisiteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PrerequisiteCountAggregateInputType | true
    }

  export interface PrerequisiteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Prerequisite'], meta: { name: 'Prerequisite' } }
    /**
     * Find zero or one Prerequisite that matches the filter.
     * @param {PrerequisiteFindUniqueArgs} args - Arguments to find a Prerequisite
     * @example
     * // Get one Prerequisite
     * const prerequisite = await prisma.prerequisite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PrerequisiteFindUniqueArgs>(args: SelectSubset<T, PrerequisiteFindUniqueArgs<ExtArgs>>): Prisma__PrerequisiteClient<$Result.GetResult<Prisma.$PrerequisitePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Prerequisite that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PrerequisiteFindUniqueOrThrowArgs} args - Arguments to find a Prerequisite
     * @example
     * // Get one Prerequisite
     * const prerequisite = await prisma.prerequisite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PrerequisiteFindUniqueOrThrowArgs>(args: SelectSubset<T, PrerequisiteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PrerequisiteClient<$Result.GetResult<Prisma.$PrerequisitePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Prerequisite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrerequisiteFindFirstArgs} args - Arguments to find a Prerequisite
     * @example
     * // Get one Prerequisite
     * const prerequisite = await prisma.prerequisite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PrerequisiteFindFirstArgs>(args?: SelectSubset<T, PrerequisiteFindFirstArgs<ExtArgs>>): Prisma__PrerequisiteClient<$Result.GetResult<Prisma.$PrerequisitePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Prerequisite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrerequisiteFindFirstOrThrowArgs} args - Arguments to find a Prerequisite
     * @example
     * // Get one Prerequisite
     * const prerequisite = await prisma.prerequisite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PrerequisiteFindFirstOrThrowArgs>(args?: SelectSubset<T, PrerequisiteFindFirstOrThrowArgs<ExtArgs>>): Prisma__PrerequisiteClient<$Result.GetResult<Prisma.$PrerequisitePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Prerequisites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrerequisiteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prerequisites
     * const prerequisites = await prisma.prerequisite.findMany()
     * 
     * // Get first 10 Prerequisites
     * const prerequisites = await prisma.prerequisite.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const prerequisiteWithIdOnly = await prisma.prerequisite.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PrerequisiteFindManyArgs>(args?: SelectSubset<T, PrerequisiteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrerequisitePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Prerequisite.
     * @param {PrerequisiteCreateArgs} args - Arguments to create a Prerequisite.
     * @example
     * // Create one Prerequisite
     * const Prerequisite = await prisma.prerequisite.create({
     *   data: {
     *     // ... data to create a Prerequisite
     *   }
     * })
     * 
     */
    create<T extends PrerequisiteCreateArgs>(args: SelectSubset<T, PrerequisiteCreateArgs<ExtArgs>>): Prisma__PrerequisiteClient<$Result.GetResult<Prisma.$PrerequisitePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Prerequisites.
     * @param {PrerequisiteCreateManyArgs} args - Arguments to create many Prerequisites.
     * @example
     * // Create many Prerequisites
     * const prerequisite = await prisma.prerequisite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PrerequisiteCreateManyArgs>(args?: SelectSubset<T, PrerequisiteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Prerequisites and returns the data saved in the database.
     * @param {PrerequisiteCreateManyAndReturnArgs} args - Arguments to create many Prerequisites.
     * @example
     * // Create many Prerequisites
     * const prerequisite = await prisma.prerequisite.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Prerequisites and only return the `id`
     * const prerequisiteWithIdOnly = await prisma.prerequisite.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PrerequisiteCreateManyAndReturnArgs>(args?: SelectSubset<T, PrerequisiteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrerequisitePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Prerequisite.
     * @param {PrerequisiteDeleteArgs} args - Arguments to delete one Prerequisite.
     * @example
     * // Delete one Prerequisite
     * const Prerequisite = await prisma.prerequisite.delete({
     *   where: {
     *     // ... filter to delete one Prerequisite
     *   }
     * })
     * 
     */
    delete<T extends PrerequisiteDeleteArgs>(args: SelectSubset<T, PrerequisiteDeleteArgs<ExtArgs>>): Prisma__PrerequisiteClient<$Result.GetResult<Prisma.$PrerequisitePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Prerequisite.
     * @param {PrerequisiteUpdateArgs} args - Arguments to update one Prerequisite.
     * @example
     * // Update one Prerequisite
     * const prerequisite = await prisma.prerequisite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PrerequisiteUpdateArgs>(args: SelectSubset<T, PrerequisiteUpdateArgs<ExtArgs>>): Prisma__PrerequisiteClient<$Result.GetResult<Prisma.$PrerequisitePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Prerequisites.
     * @param {PrerequisiteDeleteManyArgs} args - Arguments to filter Prerequisites to delete.
     * @example
     * // Delete a few Prerequisites
     * const { count } = await prisma.prerequisite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PrerequisiteDeleteManyArgs>(args?: SelectSubset<T, PrerequisiteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prerequisites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrerequisiteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prerequisites
     * const prerequisite = await prisma.prerequisite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PrerequisiteUpdateManyArgs>(args: SelectSubset<T, PrerequisiteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prerequisites and returns the data updated in the database.
     * @param {PrerequisiteUpdateManyAndReturnArgs} args - Arguments to update many Prerequisites.
     * @example
     * // Update many Prerequisites
     * const prerequisite = await prisma.prerequisite.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Prerequisites and only return the `id`
     * const prerequisiteWithIdOnly = await prisma.prerequisite.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PrerequisiteUpdateManyAndReturnArgs>(args: SelectSubset<T, PrerequisiteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrerequisitePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Prerequisite.
     * @param {PrerequisiteUpsertArgs} args - Arguments to update or create a Prerequisite.
     * @example
     * // Update or create a Prerequisite
     * const prerequisite = await prisma.prerequisite.upsert({
     *   create: {
     *     // ... data to create a Prerequisite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Prerequisite we want to update
     *   }
     * })
     */
    upsert<T extends PrerequisiteUpsertArgs>(args: SelectSubset<T, PrerequisiteUpsertArgs<ExtArgs>>): Prisma__PrerequisiteClient<$Result.GetResult<Prisma.$PrerequisitePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Prerequisites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrerequisiteCountArgs} args - Arguments to filter Prerequisites to count.
     * @example
     * // Count the number of Prerequisites
     * const count = await prisma.prerequisite.count({
     *   where: {
     *     // ... the filter for the Prerequisites we want to count
     *   }
     * })
    **/
    count<T extends PrerequisiteCountArgs>(
      args?: Subset<T, PrerequisiteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrerequisiteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Prerequisite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrerequisiteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrerequisiteAggregateArgs>(args: Subset<T, PrerequisiteAggregateArgs>): Prisma.PrismaPromise<GetPrerequisiteAggregateType<T>>

    /**
     * Group by Prerequisite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrerequisiteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PrerequisiteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PrerequisiteGroupByArgs['orderBy'] }
        : { orderBy?: PrerequisiteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PrerequisiteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrerequisiteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Prerequisite model
   */
  readonly fields: PrerequisiteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Prerequisite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PrerequisiteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    learningPath<T extends LearningPathDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LearningPathDefaultArgs<ExtArgs>>): Prisma__LearningPathClient<$Result.GetResult<Prisma.$LearningPathPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    topic<T extends TopicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TopicDefaultArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Prerequisite model
   */ 
  interface PrerequisiteFieldRefs {
    readonly id: FieldRef<"Prerequisite", 'String'>
    readonly learningPathId: FieldRef<"Prerequisite", 'String'>
    readonly topicId: FieldRef<"Prerequisite", 'String'>
    readonly completed: FieldRef<"Prerequisite", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Prerequisite findUnique
   */
  export type PrerequisiteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prerequisite
     */
    select?: PrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prerequisite
     */
    omit?: PrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrerequisiteInclude<ExtArgs> | null
    /**
     * Filter, which Prerequisite to fetch.
     */
    where: PrerequisiteWhereUniqueInput
  }

  /**
   * Prerequisite findUniqueOrThrow
   */
  export type PrerequisiteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prerequisite
     */
    select?: PrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prerequisite
     */
    omit?: PrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrerequisiteInclude<ExtArgs> | null
    /**
     * Filter, which Prerequisite to fetch.
     */
    where: PrerequisiteWhereUniqueInput
  }

  /**
   * Prerequisite findFirst
   */
  export type PrerequisiteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prerequisite
     */
    select?: PrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prerequisite
     */
    omit?: PrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrerequisiteInclude<ExtArgs> | null
    /**
     * Filter, which Prerequisite to fetch.
     */
    where?: PrerequisiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prerequisites to fetch.
     */
    orderBy?: PrerequisiteOrderByWithRelationInput | PrerequisiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prerequisites.
     */
    cursor?: PrerequisiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prerequisites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prerequisites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prerequisites.
     */
    distinct?: PrerequisiteScalarFieldEnum | PrerequisiteScalarFieldEnum[]
  }

  /**
   * Prerequisite findFirstOrThrow
   */
  export type PrerequisiteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prerequisite
     */
    select?: PrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prerequisite
     */
    omit?: PrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrerequisiteInclude<ExtArgs> | null
    /**
     * Filter, which Prerequisite to fetch.
     */
    where?: PrerequisiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prerequisites to fetch.
     */
    orderBy?: PrerequisiteOrderByWithRelationInput | PrerequisiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prerequisites.
     */
    cursor?: PrerequisiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prerequisites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prerequisites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prerequisites.
     */
    distinct?: PrerequisiteScalarFieldEnum | PrerequisiteScalarFieldEnum[]
  }

  /**
   * Prerequisite findMany
   */
  export type PrerequisiteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prerequisite
     */
    select?: PrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prerequisite
     */
    omit?: PrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrerequisiteInclude<ExtArgs> | null
    /**
     * Filter, which Prerequisites to fetch.
     */
    where?: PrerequisiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prerequisites to fetch.
     */
    orderBy?: PrerequisiteOrderByWithRelationInput | PrerequisiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Prerequisites.
     */
    cursor?: PrerequisiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prerequisites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prerequisites.
     */
    skip?: number
    distinct?: PrerequisiteScalarFieldEnum | PrerequisiteScalarFieldEnum[]
  }

  /**
   * Prerequisite create
   */
  export type PrerequisiteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prerequisite
     */
    select?: PrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prerequisite
     */
    omit?: PrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrerequisiteInclude<ExtArgs> | null
    /**
     * The data needed to create a Prerequisite.
     */
    data: XOR<PrerequisiteCreateInput, PrerequisiteUncheckedCreateInput>
  }

  /**
   * Prerequisite createMany
   */
  export type PrerequisiteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Prerequisites.
     */
    data: PrerequisiteCreateManyInput | PrerequisiteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Prerequisite createManyAndReturn
   */
  export type PrerequisiteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prerequisite
     */
    select?: PrerequisiteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Prerequisite
     */
    omit?: PrerequisiteOmit<ExtArgs> | null
    /**
     * The data used to create many Prerequisites.
     */
    data: PrerequisiteCreateManyInput | PrerequisiteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrerequisiteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Prerequisite update
   */
  export type PrerequisiteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prerequisite
     */
    select?: PrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prerequisite
     */
    omit?: PrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrerequisiteInclude<ExtArgs> | null
    /**
     * The data needed to update a Prerequisite.
     */
    data: XOR<PrerequisiteUpdateInput, PrerequisiteUncheckedUpdateInput>
    /**
     * Choose, which Prerequisite to update.
     */
    where: PrerequisiteWhereUniqueInput
  }

  /**
   * Prerequisite updateMany
   */
  export type PrerequisiteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Prerequisites.
     */
    data: XOR<PrerequisiteUpdateManyMutationInput, PrerequisiteUncheckedUpdateManyInput>
    /**
     * Filter which Prerequisites to update
     */
    where?: PrerequisiteWhereInput
    /**
     * Limit how many Prerequisites to update.
     */
    limit?: number
  }

  /**
   * Prerequisite updateManyAndReturn
   */
  export type PrerequisiteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prerequisite
     */
    select?: PrerequisiteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Prerequisite
     */
    omit?: PrerequisiteOmit<ExtArgs> | null
    /**
     * The data used to update Prerequisites.
     */
    data: XOR<PrerequisiteUpdateManyMutationInput, PrerequisiteUncheckedUpdateManyInput>
    /**
     * Filter which Prerequisites to update
     */
    where?: PrerequisiteWhereInput
    /**
     * Limit how many Prerequisites to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrerequisiteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Prerequisite upsert
   */
  export type PrerequisiteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prerequisite
     */
    select?: PrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prerequisite
     */
    omit?: PrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrerequisiteInclude<ExtArgs> | null
    /**
     * The filter to search for the Prerequisite to update in case it exists.
     */
    where: PrerequisiteWhereUniqueInput
    /**
     * In case the Prerequisite found by the `where` argument doesn't exist, create a new Prerequisite with this data.
     */
    create: XOR<PrerequisiteCreateInput, PrerequisiteUncheckedCreateInput>
    /**
     * In case the Prerequisite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PrerequisiteUpdateInput, PrerequisiteUncheckedUpdateInput>
  }

  /**
   * Prerequisite delete
   */
  export type PrerequisiteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prerequisite
     */
    select?: PrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prerequisite
     */
    omit?: PrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrerequisiteInclude<ExtArgs> | null
    /**
     * Filter which Prerequisite to delete.
     */
    where: PrerequisiteWhereUniqueInput
  }

  /**
   * Prerequisite deleteMany
   */
  export type PrerequisiteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prerequisites to delete
     */
    where?: PrerequisiteWhereInput
    /**
     * Limit how many Prerequisites to delete.
     */
    limit?: number
  }

  /**
   * Prerequisite without action
   */
  export type PrerequisiteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prerequisite
     */
    select?: PrerequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prerequisite
     */
    omit?: PrerequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrerequisiteInclude<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentMinAggregateOutputType = {
    id: string | null
    content: string | null
    userId: string | null
    topicId: string | null
    createdAt: Date | null
  }

  export type CommentMaxAggregateOutputType = {
    id: string | null
    content: string | null
    userId: string | null
    topicId: string | null
    createdAt: Date | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    content: number
    userId: number
    topicId: number
    createdAt: number
    _all: number
  }


  export type CommentMinAggregateInputType = {
    id?: true
    content?: true
    userId?: true
    topicId?: true
    createdAt?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    content?: true
    userId?: true
    topicId?: true
    createdAt?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    content?: true
    userId?: true
    topicId?: true
    createdAt?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: string
    content: string
    userId: string
    topicId: string
    createdAt: Date
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    userId?: boolean
    topicId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    topic?: boolean | TopicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    userId?: boolean
    topicId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    topic?: boolean | TopicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    userId?: boolean
    topicId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    topic?: boolean | TopicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    id?: boolean
    content?: boolean
    userId?: boolean
    topicId?: boolean
    createdAt?: boolean
  }

  export type CommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "userId" | "topicId" | "createdAt", ExtArgs["result"]["comment"]>
  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    topic?: boolean | TopicDefaultArgs<ExtArgs>
  }
  export type CommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    topic?: boolean | TopicDefaultArgs<ExtArgs>
  }
  export type CommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    topic?: boolean | TopicDefaultArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      topic: Prisma.$TopicPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      userId: string
      topicId: string
      createdAt: Date
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {CommentCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments and returns the data updated in the database.
     * @param {CommentUpdateManyAndReturnArgs} args - Arguments to update many Comments.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommentUpdateManyAndReturnArgs>(args: SelectSubset<T, CommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    topic<T extends TopicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TopicDefaultArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */ 
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'String'>
    readonly content: FieldRef<"Comment", 'String'>
    readonly userId: FieldRef<"Comment", 'String'>
    readonly topicId: FieldRef<"Comment", 'String'>
    readonly createdAt: FieldRef<"Comment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comment createManyAndReturn
   */
  export type CommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
  }

  /**
   * Comment updateManyAndReturn
   */
  export type CommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to delete.
     */
    limit?: number
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Model AIPlaylist
   */

  export type AggregateAIPlaylist = {
    _count: AIPlaylistCountAggregateOutputType | null
    _min: AIPlaylistMinAggregateOutputType | null
    _max: AIPlaylistMaxAggregateOutputType | null
  }

  export type AIPlaylistMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AIPlaylistMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AIPlaylistCountAggregateOutputType = {
    id: number
    title: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AIPlaylistMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AIPlaylistMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AIPlaylistCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AIPlaylistAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIPlaylist to aggregate.
     */
    where?: AIPlaylistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIPlaylists to fetch.
     */
    orderBy?: AIPlaylistOrderByWithRelationInput | AIPlaylistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AIPlaylistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIPlaylists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIPlaylists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AIPlaylists
    **/
    _count?: true | AIPlaylistCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AIPlaylistMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AIPlaylistMaxAggregateInputType
  }

  export type GetAIPlaylistAggregateType<T extends AIPlaylistAggregateArgs> = {
        [P in keyof T & keyof AggregateAIPlaylist]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAIPlaylist[P]>
      : GetScalarType<T[P], AggregateAIPlaylist[P]>
  }




  export type AIPlaylistGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIPlaylistWhereInput
    orderBy?: AIPlaylistOrderByWithAggregationInput | AIPlaylistOrderByWithAggregationInput[]
    by: AIPlaylistScalarFieldEnum[] | AIPlaylistScalarFieldEnum
    having?: AIPlaylistScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AIPlaylistCountAggregateInputType | true
    _min?: AIPlaylistMinAggregateInputType
    _max?: AIPlaylistMaxAggregateInputType
  }

  export type AIPlaylistGroupByOutputType = {
    id: string
    title: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: AIPlaylistCountAggregateOutputType | null
    _min: AIPlaylistMinAggregateOutputType | null
    _max: AIPlaylistMaxAggregateOutputType | null
  }

  type GetAIPlaylistGroupByPayload<T extends AIPlaylistGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AIPlaylistGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AIPlaylistGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AIPlaylistGroupByOutputType[P]>
            : GetScalarType<T[P], AIPlaylistGroupByOutputType[P]>
        }
      >
    >


  export type AIPlaylistSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    items?: boolean | AIPlaylist$itemsArgs<ExtArgs>
    _count?: boolean | AIPlaylistCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIPlaylist"]>

  export type AIPlaylistSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aIPlaylist"]>

  export type AIPlaylistSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aIPlaylist"]>

  export type AIPlaylistSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AIPlaylistOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["aIPlaylist"]>
  export type AIPlaylistInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | AIPlaylist$itemsArgs<ExtArgs>
    _count?: boolean | AIPlaylistCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AIPlaylistIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AIPlaylistIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AIPlaylistPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AIPlaylist"
    objects: {
      items: Prisma.$AIPlaylistItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["aIPlaylist"]>
    composites: {}
  }

  type AIPlaylistGetPayload<S extends boolean | null | undefined | AIPlaylistDefaultArgs> = $Result.GetResult<Prisma.$AIPlaylistPayload, S>

  type AIPlaylistCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AIPlaylistFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AIPlaylistCountAggregateInputType | true
    }

  export interface AIPlaylistDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AIPlaylist'], meta: { name: 'AIPlaylist' } }
    /**
     * Find zero or one AIPlaylist that matches the filter.
     * @param {AIPlaylistFindUniqueArgs} args - Arguments to find a AIPlaylist
     * @example
     * // Get one AIPlaylist
     * const aIPlaylist = await prisma.aIPlaylist.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AIPlaylistFindUniqueArgs>(args: SelectSubset<T, AIPlaylistFindUniqueArgs<ExtArgs>>): Prisma__AIPlaylistClient<$Result.GetResult<Prisma.$AIPlaylistPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one AIPlaylist that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AIPlaylistFindUniqueOrThrowArgs} args - Arguments to find a AIPlaylist
     * @example
     * // Get one AIPlaylist
     * const aIPlaylist = await prisma.aIPlaylist.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AIPlaylistFindUniqueOrThrowArgs>(args: SelectSubset<T, AIPlaylistFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AIPlaylistClient<$Result.GetResult<Prisma.$AIPlaylistPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first AIPlaylist that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIPlaylistFindFirstArgs} args - Arguments to find a AIPlaylist
     * @example
     * // Get one AIPlaylist
     * const aIPlaylist = await prisma.aIPlaylist.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AIPlaylistFindFirstArgs>(args?: SelectSubset<T, AIPlaylistFindFirstArgs<ExtArgs>>): Prisma__AIPlaylistClient<$Result.GetResult<Prisma.$AIPlaylistPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first AIPlaylist that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIPlaylistFindFirstOrThrowArgs} args - Arguments to find a AIPlaylist
     * @example
     * // Get one AIPlaylist
     * const aIPlaylist = await prisma.aIPlaylist.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AIPlaylistFindFirstOrThrowArgs>(args?: SelectSubset<T, AIPlaylistFindFirstOrThrowArgs<ExtArgs>>): Prisma__AIPlaylistClient<$Result.GetResult<Prisma.$AIPlaylistPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more AIPlaylists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIPlaylistFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AIPlaylists
     * const aIPlaylists = await prisma.aIPlaylist.findMany()
     * 
     * // Get first 10 AIPlaylists
     * const aIPlaylists = await prisma.aIPlaylist.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aIPlaylistWithIdOnly = await prisma.aIPlaylist.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AIPlaylistFindManyArgs>(args?: SelectSubset<T, AIPlaylistFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIPlaylistPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a AIPlaylist.
     * @param {AIPlaylistCreateArgs} args - Arguments to create a AIPlaylist.
     * @example
     * // Create one AIPlaylist
     * const AIPlaylist = await prisma.aIPlaylist.create({
     *   data: {
     *     // ... data to create a AIPlaylist
     *   }
     * })
     * 
     */
    create<T extends AIPlaylistCreateArgs>(args: SelectSubset<T, AIPlaylistCreateArgs<ExtArgs>>): Prisma__AIPlaylistClient<$Result.GetResult<Prisma.$AIPlaylistPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many AIPlaylists.
     * @param {AIPlaylistCreateManyArgs} args - Arguments to create many AIPlaylists.
     * @example
     * // Create many AIPlaylists
     * const aIPlaylist = await prisma.aIPlaylist.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AIPlaylistCreateManyArgs>(args?: SelectSubset<T, AIPlaylistCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AIPlaylists and returns the data saved in the database.
     * @param {AIPlaylistCreateManyAndReturnArgs} args - Arguments to create many AIPlaylists.
     * @example
     * // Create many AIPlaylists
     * const aIPlaylist = await prisma.aIPlaylist.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AIPlaylists and only return the `id`
     * const aIPlaylistWithIdOnly = await prisma.aIPlaylist.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AIPlaylistCreateManyAndReturnArgs>(args?: SelectSubset<T, AIPlaylistCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIPlaylistPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a AIPlaylist.
     * @param {AIPlaylistDeleteArgs} args - Arguments to delete one AIPlaylist.
     * @example
     * // Delete one AIPlaylist
     * const AIPlaylist = await prisma.aIPlaylist.delete({
     *   where: {
     *     // ... filter to delete one AIPlaylist
     *   }
     * })
     * 
     */
    delete<T extends AIPlaylistDeleteArgs>(args: SelectSubset<T, AIPlaylistDeleteArgs<ExtArgs>>): Prisma__AIPlaylistClient<$Result.GetResult<Prisma.$AIPlaylistPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one AIPlaylist.
     * @param {AIPlaylistUpdateArgs} args - Arguments to update one AIPlaylist.
     * @example
     * // Update one AIPlaylist
     * const aIPlaylist = await prisma.aIPlaylist.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AIPlaylistUpdateArgs>(args: SelectSubset<T, AIPlaylistUpdateArgs<ExtArgs>>): Prisma__AIPlaylistClient<$Result.GetResult<Prisma.$AIPlaylistPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more AIPlaylists.
     * @param {AIPlaylistDeleteManyArgs} args - Arguments to filter AIPlaylists to delete.
     * @example
     * // Delete a few AIPlaylists
     * const { count } = await prisma.aIPlaylist.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AIPlaylistDeleteManyArgs>(args?: SelectSubset<T, AIPlaylistDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIPlaylists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIPlaylistUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AIPlaylists
     * const aIPlaylist = await prisma.aIPlaylist.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AIPlaylistUpdateManyArgs>(args: SelectSubset<T, AIPlaylistUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIPlaylists and returns the data updated in the database.
     * @param {AIPlaylistUpdateManyAndReturnArgs} args - Arguments to update many AIPlaylists.
     * @example
     * // Update many AIPlaylists
     * const aIPlaylist = await prisma.aIPlaylist.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AIPlaylists and only return the `id`
     * const aIPlaylistWithIdOnly = await prisma.aIPlaylist.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AIPlaylistUpdateManyAndReturnArgs>(args: SelectSubset<T, AIPlaylistUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIPlaylistPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one AIPlaylist.
     * @param {AIPlaylistUpsertArgs} args - Arguments to update or create a AIPlaylist.
     * @example
     * // Update or create a AIPlaylist
     * const aIPlaylist = await prisma.aIPlaylist.upsert({
     *   create: {
     *     // ... data to create a AIPlaylist
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AIPlaylist we want to update
     *   }
     * })
     */
    upsert<T extends AIPlaylistUpsertArgs>(args: SelectSubset<T, AIPlaylistUpsertArgs<ExtArgs>>): Prisma__AIPlaylistClient<$Result.GetResult<Prisma.$AIPlaylistPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of AIPlaylists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIPlaylistCountArgs} args - Arguments to filter AIPlaylists to count.
     * @example
     * // Count the number of AIPlaylists
     * const count = await prisma.aIPlaylist.count({
     *   where: {
     *     // ... the filter for the AIPlaylists we want to count
     *   }
     * })
    **/
    count<T extends AIPlaylistCountArgs>(
      args?: Subset<T, AIPlaylistCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AIPlaylistCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AIPlaylist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIPlaylistAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AIPlaylistAggregateArgs>(args: Subset<T, AIPlaylistAggregateArgs>): Prisma.PrismaPromise<GetAIPlaylistAggregateType<T>>

    /**
     * Group by AIPlaylist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIPlaylistGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AIPlaylistGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AIPlaylistGroupByArgs['orderBy'] }
        : { orderBy?: AIPlaylistGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AIPlaylistGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAIPlaylistGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AIPlaylist model
   */
  readonly fields: AIPlaylistFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AIPlaylist.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AIPlaylistClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    items<T extends AIPlaylist$itemsArgs<ExtArgs> = {}>(args?: Subset<T, AIPlaylist$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIPlaylistItemPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AIPlaylist model
   */ 
  interface AIPlaylistFieldRefs {
    readonly id: FieldRef<"AIPlaylist", 'String'>
    readonly title: FieldRef<"AIPlaylist", 'String'>
    readonly description: FieldRef<"AIPlaylist", 'String'>
    readonly createdAt: FieldRef<"AIPlaylist", 'DateTime'>
    readonly updatedAt: FieldRef<"AIPlaylist", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AIPlaylist findUnique
   */
  export type AIPlaylistFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIPlaylist
     */
    select?: AIPlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIPlaylist
     */
    omit?: AIPlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIPlaylistInclude<ExtArgs> | null
    /**
     * Filter, which AIPlaylist to fetch.
     */
    where: AIPlaylistWhereUniqueInput
  }

  /**
   * AIPlaylist findUniqueOrThrow
   */
  export type AIPlaylistFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIPlaylist
     */
    select?: AIPlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIPlaylist
     */
    omit?: AIPlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIPlaylistInclude<ExtArgs> | null
    /**
     * Filter, which AIPlaylist to fetch.
     */
    where: AIPlaylistWhereUniqueInput
  }

  /**
   * AIPlaylist findFirst
   */
  export type AIPlaylistFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIPlaylist
     */
    select?: AIPlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIPlaylist
     */
    omit?: AIPlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIPlaylistInclude<ExtArgs> | null
    /**
     * Filter, which AIPlaylist to fetch.
     */
    where?: AIPlaylistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIPlaylists to fetch.
     */
    orderBy?: AIPlaylistOrderByWithRelationInput | AIPlaylistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIPlaylists.
     */
    cursor?: AIPlaylistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIPlaylists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIPlaylists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIPlaylists.
     */
    distinct?: AIPlaylistScalarFieldEnum | AIPlaylistScalarFieldEnum[]
  }

  /**
   * AIPlaylist findFirstOrThrow
   */
  export type AIPlaylistFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIPlaylist
     */
    select?: AIPlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIPlaylist
     */
    omit?: AIPlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIPlaylistInclude<ExtArgs> | null
    /**
     * Filter, which AIPlaylist to fetch.
     */
    where?: AIPlaylistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIPlaylists to fetch.
     */
    orderBy?: AIPlaylistOrderByWithRelationInput | AIPlaylistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIPlaylists.
     */
    cursor?: AIPlaylistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIPlaylists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIPlaylists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIPlaylists.
     */
    distinct?: AIPlaylistScalarFieldEnum | AIPlaylistScalarFieldEnum[]
  }

  /**
   * AIPlaylist findMany
   */
  export type AIPlaylistFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIPlaylist
     */
    select?: AIPlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIPlaylist
     */
    omit?: AIPlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIPlaylistInclude<ExtArgs> | null
    /**
     * Filter, which AIPlaylists to fetch.
     */
    where?: AIPlaylistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIPlaylists to fetch.
     */
    orderBy?: AIPlaylistOrderByWithRelationInput | AIPlaylistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AIPlaylists.
     */
    cursor?: AIPlaylistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIPlaylists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIPlaylists.
     */
    skip?: number
    distinct?: AIPlaylistScalarFieldEnum | AIPlaylistScalarFieldEnum[]
  }

  /**
   * AIPlaylist create
   */
  export type AIPlaylistCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIPlaylist
     */
    select?: AIPlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIPlaylist
     */
    omit?: AIPlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIPlaylistInclude<ExtArgs> | null
    /**
     * The data needed to create a AIPlaylist.
     */
    data: XOR<AIPlaylistCreateInput, AIPlaylistUncheckedCreateInput>
  }

  /**
   * AIPlaylist createMany
   */
  export type AIPlaylistCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AIPlaylists.
     */
    data: AIPlaylistCreateManyInput | AIPlaylistCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIPlaylist createManyAndReturn
   */
  export type AIPlaylistCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIPlaylist
     */
    select?: AIPlaylistSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIPlaylist
     */
    omit?: AIPlaylistOmit<ExtArgs> | null
    /**
     * The data used to create many AIPlaylists.
     */
    data: AIPlaylistCreateManyInput | AIPlaylistCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIPlaylist update
   */
  export type AIPlaylistUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIPlaylist
     */
    select?: AIPlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIPlaylist
     */
    omit?: AIPlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIPlaylistInclude<ExtArgs> | null
    /**
     * The data needed to update a AIPlaylist.
     */
    data: XOR<AIPlaylistUpdateInput, AIPlaylistUncheckedUpdateInput>
    /**
     * Choose, which AIPlaylist to update.
     */
    where: AIPlaylistWhereUniqueInput
  }

  /**
   * AIPlaylist updateMany
   */
  export type AIPlaylistUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AIPlaylists.
     */
    data: XOR<AIPlaylistUpdateManyMutationInput, AIPlaylistUncheckedUpdateManyInput>
    /**
     * Filter which AIPlaylists to update
     */
    where?: AIPlaylistWhereInput
    /**
     * Limit how many AIPlaylists to update.
     */
    limit?: number
  }

  /**
   * AIPlaylist updateManyAndReturn
   */
  export type AIPlaylistUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIPlaylist
     */
    select?: AIPlaylistSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIPlaylist
     */
    omit?: AIPlaylistOmit<ExtArgs> | null
    /**
     * The data used to update AIPlaylists.
     */
    data: XOR<AIPlaylistUpdateManyMutationInput, AIPlaylistUncheckedUpdateManyInput>
    /**
     * Filter which AIPlaylists to update
     */
    where?: AIPlaylistWhereInput
    /**
     * Limit how many AIPlaylists to update.
     */
    limit?: number
  }

  /**
   * AIPlaylist upsert
   */
  export type AIPlaylistUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIPlaylist
     */
    select?: AIPlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIPlaylist
     */
    omit?: AIPlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIPlaylistInclude<ExtArgs> | null
    /**
     * The filter to search for the AIPlaylist to update in case it exists.
     */
    where: AIPlaylistWhereUniqueInput
    /**
     * In case the AIPlaylist found by the `where` argument doesn't exist, create a new AIPlaylist with this data.
     */
    create: XOR<AIPlaylistCreateInput, AIPlaylistUncheckedCreateInput>
    /**
     * In case the AIPlaylist was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AIPlaylistUpdateInput, AIPlaylistUncheckedUpdateInput>
  }

  /**
   * AIPlaylist delete
   */
  export type AIPlaylistDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIPlaylist
     */
    select?: AIPlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIPlaylist
     */
    omit?: AIPlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIPlaylistInclude<ExtArgs> | null
    /**
     * Filter which AIPlaylist to delete.
     */
    where: AIPlaylistWhereUniqueInput
  }

  /**
   * AIPlaylist deleteMany
   */
  export type AIPlaylistDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIPlaylists to delete
     */
    where?: AIPlaylistWhereInput
    /**
     * Limit how many AIPlaylists to delete.
     */
    limit?: number
  }

  /**
   * AIPlaylist.items
   */
  export type AIPlaylist$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIPlaylistItem
     */
    select?: AIPlaylistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIPlaylistItem
     */
    omit?: AIPlaylistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIPlaylistItemInclude<ExtArgs> | null
    where?: AIPlaylistItemWhereInput
    orderBy?: AIPlaylistItemOrderByWithRelationInput | AIPlaylistItemOrderByWithRelationInput[]
    cursor?: AIPlaylistItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AIPlaylistItemScalarFieldEnum | AIPlaylistItemScalarFieldEnum[]
  }

  /**
   * AIPlaylist without action
   */
  export type AIPlaylistDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIPlaylist
     */
    select?: AIPlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIPlaylist
     */
    omit?: AIPlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIPlaylistInclude<ExtArgs> | null
  }


  /**
   * Model AIPlaylistItem
   */

  export type AggregateAIPlaylistItem = {
    _count: AIPlaylistItemCountAggregateOutputType | null
    _avg: AIPlaylistItemAvgAggregateOutputType | null
    _sum: AIPlaylistItemSumAggregateOutputType | null
    _min: AIPlaylistItemMinAggregateOutputType | null
    _max: AIPlaylistItemMaxAggregateOutputType | null
  }

  export type AIPlaylistItemAvgAggregateOutputType = {
    order: number | null
  }

  export type AIPlaylistItemSumAggregateOutputType = {
    order: number | null
  }

  export type AIPlaylistItemMinAggregateOutputType = {
    id: string | null
    playlistId: string | null
    contentItemId: string | null
    order: number | null
  }

  export type AIPlaylistItemMaxAggregateOutputType = {
    id: string | null
    playlistId: string | null
    contentItemId: string | null
    order: number | null
  }

  export type AIPlaylistItemCountAggregateOutputType = {
    id: number
    playlistId: number
    contentItemId: number
    order: number
    _all: number
  }


  export type AIPlaylistItemAvgAggregateInputType = {
    order?: true
  }

  export type AIPlaylistItemSumAggregateInputType = {
    order?: true
  }

  export type AIPlaylistItemMinAggregateInputType = {
    id?: true
    playlistId?: true
    contentItemId?: true
    order?: true
  }

  export type AIPlaylistItemMaxAggregateInputType = {
    id?: true
    playlistId?: true
    contentItemId?: true
    order?: true
  }

  export type AIPlaylistItemCountAggregateInputType = {
    id?: true
    playlistId?: true
    contentItemId?: true
    order?: true
    _all?: true
  }

  export type AIPlaylistItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIPlaylistItem to aggregate.
     */
    where?: AIPlaylistItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIPlaylistItems to fetch.
     */
    orderBy?: AIPlaylistItemOrderByWithRelationInput | AIPlaylistItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AIPlaylistItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIPlaylistItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIPlaylistItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AIPlaylistItems
    **/
    _count?: true | AIPlaylistItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AIPlaylistItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AIPlaylistItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AIPlaylistItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AIPlaylistItemMaxAggregateInputType
  }

  export type GetAIPlaylistItemAggregateType<T extends AIPlaylistItemAggregateArgs> = {
        [P in keyof T & keyof AggregateAIPlaylistItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAIPlaylistItem[P]>
      : GetScalarType<T[P], AggregateAIPlaylistItem[P]>
  }




  export type AIPlaylistItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIPlaylistItemWhereInput
    orderBy?: AIPlaylistItemOrderByWithAggregationInput | AIPlaylistItemOrderByWithAggregationInput[]
    by: AIPlaylistItemScalarFieldEnum[] | AIPlaylistItemScalarFieldEnum
    having?: AIPlaylistItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AIPlaylistItemCountAggregateInputType | true
    _avg?: AIPlaylistItemAvgAggregateInputType
    _sum?: AIPlaylistItemSumAggregateInputType
    _min?: AIPlaylistItemMinAggregateInputType
    _max?: AIPlaylistItemMaxAggregateInputType
  }

  export type AIPlaylistItemGroupByOutputType = {
    id: string
    playlistId: string
    contentItemId: string
    order: number
    _count: AIPlaylistItemCountAggregateOutputType | null
    _avg: AIPlaylistItemAvgAggregateOutputType | null
    _sum: AIPlaylistItemSumAggregateOutputType | null
    _min: AIPlaylistItemMinAggregateOutputType | null
    _max: AIPlaylistItemMaxAggregateOutputType | null
  }

  type GetAIPlaylistItemGroupByPayload<T extends AIPlaylistItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AIPlaylistItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AIPlaylistItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AIPlaylistItemGroupByOutputType[P]>
            : GetScalarType<T[P], AIPlaylistItemGroupByOutputType[P]>
        }
      >
    >


  export type AIPlaylistItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playlistId?: boolean
    contentItemId?: boolean
    order?: boolean
    playlist?: boolean | AIPlaylistDefaultArgs<ExtArgs>
    contentItem?: boolean | ContentItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIPlaylistItem"]>

  export type AIPlaylistItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playlistId?: boolean
    contentItemId?: boolean
    order?: boolean
    playlist?: boolean | AIPlaylistDefaultArgs<ExtArgs>
    contentItem?: boolean | ContentItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIPlaylistItem"]>

  export type AIPlaylistItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playlistId?: boolean
    contentItemId?: boolean
    order?: boolean
    playlist?: boolean | AIPlaylistDefaultArgs<ExtArgs>
    contentItem?: boolean | ContentItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIPlaylistItem"]>

  export type AIPlaylistItemSelectScalar = {
    id?: boolean
    playlistId?: boolean
    contentItemId?: boolean
    order?: boolean
  }

  export type AIPlaylistItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "playlistId" | "contentItemId" | "order", ExtArgs["result"]["aIPlaylistItem"]>
  export type AIPlaylistItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    playlist?: boolean | AIPlaylistDefaultArgs<ExtArgs>
    contentItem?: boolean | ContentItemDefaultArgs<ExtArgs>
  }
  export type AIPlaylistItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    playlist?: boolean | AIPlaylistDefaultArgs<ExtArgs>
    contentItem?: boolean | ContentItemDefaultArgs<ExtArgs>
  }
  export type AIPlaylistItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    playlist?: boolean | AIPlaylistDefaultArgs<ExtArgs>
    contentItem?: boolean | ContentItemDefaultArgs<ExtArgs>
  }

  export type $AIPlaylistItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AIPlaylistItem"
    objects: {
      playlist: Prisma.$AIPlaylistPayload<ExtArgs>
      contentItem: Prisma.$ContentItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      playlistId: string
      contentItemId: string
      order: number
    }, ExtArgs["result"]["aIPlaylistItem"]>
    composites: {}
  }

  type AIPlaylistItemGetPayload<S extends boolean | null | undefined | AIPlaylistItemDefaultArgs> = $Result.GetResult<Prisma.$AIPlaylistItemPayload, S>

  type AIPlaylistItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AIPlaylistItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AIPlaylistItemCountAggregateInputType | true
    }

  export interface AIPlaylistItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AIPlaylistItem'], meta: { name: 'AIPlaylistItem' } }
    /**
     * Find zero or one AIPlaylistItem that matches the filter.
     * @param {AIPlaylistItemFindUniqueArgs} args - Arguments to find a AIPlaylistItem
     * @example
     * // Get one AIPlaylistItem
     * const aIPlaylistItem = await prisma.aIPlaylistItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AIPlaylistItemFindUniqueArgs>(args: SelectSubset<T, AIPlaylistItemFindUniqueArgs<ExtArgs>>): Prisma__AIPlaylistItemClient<$Result.GetResult<Prisma.$AIPlaylistItemPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one AIPlaylistItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AIPlaylistItemFindUniqueOrThrowArgs} args - Arguments to find a AIPlaylistItem
     * @example
     * // Get one AIPlaylistItem
     * const aIPlaylistItem = await prisma.aIPlaylistItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AIPlaylistItemFindUniqueOrThrowArgs>(args: SelectSubset<T, AIPlaylistItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AIPlaylistItemClient<$Result.GetResult<Prisma.$AIPlaylistItemPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first AIPlaylistItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIPlaylistItemFindFirstArgs} args - Arguments to find a AIPlaylistItem
     * @example
     * // Get one AIPlaylistItem
     * const aIPlaylistItem = await prisma.aIPlaylistItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AIPlaylistItemFindFirstArgs>(args?: SelectSubset<T, AIPlaylistItemFindFirstArgs<ExtArgs>>): Prisma__AIPlaylistItemClient<$Result.GetResult<Prisma.$AIPlaylistItemPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first AIPlaylistItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIPlaylistItemFindFirstOrThrowArgs} args - Arguments to find a AIPlaylistItem
     * @example
     * // Get one AIPlaylistItem
     * const aIPlaylistItem = await prisma.aIPlaylistItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AIPlaylistItemFindFirstOrThrowArgs>(args?: SelectSubset<T, AIPlaylistItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__AIPlaylistItemClient<$Result.GetResult<Prisma.$AIPlaylistItemPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more AIPlaylistItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIPlaylistItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AIPlaylistItems
     * const aIPlaylistItems = await prisma.aIPlaylistItem.findMany()
     * 
     * // Get first 10 AIPlaylistItems
     * const aIPlaylistItems = await prisma.aIPlaylistItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aIPlaylistItemWithIdOnly = await prisma.aIPlaylistItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AIPlaylistItemFindManyArgs>(args?: SelectSubset<T, AIPlaylistItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIPlaylistItemPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a AIPlaylistItem.
     * @param {AIPlaylistItemCreateArgs} args - Arguments to create a AIPlaylistItem.
     * @example
     * // Create one AIPlaylistItem
     * const AIPlaylistItem = await prisma.aIPlaylistItem.create({
     *   data: {
     *     // ... data to create a AIPlaylistItem
     *   }
     * })
     * 
     */
    create<T extends AIPlaylistItemCreateArgs>(args: SelectSubset<T, AIPlaylistItemCreateArgs<ExtArgs>>): Prisma__AIPlaylistItemClient<$Result.GetResult<Prisma.$AIPlaylistItemPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many AIPlaylistItems.
     * @param {AIPlaylistItemCreateManyArgs} args - Arguments to create many AIPlaylistItems.
     * @example
     * // Create many AIPlaylistItems
     * const aIPlaylistItem = await prisma.aIPlaylistItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AIPlaylistItemCreateManyArgs>(args?: SelectSubset<T, AIPlaylistItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AIPlaylistItems and returns the data saved in the database.
     * @param {AIPlaylistItemCreateManyAndReturnArgs} args - Arguments to create many AIPlaylistItems.
     * @example
     * // Create many AIPlaylistItems
     * const aIPlaylistItem = await prisma.aIPlaylistItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AIPlaylistItems and only return the `id`
     * const aIPlaylistItemWithIdOnly = await prisma.aIPlaylistItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AIPlaylistItemCreateManyAndReturnArgs>(args?: SelectSubset<T, AIPlaylistItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIPlaylistItemPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a AIPlaylistItem.
     * @param {AIPlaylistItemDeleteArgs} args - Arguments to delete one AIPlaylistItem.
     * @example
     * // Delete one AIPlaylistItem
     * const AIPlaylistItem = await prisma.aIPlaylistItem.delete({
     *   where: {
     *     // ... filter to delete one AIPlaylistItem
     *   }
     * })
     * 
     */
    delete<T extends AIPlaylistItemDeleteArgs>(args: SelectSubset<T, AIPlaylistItemDeleteArgs<ExtArgs>>): Prisma__AIPlaylistItemClient<$Result.GetResult<Prisma.$AIPlaylistItemPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one AIPlaylistItem.
     * @param {AIPlaylistItemUpdateArgs} args - Arguments to update one AIPlaylistItem.
     * @example
     * // Update one AIPlaylistItem
     * const aIPlaylistItem = await prisma.aIPlaylistItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AIPlaylistItemUpdateArgs>(args: SelectSubset<T, AIPlaylistItemUpdateArgs<ExtArgs>>): Prisma__AIPlaylistItemClient<$Result.GetResult<Prisma.$AIPlaylistItemPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more AIPlaylistItems.
     * @param {AIPlaylistItemDeleteManyArgs} args - Arguments to filter AIPlaylistItems to delete.
     * @example
     * // Delete a few AIPlaylistItems
     * const { count } = await prisma.aIPlaylistItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AIPlaylistItemDeleteManyArgs>(args?: SelectSubset<T, AIPlaylistItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIPlaylistItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIPlaylistItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AIPlaylistItems
     * const aIPlaylistItem = await prisma.aIPlaylistItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AIPlaylistItemUpdateManyArgs>(args: SelectSubset<T, AIPlaylistItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIPlaylistItems and returns the data updated in the database.
     * @param {AIPlaylistItemUpdateManyAndReturnArgs} args - Arguments to update many AIPlaylistItems.
     * @example
     * // Update many AIPlaylistItems
     * const aIPlaylistItem = await prisma.aIPlaylistItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AIPlaylistItems and only return the `id`
     * const aIPlaylistItemWithIdOnly = await prisma.aIPlaylistItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AIPlaylistItemUpdateManyAndReturnArgs>(args: SelectSubset<T, AIPlaylistItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIPlaylistItemPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one AIPlaylistItem.
     * @param {AIPlaylistItemUpsertArgs} args - Arguments to update or create a AIPlaylistItem.
     * @example
     * // Update or create a AIPlaylistItem
     * const aIPlaylistItem = await prisma.aIPlaylistItem.upsert({
     *   create: {
     *     // ... data to create a AIPlaylistItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AIPlaylistItem we want to update
     *   }
     * })
     */
    upsert<T extends AIPlaylistItemUpsertArgs>(args: SelectSubset<T, AIPlaylistItemUpsertArgs<ExtArgs>>): Prisma__AIPlaylistItemClient<$Result.GetResult<Prisma.$AIPlaylistItemPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of AIPlaylistItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIPlaylistItemCountArgs} args - Arguments to filter AIPlaylistItems to count.
     * @example
     * // Count the number of AIPlaylistItems
     * const count = await prisma.aIPlaylistItem.count({
     *   where: {
     *     // ... the filter for the AIPlaylistItems we want to count
     *   }
     * })
    **/
    count<T extends AIPlaylistItemCountArgs>(
      args?: Subset<T, AIPlaylistItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AIPlaylistItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AIPlaylistItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIPlaylistItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AIPlaylistItemAggregateArgs>(args: Subset<T, AIPlaylistItemAggregateArgs>): Prisma.PrismaPromise<GetAIPlaylistItemAggregateType<T>>

    /**
     * Group by AIPlaylistItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIPlaylistItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AIPlaylistItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AIPlaylistItemGroupByArgs['orderBy'] }
        : { orderBy?: AIPlaylistItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AIPlaylistItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAIPlaylistItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AIPlaylistItem model
   */
  readonly fields: AIPlaylistItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AIPlaylistItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AIPlaylistItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    playlist<T extends AIPlaylistDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AIPlaylistDefaultArgs<ExtArgs>>): Prisma__AIPlaylistClient<$Result.GetResult<Prisma.$AIPlaylistPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    contentItem<T extends ContentItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContentItemDefaultArgs<ExtArgs>>): Prisma__ContentItemClient<$Result.GetResult<Prisma.$ContentItemPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AIPlaylistItem model
   */ 
  interface AIPlaylistItemFieldRefs {
    readonly id: FieldRef<"AIPlaylistItem", 'String'>
    readonly playlistId: FieldRef<"AIPlaylistItem", 'String'>
    readonly contentItemId: FieldRef<"AIPlaylistItem", 'String'>
    readonly order: FieldRef<"AIPlaylistItem", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * AIPlaylistItem findUnique
   */
  export type AIPlaylistItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIPlaylistItem
     */
    select?: AIPlaylistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIPlaylistItem
     */
    omit?: AIPlaylistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIPlaylistItemInclude<ExtArgs> | null
    /**
     * Filter, which AIPlaylistItem to fetch.
     */
    where: AIPlaylistItemWhereUniqueInput
  }

  /**
   * AIPlaylistItem findUniqueOrThrow
   */
  export type AIPlaylistItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIPlaylistItem
     */
    select?: AIPlaylistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIPlaylistItem
     */
    omit?: AIPlaylistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIPlaylistItemInclude<ExtArgs> | null
    /**
     * Filter, which AIPlaylistItem to fetch.
     */
    where: AIPlaylistItemWhereUniqueInput
  }

  /**
   * AIPlaylistItem findFirst
   */
  export type AIPlaylistItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIPlaylistItem
     */
    select?: AIPlaylistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIPlaylistItem
     */
    omit?: AIPlaylistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIPlaylistItemInclude<ExtArgs> | null
    /**
     * Filter, which AIPlaylistItem to fetch.
     */
    where?: AIPlaylistItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIPlaylistItems to fetch.
     */
    orderBy?: AIPlaylistItemOrderByWithRelationInput | AIPlaylistItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIPlaylistItems.
     */
    cursor?: AIPlaylistItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIPlaylistItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIPlaylistItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIPlaylistItems.
     */
    distinct?: AIPlaylistItemScalarFieldEnum | AIPlaylistItemScalarFieldEnum[]
  }

  /**
   * AIPlaylistItem findFirstOrThrow
   */
  export type AIPlaylistItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIPlaylistItem
     */
    select?: AIPlaylistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIPlaylistItem
     */
    omit?: AIPlaylistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIPlaylistItemInclude<ExtArgs> | null
    /**
     * Filter, which AIPlaylistItem to fetch.
     */
    where?: AIPlaylistItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIPlaylistItems to fetch.
     */
    orderBy?: AIPlaylistItemOrderByWithRelationInput | AIPlaylistItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIPlaylistItems.
     */
    cursor?: AIPlaylistItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIPlaylistItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIPlaylistItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIPlaylistItems.
     */
    distinct?: AIPlaylistItemScalarFieldEnum | AIPlaylistItemScalarFieldEnum[]
  }

  /**
   * AIPlaylistItem findMany
   */
  export type AIPlaylistItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIPlaylistItem
     */
    select?: AIPlaylistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIPlaylistItem
     */
    omit?: AIPlaylistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIPlaylistItemInclude<ExtArgs> | null
    /**
     * Filter, which AIPlaylistItems to fetch.
     */
    where?: AIPlaylistItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIPlaylistItems to fetch.
     */
    orderBy?: AIPlaylistItemOrderByWithRelationInput | AIPlaylistItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AIPlaylistItems.
     */
    cursor?: AIPlaylistItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIPlaylistItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIPlaylistItems.
     */
    skip?: number
    distinct?: AIPlaylistItemScalarFieldEnum | AIPlaylistItemScalarFieldEnum[]
  }

  /**
   * AIPlaylistItem create
   */
  export type AIPlaylistItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIPlaylistItem
     */
    select?: AIPlaylistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIPlaylistItem
     */
    omit?: AIPlaylistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIPlaylistItemInclude<ExtArgs> | null
    /**
     * The data needed to create a AIPlaylistItem.
     */
    data: XOR<AIPlaylistItemCreateInput, AIPlaylistItemUncheckedCreateInput>
  }

  /**
   * AIPlaylistItem createMany
   */
  export type AIPlaylistItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AIPlaylistItems.
     */
    data: AIPlaylistItemCreateManyInput | AIPlaylistItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIPlaylistItem createManyAndReturn
   */
  export type AIPlaylistItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIPlaylistItem
     */
    select?: AIPlaylistItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIPlaylistItem
     */
    omit?: AIPlaylistItemOmit<ExtArgs> | null
    /**
     * The data used to create many AIPlaylistItems.
     */
    data: AIPlaylistItemCreateManyInput | AIPlaylistItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIPlaylistItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIPlaylistItem update
   */
  export type AIPlaylistItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIPlaylistItem
     */
    select?: AIPlaylistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIPlaylistItem
     */
    omit?: AIPlaylistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIPlaylistItemInclude<ExtArgs> | null
    /**
     * The data needed to update a AIPlaylistItem.
     */
    data: XOR<AIPlaylistItemUpdateInput, AIPlaylistItemUncheckedUpdateInput>
    /**
     * Choose, which AIPlaylistItem to update.
     */
    where: AIPlaylistItemWhereUniqueInput
  }

  /**
   * AIPlaylistItem updateMany
   */
  export type AIPlaylistItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AIPlaylistItems.
     */
    data: XOR<AIPlaylistItemUpdateManyMutationInput, AIPlaylistItemUncheckedUpdateManyInput>
    /**
     * Filter which AIPlaylistItems to update
     */
    where?: AIPlaylistItemWhereInput
    /**
     * Limit how many AIPlaylistItems to update.
     */
    limit?: number
  }

  /**
   * AIPlaylistItem updateManyAndReturn
   */
  export type AIPlaylistItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIPlaylistItem
     */
    select?: AIPlaylistItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIPlaylistItem
     */
    omit?: AIPlaylistItemOmit<ExtArgs> | null
    /**
     * The data used to update AIPlaylistItems.
     */
    data: XOR<AIPlaylistItemUpdateManyMutationInput, AIPlaylistItemUncheckedUpdateManyInput>
    /**
     * Filter which AIPlaylistItems to update
     */
    where?: AIPlaylistItemWhereInput
    /**
     * Limit how many AIPlaylistItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIPlaylistItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIPlaylistItem upsert
   */
  export type AIPlaylistItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIPlaylistItem
     */
    select?: AIPlaylistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIPlaylistItem
     */
    omit?: AIPlaylistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIPlaylistItemInclude<ExtArgs> | null
    /**
     * The filter to search for the AIPlaylistItem to update in case it exists.
     */
    where: AIPlaylistItemWhereUniqueInput
    /**
     * In case the AIPlaylistItem found by the `where` argument doesn't exist, create a new AIPlaylistItem with this data.
     */
    create: XOR<AIPlaylistItemCreateInput, AIPlaylistItemUncheckedCreateInput>
    /**
     * In case the AIPlaylistItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AIPlaylistItemUpdateInput, AIPlaylistItemUncheckedUpdateInput>
  }

  /**
   * AIPlaylistItem delete
   */
  export type AIPlaylistItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIPlaylistItem
     */
    select?: AIPlaylistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIPlaylistItem
     */
    omit?: AIPlaylistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIPlaylistItemInclude<ExtArgs> | null
    /**
     * Filter which AIPlaylistItem to delete.
     */
    where: AIPlaylistItemWhereUniqueInput
  }

  /**
   * AIPlaylistItem deleteMany
   */
  export type AIPlaylistItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIPlaylistItems to delete
     */
    where?: AIPlaylistItemWhereInput
    /**
     * Limit how many AIPlaylistItems to delete.
     */
    limit?: number
  }

  /**
   * AIPlaylistItem without action
   */
  export type AIPlaylistItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIPlaylistItem
     */
    select?: AIPlaylistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIPlaylistItem
     */
    omit?: AIPlaylistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIPlaylistItemInclude<ExtArgs> | null
  }


  /**
   * Model ChallengeScore
   */

  export type AggregateChallengeScore = {
    _count: ChallengeScoreCountAggregateOutputType | null
    _avg: ChallengeScoreAvgAggregateOutputType | null
    _sum: ChallengeScoreSumAggregateOutputType | null
    _min: ChallengeScoreMinAggregateOutputType | null
    _max: ChallengeScoreMaxAggregateOutputType | null
  }

  export type ChallengeScoreAvgAggregateOutputType = {
    score: number | null
  }

  export type ChallengeScoreSumAggregateOutputType = {
    score: number | null
  }

  export type ChallengeScoreMinAggregateOutputType = {
    id: string | null
    userId: string | null
    score: number | null
    createdAt: Date | null
  }

  export type ChallengeScoreMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    score: number | null
    createdAt: Date | null
  }

  export type ChallengeScoreCountAggregateOutputType = {
    id: number
    userId: number
    score: number
    createdAt: number
    _all: number
  }


  export type ChallengeScoreAvgAggregateInputType = {
    score?: true
  }

  export type ChallengeScoreSumAggregateInputType = {
    score?: true
  }

  export type ChallengeScoreMinAggregateInputType = {
    id?: true
    userId?: true
    score?: true
    createdAt?: true
  }

  export type ChallengeScoreMaxAggregateInputType = {
    id?: true
    userId?: true
    score?: true
    createdAt?: true
  }

  export type ChallengeScoreCountAggregateInputType = {
    id?: true
    userId?: true
    score?: true
    createdAt?: true
    _all?: true
  }

  export type ChallengeScoreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengeScore to aggregate.
     */
    where?: ChallengeScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeScores to fetch.
     */
    orderBy?: ChallengeScoreOrderByWithRelationInput | ChallengeScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChallengeScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeScores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeScores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChallengeScores
    **/
    _count?: true | ChallengeScoreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChallengeScoreAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChallengeScoreSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChallengeScoreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChallengeScoreMaxAggregateInputType
  }

  export type GetChallengeScoreAggregateType<T extends ChallengeScoreAggregateArgs> = {
        [P in keyof T & keyof AggregateChallengeScore]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChallengeScore[P]>
      : GetScalarType<T[P], AggregateChallengeScore[P]>
  }




  export type ChallengeScoreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeScoreWhereInput
    orderBy?: ChallengeScoreOrderByWithAggregationInput | ChallengeScoreOrderByWithAggregationInput[]
    by: ChallengeScoreScalarFieldEnum[] | ChallengeScoreScalarFieldEnum
    having?: ChallengeScoreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChallengeScoreCountAggregateInputType | true
    _avg?: ChallengeScoreAvgAggregateInputType
    _sum?: ChallengeScoreSumAggregateInputType
    _min?: ChallengeScoreMinAggregateInputType
    _max?: ChallengeScoreMaxAggregateInputType
  }

  export type ChallengeScoreGroupByOutputType = {
    id: string
    userId: string
    score: number
    createdAt: Date
    _count: ChallengeScoreCountAggregateOutputType | null
    _avg: ChallengeScoreAvgAggregateOutputType | null
    _sum: ChallengeScoreSumAggregateOutputType | null
    _min: ChallengeScoreMinAggregateOutputType | null
    _max: ChallengeScoreMaxAggregateOutputType | null
  }

  type GetChallengeScoreGroupByPayload<T extends ChallengeScoreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChallengeScoreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChallengeScoreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChallengeScoreGroupByOutputType[P]>
            : GetScalarType<T[P], ChallengeScoreGroupByOutputType[P]>
        }
      >
    >


  export type ChallengeScoreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    score?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeScore"]>

  export type ChallengeScoreSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    score?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeScore"]>

  export type ChallengeScoreSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    score?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeScore"]>

  export type ChallengeScoreSelectScalar = {
    id?: boolean
    userId?: boolean
    score?: boolean
    createdAt?: boolean
  }

  export type ChallengeScoreOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "score" | "createdAt", ExtArgs["result"]["challengeScore"]>
  export type ChallengeScoreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ChallengeScoreIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ChallengeScoreIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ChallengeScorePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChallengeScore"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      score: number
      createdAt: Date
    }, ExtArgs["result"]["challengeScore"]>
    composites: {}
  }

  type ChallengeScoreGetPayload<S extends boolean | null | undefined | ChallengeScoreDefaultArgs> = $Result.GetResult<Prisma.$ChallengeScorePayload, S>

  type ChallengeScoreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChallengeScoreFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChallengeScoreCountAggregateInputType | true
    }

  export interface ChallengeScoreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChallengeScore'], meta: { name: 'ChallengeScore' } }
    /**
     * Find zero or one ChallengeScore that matches the filter.
     * @param {ChallengeScoreFindUniqueArgs} args - Arguments to find a ChallengeScore
     * @example
     * // Get one ChallengeScore
     * const challengeScore = await prisma.challengeScore.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChallengeScoreFindUniqueArgs>(args: SelectSubset<T, ChallengeScoreFindUniqueArgs<ExtArgs>>): Prisma__ChallengeScoreClient<$Result.GetResult<Prisma.$ChallengeScorePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ChallengeScore that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChallengeScoreFindUniqueOrThrowArgs} args - Arguments to find a ChallengeScore
     * @example
     * // Get one ChallengeScore
     * const challengeScore = await prisma.challengeScore.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChallengeScoreFindUniqueOrThrowArgs>(args: SelectSubset<T, ChallengeScoreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChallengeScoreClient<$Result.GetResult<Prisma.$ChallengeScorePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ChallengeScore that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeScoreFindFirstArgs} args - Arguments to find a ChallengeScore
     * @example
     * // Get one ChallengeScore
     * const challengeScore = await prisma.challengeScore.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChallengeScoreFindFirstArgs>(args?: SelectSubset<T, ChallengeScoreFindFirstArgs<ExtArgs>>): Prisma__ChallengeScoreClient<$Result.GetResult<Prisma.$ChallengeScorePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ChallengeScore that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeScoreFindFirstOrThrowArgs} args - Arguments to find a ChallengeScore
     * @example
     * // Get one ChallengeScore
     * const challengeScore = await prisma.challengeScore.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChallengeScoreFindFirstOrThrowArgs>(args?: SelectSubset<T, ChallengeScoreFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChallengeScoreClient<$Result.GetResult<Prisma.$ChallengeScorePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ChallengeScores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeScoreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChallengeScores
     * const challengeScores = await prisma.challengeScore.findMany()
     * 
     * // Get first 10 ChallengeScores
     * const challengeScores = await prisma.challengeScore.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const challengeScoreWithIdOnly = await prisma.challengeScore.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChallengeScoreFindManyArgs>(args?: SelectSubset<T, ChallengeScoreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeScorePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ChallengeScore.
     * @param {ChallengeScoreCreateArgs} args - Arguments to create a ChallengeScore.
     * @example
     * // Create one ChallengeScore
     * const ChallengeScore = await prisma.challengeScore.create({
     *   data: {
     *     // ... data to create a ChallengeScore
     *   }
     * })
     * 
     */
    create<T extends ChallengeScoreCreateArgs>(args: SelectSubset<T, ChallengeScoreCreateArgs<ExtArgs>>): Prisma__ChallengeScoreClient<$Result.GetResult<Prisma.$ChallengeScorePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ChallengeScores.
     * @param {ChallengeScoreCreateManyArgs} args - Arguments to create many ChallengeScores.
     * @example
     * // Create many ChallengeScores
     * const challengeScore = await prisma.challengeScore.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChallengeScoreCreateManyArgs>(args?: SelectSubset<T, ChallengeScoreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChallengeScores and returns the data saved in the database.
     * @param {ChallengeScoreCreateManyAndReturnArgs} args - Arguments to create many ChallengeScores.
     * @example
     * // Create many ChallengeScores
     * const challengeScore = await prisma.challengeScore.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChallengeScores and only return the `id`
     * const challengeScoreWithIdOnly = await prisma.challengeScore.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChallengeScoreCreateManyAndReturnArgs>(args?: SelectSubset<T, ChallengeScoreCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeScorePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a ChallengeScore.
     * @param {ChallengeScoreDeleteArgs} args - Arguments to delete one ChallengeScore.
     * @example
     * // Delete one ChallengeScore
     * const ChallengeScore = await prisma.challengeScore.delete({
     *   where: {
     *     // ... filter to delete one ChallengeScore
     *   }
     * })
     * 
     */
    delete<T extends ChallengeScoreDeleteArgs>(args: SelectSubset<T, ChallengeScoreDeleteArgs<ExtArgs>>): Prisma__ChallengeScoreClient<$Result.GetResult<Prisma.$ChallengeScorePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ChallengeScore.
     * @param {ChallengeScoreUpdateArgs} args - Arguments to update one ChallengeScore.
     * @example
     * // Update one ChallengeScore
     * const challengeScore = await prisma.challengeScore.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChallengeScoreUpdateArgs>(args: SelectSubset<T, ChallengeScoreUpdateArgs<ExtArgs>>): Prisma__ChallengeScoreClient<$Result.GetResult<Prisma.$ChallengeScorePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ChallengeScores.
     * @param {ChallengeScoreDeleteManyArgs} args - Arguments to filter ChallengeScores to delete.
     * @example
     * // Delete a few ChallengeScores
     * const { count } = await prisma.challengeScore.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChallengeScoreDeleteManyArgs>(args?: SelectSubset<T, ChallengeScoreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChallengeScores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeScoreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChallengeScores
     * const challengeScore = await prisma.challengeScore.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChallengeScoreUpdateManyArgs>(args: SelectSubset<T, ChallengeScoreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChallengeScores and returns the data updated in the database.
     * @param {ChallengeScoreUpdateManyAndReturnArgs} args - Arguments to update many ChallengeScores.
     * @example
     * // Update many ChallengeScores
     * const challengeScore = await prisma.challengeScore.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChallengeScores and only return the `id`
     * const challengeScoreWithIdOnly = await prisma.challengeScore.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChallengeScoreUpdateManyAndReturnArgs>(args: SelectSubset<T, ChallengeScoreUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeScorePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one ChallengeScore.
     * @param {ChallengeScoreUpsertArgs} args - Arguments to update or create a ChallengeScore.
     * @example
     * // Update or create a ChallengeScore
     * const challengeScore = await prisma.challengeScore.upsert({
     *   create: {
     *     // ... data to create a ChallengeScore
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChallengeScore we want to update
     *   }
     * })
     */
    upsert<T extends ChallengeScoreUpsertArgs>(args: SelectSubset<T, ChallengeScoreUpsertArgs<ExtArgs>>): Prisma__ChallengeScoreClient<$Result.GetResult<Prisma.$ChallengeScorePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ChallengeScores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeScoreCountArgs} args - Arguments to filter ChallengeScores to count.
     * @example
     * // Count the number of ChallengeScores
     * const count = await prisma.challengeScore.count({
     *   where: {
     *     // ... the filter for the ChallengeScores we want to count
     *   }
     * })
    **/
    count<T extends ChallengeScoreCountArgs>(
      args?: Subset<T, ChallengeScoreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChallengeScoreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChallengeScore.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeScoreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChallengeScoreAggregateArgs>(args: Subset<T, ChallengeScoreAggregateArgs>): Prisma.PrismaPromise<GetChallengeScoreAggregateType<T>>

    /**
     * Group by ChallengeScore.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeScoreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChallengeScoreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChallengeScoreGroupByArgs['orderBy'] }
        : { orderBy?: ChallengeScoreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChallengeScoreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChallengeScoreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChallengeScore model
   */
  readonly fields: ChallengeScoreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChallengeScore.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChallengeScoreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChallengeScore model
   */ 
  interface ChallengeScoreFieldRefs {
    readonly id: FieldRef<"ChallengeScore", 'String'>
    readonly userId: FieldRef<"ChallengeScore", 'String'>
    readonly score: FieldRef<"ChallengeScore", 'Int'>
    readonly createdAt: FieldRef<"ChallengeScore", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChallengeScore findUnique
   */
  export type ChallengeScoreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeScore
     */
    select?: ChallengeScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeScore
     */
    omit?: ChallengeScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeScoreInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeScore to fetch.
     */
    where: ChallengeScoreWhereUniqueInput
  }

  /**
   * ChallengeScore findUniqueOrThrow
   */
  export type ChallengeScoreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeScore
     */
    select?: ChallengeScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeScore
     */
    omit?: ChallengeScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeScoreInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeScore to fetch.
     */
    where: ChallengeScoreWhereUniqueInput
  }

  /**
   * ChallengeScore findFirst
   */
  export type ChallengeScoreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeScore
     */
    select?: ChallengeScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeScore
     */
    omit?: ChallengeScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeScoreInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeScore to fetch.
     */
    where?: ChallengeScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeScores to fetch.
     */
    orderBy?: ChallengeScoreOrderByWithRelationInput | ChallengeScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengeScores.
     */
    cursor?: ChallengeScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeScores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeScores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengeScores.
     */
    distinct?: ChallengeScoreScalarFieldEnum | ChallengeScoreScalarFieldEnum[]
  }

  /**
   * ChallengeScore findFirstOrThrow
   */
  export type ChallengeScoreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeScore
     */
    select?: ChallengeScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeScore
     */
    omit?: ChallengeScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeScoreInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeScore to fetch.
     */
    where?: ChallengeScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeScores to fetch.
     */
    orderBy?: ChallengeScoreOrderByWithRelationInput | ChallengeScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengeScores.
     */
    cursor?: ChallengeScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeScores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeScores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengeScores.
     */
    distinct?: ChallengeScoreScalarFieldEnum | ChallengeScoreScalarFieldEnum[]
  }

  /**
   * ChallengeScore findMany
   */
  export type ChallengeScoreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeScore
     */
    select?: ChallengeScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeScore
     */
    omit?: ChallengeScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeScoreInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeScores to fetch.
     */
    where?: ChallengeScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeScores to fetch.
     */
    orderBy?: ChallengeScoreOrderByWithRelationInput | ChallengeScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChallengeScores.
     */
    cursor?: ChallengeScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeScores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeScores.
     */
    skip?: number
    distinct?: ChallengeScoreScalarFieldEnum | ChallengeScoreScalarFieldEnum[]
  }

  /**
   * ChallengeScore create
   */
  export type ChallengeScoreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeScore
     */
    select?: ChallengeScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeScore
     */
    omit?: ChallengeScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeScoreInclude<ExtArgs> | null
    /**
     * The data needed to create a ChallengeScore.
     */
    data: XOR<ChallengeScoreCreateInput, ChallengeScoreUncheckedCreateInput>
  }

  /**
   * ChallengeScore createMany
   */
  export type ChallengeScoreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChallengeScores.
     */
    data: ChallengeScoreCreateManyInput | ChallengeScoreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChallengeScore createManyAndReturn
   */
  export type ChallengeScoreCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeScore
     */
    select?: ChallengeScoreSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeScore
     */
    omit?: ChallengeScoreOmit<ExtArgs> | null
    /**
     * The data used to create many ChallengeScores.
     */
    data: ChallengeScoreCreateManyInput | ChallengeScoreCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeScoreIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChallengeScore update
   */
  export type ChallengeScoreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeScore
     */
    select?: ChallengeScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeScore
     */
    omit?: ChallengeScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeScoreInclude<ExtArgs> | null
    /**
     * The data needed to update a ChallengeScore.
     */
    data: XOR<ChallengeScoreUpdateInput, ChallengeScoreUncheckedUpdateInput>
    /**
     * Choose, which ChallengeScore to update.
     */
    where: ChallengeScoreWhereUniqueInput
  }

  /**
   * ChallengeScore updateMany
   */
  export type ChallengeScoreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChallengeScores.
     */
    data: XOR<ChallengeScoreUpdateManyMutationInput, ChallengeScoreUncheckedUpdateManyInput>
    /**
     * Filter which ChallengeScores to update
     */
    where?: ChallengeScoreWhereInput
    /**
     * Limit how many ChallengeScores to update.
     */
    limit?: number
  }

  /**
   * ChallengeScore updateManyAndReturn
   */
  export type ChallengeScoreUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeScore
     */
    select?: ChallengeScoreSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeScore
     */
    omit?: ChallengeScoreOmit<ExtArgs> | null
    /**
     * The data used to update ChallengeScores.
     */
    data: XOR<ChallengeScoreUpdateManyMutationInput, ChallengeScoreUncheckedUpdateManyInput>
    /**
     * Filter which ChallengeScores to update
     */
    where?: ChallengeScoreWhereInput
    /**
     * Limit how many ChallengeScores to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeScoreIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChallengeScore upsert
   */
  export type ChallengeScoreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeScore
     */
    select?: ChallengeScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeScore
     */
    omit?: ChallengeScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeScoreInclude<ExtArgs> | null
    /**
     * The filter to search for the ChallengeScore to update in case it exists.
     */
    where: ChallengeScoreWhereUniqueInput
    /**
     * In case the ChallengeScore found by the `where` argument doesn't exist, create a new ChallengeScore with this data.
     */
    create: XOR<ChallengeScoreCreateInput, ChallengeScoreUncheckedCreateInput>
    /**
     * In case the ChallengeScore was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChallengeScoreUpdateInput, ChallengeScoreUncheckedUpdateInput>
  }

  /**
   * ChallengeScore delete
   */
  export type ChallengeScoreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeScore
     */
    select?: ChallengeScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeScore
     */
    omit?: ChallengeScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeScoreInclude<ExtArgs> | null
    /**
     * Filter which ChallengeScore to delete.
     */
    where: ChallengeScoreWhereUniqueInput
  }

  /**
   * ChallengeScore deleteMany
   */
  export type ChallengeScoreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengeScores to delete
     */
    where?: ChallengeScoreWhereInput
    /**
     * Limit how many ChallengeScores to delete.
     */
    limit?: number
  }

  /**
   * ChallengeScore without action
   */
  export type ChallengeScoreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeScore
     */
    select?: ChallengeScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeScore
     */
    omit?: ChallengeScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeScoreInclude<ExtArgs> | null
  }


  /**
   * Model AIRecommendation
   */

  export type AggregateAIRecommendation = {
    _count: AIRecommendationCountAggregateOutputType | null
    _min: AIRecommendationMinAggregateOutputType | null
    _max: AIRecommendationMaxAggregateOutputType | null
  }

  export type AIRecommendationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    content: string | null
    createdAt: Date | null
  }

  export type AIRecommendationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    content: string | null
    createdAt: Date | null
  }

  export type AIRecommendationCountAggregateOutputType = {
    id: number
    userId: number
    content: number
    createdAt: number
    _all: number
  }


  export type AIRecommendationMinAggregateInputType = {
    id?: true
    userId?: true
    content?: true
    createdAt?: true
  }

  export type AIRecommendationMaxAggregateInputType = {
    id?: true
    userId?: true
    content?: true
    createdAt?: true
  }

  export type AIRecommendationCountAggregateInputType = {
    id?: true
    userId?: true
    content?: true
    createdAt?: true
    _all?: true
  }

  export type AIRecommendationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIRecommendation to aggregate.
     */
    where?: AIRecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIRecommendations to fetch.
     */
    orderBy?: AIRecommendationOrderByWithRelationInput | AIRecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AIRecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIRecommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIRecommendations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AIRecommendations
    **/
    _count?: true | AIRecommendationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AIRecommendationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AIRecommendationMaxAggregateInputType
  }

  export type GetAIRecommendationAggregateType<T extends AIRecommendationAggregateArgs> = {
        [P in keyof T & keyof AggregateAIRecommendation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAIRecommendation[P]>
      : GetScalarType<T[P], AggregateAIRecommendation[P]>
  }




  export type AIRecommendationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIRecommendationWhereInput
    orderBy?: AIRecommendationOrderByWithAggregationInput | AIRecommendationOrderByWithAggregationInput[]
    by: AIRecommendationScalarFieldEnum[] | AIRecommendationScalarFieldEnum
    having?: AIRecommendationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AIRecommendationCountAggregateInputType | true
    _min?: AIRecommendationMinAggregateInputType
    _max?: AIRecommendationMaxAggregateInputType
  }

  export type AIRecommendationGroupByOutputType = {
    id: string
    userId: string
    content: string
    createdAt: Date
    _count: AIRecommendationCountAggregateOutputType | null
    _min: AIRecommendationMinAggregateOutputType | null
    _max: AIRecommendationMaxAggregateOutputType | null
  }

  type GetAIRecommendationGroupByPayload<T extends AIRecommendationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AIRecommendationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AIRecommendationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AIRecommendationGroupByOutputType[P]>
            : GetScalarType<T[P], AIRecommendationGroupByOutputType[P]>
        }
      >
    >


  export type AIRecommendationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIRecommendation"]>

  export type AIRecommendationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIRecommendation"]>

  export type AIRecommendationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIRecommendation"]>

  export type AIRecommendationSelectScalar = {
    id?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
  }

  export type AIRecommendationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "content" | "createdAt", ExtArgs["result"]["aIRecommendation"]>
  export type AIRecommendationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AIRecommendationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AIRecommendationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AIRecommendationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AIRecommendation"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      content: string
      createdAt: Date
    }, ExtArgs["result"]["aIRecommendation"]>
    composites: {}
  }

  type AIRecommendationGetPayload<S extends boolean | null | undefined | AIRecommendationDefaultArgs> = $Result.GetResult<Prisma.$AIRecommendationPayload, S>

  type AIRecommendationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AIRecommendationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AIRecommendationCountAggregateInputType | true
    }

  export interface AIRecommendationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AIRecommendation'], meta: { name: 'AIRecommendation' } }
    /**
     * Find zero or one AIRecommendation that matches the filter.
     * @param {AIRecommendationFindUniqueArgs} args - Arguments to find a AIRecommendation
     * @example
     * // Get one AIRecommendation
     * const aIRecommendation = await prisma.aIRecommendation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AIRecommendationFindUniqueArgs>(args: SelectSubset<T, AIRecommendationFindUniqueArgs<ExtArgs>>): Prisma__AIRecommendationClient<$Result.GetResult<Prisma.$AIRecommendationPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one AIRecommendation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AIRecommendationFindUniqueOrThrowArgs} args - Arguments to find a AIRecommendation
     * @example
     * // Get one AIRecommendation
     * const aIRecommendation = await prisma.aIRecommendation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AIRecommendationFindUniqueOrThrowArgs>(args: SelectSubset<T, AIRecommendationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AIRecommendationClient<$Result.GetResult<Prisma.$AIRecommendationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first AIRecommendation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIRecommendationFindFirstArgs} args - Arguments to find a AIRecommendation
     * @example
     * // Get one AIRecommendation
     * const aIRecommendation = await prisma.aIRecommendation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AIRecommendationFindFirstArgs>(args?: SelectSubset<T, AIRecommendationFindFirstArgs<ExtArgs>>): Prisma__AIRecommendationClient<$Result.GetResult<Prisma.$AIRecommendationPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first AIRecommendation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIRecommendationFindFirstOrThrowArgs} args - Arguments to find a AIRecommendation
     * @example
     * // Get one AIRecommendation
     * const aIRecommendation = await prisma.aIRecommendation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AIRecommendationFindFirstOrThrowArgs>(args?: SelectSubset<T, AIRecommendationFindFirstOrThrowArgs<ExtArgs>>): Prisma__AIRecommendationClient<$Result.GetResult<Prisma.$AIRecommendationPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more AIRecommendations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIRecommendationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AIRecommendations
     * const aIRecommendations = await prisma.aIRecommendation.findMany()
     * 
     * // Get first 10 AIRecommendations
     * const aIRecommendations = await prisma.aIRecommendation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aIRecommendationWithIdOnly = await prisma.aIRecommendation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AIRecommendationFindManyArgs>(args?: SelectSubset<T, AIRecommendationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIRecommendationPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a AIRecommendation.
     * @param {AIRecommendationCreateArgs} args - Arguments to create a AIRecommendation.
     * @example
     * // Create one AIRecommendation
     * const AIRecommendation = await prisma.aIRecommendation.create({
     *   data: {
     *     // ... data to create a AIRecommendation
     *   }
     * })
     * 
     */
    create<T extends AIRecommendationCreateArgs>(args: SelectSubset<T, AIRecommendationCreateArgs<ExtArgs>>): Prisma__AIRecommendationClient<$Result.GetResult<Prisma.$AIRecommendationPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many AIRecommendations.
     * @param {AIRecommendationCreateManyArgs} args - Arguments to create many AIRecommendations.
     * @example
     * // Create many AIRecommendations
     * const aIRecommendation = await prisma.aIRecommendation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AIRecommendationCreateManyArgs>(args?: SelectSubset<T, AIRecommendationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AIRecommendations and returns the data saved in the database.
     * @param {AIRecommendationCreateManyAndReturnArgs} args - Arguments to create many AIRecommendations.
     * @example
     * // Create many AIRecommendations
     * const aIRecommendation = await prisma.aIRecommendation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AIRecommendations and only return the `id`
     * const aIRecommendationWithIdOnly = await prisma.aIRecommendation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AIRecommendationCreateManyAndReturnArgs>(args?: SelectSubset<T, AIRecommendationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIRecommendationPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a AIRecommendation.
     * @param {AIRecommendationDeleteArgs} args - Arguments to delete one AIRecommendation.
     * @example
     * // Delete one AIRecommendation
     * const AIRecommendation = await prisma.aIRecommendation.delete({
     *   where: {
     *     // ... filter to delete one AIRecommendation
     *   }
     * })
     * 
     */
    delete<T extends AIRecommendationDeleteArgs>(args: SelectSubset<T, AIRecommendationDeleteArgs<ExtArgs>>): Prisma__AIRecommendationClient<$Result.GetResult<Prisma.$AIRecommendationPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one AIRecommendation.
     * @param {AIRecommendationUpdateArgs} args - Arguments to update one AIRecommendation.
     * @example
     * // Update one AIRecommendation
     * const aIRecommendation = await prisma.aIRecommendation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AIRecommendationUpdateArgs>(args: SelectSubset<T, AIRecommendationUpdateArgs<ExtArgs>>): Prisma__AIRecommendationClient<$Result.GetResult<Prisma.$AIRecommendationPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more AIRecommendations.
     * @param {AIRecommendationDeleteManyArgs} args - Arguments to filter AIRecommendations to delete.
     * @example
     * // Delete a few AIRecommendations
     * const { count } = await prisma.aIRecommendation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AIRecommendationDeleteManyArgs>(args?: SelectSubset<T, AIRecommendationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIRecommendations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIRecommendationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AIRecommendations
     * const aIRecommendation = await prisma.aIRecommendation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AIRecommendationUpdateManyArgs>(args: SelectSubset<T, AIRecommendationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIRecommendations and returns the data updated in the database.
     * @param {AIRecommendationUpdateManyAndReturnArgs} args - Arguments to update many AIRecommendations.
     * @example
     * // Update many AIRecommendations
     * const aIRecommendation = await prisma.aIRecommendation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AIRecommendations and only return the `id`
     * const aIRecommendationWithIdOnly = await prisma.aIRecommendation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AIRecommendationUpdateManyAndReturnArgs>(args: SelectSubset<T, AIRecommendationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIRecommendationPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one AIRecommendation.
     * @param {AIRecommendationUpsertArgs} args - Arguments to update or create a AIRecommendation.
     * @example
     * // Update or create a AIRecommendation
     * const aIRecommendation = await prisma.aIRecommendation.upsert({
     *   create: {
     *     // ... data to create a AIRecommendation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AIRecommendation we want to update
     *   }
     * })
     */
    upsert<T extends AIRecommendationUpsertArgs>(args: SelectSubset<T, AIRecommendationUpsertArgs<ExtArgs>>): Prisma__AIRecommendationClient<$Result.GetResult<Prisma.$AIRecommendationPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of AIRecommendations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIRecommendationCountArgs} args - Arguments to filter AIRecommendations to count.
     * @example
     * // Count the number of AIRecommendations
     * const count = await prisma.aIRecommendation.count({
     *   where: {
     *     // ... the filter for the AIRecommendations we want to count
     *   }
     * })
    **/
    count<T extends AIRecommendationCountArgs>(
      args?: Subset<T, AIRecommendationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AIRecommendationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AIRecommendation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIRecommendationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AIRecommendationAggregateArgs>(args: Subset<T, AIRecommendationAggregateArgs>): Prisma.PrismaPromise<GetAIRecommendationAggregateType<T>>

    /**
     * Group by AIRecommendation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIRecommendationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AIRecommendationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AIRecommendationGroupByArgs['orderBy'] }
        : { orderBy?: AIRecommendationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AIRecommendationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAIRecommendationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AIRecommendation model
   */
  readonly fields: AIRecommendationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AIRecommendation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AIRecommendationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AIRecommendation model
   */ 
  interface AIRecommendationFieldRefs {
    readonly id: FieldRef<"AIRecommendation", 'String'>
    readonly userId: FieldRef<"AIRecommendation", 'String'>
    readonly content: FieldRef<"AIRecommendation", 'String'>
    readonly createdAt: FieldRef<"AIRecommendation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AIRecommendation findUnique
   */
  export type AIRecommendationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRecommendation
     */
    select?: AIRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIRecommendation
     */
    omit?: AIRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which AIRecommendation to fetch.
     */
    where: AIRecommendationWhereUniqueInput
  }

  /**
   * AIRecommendation findUniqueOrThrow
   */
  export type AIRecommendationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRecommendation
     */
    select?: AIRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIRecommendation
     */
    omit?: AIRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which AIRecommendation to fetch.
     */
    where: AIRecommendationWhereUniqueInput
  }

  /**
   * AIRecommendation findFirst
   */
  export type AIRecommendationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRecommendation
     */
    select?: AIRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIRecommendation
     */
    omit?: AIRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which AIRecommendation to fetch.
     */
    where?: AIRecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIRecommendations to fetch.
     */
    orderBy?: AIRecommendationOrderByWithRelationInput | AIRecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIRecommendations.
     */
    cursor?: AIRecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIRecommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIRecommendations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIRecommendations.
     */
    distinct?: AIRecommendationScalarFieldEnum | AIRecommendationScalarFieldEnum[]
  }

  /**
   * AIRecommendation findFirstOrThrow
   */
  export type AIRecommendationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRecommendation
     */
    select?: AIRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIRecommendation
     */
    omit?: AIRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which AIRecommendation to fetch.
     */
    where?: AIRecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIRecommendations to fetch.
     */
    orderBy?: AIRecommendationOrderByWithRelationInput | AIRecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIRecommendations.
     */
    cursor?: AIRecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIRecommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIRecommendations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIRecommendations.
     */
    distinct?: AIRecommendationScalarFieldEnum | AIRecommendationScalarFieldEnum[]
  }

  /**
   * AIRecommendation findMany
   */
  export type AIRecommendationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRecommendation
     */
    select?: AIRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIRecommendation
     */
    omit?: AIRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which AIRecommendations to fetch.
     */
    where?: AIRecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIRecommendations to fetch.
     */
    orderBy?: AIRecommendationOrderByWithRelationInput | AIRecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AIRecommendations.
     */
    cursor?: AIRecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIRecommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIRecommendations.
     */
    skip?: number
    distinct?: AIRecommendationScalarFieldEnum | AIRecommendationScalarFieldEnum[]
  }

  /**
   * AIRecommendation create
   */
  export type AIRecommendationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRecommendation
     */
    select?: AIRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIRecommendation
     */
    omit?: AIRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRecommendationInclude<ExtArgs> | null
    /**
     * The data needed to create a AIRecommendation.
     */
    data: XOR<AIRecommendationCreateInput, AIRecommendationUncheckedCreateInput>
  }

  /**
   * AIRecommendation createMany
   */
  export type AIRecommendationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AIRecommendations.
     */
    data: AIRecommendationCreateManyInput | AIRecommendationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIRecommendation createManyAndReturn
   */
  export type AIRecommendationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRecommendation
     */
    select?: AIRecommendationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIRecommendation
     */
    omit?: AIRecommendationOmit<ExtArgs> | null
    /**
     * The data used to create many AIRecommendations.
     */
    data: AIRecommendationCreateManyInput | AIRecommendationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRecommendationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIRecommendation update
   */
  export type AIRecommendationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRecommendation
     */
    select?: AIRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIRecommendation
     */
    omit?: AIRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRecommendationInclude<ExtArgs> | null
    /**
     * The data needed to update a AIRecommendation.
     */
    data: XOR<AIRecommendationUpdateInput, AIRecommendationUncheckedUpdateInput>
    /**
     * Choose, which AIRecommendation to update.
     */
    where: AIRecommendationWhereUniqueInput
  }

  /**
   * AIRecommendation updateMany
   */
  export type AIRecommendationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AIRecommendations.
     */
    data: XOR<AIRecommendationUpdateManyMutationInput, AIRecommendationUncheckedUpdateManyInput>
    /**
     * Filter which AIRecommendations to update
     */
    where?: AIRecommendationWhereInput
    /**
     * Limit how many AIRecommendations to update.
     */
    limit?: number
  }

  /**
   * AIRecommendation updateManyAndReturn
   */
  export type AIRecommendationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRecommendation
     */
    select?: AIRecommendationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIRecommendation
     */
    omit?: AIRecommendationOmit<ExtArgs> | null
    /**
     * The data used to update AIRecommendations.
     */
    data: XOR<AIRecommendationUpdateManyMutationInput, AIRecommendationUncheckedUpdateManyInput>
    /**
     * Filter which AIRecommendations to update
     */
    where?: AIRecommendationWhereInput
    /**
     * Limit how many AIRecommendations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRecommendationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIRecommendation upsert
   */
  export type AIRecommendationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRecommendation
     */
    select?: AIRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIRecommendation
     */
    omit?: AIRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRecommendationInclude<ExtArgs> | null
    /**
     * The filter to search for the AIRecommendation to update in case it exists.
     */
    where: AIRecommendationWhereUniqueInput
    /**
     * In case the AIRecommendation found by the `where` argument doesn't exist, create a new AIRecommendation with this data.
     */
    create: XOR<AIRecommendationCreateInput, AIRecommendationUncheckedCreateInput>
    /**
     * In case the AIRecommendation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AIRecommendationUpdateInput, AIRecommendationUncheckedUpdateInput>
  }

  /**
   * AIRecommendation delete
   */
  export type AIRecommendationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRecommendation
     */
    select?: AIRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIRecommendation
     */
    omit?: AIRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRecommendationInclude<ExtArgs> | null
    /**
     * Filter which AIRecommendation to delete.
     */
    where: AIRecommendationWhereUniqueInput
  }

  /**
   * AIRecommendation deleteMany
   */
  export type AIRecommendationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIRecommendations to delete
     */
    where?: AIRecommendationWhereInput
    /**
     * Limit how many AIRecommendations to delete.
     */
    limit?: number
  }

  /**
   * AIRecommendation without action
   */
  export type AIRecommendationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRecommendation
     */
    select?: AIRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIRecommendation
     */
    omit?: AIRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRecommendationInclude<ExtArgs> | null
  }


  /**
   * Model AIModule
   */

  export type AggregateAIModule = {
    _count: AIModuleCountAggregateOutputType | null
    _min: AIModuleMinAggregateOutputType | null
    _max: AIModuleMaxAggregateOutputType | null
  }

  export type AIModuleMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    difficulty: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    topicId: string | null
  }

  export type AIModuleMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    difficulty: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    topicId: string | null
  }

  export type AIModuleCountAggregateOutputType = {
    id: number
    title: number
    description: number
    content: number
    tags: number
    difficulty: number
    status: number
    createdAt: number
    updatedAt: number
    userId: number
    topicId: number
    _all: number
  }


  export type AIModuleMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    difficulty?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    topicId?: true
  }

  export type AIModuleMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    difficulty?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    topicId?: true
  }

  export type AIModuleCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    content?: true
    tags?: true
    difficulty?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    topicId?: true
    _all?: true
  }

  export type AIModuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIModule to aggregate.
     */
    where?: AIModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIModules to fetch.
     */
    orderBy?: AIModuleOrderByWithRelationInput | AIModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AIModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIModules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AIModules
    **/
    _count?: true | AIModuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AIModuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AIModuleMaxAggregateInputType
  }

  export type GetAIModuleAggregateType<T extends AIModuleAggregateArgs> = {
        [P in keyof T & keyof AggregateAIModule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAIModule[P]>
      : GetScalarType<T[P], AggregateAIModule[P]>
  }




  export type AIModuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIModuleWhereInput
    orderBy?: AIModuleOrderByWithAggregationInput | AIModuleOrderByWithAggregationInput[]
    by: AIModuleScalarFieldEnum[] | AIModuleScalarFieldEnum
    having?: AIModuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AIModuleCountAggregateInputType | true
    _min?: AIModuleMinAggregateInputType
    _max?: AIModuleMaxAggregateInputType
  }

  export type AIModuleGroupByOutputType = {
    id: string
    title: string
    description: string | null
    content: JsonValue
    tags: string[]
    difficulty: string | null
    status: string
    createdAt: Date
    updatedAt: Date
    userId: string | null
    topicId: string | null
    _count: AIModuleCountAggregateOutputType | null
    _min: AIModuleMinAggregateOutputType | null
    _max: AIModuleMaxAggregateOutputType | null
  }

  type GetAIModuleGroupByPayload<T extends AIModuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AIModuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AIModuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AIModuleGroupByOutputType[P]>
            : GetScalarType<T[P], AIModuleGroupByOutputType[P]>
        }
      >
    >


  export type AIModuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    content?: boolean
    tags?: boolean
    difficulty?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    topicId?: boolean
    user?: boolean | AIModule$userArgs<ExtArgs>
    topic?: boolean | AIModule$topicArgs<ExtArgs>
    learningPathItems?: boolean | AIModule$learningPathItemsArgs<ExtArgs>
    quizAttempts?: boolean | AIModule$quizAttemptsArgs<ExtArgs>
    ratings?: boolean | AIModule$ratingsArgs<ExtArgs>
    PracticeAttempts?: boolean | AIModule$PracticeAttemptsArgs<ExtArgs>
    _count?: boolean | AIModuleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIModule"]>

  export type AIModuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    content?: boolean
    tags?: boolean
    difficulty?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    topicId?: boolean
    user?: boolean | AIModule$userArgs<ExtArgs>
    topic?: boolean | AIModule$topicArgs<ExtArgs>
  }, ExtArgs["result"]["aIModule"]>

  export type AIModuleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    content?: boolean
    tags?: boolean
    difficulty?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    topicId?: boolean
    user?: boolean | AIModule$userArgs<ExtArgs>
    topic?: boolean | AIModule$topicArgs<ExtArgs>
  }, ExtArgs["result"]["aIModule"]>

  export type AIModuleSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    content?: boolean
    tags?: boolean
    difficulty?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    topicId?: boolean
  }

  export type AIModuleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "content" | "tags" | "difficulty" | "status" | "createdAt" | "updatedAt" | "userId" | "topicId", ExtArgs["result"]["aIModule"]>
  export type AIModuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AIModule$userArgs<ExtArgs>
    topic?: boolean | AIModule$topicArgs<ExtArgs>
    learningPathItems?: boolean | AIModule$learningPathItemsArgs<ExtArgs>
    quizAttempts?: boolean | AIModule$quizAttemptsArgs<ExtArgs>
    ratings?: boolean | AIModule$ratingsArgs<ExtArgs>
    PracticeAttempts?: boolean | AIModule$PracticeAttemptsArgs<ExtArgs>
    _count?: boolean | AIModuleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AIModuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AIModule$userArgs<ExtArgs>
    topic?: boolean | AIModule$topicArgs<ExtArgs>
  }
  export type AIModuleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AIModule$userArgs<ExtArgs>
    topic?: boolean | AIModule$topicArgs<ExtArgs>
  }

  export type $AIModulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AIModule"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      topic: Prisma.$TopicPayload<ExtArgs> | null
      learningPathItems: Prisma.$AIModuleLearningPathItemPayload<ExtArgs>[]
      quizAttempts: Prisma.$AIModuleQuizAttemptPayload<ExtArgs>[]
      ratings: Prisma.$AIModuleRatingPayload<ExtArgs>[]
      PracticeAttempts: Prisma.$PracticeAttemptPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      content: Prisma.JsonValue
      tags: string[]
      difficulty: string | null
      status: string
      createdAt: Date
      updatedAt: Date
      userId: string | null
      topicId: string | null
    }, ExtArgs["result"]["aIModule"]>
    composites: {}
  }

  type AIModuleGetPayload<S extends boolean | null | undefined | AIModuleDefaultArgs> = $Result.GetResult<Prisma.$AIModulePayload, S>

  type AIModuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AIModuleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AIModuleCountAggregateInputType | true
    }

  export interface AIModuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AIModule'], meta: { name: 'AIModule' } }
    /**
     * Find zero or one AIModule that matches the filter.
     * @param {AIModuleFindUniqueArgs} args - Arguments to find a AIModule
     * @example
     * // Get one AIModule
     * const aIModule = await prisma.aIModule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AIModuleFindUniqueArgs>(args: SelectSubset<T, AIModuleFindUniqueArgs<ExtArgs>>): Prisma__AIModuleClient<$Result.GetResult<Prisma.$AIModulePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one AIModule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AIModuleFindUniqueOrThrowArgs} args - Arguments to find a AIModule
     * @example
     * // Get one AIModule
     * const aIModule = await prisma.aIModule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AIModuleFindUniqueOrThrowArgs>(args: SelectSubset<T, AIModuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AIModuleClient<$Result.GetResult<Prisma.$AIModulePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first AIModule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIModuleFindFirstArgs} args - Arguments to find a AIModule
     * @example
     * // Get one AIModule
     * const aIModule = await prisma.aIModule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AIModuleFindFirstArgs>(args?: SelectSubset<T, AIModuleFindFirstArgs<ExtArgs>>): Prisma__AIModuleClient<$Result.GetResult<Prisma.$AIModulePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first AIModule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIModuleFindFirstOrThrowArgs} args - Arguments to find a AIModule
     * @example
     * // Get one AIModule
     * const aIModule = await prisma.aIModule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AIModuleFindFirstOrThrowArgs>(args?: SelectSubset<T, AIModuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__AIModuleClient<$Result.GetResult<Prisma.$AIModulePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more AIModules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIModuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AIModules
     * const aIModules = await prisma.aIModule.findMany()
     * 
     * // Get first 10 AIModules
     * const aIModules = await prisma.aIModule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aIModuleWithIdOnly = await prisma.aIModule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AIModuleFindManyArgs>(args?: SelectSubset<T, AIModuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIModulePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a AIModule.
     * @param {AIModuleCreateArgs} args - Arguments to create a AIModule.
     * @example
     * // Create one AIModule
     * const AIModule = await prisma.aIModule.create({
     *   data: {
     *     // ... data to create a AIModule
     *   }
     * })
     * 
     */
    create<T extends AIModuleCreateArgs>(args: SelectSubset<T, AIModuleCreateArgs<ExtArgs>>): Prisma__AIModuleClient<$Result.GetResult<Prisma.$AIModulePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many AIModules.
     * @param {AIModuleCreateManyArgs} args - Arguments to create many AIModules.
     * @example
     * // Create many AIModules
     * const aIModule = await prisma.aIModule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AIModuleCreateManyArgs>(args?: SelectSubset<T, AIModuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AIModules and returns the data saved in the database.
     * @param {AIModuleCreateManyAndReturnArgs} args - Arguments to create many AIModules.
     * @example
     * // Create many AIModules
     * const aIModule = await prisma.aIModule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AIModules and only return the `id`
     * const aIModuleWithIdOnly = await prisma.aIModule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AIModuleCreateManyAndReturnArgs>(args?: SelectSubset<T, AIModuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIModulePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a AIModule.
     * @param {AIModuleDeleteArgs} args - Arguments to delete one AIModule.
     * @example
     * // Delete one AIModule
     * const AIModule = await prisma.aIModule.delete({
     *   where: {
     *     // ... filter to delete one AIModule
     *   }
     * })
     * 
     */
    delete<T extends AIModuleDeleteArgs>(args: SelectSubset<T, AIModuleDeleteArgs<ExtArgs>>): Prisma__AIModuleClient<$Result.GetResult<Prisma.$AIModulePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one AIModule.
     * @param {AIModuleUpdateArgs} args - Arguments to update one AIModule.
     * @example
     * // Update one AIModule
     * const aIModule = await prisma.aIModule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AIModuleUpdateArgs>(args: SelectSubset<T, AIModuleUpdateArgs<ExtArgs>>): Prisma__AIModuleClient<$Result.GetResult<Prisma.$AIModulePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more AIModules.
     * @param {AIModuleDeleteManyArgs} args - Arguments to filter AIModules to delete.
     * @example
     * // Delete a few AIModules
     * const { count } = await prisma.aIModule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AIModuleDeleteManyArgs>(args?: SelectSubset<T, AIModuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIModules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIModuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AIModules
     * const aIModule = await prisma.aIModule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AIModuleUpdateManyArgs>(args: SelectSubset<T, AIModuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIModules and returns the data updated in the database.
     * @param {AIModuleUpdateManyAndReturnArgs} args - Arguments to update many AIModules.
     * @example
     * // Update many AIModules
     * const aIModule = await prisma.aIModule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AIModules and only return the `id`
     * const aIModuleWithIdOnly = await prisma.aIModule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AIModuleUpdateManyAndReturnArgs>(args: SelectSubset<T, AIModuleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIModulePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one AIModule.
     * @param {AIModuleUpsertArgs} args - Arguments to update or create a AIModule.
     * @example
     * // Update or create a AIModule
     * const aIModule = await prisma.aIModule.upsert({
     *   create: {
     *     // ... data to create a AIModule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AIModule we want to update
     *   }
     * })
     */
    upsert<T extends AIModuleUpsertArgs>(args: SelectSubset<T, AIModuleUpsertArgs<ExtArgs>>): Prisma__AIModuleClient<$Result.GetResult<Prisma.$AIModulePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of AIModules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIModuleCountArgs} args - Arguments to filter AIModules to count.
     * @example
     * // Count the number of AIModules
     * const count = await prisma.aIModule.count({
     *   where: {
     *     // ... the filter for the AIModules we want to count
     *   }
     * })
    **/
    count<T extends AIModuleCountArgs>(
      args?: Subset<T, AIModuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AIModuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AIModule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIModuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AIModuleAggregateArgs>(args: Subset<T, AIModuleAggregateArgs>): Prisma.PrismaPromise<GetAIModuleAggregateType<T>>

    /**
     * Group by AIModule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIModuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AIModuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AIModuleGroupByArgs['orderBy'] }
        : { orderBy?: AIModuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AIModuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAIModuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AIModule model
   */
  readonly fields: AIModuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AIModule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AIModuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends AIModule$userArgs<ExtArgs> = {}>(args?: Subset<T, AIModule$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    topic<T extends AIModule$topicArgs<ExtArgs> = {}>(args?: Subset<T, AIModule$topicArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    learningPathItems<T extends AIModule$learningPathItemsArgs<ExtArgs> = {}>(args?: Subset<T, AIModule$learningPathItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIModuleLearningPathItemPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    quizAttempts<T extends AIModule$quizAttemptsArgs<ExtArgs> = {}>(args?: Subset<T, AIModule$quizAttemptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIModuleQuizAttemptPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    ratings<T extends AIModule$ratingsArgs<ExtArgs> = {}>(args?: Subset<T, AIModule$ratingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIModuleRatingPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    PracticeAttempts<T extends AIModule$PracticeAttemptsArgs<ExtArgs> = {}>(args?: Subset<T, AIModule$PracticeAttemptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PracticeAttemptPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AIModule model
   */ 
  interface AIModuleFieldRefs {
    readonly id: FieldRef<"AIModule", 'String'>
    readonly title: FieldRef<"AIModule", 'String'>
    readonly description: FieldRef<"AIModule", 'String'>
    readonly content: FieldRef<"AIModule", 'Json'>
    readonly tags: FieldRef<"AIModule", 'String[]'>
    readonly difficulty: FieldRef<"AIModule", 'String'>
    readonly status: FieldRef<"AIModule", 'String'>
    readonly createdAt: FieldRef<"AIModule", 'DateTime'>
    readonly updatedAt: FieldRef<"AIModule", 'DateTime'>
    readonly userId: FieldRef<"AIModule", 'String'>
    readonly topicId: FieldRef<"AIModule", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AIModule findUnique
   */
  export type AIModuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModule
     */
    select?: AIModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIModule
     */
    omit?: AIModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModuleInclude<ExtArgs> | null
    /**
     * Filter, which AIModule to fetch.
     */
    where: AIModuleWhereUniqueInput
  }

  /**
   * AIModule findUniqueOrThrow
   */
  export type AIModuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModule
     */
    select?: AIModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIModule
     */
    omit?: AIModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModuleInclude<ExtArgs> | null
    /**
     * Filter, which AIModule to fetch.
     */
    where: AIModuleWhereUniqueInput
  }

  /**
   * AIModule findFirst
   */
  export type AIModuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModule
     */
    select?: AIModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIModule
     */
    omit?: AIModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModuleInclude<ExtArgs> | null
    /**
     * Filter, which AIModule to fetch.
     */
    where?: AIModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIModules to fetch.
     */
    orderBy?: AIModuleOrderByWithRelationInput | AIModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIModules.
     */
    cursor?: AIModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIModules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIModules.
     */
    distinct?: AIModuleScalarFieldEnum | AIModuleScalarFieldEnum[]
  }

  /**
   * AIModule findFirstOrThrow
   */
  export type AIModuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModule
     */
    select?: AIModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIModule
     */
    omit?: AIModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModuleInclude<ExtArgs> | null
    /**
     * Filter, which AIModule to fetch.
     */
    where?: AIModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIModules to fetch.
     */
    orderBy?: AIModuleOrderByWithRelationInput | AIModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIModules.
     */
    cursor?: AIModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIModules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIModules.
     */
    distinct?: AIModuleScalarFieldEnum | AIModuleScalarFieldEnum[]
  }

  /**
   * AIModule findMany
   */
  export type AIModuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModule
     */
    select?: AIModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIModule
     */
    omit?: AIModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModuleInclude<ExtArgs> | null
    /**
     * Filter, which AIModules to fetch.
     */
    where?: AIModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIModules to fetch.
     */
    orderBy?: AIModuleOrderByWithRelationInput | AIModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AIModules.
     */
    cursor?: AIModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIModules.
     */
    skip?: number
    distinct?: AIModuleScalarFieldEnum | AIModuleScalarFieldEnum[]
  }

  /**
   * AIModule create
   */
  export type AIModuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModule
     */
    select?: AIModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIModule
     */
    omit?: AIModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModuleInclude<ExtArgs> | null
    /**
     * The data needed to create a AIModule.
     */
    data: XOR<AIModuleCreateInput, AIModuleUncheckedCreateInput>
  }

  /**
   * AIModule createMany
   */
  export type AIModuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AIModules.
     */
    data: AIModuleCreateManyInput | AIModuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIModule createManyAndReturn
   */
  export type AIModuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModule
     */
    select?: AIModuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIModule
     */
    omit?: AIModuleOmit<ExtArgs> | null
    /**
     * The data used to create many AIModules.
     */
    data: AIModuleCreateManyInput | AIModuleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModuleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIModule update
   */
  export type AIModuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModule
     */
    select?: AIModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIModule
     */
    omit?: AIModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModuleInclude<ExtArgs> | null
    /**
     * The data needed to update a AIModule.
     */
    data: XOR<AIModuleUpdateInput, AIModuleUncheckedUpdateInput>
    /**
     * Choose, which AIModule to update.
     */
    where: AIModuleWhereUniqueInput
  }

  /**
   * AIModule updateMany
   */
  export type AIModuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AIModules.
     */
    data: XOR<AIModuleUpdateManyMutationInput, AIModuleUncheckedUpdateManyInput>
    /**
     * Filter which AIModules to update
     */
    where?: AIModuleWhereInput
    /**
     * Limit how many AIModules to update.
     */
    limit?: number
  }

  /**
   * AIModule updateManyAndReturn
   */
  export type AIModuleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModule
     */
    select?: AIModuleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIModule
     */
    omit?: AIModuleOmit<ExtArgs> | null
    /**
     * The data used to update AIModules.
     */
    data: XOR<AIModuleUpdateManyMutationInput, AIModuleUncheckedUpdateManyInput>
    /**
     * Filter which AIModules to update
     */
    where?: AIModuleWhereInput
    /**
     * Limit how many AIModules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModuleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIModule upsert
   */
  export type AIModuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModule
     */
    select?: AIModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIModule
     */
    omit?: AIModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModuleInclude<ExtArgs> | null
    /**
     * The filter to search for the AIModule to update in case it exists.
     */
    where: AIModuleWhereUniqueInput
    /**
     * In case the AIModule found by the `where` argument doesn't exist, create a new AIModule with this data.
     */
    create: XOR<AIModuleCreateInput, AIModuleUncheckedCreateInput>
    /**
     * In case the AIModule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AIModuleUpdateInput, AIModuleUncheckedUpdateInput>
  }

  /**
   * AIModule delete
   */
  export type AIModuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModule
     */
    select?: AIModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIModule
     */
    omit?: AIModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModuleInclude<ExtArgs> | null
    /**
     * Filter which AIModule to delete.
     */
    where: AIModuleWhereUniqueInput
  }

  /**
   * AIModule deleteMany
   */
  export type AIModuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIModules to delete
     */
    where?: AIModuleWhereInput
    /**
     * Limit how many AIModules to delete.
     */
    limit?: number
  }

  /**
   * AIModule.user
   */
  export type AIModule$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AIModule.topic
   */
  export type AIModule$topicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    where?: TopicWhereInput
  }

  /**
   * AIModule.learningPathItems
   */
  export type AIModule$learningPathItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModuleLearningPathItem
     */
    select?: AIModuleLearningPathItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIModuleLearningPathItem
     */
    omit?: AIModuleLearningPathItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModuleLearningPathItemInclude<ExtArgs> | null
    where?: AIModuleLearningPathItemWhereInput
    orderBy?: AIModuleLearningPathItemOrderByWithRelationInput | AIModuleLearningPathItemOrderByWithRelationInput[]
    cursor?: AIModuleLearningPathItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AIModuleLearningPathItemScalarFieldEnum | AIModuleLearningPathItemScalarFieldEnum[]
  }

  /**
   * AIModule.quizAttempts
   */
  export type AIModule$quizAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModuleQuizAttempt
     */
    select?: AIModuleQuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIModuleQuizAttempt
     */
    omit?: AIModuleQuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModuleQuizAttemptInclude<ExtArgs> | null
    where?: AIModuleQuizAttemptWhereInput
    orderBy?: AIModuleQuizAttemptOrderByWithRelationInput | AIModuleQuizAttemptOrderByWithRelationInput[]
    cursor?: AIModuleQuizAttemptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AIModuleQuizAttemptScalarFieldEnum | AIModuleQuizAttemptScalarFieldEnum[]
  }

  /**
   * AIModule.ratings
   */
  export type AIModule$ratingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModuleRating
     */
    select?: AIModuleRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIModuleRating
     */
    omit?: AIModuleRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModuleRatingInclude<ExtArgs> | null
    where?: AIModuleRatingWhereInput
    orderBy?: AIModuleRatingOrderByWithRelationInput | AIModuleRatingOrderByWithRelationInput[]
    cursor?: AIModuleRatingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AIModuleRatingScalarFieldEnum | AIModuleRatingScalarFieldEnum[]
  }

  /**
   * AIModule.PracticeAttempts
   */
  export type AIModule$PracticeAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticeAttempt
     */
    select?: PracticeAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PracticeAttempt
     */
    omit?: PracticeAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PracticeAttemptInclude<ExtArgs> | null
    where?: PracticeAttemptWhereInput
    orderBy?: PracticeAttemptOrderByWithRelationInput | PracticeAttemptOrderByWithRelationInput[]
    cursor?: PracticeAttemptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PracticeAttemptScalarFieldEnum | PracticeAttemptScalarFieldEnum[]
  }

  /**
   * AIModule without action
   */
  export type AIModuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModule
     */
    select?: AIModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIModule
     */
    omit?: AIModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModuleInclude<ExtArgs> | null
  }


  /**
   * Model AIModuleLearningPathItem
   */

  export type AggregateAIModuleLearningPathItem = {
    _count: AIModuleLearningPathItemCountAggregateOutputType | null
    _avg: AIModuleLearningPathItemAvgAggregateOutputType | null
    _sum: AIModuleLearningPathItemSumAggregateOutputType | null
    _min: AIModuleLearningPathItemMinAggregateOutputType | null
    _max: AIModuleLearningPathItemMaxAggregateOutputType | null
  }

  export type AIModuleLearningPathItemAvgAggregateOutputType = {
    order: number | null
    confidence: number | null
  }

  export type AIModuleLearningPathItemSumAggregateOutputType = {
    order: number | null
    confidence: number | null
  }

  export type AIModuleLearningPathItemMinAggregateOutputType = {
    id: string | null
    order: number | null
    learningPathId: string | null
    aiModuleId: string | null
    confidence: number | null
  }

  export type AIModuleLearningPathItemMaxAggregateOutputType = {
    id: string | null
    order: number | null
    learningPathId: string | null
    aiModuleId: string | null
    confidence: number | null
  }

  export type AIModuleLearningPathItemCountAggregateOutputType = {
    id: number
    order: number
    learningPathId: number
    aiModuleId: number
    confidence: number
    _all: number
  }


  export type AIModuleLearningPathItemAvgAggregateInputType = {
    order?: true
    confidence?: true
  }

  export type AIModuleLearningPathItemSumAggregateInputType = {
    order?: true
    confidence?: true
  }

  export type AIModuleLearningPathItemMinAggregateInputType = {
    id?: true
    order?: true
    learningPathId?: true
    aiModuleId?: true
    confidence?: true
  }

  export type AIModuleLearningPathItemMaxAggregateInputType = {
    id?: true
    order?: true
    learningPathId?: true
    aiModuleId?: true
    confidence?: true
  }

  export type AIModuleLearningPathItemCountAggregateInputType = {
    id?: true
    order?: true
    learningPathId?: true
    aiModuleId?: true
    confidence?: true
    _all?: true
  }

  export type AIModuleLearningPathItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIModuleLearningPathItem to aggregate.
     */
    where?: AIModuleLearningPathItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIModuleLearningPathItems to fetch.
     */
    orderBy?: AIModuleLearningPathItemOrderByWithRelationInput | AIModuleLearningPathItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AIModuleLearningPathItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIModuleLearningPathItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIModuleLearningPathItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AIModuleLearningPathItems
    **/
    _count?: true | AIModuleLearningPathItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AIModuleLearningPathItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AIModuleLearningPathItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AIModuleLearningPathItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AIModuleLearningPathItemMaxAggregateInputType
  }

  export type GetAIModuleLearningPathItemAggregateType<T extends AIModuleLearningPathItemAggregateArgs> = {
        [P in keyof T & keyof AggregateAIModuleLearningPathItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAIModuleLearningPathItem[P]>
      : GetScalarType<T[P], AggregateAIModuleLearningPathItem[P]>
  }




  export type AIModuleLearningPathItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIModuleLearningPathItemWhereInput
    orderBy?: AIModuleLearningPathItemOrderByWithAggregationInput | AIModuleLearningPathItemOrderByWithAggregationInput[]
    by: AIModuleLearningPathItemScalarFieldEnum[] | AIModuleLearningPathItemScalarFieldEnum
    having?: AIModuleLearningPathItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AIModuleLearningPathItemCountAggregateInputType | true
    _avg?: AIModuleLearningPathItemAvgAggregateInputType
    _sum?: AIModuleLearningPathItemSumAggregateInputType
    _min?: AIModuleLearningPathItemMinAggregateInputType
    _max?: AIModuleLearningPathItemMaxAggregateInputType
  }

  export type AIModuleLearningPathItemGroupByOutputType = {
    id: string
    order: number
    learningPathId: string
    aiModuleId: string
    confidence: number
    _count: AIModuleLearningPathItemCountAggregateOutputType | null
    _avg: AIModuleLearningPathItemAvgAggregateOutputType | null
    _sum: AIModuleLearningPathItemSumAggregateOutputType | null
    _min: AIModuleLearningPathItemMinAggregateOutputType | null
    _max: AIModuleLearningPathItemMaxAggregateOutputType | null
  }

  type GetAIModuleLearningPathItemGroupByPayload<T extends AIModuleLearningPathItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AIModuleLearningPathItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AIModuleLearningPathItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AIModuleLearningPathItemGroupByOutputType[P]>
            : GetScalarType<T[P], AIModuleLearningPathItemGroupByOutputType[P]>
        }
      >
    >


  export type AIModuleLearningPathItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    order?: boolean
    learningPathId?: boolean
    aiModuleId?: boolean
    confidence?: boolean
    learningPath?: boolean | LearningPathDefaultArgs<ExtArgs>
    aiModule?: boolean | AIModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIModuleLearningPathItem"]>

  export type AIModuleLearningPathItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    order?: boolean
    learningPathId?: boolean
    aiModuleId?: boolean
    confidence?: boolean
    learningPath?: boolean | LearningPathDefaultArgs<ExtArgs>
    aiModule?: boolean | AIModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIModuleLearningPathItem"]>

  export type AIModuleLearningPathItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    order?: boolean
    learningPathId?: boolean
    aiModuleId?: boolean
    confidence?: boolean
    learningPath?: boolean | LearningPathDefaultArgs<ExtArgs>
    aiModule?: boolean | AIModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIModuleLearningPathItem"]>

  export type AIModuleLearningPathItemSelectScalar = {
    id?: boolean
    order?: boolean
    learningPathId?: boolean
    aiModuleId?: boolean
    confidence?: boolean
  }

  export type AIModuleLearningPathItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "order" | "learningPathId" | "aiModuleId" | "confidence", ExtArgs["result"]["aIModuleLearningPathItem"]>
  export type AIModuleLearningPathItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    learningPath?: boolean | LearningPathDefaultArgs<ExtArgs>
    aiModule?: boolean | AIModuleDefaultArgs<ExtArgs>
  }
  export type AIModuleLearningPathItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    learningPath?: boolean | LearningPathDefaultArgs<ExtArgs>
    aiModule?: boolean | AIModuleDefaultArgs<ExtArgs>
  }
  export type AIModuleLearningPathItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    learningPath?: boolean | LearningPathDefaultArgs<ExtArgs>
    aiModule?: boolean | AIModuleDefaultArgs<ExtArgs>
  }

  export type $AIModuleLearningPathItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AIModuleLearningPathItem"
    objects: {
      learningPath: Prisma.$LearningPathPayload<ExtArgs>
      aiModule: Prisma.$AIModulePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      order: number
      learningPathId: string
      aiModuleId: string
      confidence: number
    }, ExtArgs["result"]["aIModuleLearningPathItem"]>
    composites: {}
  }

  type AIModuleLearningPathItemGetPayload<S extends boolean | null | undefined | AIModuleLearningPathItemDefaultArgs> = $Result.GetResult<Prisma.$AIModuleLearningPathItemPayload, S>

  type AIModuleLearningPathItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AIModuleLearningPathItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AIModuleLearningPathItemCountAggregateInputType | true
    }

  export interface AIModuleLearningPathItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AIModuleLearningPathItem'], meta: { name: 'AIModuleLearningPathItem' } }
    /**
     * Find zero or one AIModuleLearningPathItem that matches the filter.
     * @param {AIModuleLearningPathItemFindUniqueArgs} args - Arguments to find a AIModuleLearningPathItem
     * @example
     * // Get one AIModuleLearningPathItem
     * const aIModuleLearningPathItem = await prisma.aIModuleLearningPathItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AIModuleLearningPathItemFindUniqueArgs>(args: SelectSubset<T, AIModuleLearningPathItemFindUniqueArgs<ExtArgs>>): Prisma__AIModuleLearningPathItemClient<$Result.GetResult<Prisma.$AIModuleLearningPathItemPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one AIModuleLearningPathItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AIModuleLearningPathItemFindUniqueOrThrowArgs} args - Arguments to find a AIModuleLearningPathItem
     * @example
     * // Get one AIModuleLearningPathItem
     * const aIModuleLearningPathItem = await prisma.aIModuleLearningPathItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AIModuleLearningPathItemFindUniqueOrThrowArgs>(args: SelectSubset<T, AIModuleLearningPathItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AIModuleLearningPathItemClient<$Result.GetResult<Prisma.$AIModuleLearningPathItemPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first AIModuleLearningPathItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIModuleLearningPathItemFindFirstArgs} args - Arguments to find a AIModuleLearningPathItem
     * @example
     * // Get one AIModuleLearningPathItem
     * const aIModuleLearningPathItem = await prisma.aIModuleLearningPathItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AIModuleLearningPathItemFindFirstArgs>(args?: SelectSubset<T, AIModuleLearningPathItemFindFirstArgs<ExtArgs>>): Prisma__AIModuleLearningPathItemClient<$Result.GetResult<Prisma.$AIModuleLearningPathItemPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first AIModuleLearningPathItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIModuleLearningPathItemFindFirstOrThrowArgs} args - Arguments to find a AIModuleLearningPathItem
     * @example
     * // Get one AIModuleLearningPathItem
     * const aIModuleLearningPathItem = await prisma.aIModuleLearningPathItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AIModuleLearningPathItemFindFirstOrThrowArgs>(args?: SelectSubset<T, AIModuleLearningPathItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__AIModuleLearningPathItemClient<$Result.GetResult<Prisma.$AIModuleLearningPathItemPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more AIModuleLearningPathItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIModuleLearningPathItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AIModuleLearningPathItems
     * const aIModuleLearningPathItems = await prisma.aIModuleLearningPathItem.findMany()
     * 
     * // Get first 10 AIModuleLearningPathItems
     * const aIModuleLearningPathItems = await prisma.aIModuleLearningPathItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aIModuleLearningPathItemWithIdOnly = await prisma.aIModuleLearningPathItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AIModuleLearningPathItemFindManyArgs>(args?: SelectSubset<T, AIModuleLearningPathItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIModuleLearningPathItemPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a AIModuleLearningPathItem.
     * @param {AIModuleLearningPathItemCreateArgs} args - Arguments to create a AIModuleLearningPathItem.
     * @example
     * // Create one AIModuleLearningPathItem
     * const AIModuleLearningPathItem = await prisma.aIModuleLearningPathItem.create({
     *   data: {
     *     // ... data to create a AIModuleLearningPathItem
     *   }
     * })
     * 
     */
    create<T extends AIModuleLearningPathItemCreateArgs>(args: SelectSubset<T, AIModuleLearningPathItemCreateArgs<ExtArgs>>): Prisma__AIModuleLearningPathItemClient<$Result.GetResult<Prisma.$AIModuleLearningPathItemPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many AIModuleLearningPathItems.
     * @param {AIModuleLearningPathItemCreateManyArgs} args - Arguments to create many AIModuleLearningPathItems.
     * @example
     * // Create many AIModuleLearningPathItems
     * const aIModuleLearningPathItem = await prisma.aIModuleLearningPathItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AIModuleLearningPathItemCreateManyArgs>(args?: SelectSubset<T, AIModuleLearningPathItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AIModuleLearningPathItems and returns the data saved in the database.
     * @param {AIModuleLearningPathItemCreateManyAndReturnArgs} args - Arguments to create many AIModuleLearningPathItems.
     * @example
     * // Create many AIModuleLearningPathItems
     * const aIModuleLearningPathItem = await prisma.aIModuleLearningPathItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AIModuleLearningPathItems and only return the `id`
     * const aIModuleLearningPathItemWithIdOnly = await prisma.aIModuleLearningPathItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AIModuleLearningPathItemCreateManyAndReturnArgs>(args?: SelectSubset<T, AIModuleLearningPathItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIModuleLearningPathItemPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a AIModuleLearningPathItem.
     * @param {AIModuleLearningPathItemDeleteArgs} args - Arguments to delete one AIModuleLearningPathItem.
     * @example
     * // Delete one AIModuleLearningPathItem
     * const AIModuleLearningPathItem = await prisma.aIModuleLearningPathItem.delete({
     *   where: {
     *     // ... filter to delete one AIModuleLearningPathItem
     *   }
     * })
     * 
     */
    delete<T extends AIModuleLearningPathItemDeleteArgs>(args: SelectSubset<T, AIModuleLearningPathItemDeleteArgs<ExtArgs>>): Prisma__AIModuleLearningPathItemClient<$Result.GetResult<Prisma.$AIModuleLearningPathItemPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one AIModuleLearningPathItem.
     * @param {AIModuleLearningPathItemUpdateArgs} args - Arguments to update one AIModuleLearningPathItem.
     * @example
     * // Update one AIModuleLearningPathItem
     * const aIModuleLearningPathItem = await prisma.aIModuleLearningPathItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AIModuleLearningPathItemUpdateArgs>(args: SelectSubset<T, AIModuleLearningPathItemUpdateArgs<ExtArgs>>): Prisma__AIModuleLearningPathItemClient<$Result.GetResult<Prisma.$AIModuleLearningPathItemPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more AIModuleLearningPathItems.
     * @param {AIModuleLearningPathItemDeleteManyArgs} args - Arguments to filter AIModuleLearningPathItems to delete.
     * @example
     * // Delete a few AIModuleLearningPathItems
     * const { count } = await prisma.aIModuleLearningPathItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AIModuleLearningPathItemDeleteManyArgs>(args?: SelectSubset<T, AIModuleLearningPathItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIModuleLearningPathItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIModuleLearningPathItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AIModuleLearningPathItems
     * const aIModuleLearningPathItem = await prisma.aIModuleLearningPathItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AIModuleLearningPathItemUpdateManyArgs>(args: SelectSubset<T, AIModuleLearningPathItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIModuleLearningPathItems and returns the data updated in the database.
     * @param {AIModuleLearningPathItemUpdateManyAndReturnArgs} args - Arguments to update many AIModuleLearningPathItems.
     * @example
     * // Update many AIModuleLearningPathItems
     * const aIModuleLearningPathItem = await prisma.aIModuleLearningPathItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AIModuleLearningPathItems and only return the `id`
     * const aIModuleLearningPathItemWithIdOnly = await prisma.aIModuleLearningPathItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AIModuleLearningPathItemUpdateManyAndReturnArgs>(args: SelectSubset<T, AIModuleLearningPathItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIModuleLearningPathItemPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one AIModuleLearningPathItem.
     * @param {AIModuleLearningPathItemUpsertArgs} args - Arguments to update or create a AIModuleLearningPathItem.
     * @example
     * // Update or create a AIModuleLearningPathItem
     * const aIModuleLearningPathItem = await prisma.aIModuleLearningPathItem.upsert({
     *   create: {
     *     // ... data to create a AIModuleLearningPathItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AIModuleLearningPathItem we want to update
     *   }
     * })
     */
    upsert<T extends AIModuleLearningPathItemUpsertArgs>(args: SelectSubset<T, AIModuleLearningPathItemUpsertArgs<ExtArgs>>): Prisma__AIModuleLearningPathItemClient<$Result.GetResult<Prisma.$AIModuleLearningPathItemPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of AIModuleLearningPathItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIModuleLearningPathItemCountArgs} args - Arguments to filter AIModuleLearningPathItems to count.
     * @example
     * // Count the number of AIModuleLearningPathItems
     * const count = await prisma.aIModuleLearningPathItem.count({
     *   where: {
     *     // ... the filter for the AIModuleLearningPathItems we want to count
     *   }
     * })
    **/
    count<T extends AIModuleLearningPathItemCountArgs>(
      args?: Subset<T, AIModuleLearningPathItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AIModuleLearningPathItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AIModuleLearningPathItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIModuleLearningPathItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AIModuleLearningPathItemAggregateArgs>(args: Subset<T, AIModuleLearningPathItemAggregateArgs>): Prisma.PrismaPromise<GetAIModuleLearningPathItemAggregateType<T>>

    /**
     * Group by AIModuleLearningPathItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIModuleLearningPathItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AIModuleLearningPathItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AIModuleLearningPathItemGroupByArgs['orderBy'] }
        : { orderBy?: AIModuleLearningPathItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AIModuleLearningPathItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAIModuleLearningPathItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AIModuleLearningPathItem model
   */
  readonly fields: AIModuleLearningPathItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AIModuleLearningPathItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AIModuleLearningPathItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    learningPath<T extends LearningPathDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LearningPathDefaultArgs<ExtArgs>>): Prisma__LearningPathClient<$Result.GetResult<Prisma.$LearningPathPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    aiModule<T extends AIModuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AIModuleDefaultArgs<ExtArgs>>): Prisma__AIModuleClient<$Result.GetResult<Prisma.$AIModulePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AIModuleLearningPathItem model
   */ 
  interface AIModuleLearningPathItemFieldRefs {
    readonly id: FieldRef<"AIModuleLearningPathItem", 'String'>
    readonly order: FieldRef<"AIModuleLearningPathItem", 'Int'>
    readonly learningPathId: FieldRef<"AIModuleLearningPathItem", 'String'>
    readonly aiModuleId: FieldRef<"AIModuleLearningPathItem", 'String'>
    readonly confidence: FieldRef<"AIModuleLearningPathItem", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * AIModuleLearningPathItem findUnique
   */
  export type AIModuleLearningPathItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModuleLearningPathItem
     */
    select?: AIModuleLearningPathItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIModuleLearningPathItem
     */
    omit?: AIModuleLearningPathItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModuleLearningPathItemInclude<ExtArgs> | null
    /**
     * Filter, which AIModuleLearningPathItem to fetch.
     */
    where: AIModuleLearningPathItemWhereUniqueInput
  }

  /**
   * AIModuleLearningPathItem findUniqueOrThrow
   */
  export type AIModuleLearningPathItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModuleLearningPathItem
     */
    select?: AIModuleLearningPathItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIModuleLearningPathItem
     */
    omit?: AIModuleLearningPathItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModuleLearningPathItemInclude<ExtArgs> | null
    /**
     * Filter, which AIModuleLearningPathItem to fetch.
     */
    where: AIModuleLearningPathItemWhereUniqueInput
  }

  /**
   * AIModuleLearningPathItem findFirst
   */
  export type AIModuleLearningPathItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModuleLearningPathItem
     */
    select?: AIModuleLearningPathItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIModuleLearningPathItem
     */
    omit?: AIModuleLearningPathItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModuleLearningPathItemInclude<ExtArgs> | null
    /**
     * Filter, which AIModuleLearningPathItem to fetch.
     */
    where?: AIModuleLearningPathItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIModuleLearningPathItems to fetch.
     */
    orderBy?: AIModuleLearningPathItemOrderByWithRelationInput | AIModuleLearningPathItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIModuleLearningPathItems.
     */
    cursor?: AIModuleLearningPathItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIModuleLearningPathItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIModuleLearningPathItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIModuleLearningPathItems.
     */
    distinct?: AIModuleLearningPathItemScalarFieldEnum | AIModuleLearningPathItemScalarFieldEnum[]
  }

  /**
   * AIModuleLearningPathItem findFirstOrThrow
   */
  export type AIModuleLearningPathItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModuleLearningPathItem
     */
    select?: AIModuleLearningPathItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIModuleLearningPathItem
     */
    omit?: AIModuleLearningPathItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModuleLearningPathItemInclude<ExtArgs> | null
    /**
     * Filter, which AIModuleLearningPathItem to fetch.
     */
    where?: AIModuleLearningPathItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIModuleLearningPathItems to fetch.
     */
    orderBy?: AIModuleLearningPathItemOrderByWithRelationInput | AIModuleLearningPathItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIModuleLearningPathItems.
     */
    cursor?: AIModuleLearningPathItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIModuleLearningPathItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIModuleLearningPathItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIModuleLearningPathItems.
     */
    distinct?: AIModuleLearningPathItemScalarFieldEnum | AIModuleLearningPathItemScalarFieldEnum[]
  }

  /**
   * AIModuleLearningPathItem findMany
   */
  export type AIModuleLearningPathItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModuleLearningPathItem
     */
    select?: AIModuleLearningPathItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIModuleLearningPathItem
     */
    omit?: AIModuleLearningPathItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModuleLearningPathItemInclude<ExtArgs> | null
    /**
     * Filter, which AIModuleLearningPathItems to fetch.
     */
    where?: AIModuleLearningPathItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIModuleLearningPathItems to fetch.
     */
    orderBy?: AIModuleLearningPathItemOrderByWithRelationInput | AIModuleLearningPathItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AIModuleLearningPathItems.
     */
    cursor?: AIModuleLearningPathItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIModuleLearningPathItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIModuleLearningPathItems.
     */
    skip?: number
    distinct?: AIModuleLearningPathItemScalarFieldEnum | AIModuleLearningPathItemScalarFieldEnum[]
  }

  /**
   * AIModuleLearningPathItem create
   */
  export type AIModuleLearningPathItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModuleLearningPathItem
     */
    select?: AIModuleLearningPathItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIModuleLearningPathItem
     */
    omit?: AIModuleLearningPathItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModuleLearningPathItemInclude<ExtArgs> | null
    /**
     * The data needed to create a AIModuleLearningPathItem.
     */
    data: XOR<AIModuleLearningPathItemCreateInput, AIModuleLearningPathItemUncheckedCreateInput>
  }

  /**
   * AIModuleLearningPathItem createMany
   */
  export type AIModuleLearningPathItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AIModuleLearningPathItems.
     */
    data: AIModuleLearningPathItemCreateManyInput | AIModuleLearningPathItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIModuleLearningPathItem createManyAndReturn
   */
  export type AIModuleLearningPathItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModuleLearningPathItem
     */
    select?: AIModuleLearningPathItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIModuleLearningPathItem
     */
    omit?: AIModuleLearningPathItemOmit<ExtArgs> | null
    /**
     * The data used to create many AIModuleLearningPathItems.
     */
    data: AIModuleLearningPathItemCreateManyInput | AIModuleLearningPathItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModuleLearningPathItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIModuleLearningPathItem update
   */
  export type AIModuleLearningPathItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModuleLearningPathItem
     */
    select?: AIModuleLearningPathItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIModuleLearningPathItem
     */
    omit?: AIModuleLearningPathItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModuleLearningPathItemInclude<ExtArgs> | null
    /**
     * The data needed to update a AIModuleLearningPathItem.
     */
    data: XOR<AIModuleLearningPathItemUpdateInput, AIModuleLearningPathItemUncheckedUpdateInput>
    /**
     * Choose, which AIModuleLearningPathItem to update.
     */
    where: AIModuleLearningPathItemWhereUniqueInput
  }

  /**
   * AIModuleLearningPathItem updateMany
   */
  export type AIModuleLearningPathItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AIModuleLearningPathItems.
     */
    data: XOR<AIModuleLearningPathItemUpdateManyMutationInput, AIModuleLearningPathItemUncheckedUpdateManyInput>
    /**
     * Filter which AIModuleLearningPathItems to update
     */
    where?: AIModuleLearningPathItemWhereInput
    /**
     * Limit how many AIModuleLearningPathItems to update.
     */
    limit?: number
  }

  /**
   * AIModuleLearningPathItem updateManyAndReturn
   */
  export type AIModuleLearningPathItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModuleLearningPathItem
     */
    select?: AIModuleLearningPathItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIModuleLearningPathItem
     */
    omit?: AIModuleLearningPathItemOmit<ExtArgs> | null
    /**
     * The data used to update AIModuleLearningPathItems.
     */
    data: XOR<AIModuleLearningPathItemUpdateManyMutationInput, AIModuleLearningPathItemUncheckedUpdateManyInput>
    /**
     * Filter which AIModuleLearningPathItems to update
     */
    where?: AIModuleLearningPathItemWhereInput
    /**
     * Limit how many AIModuleLearningPathItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModuleLearningPathItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIModuleLearningPathItem upsert
   */
  export type AIModuleLearningPathItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModuleLearningPathItem
     */
    select?: AIModuleLearningPathItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIModuleLearningPathItem
     */
    omit?: AIModuleLearningPathItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModuleLearningPathItemInclude<ExtArgs> | null
    /**
     * The filter to search for the AIModuleLearningPathItem to update in case it exists.
     */
    where: AIModuleLearningPathItemWhereUniqueInput
    /**
     * In case the AIModuleLearningPathItem found by the `where` argument doesn't exist, create a new AIModuleLearningPathItem with this data.
     */
    create: XOR<AIModuleLearningPathItemCreateInput, AIModuleLearningPathItemUncheckedCreateInput>
    /**
     * In case the AIModuleLearningPathItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AIModuleLearningPathItemUpdateInput, AIModuleLearningPathItemUncheckedUpdateInput>
  }

  /**
   * AIModuleLearningPathItem delete
   */
  export type AIModuleLearningPathItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModuleLearningPathItem
     */
    select?: AIModuleLearningPathItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIModuleLearningPathItem
     */
    omit?: AIModuleLearningPathItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModuleLearningPathItemInclude<ExtArgs> | null
    /**
     * Filter which AIModuleLearningPathItem to delete.
     */
    where: AIModuleLearningPathItemWhereUniqueInput
  }

  /**
   * AIModuleLearningPathItem deleteMany
   */
  export type AIModuleLearningPathItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIModuleLearningPathItems to delete
     */
    where?: AIModuleLearningPathItemWhereInput
    /**
     * Limit how many AIModuleLearningPathItems to delete.
     */
    limit?: number
  }

  /**
   * AIModuleLearningPathItem without action
   */
  export type AIModuleLearningPathItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModuleLearningPathItem
     */
    select?: AIModuleLearningPathItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIModuleLearningPathItem
     */
    omit?: AIModuleLearningPathItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModuleLearningPathItemInclude<ExtArgs> | null
  }


  /**
   * Model AIModuleQuizAttempt
   */

  export type AggregateAIModuleQuizAttempt = {
    _count: AIModuleQuizAttemptCountAggregateOutputType | null
    _avg: AIModuleQuizAttemptAvgAggregateOutputType | null
    _sum: AIModuleQuizAttemptSumAggregateOutputType | null
    _min: AIModuleQuizAttemptMinAggregateOutputType | null
    _max: AIModuleQuizAttemptMaxAggregateOutputType | null
  }

  export type AIModuleQuizAttemptAvgAggregateOutputType = {
    score: number | null
  }

  export type AIModuleQuizAttemptSumAggregateOutputType = {
    score: number | null
  }

  export type AIModuleQuizAttemptMinAggregateOutputType = {
    id: string | null
    userId: string | null
    aiModuleId: string | null
    topicId: string | null
    score: number | null
    startedAt: Date | null
    completedAt: Date | null
  }

  export type AIModuleQuizAttemptMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    aiModuleId: string | null
    topicId: string | null
    score: number | null
    startedAt: Date | null
    completedAt: Date | null
  }

  export type AIModuleQuizAttemptCountAggregateOutputType = {
    id: number
    userId: number
    aiModuleId: number
    topicId: number
    score: number
    startedAt: number
    completedAt: number
    answers: number
    _all: number
  }


  export type AIModuleQuizAttemptAvgAggregateInputType = {
    score?: true
  }

  export type AIModuleQuizAttemptSumAggregateInputType = {
    score?: true
  }

  export type AIModuleQuizAttemptMinAggregateInputType = {
    id?: true
    userId?: true
    aiModuleId?: true
    topicId?: true
    score?: true
    startedAt?: true
    completedAt?: true
  }

  export type AIModuleQuizAttemptMaxAggregateInputType = {
    id?: true
    userId?: true
    aiModuleId?: true
    topicId?: true
    score?: true
    startedAt?: true
    completedAt?: true
  }

  export type AIModuleQuizAttemptCountAggregateInputType = {
    id?: true
    userId?: true
    aiModuleId?: true
    topicId?: true
    score?: true
    startedAt?: true
    completedAt?: true
    answers?: true
    _all?: true
  }

  export type AIModuleQuizAttemptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIModuleQuizAttempt to aggregate.
     */
    where?: AIModuleQuizAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIModuleQuizAttempts to fetch.
     */
    orderBy?: AIModuleQuizAttemptOrderByWithRelationInput | AIModuleQuizAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AIModuleQuizAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIModuleQuizAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIModuleQuizAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AIModuleQuizAttempts
    **/
    _count?: true | AIModuleQuizAttemptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AIModuleQuizAttemptAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AIModuleQuizAttemptSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AIModuleQuizAttemptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AIModuleQuizAttemptMaxAggregateInputType
  }

  export type GetAIModuleQuizAttemptAggregateType<T extends AIModuleQuizAttemptAggregateArgs> = {
        [P in keyof T & keyof AggregateAIModuleQuizAttempt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAIModuleQuizAttempt[P]>
      : GetScalarType<T[P], AggregateAIModuleQuizAttempt[P]>
  }




  export type AIModuleQuizAttemptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIModuleQuizAttemptWhereInput
    orderBy?: AIModuleQuizAttemptOrderByWithAggregationInput | AIModuleQuizAttemptOrderByWithAggregationInput[]
    by: AIModuleQuizAttemptScalarFieldEnum[] | AIModuleQuizAttemptScalarFieldEnum
    having?: AIModuleQuizAttemptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AIModuleQuizAttemptCountAggregateInputType | true
    _avg?: AIModuleQuizAttemptAvgAggregateInputType
    _sum?: AIModuleQuizAttemptSumAggregateInputType
    _min?: AIModuleQuizAttemptMinAggregateInputType
    _max?: AIModuleQuizAttemptMaxAggregateInputType
  }

  export type AIModuleQuizAttemptGroupByOutputType = {
    id: string
    userId: string
    aiModuleId: string
    topicId: string
    score: number
    startedAt: Date
    completedAt: Date | null
    answers: JsonValue
    _count: AIModuleQuizAttemptCountAggregateOutputType | null
    _avg: AIModuleQuizAttemptAvgAggregateOutputType | null
    _sum: AIModuleQuizAttemptSumAggregateOutputType | null
    _min: AIModuleQuizAttemptMinAggregateOutputType | null
    _max: AIModuleQuizAttemptMaxAggregateOutputType | null
  }

  type GetAIModuleQuizAttemptGroupByPayload<T extends AIModuleQuizAttemptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AIModuleQuizAttemptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AIModuleQuizAttemptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AIModuleQuizAttemptGroupByOutputType[P]>
            : GetScalarType<T[P], AIModuleQuizAttemptGroupByOutputType[P]>
        }
      >
    >


  export type AIModuleQuizAttemptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    aiModuleId?: boolean
    topicId?: boolean
    score?: boolean
    startedAt?: boolean
    completedAt?: boolean
    answers?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    aiModule?: boolean | AIModuleDefaultArgs<ExtArgs>
    topic?: boolean | TopicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIModuleQuizAttempt"]>

  export type AIModuleQuizAttemptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    aiModuleId?: boolean
    topicId?: boolean
    score?: boolean
    startedAt?: boolean
    completedAt?: boolean
    answers?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    aiModule?: boolean | AIModuleDefaultArgs<ExtArgs>
    topic?: boolean | TopicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIModuleQuizAttempt"]>

  export type AIModuleQuizAttemptSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    aiModuleId?: boolean
    topicId?: boolean
    score?: boolean
    startedAt?: boolean
    completedAt?: boolean
    answers?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    aiModule?: boolean | AIModuleDefaultArgs<ExtArgs>
    topic?: boolean | TopicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIModuleQuizAttempt"]>

  export type AIModuleQuizAttemptSelectScalar = {
    id?: boolean
    userId?: boolean
    aiModuleId?: boolean
    topicId?: boolean
    score?: boolean
    startedAt?: boolean
    completedAt?: boolean
    answers?: boolean
  }

  export type AIModuleQuizAttemptOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "aiModuleId" | "topicId" | "score" | "startedAt" | "completedAt" | "answers", ExtArgs["result"]["aIModuleQuizAttempt"]>
  export type AIModuleQuizAttemptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    aiModule?: boolean | AIModuleDefaultArgs<ExtArgs>
    topic?: boolean | TopicDefaultArgs<ExtArgs>
  }
  export type AIModuleQuizAttemptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    aiModule?: boolean | AIModuleDefaultArgs<ExtArgs>
    topic?: boolean | TopicDefaultArgs<ExtArgs>
  }
  export type AIModuleQuizAttemptIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    aiModule?: boolean | AIModuleDefaultArgs<ExtArgs>
    topic?: boolean | TopicDefaultArgs<ExtArgs>
  }

  export type $AIModuleQuizAttemptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AIModuleQuizAttempt"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      aiModule: Prisma.$AIModulePayload<ExtArgs>
      topic: Prisma.$TopicPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      aiModuleId: string
      topicId: string
      score: number
      startedAt: Date
      completedAt: Date | null
      answers: Prisma.JsonValue
    }, ExtArgs["result"]["aIModuleQuizAttempt"]>
    composites: {}
  }

  type AIModuleQuizAttemptGetPayload<S extends boolean | null | undefined | AIModuleQuizAttemptDefaultArgs> = $Result.GetResult<Prisma.$AIModuleQuizAttemptPayload, S>

  type AIModuleQuizAttemptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AIModuleQuizAttemptFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AIModuleQuizAttemptCountAggregateInputType | true
    }

  export interface AIModuleQuizAttemptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AIModuleQuizAttempt'], meta: { name: 'AIModuleQuizAttempt' } }
    /**
     * Find zero or one AIModuleQuizAttempt that matches the filter.
     * @param {AIModuleQuizAttemptFindUniqueArgs} args - Arguments to find a AIModuleQuizAttempt
     * @example
     * // Get one AIModuleQuizAttempt
     * const aIModuleQuizAttempt = await prisma.aIModuleQuizAttempt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AIModuleQuizAttemptFindUniqueArgs>(args: SelectSubset<T, AIModuleQuizAttemptFindUniqueArgs<ExtArgs>>): Prisma__AIModuleQuizAttemptClient<$Result.GetResult<Prisma.$AIModuleQuizAttemptPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one AIModuleQuizAttempt that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AIModuleQuizAttemptFindUniqueOrThrowArgs} args - Arguments to find a AIModuleQuizAttempt
     * @example
     * // Get one AIModuleQuizAttempt
     * const aIModuleQuizAttempt = await prisma.aIModuleQuizAttempt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AIModuleQuizAttemptFindUniqueOrThrowArgs>(args: SelectSubset<T, AIModuleQuizAttemptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AIModuleQuizAttemptClient<$Result.GetResult<Prisma.$AIModuleQuizAttemptPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first AIModuleQuizAttempt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIModuleQuizAttemptFindFirstArgs} args - Arguments to find a AIModuleQuizAttempt
     * @example
     * // Get one AIModuleQuizAttempt
     * const aIModuleQuizAttempt = await prisma.aIModuleQuizAttempt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AIModuleQuizAttemptFindFirstArgs>(args?: SelectSubset<T, AIModuleQuizAttemptFindFirstArgs<ExtArgs>>): Prisma__AIModuleQuizAttemptClient<$Result.GetResult<Prisma.$AIModuleQuizAttemptPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first AIModuleQuizAttempt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIModuleQuizAttemptFindFirstOrThrowArgs} args - Arguments to find a AIModuleQuizAttempt
     * @example
     * // Get one AIModuleQuizAttempt
     * const aIModuleQuizAttempt = await prisma.aIModuleQuizAttempt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AIModuleQuizAttemptFindFirstOrThrowArgs>(args?: SelectSubset<T, AIModuleQuizAttemptFindFirstOrThrowArgs<ExtArgs>>): Prisma__AIModuleQuizAttemptClient<$Result.GetResult<Prisma.$AIModuleQuizAttemptPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more AIModuleQuizAttempts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIModuleQuizAttemptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AIModuleQuizAttempts
     * const aIModuleQuizAttempts = await prisma.aIModuleQuizAttempt.findMany()
     * 
     * // Get first 10 AIModuleQuizAttempts
     * const aIModuleQuizAttempts = await prisma.aIModuleQuizAttempt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aIModuleQuizAttemptWithIdOnly = await prisma.aIModuleQuizAttempt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AIModuleQuizAttemptFindManyArgs>(args?: SelectSubset<T, AIModuleQuizAttemptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIModuleQuizAttemptPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a AIModuleQuizAttempt.
     * @param {AIModuleQuizAttemptCreateArgs} args - Arguments to create a AIModuleQuizAttempt.
     * @example
     * // Create one AIModuleQuizAttempt
     * const AIModuleQuizAttempt = await prisma.aIModuleQuizAttempt.create({
     *   data: {
     *     // ... data to create a AIModuleQuizAttempt
     *   }
     * })
     * 
     */
    create<T extends AIModuleQuizAttemptCreateArgs>(args: SelectSubset<T, AIModuleQuizAttemptCreateArgs<ExtArgs>>): Prisma__AIModuleQuizAttemptClient<$Result.GetResult<Prisma.$AIModuleQuizAttemptPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many AIModuleQuizAttempts.
     * @param {AIModuleQuizAttemptCreateManyArgs} args - Arguments to create many AIModuleQuizAttempts.
     * @example
     * // Create many AIModuleQuizAttempts
     * const aIModuleQuizAttempt = await prisma.aIModuleQuizAttempt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AIModuleQuizAttemptCreateManyArgs>(args?: SelectSubset<T, AIModuleQuizAttemptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AIModuleQuizAttempts and returns the data saved in the database.
     * @param {AIModuleQuizAttemptCreateManyAndReturnArgs} args - Arguments to create many AIModuleQuizAttempts.
     * @example
     * // Create many AIModuleQuizAttempts
     * const aIModuleQuizAttempt = await prisma.aIModuleQuizAttempt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AIModuleQuizAttempts and only return the `id`
     * const aIModuleQuizAttemptWithIdOnly = await prisma.aIModuleQuizAttempt.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AIModuleQuizAttemptCreateManyAndReturnArgs>(args?: SelectSubset<T, AIModuleQuizAttemptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIModuleQuizAttemptPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a AIModuleQuizAttempt.
     * @param {AIModuleQuizAttemptDeleteArgs} args - Arguments to delete one AIModuleQuizAttempt.
     * @example
     * // Delete one AIModuleQuizAttempt
     * const AIModuleQuizAttempt = await prisma.aIModuleQuizAttempt.delete({
     *   where: {
     *     // ... filter to delete one AIModuleQuizAttempt
     *   }
     * })
     * 
     */
    delete<T extends AIModuleQuizAttemptDeleteArgs>(args: SelectSubset<T, AIModuleQuizAttemptDeleteArgs<ExtArgs>>): Prisma__AIModuleQuizAttemptClient<$Result.GetResult<Prisma.$AIModuleQuizAttemptPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one AIModuleQuizAttempt.
     * @param {AIModuleQuizAttemptUpdateArgs} args - Arguments to update one AIModuleQuizAttempt.
     * @example
     * // Update one AIModuleQuizAttempt
     * const aIModuleQuizAttempt = await prisma.aIModuleQuizAttempt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AIModuleQuizAttemptUpdateArgs>(args: SelectSubset<T, AIModuleQuizAttemptUpdateArgs<ExtArgs>>): Prisma__AIModuleQuizAttemptClient<$Result.GetResult<Prisma.$AIModuleQuizAttemptPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more AIModuleQuizAttempts.
     * @param {AIModuleQuizAttemptDeleteManyArgs} args - Arguments to filter AIModuleQuizAttempts to delete.
     * @example
     * // Delete a few AIModuleQuizAttempts
     * const { count } = await prisma.aIModuleQuizAttempt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AIModuleQuizAttemptDeleteManyArgs>(args?: SelectSubset<T, AIModuleQuizAttemptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIModuleQuizAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIModuleQuizAttemptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AIModuleQuizAttempts
     * const aIModuleQuizAttempt = await prisma.aIModuleQuizAttempt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AIModuleQuizAttemptUpdateManyArgs>(args: SelectSubset<T, AIModuleQuizAttemptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIModuleQuizAttempts and returns the data updated in the database.
     * @param {AIModuleQuizAttemptUpdateManyAndReturnArgs} args - Arguments to update many AIModuleQuizAttempts.
     * @example
     * // Update many AIModuleQuizAttempts
     * const aIModuleQuizAttempt = await prisma.aIModuleQuizAttempt.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AIModuleQuizAttempts and only return the `id`
     * const aIModuleQuizAttemptWithIdOnly = await prisma.aIModuleQuizAttempt.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AIModuleQuizAttemptUpdateManyAndReturnArgs>(args: SelectSubset<T, AIModuleQuizAttemptUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIModuleQuizAttemptPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one AIModuleQuizAttempt.
     * @param {AIModuleQuizAttemptUpsertArgs} args - Arguments to update or create a AIModuleQuizAttempt.
     * @example
     * // Update or create a AIModuleQuizAttempt
     * const aIModuleQuizAttempt = await prisma.aIModuleQuizAttempt.upsert({
     *   create: {
     *     // ... data to create a AIModuleQuizAttempt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AIModuleQuizAttempt we want to update
     *   }
     * })
     */
    upsert<T extends AIModuleQuizAttemptUpsertArgs>(args: SelectSubset<T, AIModuleQuizAttemptUpsertArgs<ExtArgs>>): Prisma__AIModuleQuizAttemptClient<$Result.GetResult<Prisma.$AIModuleQuizAttemptPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of AIModuleQuizAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIModuleQuizAttemptCountArgs} args - Arguments to filter AIModuleQuizAttempts to count.
     * @example
     * // Count the number of AIModuleQuizAttempts
     * const count = await prisma.aIModuleQuizAttempt.count({
     *   where: {
     *     // ... the filter for the AIModuleQuizAttempts we want to count
     *   }
     * })
    **/
    count<T extends AIModuleQuizAttemptCountArgs>(
      args?: Subset<T, AIModuleQuizAttemptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AIModuleQuizAttemptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AIModuleQuizAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIModuleQuizAttemptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AIModuleQuizAttemptAggregateArgs>(args: Subset<T, AIModuleQuizAttemptAggregateArgs>): Prisma.PrismaPromise<GetAIModuleQuizAttemptAggregateType<T>>

    /**
     * Group by AIModuleQuizAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIModuleQuizAttemptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AIModuleQuizAttemptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AIModuleQuizAttemptGroupByArgs['orderBy'] }
        : { orderBy?: AIModuleQuizAttemptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AIModuleQuizAttemptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAIModuleQuizAttemptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AIModuleQuizAttempt model
   */
  readonly fields: AIModuleQuizAttemptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AIModuleQuizAttempt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AIModuleQuizAttemptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    aiModule<T extends AIModuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AIModuleDefaultArgs<ExtArgs>>): Prisma__AIModuleClient<$Result.GetResult<Prisma.$AIModulePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    topic<T extends TopicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TopicDefaultArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AIModuleQuizAttempt model
   */ 
  interface AIModuleQuizAttemptFieldRefs {
    readonly id: FieldRef<"AIModuleQuizAttempt", 'String'>
    readonly userId: FieldRef<"AIModuleQuizAttempt", 'String'>
    readonly aiModuleId: FieldRef<"AIModuleQuizAttempt", 'String'>
    readonly topicId: FieldRef<"AIModuleQuizAttempt", 'String'>
    readonly score: FieldRef<"AIModuleQuizAttempt", 'Float'>
    readonly startedAt: FieldRef<"AIModuleQuizAttempt", 'DateTime'>
    readonly completedAt: FieldRef<"AIModuleQuizAttempt", 'DateTime'>
    readonly answers: FieldRef<"AIModuleQuizAttempt", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * AIModuleQuizAttempt findUnique
   */
  export type AIModuleQuizAttemptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModuleQuizAttempt
     */
    select?: AIModuleQuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIModuleQuizAttempt
     */
    omit?: AIModuleQuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModuleQuizAttemptInclude<ExtArgs> | null
    /**
     * Filter, which AIModuleQuizAttempt to fetch.
     */
    where: AIModuleQuizAttemptWhereUniqueInput
  }

  /**
   * AIModuleQuizAttempt findUniqueOrThrow
   */
  export type AIModuleQuizAttemptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModuleQuizAttempt
     */
    select?: AIModuleQuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIModuleQuizAttempt
     */
    omit?: AIModuleQuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModuleQuizAttemptInclude<ExtArgs> | null
    /**
     * Filter, which AIModuleQuizAttempt to fetch.
     */
    where: AIModuleQuizAttemptWhereUniqueInput
  }

  /**
   * AIModuleQuizAttempt findFirst
   */
  export type AIModuleQuizAttemptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModuleQuizAttempt
     */
    select?: AIModuleQuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIModuleQuizAttempt
     */
    omit?: AIModuleQuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModuleQuizAttemptInclude<ExtArgs> | null
    /**
     * Filter, which AIModuleQuizAttempt to fetch.
     */
    where?: AIModuleQuizAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIModuleQuizAttempts to fetch.
     */
    orderBy?: AIModuleQuizAttemptOrderByWithRelationInput | AIModuleQuizAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIModuleQuizAttempts.
     */
    cursor?: AIModuleQuizAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIModuleQuizAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIModuleQuizAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIModuleQuizAttempts.
     */
    distinct?: AIModuleQuizAttemptScalarFieldEnum | AIModuleQuizAttemptScalarFieldEnum[]
  }

  /**
   * AIModuleQuizAttempt findFirstOrThrow
   */
  export type AIModuleQuizAttemptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModuleQuizAttempt
     */
    select?: AIModuleQuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIModuleQuizAttempt
     */
    omit?: AIModuleQuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModuleQuizAttemptInclude<ExtArgs> | null
    /**
     * Filter, which AIModuleQuizAttempt to fetch.
     */
    where?: AIModuleQuizAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIModuleQuizAttempts to fetch.
     */
    orderBy?: AIModuleQuizAttemptOrderByWithRelationInput | AIModuleQuizAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIModuleQuizAttempts.
     */
    cursor?: AIModuleQuizAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIModuleQuizAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIModuleQuizAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIModuleQuizAttempts.
     */
    distinct?: AIModuleQuizAttemptScalarFieldEnum | AIModuleQuizAttemptScalarFieldEnum[]
  }

  /**
   * AIModuleQuizAttempt findMany
   */
  export type AIModuleQuizAttemptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModuleQuizAttempt
     */
    select?: AIModuleQuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIModuleQuizAttempt
     */
    omit?: AIModuleQuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModuleQuizAttemptInclude<ExtArgs> | null
    /**
     * Filter, which AIModuleQuizAttempts to fetch.
     */
    where?: AIModuleQuizAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIModuleQuizAttempts to fetch.
     */
    orderBy?: AIModuleQuizAttemptOrderByWithRelationInput | AIModuleQuizAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AIModuleQuizAttempts.
     */
    cursor?: AIModuleQuizAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIModuleQuizAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIModuleQuizAttempts.
     */
    skip?: number
    distinct?: AIModuleQuizAttemptScalarFieldEnum | AIModuleQuizAttemptScalarFieldEnum[]
  }

  /**
   * AIModuleQuizAttempt create
   */
  export type AIModuleQuizAttemptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModuleQuizAttempt
     */
    select?: AIModuleQuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIModuleQuizAttempt
     */
    omit?: AIModuleQuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModuleQuizAttemptInclude<ExtArgs> | null
    /**
     * The data needed to create a AIModuleQuizAttempt.
     */
    data: XOR<AIModuleQuizAttemptCreateInput, AIModuleQuizAttemptUncheckedCreateInput>
  }

  /**
   * AIModuleQuizAttempt createMany
   */
  export type AIModuleQuizAttemptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AIModuleQuizAttempts.
     */
    data: AIModuleQuizAttemptCreateManyInput | AIModuleQuizAttemptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIModuleQuizAttempt createManyAndReturn
   */
  export type AIModuleQuizAttemptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModuleQuizAttempt
     */
    select?: AIModuleQuizAttemptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIModuleQuizAttempt
     */
    omit?: AIModuleQuizAttemptOmit<ExtArgs> | null
    /**
     * The data used to create many AIModuleQuizAttempts.
     */
    data: AIModuleQuizAttemptCreateManyInput | AIModuleQuizAttemptCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModuleQuizAttemptIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIModuleQuizAttempt update
   */
  export type AIModuleQuizAttemptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModuleQuizAttempt
     */
    select?: AIModuleQuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIModuleQuizAttempt
     */
    omit?: AIModuleQuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModuleQuizAttemptInclude<ExtArgs> | null
    /**
     * The data needed to update a AIModuleQuizAttempt.
     */
    data: XOR<AIModuleQuizAttemptUpdateInput, AIModuleQuizAttemptUncheckedUpdateInput>
    /**
     * Choose, which AIModuleQuizAttempt to update.
     */
    where: AIModuleQuizAttemptWhereUniqueInput
  }

  /**
   * AIModuleQuizAttempt updateMany
   */
  export type AIModuleQuizAttemptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AIModuleQuizAttempts.
     */
    data: XOR<AIModuleQuizAttemptUpdateManyMutationInput, AIModuleQuizAttemptUncheckedUpdateManyInput>
    /**
     * Filter which AIModuleQuizAttempts to update
     */
    where?: AIModuleQuizAttemptWhereInput
    /**
     * Limit how many AIModuleQuizAttempts to update.
     */
    limit?: number
  }

  /**
   * AIModuleQuizAttempt updateManyAndReturn
   */
  export type AIModuleQuizAttemptUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModuleQuizAttempt
     */
    select?: AIModuleQuizAttemptSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIModuleQuizAttempt
     */
    omit?: AIModuleQuizAttemptOmit<ExtArgs> | null
    /**
     * The data used to update AIModuleQuizAttempts.
     */
    data: XOR<AIModuleQuizAttemptUpdateManyMutationInput, AIModuleQuizAttemptUncheckedUpdateManyInput>
    /**
     * Filter which AIModuleQuizAttempts to update
     */
    where?: AIModuleQuizAttemptWhereInput
    /**
     * Limit how many AIModuleQuizAttempts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModuleQuizAttemptIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIModuleQuizAttempt upsert
   */
  export type AIModuleQuizAttemptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModuleQuizAttempt
     */
    select?: AIModuleQuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIModuleQuizAttempt
     */
    omit?: AIModuleQuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModuleQuizAttemptInclude<ExtArgs> | null
    /**
     * The filter to search for the AIModuleQuizAttempt to update in case it exists.
     */
    where: AIModuleQuizAttemptWhereUniqueInput
    /**
     * In case the AIModuleQuizAttempt found by the `where` argument doesn't exist, create a new AIModuleQuizAttempt with this data.
     */
    create: XOR<AIModuleQuizAttemptCreateInput, AIModuleQuizAttemptUncheckedCreateInput>
    /**
     * In case the AIModuleQuizAttempt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AIModuleQuizAttemptUpdateInput, AIModuleQuizAttemptUncheckedUpdateInput>
  }

  /**
   * AIModuleQuizAttempt delete
   */
  export type AIModuleQuizAttemptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModuleQuizAttempt
     */
    select?: AIModuleQuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIModuleQuizAttempt
     */
    omit?: AIModuleQuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModuleQuizAttemptInclude<ExtArgs> | null
    /**
     * Filter which AIModuleQuizAttempt to delete.
     */
    where: AIModuleQuizAttemptWhereUniqueInput
  }

  /**
   * AIModuleQuizAttempt deleteMany
   */
  export type AIModuleQuizAttemptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIModuleQuizAttempts to delete
     */
    where?: AIModuleQuizAttemptWhereInput
    /**
     * Limit how many AIModuleQuizAttempts to delete.
     */
    limit?: number
  }

  /**
   * AIModuleQuizAttempt without action
   */
  export type AIModuleQuizAttemptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModuleQuizAttempt
     */
    select?: AIModuleQuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIModuleQuizAttempt
     */
    omit?: AIModuleQuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModuleQuizAttemptInclude<ExtArgs> | null
  }


  /**
   * Model AIModuleRating
   */

  export type AggregateAIModuleRating = {
    _count: AIModuleRatingCountAggregateOutputType | null
    _avg: AIModuleRatingAvgAggregateOutputType | null
    _sum: AIModuleRatingSumAggregateOutputType | null
    _min: AIModuleRatingMinAggregateOutputType | null
    _max: AIModuleRatingMaxAggregateOutputType | null
  }

  export type AIModuleRatingAvgAggregateOutputType = {
    rating: number | null
  }

  export type AIModuleRatingSumAggregateOutputType = {
    rating: number | null
  }

  export type AIModuleRatingMinAggregateOutputType = {
    id: string | null
    userId: string | null
    aiModuleId: string | null
    topicId: string | null
    rating: number | null
    feedback: string | null
    createdAt: Date | null
  }

  export type AIModuleRatingMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    aiModuleId: string | null
    topicId: string | null
    rating: number | null
    feedback: string | null
    createdAt: Date | null
  }

  export type AIModuleRatingCountAggregateOutputType = {
    id: number
    userId: number
    aiModuleId: number
    topicId: number
    rating: number
    feedback: number
    createdAt: number
    _all: number
  }


  export type AIModuleRatingAvgAggregateInputType = {
    rating?: true
  }

  export type AIModuleRatingSumAggregateInputType = {
    rating?: true
  }

  export type AIModuleRatingMinAggregateInputType = {
    id?: true
    userId?: true
    aiModuleId?: true
    topicId?: true
    rating?: true
    feedback?: true
    createdAt?: true
  }

  export type AIModuleRatingMaxAggregateInputType = {
    id?: true
    userId?: true
    aiModuleId?: true
    topicId?: true
    rating?: true
    feedback?: true
    createdAt?: true
  }

  export type AIModuleRatingCountAggregateInputType = {
    id?: true
    userId?: true
    aiModuleId?: true
    topicId?: true
    rating?: true
    feedback?: true
    createdAt?: true
    _all?: true
  }

  export type AIModuleRatingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIModuleRating to aggregate.
     */
    where?: AIModuleRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIModuleRatings to fetch.
     */
    orderBy?: AIModuleRatingOrderByWithRelationInput | AIModuleRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AIModuleRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIModuleRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIModuleRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AIModuleRatings
    **/
    _count?: true | AIModuleRatingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AIModuleRatingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AIModuleRatingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AIModuleRatingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AIModuleRatingMaxAggregateInputType
  }

  export type GetAIModuleRatingAggregateType<T extends AIModuleRatingAggregateArgs> = {
        [P in keyof T & keyof AggregateAIModuleRating]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAIModuleRating[P]>
      : GetScalarType<T[P], AggregateAIModuleRating[P]>
  }




  export type AIModuleRatingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIModuleRatingWhereInput
    orderBy?: AIModuleRatingOrderByWithAggregationInput | AIModuleRatingOrderByWithAggregationInput[]
    by: AIModuleRatingScalarFieldEnum[] | AIModuleRatingScalarFieldEnum
    having?: AIModuleRatingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AIModuleRatingCountAggregateInputType | true
    _avg?: AIModuleRatingAvgAggregateInputType
    _sum?: AIModuleRatingSumAggregateInputType
    _min?: AIModuleRatingMinAggregateInputType
    _max?: AIModuleRatingMaxAggregateInputType
  }

  export type AIModuleRatingGroupByOutputType = {
    id: string
    userId: string
    aiModuleId: string
    topicId: string
    rating: number
    feedback: string | null
    createdAt: Date
    _count: AIModuleRatingCountAggregateOutputType | null
    _avg: AIModuleRatingAvgAggregateOutputType | null
    _sum: AIModuleRatingSumAggregateOutputType | null
    _min: AIModuleRatingMinAggregateOutputType | null
    _max: AIModuleRatingMaxAggregateOutputType | null
  }

  type GetAIModuleRatingGroupByPayload<T extends AIModuleRatingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AIModuleRatingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AIModuleRatingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AIModuleRatingGroupByOutputType[P]>
            : GetScalarType<T[P], AIModuleRatingGroupByOutputType[P]>
        }
      >
    >


  export type AIModuleRatingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    aiModuleId?: boolean
    topicId?: boolean
    rating?: boolean
    feedback?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    aiModule?: boolean | AIModuleDefaultArgs<ExtArgs>
    topic?: boolean | TopicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIModuleRating"]>

  export type AIModuleRatingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    aiModuleId?: boolean
    topicId?: boolean
    rating?: boolean
    feedback?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    aiModule?: boolean | AIModuleDefaultArgs<ExtArgs>
    topic?: boolean | TopicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIModuleRating"]>

  export type AIModuleRatingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    aiModuleId?: boolean
    topicId?: boolean
    rating?: boolean
    feedback?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    aiModule?: boolean | AIModuleDefaultArgs<ExtArgs>
    topic?: boolean | TopicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIModuleRating"]>

  export type AIModuleRatingSelectScalar = {
    id?: boolean
    userId?: boolean
    aiModuleId?: boolean
    topicId?: boolean
    rating?: boolean
    feedback?: boolean
    createdAt?: boolean
  }

  export type AIModuleRatingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "aiModuleId" | "topicId" | "rating" | "feedback" | "createdAt", ExtArgs["result"]["aIModuleRating"]>
  export type AIModuleRatingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    aiModule?: boolean | AIModuleDefaultArgs<ExtArgs>
    topic?: boolean | TopicDefaultArgs<ExtArgs>
  }
  export type AIModuleRatingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    aiModule?: boolean | AIModuleDefaultArgs<ExtArgs>
    topic?: boolean | TopicDefaultArgs<ExtArgs>
  }
  export type AIModuleRatingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    aiModule?: boolean | AIModuleDefaultArgs<ExtArgs>
    topic?: boolean | TopicDefaultArgs<ExtArgs>
  }

  export type $AIModuleRatingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AIModuleRating"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      aiModule: Prisma.$AIModulePayload<ExtArgs>
      topic: Prisma.$TopicPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      aiModuleId: string
      topicId: string
      rating: number
      feedback: string | null
      createdAt: Date
    }, ExtArgs["result"]["aIModuleRating"]>
    composites: {}
  }

  type AIModuleRatingGetPayload<S extends boolean | null | undefined | AIModuleRatingDefaultArgs> = $Result.GetResult<Prisma.$AIModuleRatingPayload, S>

  type AIModuleRatingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AIModuleRatingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AIModuleRatingCountAggregateInputType | true
    }

  export interface AIModuleRatingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AIModuleRating'], meta: { name: 'AIModuleRating' } }
    /**
     * Find zero or one AIModuleRating that matches the filter.
     * @param {AIModuleRatingFindUniqueArgs} args - Arguments to find a AIModuleRating
     * @example
     * // Get one AIModuleRating
     * const aIModuleRating = await prisma.aIModuleRating.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AIModuleRatingFindUniqueArgs>(args: SelectSubset<T, AIModuleRatingFindUniqueArgs<ExtArgs>>): Prisma__AIModuleRatingClient<$Result.GetResult<Prisma.$AIModuleRatingPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one AIModuleRating that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AIModuleRatingFindUniqueOrThrowArgs} args - Arguments to find a AIModuleRating
     * @example
     * // Get one AIModuleRating
     * const aIModuleRating = await prisma.aIModuleRating.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AIModuleRatingFindUniqueOrThrowArgs>(args: SelectSubset<T, AIModuleRatingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AIModuleRatingClient<$Result.GetResult<Prisma.$AIModuleRatingPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first AIModuleRating that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIModuleRatingFindFirstArgs} args - Arguments to find a AIModuleRating
     * @example
     * // Get one AIModuleRating
     * const aIModuleRating = await prisma.aIModuleRating.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AIModuleRatingFindFirstArgs>(args?: SelectSubset<T, AIModuleRatingFindFirstArgs<ExtArgs>>): Prisma__AIModuleRatingClient<$Result.GetResult<Prisma.$AIModuleRatingPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first AIModuleRating that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIModuleRatingFindFirstOrThrowArgs} args - Arguments to find a AIModuleRating
     * @example
     * // Get one AIModuleRating
     * const aIModuleRating = await prisma.aIModuleRating.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AIModuleRatingFindFirstOrThrowArgs>(args?: SelectSubset<T, AIModuleRatingFindFirstOrThrowArgs<ExtArgs>>): Prisma__AIModuleRatingClient<$Result.GetResult<Prisma.$AIModuleRatingPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more AIModuleRatings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIModuleRatingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AIModuleRatings
     * const aIModuleRatings = await prisma.aIModuleRating.findMany()
     * 
     * // Get first 10 AIModuleRatings
     * const aIModuleRatings = await prisma.aIModuleRating.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aIModuleRatingWithIdOnly = await prisma.aIModuleRating.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AIModuleRatingFindManyArgs>(args?: SelectSubset<T, AIModuleRatingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIModuleRatingPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a AIModuleRating.
     * @param {AIModuleRatingCreateArgs} args - Arguments to create a AIModuleRating.
     * @example
     * // Create one AIModuleRating
     * const AIModuleRating = await prisma.aIModuleRating.create({
     *   data: {
     *     // ... data to create a AIModuleRating
     *   }
     * })
     * 
     */
    create<T extends AIModuleRatingCreateArgs>(args: SelectSubset<T, AIModuleRatingCreateArgs<ExtArgs>>): Prisma__AIModuleRatingClient<$Result.GetResult<Prisma.$AIModuleRatingPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many AIModuleRatings.
     * @param {AIModuleRatingCreateManyArgs} args - Arguments to create many AIModuleRatings.
     * @example
     * // Create many AIModuleRatings
     * const aIModuleRating = await prisma.aIModuleRating.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AIModuleRatingCreateManyArgs>(args?: SelectSubset<T, AIModuleRatingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AIModuleRatings and returns the data saved in the database.
     * @param {AIModuleRatingCreateManyAndReturnArgs} args - Arguments to create many AIModuleRatings.
     * @example
     * // Create many AIModuleRatings
     * const aIModuleRating = await prisma.aIModuleRating.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AIModuleRatings and only return the `id`
     * const aIModuleRatingWithIdOnly = await prisma.aIModuleRating.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AIModuleRatingCreateManyAndReturnArgs>(args?: SelectSubset<T, AIModuleRatingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIModuleRatingPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a AIModuleRating.
     * @param {AIModuleRatingDeleteArgs} args - Arguments to delete one AIModuleRating.
     * @example
     * // Delete one AIModuleRating
     * const AIModuleRating = await prisma.aIModuleRating.delete({
     *   where: {
     *     // ... filter to delete one AIModuleRating
     *   }
     * })
     * 
     */
    delete<T extends AIModuleRatingDeleteArgs>(args: SelectSubset<T, AIModuleRatingDeleteArgs<ExtArgs>>): Prisma__AIModuleRatingClient<$Result.GetResult<Prisma.$AIModuleRatingPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one AIModuleRating.
     * @param {AIModuleRatingUpdateArgs} args - Arguments to update one AIModuleRating.
     * @example
     * // Update one AIModuleRating
     * const aIModuleRating = await prisma.aIModuleRating.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AIModuleRatingUpdateArgs>(args: SelectSubset<T, AIModuleRatingUpdateArgs<ExtArgs>>): Prisma__AIModuleRatingClient<$Result.GetResult<Prisma.$AIModuleRatingPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more AIModuleRatings.
     * @param {AIModuleRatingDeleteManyArgs} args - Arguments to filter AIModuleRatings to delete.
     * @example
     * // Delete a few AIModuleRatings
     * const { count } = await prisma.aIModuleRating.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AIModuleRatingDeleteManyArgs>(args?: SelectSubset<T, AIModuleRatingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIModuleRatings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIModuleRatingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AIModuleRatings
     * const aIModuleRating = await prisma.aIModuleRating.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AIModuleRatingUpdateManyArgs>(args: SelectSubset<T, AIModuleRatingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIModuleRatings and returns the data updated in the database.
     * @param {AIModuleRatingUpdateManyAndReturnArgs} args - Arguments to update many AIModuleRatings.
     * @example
     * // Update many AIModuleRatings
     * const aIModuleRating = await prisma.aIModuleRating.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AIModuleRatings and only return the `id`
     * const aIModuleRatingWithIdOnly = await prisma.aIModuleRating.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AIModuleRatingUpdateManyAndReturnArgs>(args: SelectSubset<T, AIModuleRatingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIModuleRatingPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one AIModuleRating.
     * @param {AIModuleRatingUpsertArgs} args - Arguments to update or create a AIModuleRating.
     * @example
     * // Update or create a AIModuleRating
     * const aIModuleRating = await prisma.aIModuleRating.upsert({
     *   create: {
     *     // ... data to create a AIModuleRating
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AIModuleRating we want to update
     *   }
     * })
     */
    upsert<T extends AIModuleRatingUpsertArgs>(args: SelectSubset<T, AIModuleRatingUpsertArgs<ExtArgs>>): Prisma__AIModuleRatingClient<$Result.GetResult<Prisma.$AIModuleRatingPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of AIModuleRatings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIModuleRatingCountArgs} args - Arguments to filter AIModuleRatings to count.
     * @example
     * // Count the number of AIModuleRatings
     * const count = await prisma.aIModuleRating.count({
     *   where: {
     *     // ... the filter for the AIModuleRatings we want to count
     *   }
     * })
    **/
    count<T extends AIModuleRatingCountArgs>(
      args?: Subset<T, AIModuleRatingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AIModuleRatingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AIModuleRating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIModuleRatingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AIModuleRatingAggregateArgs>(args: Subset<T, AIModuleRatingAggregateArgs>): Prisma.PrismaPromise<GetAIModuleRatingAggregateType<T>>

    /**
     * Group by AIModuleRating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIModuleRatingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AIModuleRatingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AIModuleRatingGroupByArgs['orderBy'] }
        : { orderBy?: AIModuleRatingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AIModuleRatingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAIModuleRatingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AIModuleRating model
   */
  readonly fields: AIModuleRatingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AIModuleRating.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AIModuleRatingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    aiModule<T extends AIModuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AIModuleDefaultArgs<ExtArgs>>): Prisma__AIModuleClient<$Result.GetResult<Prisma.$AIModulePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    topic<T extends TopicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TopicDefaultArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AIModuleRating model
   */ 
  interface AIModuleRatingFieldRefs {
    readonly id: FieldRef<"AIModuleRating", 'String'>
    readonly userId: FieldRef<"AIModuleRating", 'String'>
    readonly aiModuleId: FieldRef<"AIModuleRating", 'String'>
    readonly topicId: FieldRef<"AIModuleRating", 'String'>
    readonly rating: FieldRef<"AIModuleRating", 'Int'>
    readonly feedback: FieldRef<"AIModuleRating", 'String'>
    readonly createdAt: FieldRef<"AIModuleRating", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AIModuleRating findUnique
   */
  export type AIModuleRatingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModuleRating
     */
    select?: AIModuleRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIModuleRating
     */
    omit?: AIModuleRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModuleRatingInclude<ExtArgs> | null
    /**
     * Filter, which AIModuleRating to fetch.
     */
    where: AIModuleRatingWhereUniqueInput
  }

  /**
   * AIModuleRating findUniqueOrThrow
   */
  export type AIModuleRatingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModuleRating
     */
    select?: AIModuleRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIModuleRating
     */
    omit?: AIModuleRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModuleRatingInclude<ExtArgs> | null
    /**
     * Filter, which AIModuleRating to fetch.
     */
    where: AIModuleRatingWhereUniqueInput
  }

  /**
   * AIModuleRating findFirst
   */
  export type AIModuleRatingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModuleRating
     */
    select?: AIModuleRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIModuleRating
     */
    omit?: AIModuleRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModuleRatingInclude<ExtArgs> | null
    /**
     * Filter, which AIModuleRating to fetch.
     */
    where?: AIModuleRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIModuleRatings to fetch.
     */
    orderBy?: AIModuleRatingOrderByWithRelationInput | AIModuleRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIModuleRatings.
     */
    cursor?: AIModuleRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIModuleRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIModuleRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIModuleRatings.
     */
    distinct?: AIModuleRatingScalarFieldEnum | AIModuleRatingScalarFieldEnum[]
  }

  /**
   * AIModuleRating findFirstOrThrow
   */
  export type AIModuleRatingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModuleRating
     */
    select?: AIModuleRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIModuleRating
     */
    omit?: AIModuleRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModuleRatingInclude<ExtArgs> | null
    /**
     * Filter, which AIModuleRating to fetch.
     */
    where?: AIModuleRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIModuleRatings to fetch.
     */
    orderBy?: AIModuleRatingOrderByWithRelationInput | AIModuleRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIModuleRatings.
     */
    cursor?: AIModuleRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIModuleRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIModuleRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIModuleRatings.
     */
    distinct?: AIModuleRatingScalarFieldEnum | AIModuleRatingScalarFieldEnum[]
  }

  /**
   * AIModuleRating findMany
   */
  export type AIModuleRatingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModuleRating
     */
    select?: AIModuleRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIModuleRating
     */
    omit?: AIModuleRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModuleRatingInclude<ExtArgs> | null
    /**
     * Filter, which AIModuleRatings to fetch.
     */
    where?: AIModuleRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIModuleRatings to fetch.
     */
    orderBy?: AIModuleRatingOrderByWithRelationInput | AIModuleRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AIModuleRatings.
     */
    cursor?: AIModuleRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIModuleRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIModuleRatings.
     */
    skip?: number
    distinct?: AIModuleRatingScalarFieldEnum | AIModuleRatingScalarFieldEnum[]
  }

  /**
   * AIModuleRating create
   */
  export type AIModuleRatingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModuleRating
     */
    select?: AIModuleRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIModuleRating
     */
    omit?: AIModuleRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModuleRatingInclude<ExtArgs> | null
    /**
     * The data needed to create a AIModuleRating.
     */
    data: XOR<AIModuleRatingCreateInput, AIModuleRatingUncheckedCreateInput>
  }

  /**
   * AIModuleRating createMany
   */
  export type AIModuleRatingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AIModuleRatings.
     */
    data: AIModuleRatingCreateManyInput | AIModuleRatingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIModuleRating createManyAndReturn
   */
  export type AIModuleRatingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModuleRating
     */
    select?: AIModuleRatingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIModuleRating
     */
    omit?: AIModuleRatingOmit<ExtArgs> | null
    /**
     * The data used to create many AIModuleRatings.
     */
    data: AIModuleRatingCreateManyInput | AIModuleRatingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModuleRatingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIModuleRating update
   */
  export type AIModuleRatingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModuleRating
     */
    select?: AIModuleRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIModuleRating
     */
    omit?: AIModuleRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModuleRatingInclude<ExtArgs> | null
    /**
     * The data needed to update a AIModuleRating.
     */
    data: XOR<AIModuleRatingUpdateInput, AIModuleRatingUncheckedUpdateInput>
    /**
     * Choose, which AIModuleRating to update.
     */
    where: AIModuleRatingWhereUniqueInput
  }

  /**
   * AIModuleRating updateMany
   */
  export type AIModuleRatingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AIModuleRatings.
     */
    data: XOR<AIModuleRatingUpdateManyMutationInput, AIModuleRatingUncheckedUpdateManyInput>
    /**
     * Filter which AIModuleRatings to update
     */
    where?: AIModuleRatingWhereInput
    /**
     * Limit how many AIModuleRatings to update.
     */
    limit?: number
  }

  /**
   * AIModuleRating updateManyAndReturn
   */
  export type AIModuleRatingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModuleRating
     */
    select?: AIModuleRatingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIModuleRating
     */
    omit?: AIModuleRatingOmit<ExtArgs> | null
    /**
     * The data used to update AIModuleRatings.
     */
    data: XOR<AIModuleRatingUpdateManyMutationInput, AIModuleRatingUncheckedUpdateManyInput>
    /**
     * Filter which AIModuleRatings to update
     */
    where?: AIModuleRatingWhereInput
    /**
     * Limit how many AIModuleRatings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModuleRatingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIModuleRating upsert
   */
  export type AIModuleRatingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModuleRating
     */
    select?: AIModuleRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIModuleRating
     */
    omit?: AIModuleRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModuleRatingInclude<ExtArgs> | null
    /**
     * The filter to search for the AIModuleRating to update in case it exists.
     */
    where: AIModuleRatingWhereUniqueInput
    /**
     * In case the AIModuleRating found by the `where` argument doesn't exist, create a new AIModuleRating with this data.
     */
    create: XOR<AIModuleRatingCreateInput, AIModuleRatingUncheckedCreateInput>
    /**
     * In case the AIModuleRating was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AIModuleRatingUpdateInput, AIModuleRatingUncheckedUpdateInput>
  }

  /**
   * AIModuleRating delete
   */
  export type AIModuleRatingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModuleRating
     */
    select?: AIModuleRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIModuleRating
     */
    omit?: AIModuleRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModuleRatingInclude<ExtArgs> | null
    /**
     * Filter which AIModuleRating to delete.
     */
    where: AIModuleRatingWhereUniqueInput
  }

  /**
   * AIModuleRating deleteMany
   */
  export type AIModuleRatingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIModuleRatings to delete
     */
    where?: AIModuleRatingWhereInput
    /**
     * Limit how many AIModuleRatings to delete.
     */
    limit?: number
  }

  /**
   * AIModuleRating without action
   */
  export type AIModuleRatingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModuleRating
     */
    select?: AIModuleRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIModuleRating
     */
    omit?: AIModuleRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModuleRatingInclude<ExtArgs> | null
  }


  /**
   * Model UserProgress
   */

  export type AggregateUserProgress = {
    _count: UserProgressCountAggregateOutputType | null
    _min: UserProgressMinAggregateOutputType | null
    _max: UserProgressMaxAggregateOutputType | null
  }

  export type UserProgressMinAggregateOutputType = {
    id: string | null
    userId: string | null
    learningPathId: string | null
    moduleId: string | null
    status: string | null
    updatedAt: Date | null
  }

  export type UserProgressMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    learningPathId: string | null
    moduleId: string | null
    status: string | null
    updatedAt: Date | null
  }

  export type UserProgressCountAggregateOutputType = {
    id: number
    userId: number
    learningPathId: number
    moduleId: number
    status: number
    updatedAt: number
    _all: number
  }


  export type UserProgressMinAggregateInputType = {
    id?: true
    userId?: true
    learningPathId?: true
    moduleId?: true
    status?: true
    updatedAt?: true
  }

  export type UserProgressMaxAggregateInputType = {
    id?: true
    userId?: true
    learningPathId?: true
    moduleId?: true
    status?: true
    updatedAt?: true
  }

  export type UserProgressCountAggregateInputType = {
    id?: true
    userId?: true
    learningPathId?: true
    moduleId?: true
    status?: true
    updatedAt?: true
    _all?: true
  }

  export type UserProgressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProgress to aggregate.
     */
    where?: UserProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProgresses to fetch.
     */
    orderBy?: UserProgressOrderByWithRelationInput | UserProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserProgresses
    **/
    _count?: true | UserProgressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserProgressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserProgressMaxAggregateInputType
  }

  export type GetUserProgressAggregateType<T extends UserProgressAggregateArgs> = {
        [P in keyof T & keyof AggregateUserProgress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserProgress[P]>
      : GetScalarType<T[P], AggregateUserProgress[P]>
  }




  export type UserProgressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProgressWhereInput
    orderBy?: UserProgressOrderByWithAggregationInput | UserProgressOrderByWithAggregationInput[]
    by: UserProgressScalarFieldEnum[] | UserProgressScalarFieldEnum
    having?: UserProgressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserProgressCountAggregateInputType | true
    _min?: UserProgressMinAggregateInputType
    _max?: UserProgressMaxAggregateInputType
  }

  export type UserProgressGroupByOutputType = {
    id: string
    userId: string
    learningPathId: string
    moduleId: string
    status: string
    updatedAt: Date
    _count: UserProgressCountAggregateOutputType | null
    _min: UserProgressMinAggregateOutputType | null
    _max: UserProgressMaxAggregateOutputType | null
  }

  type GetUserProgressGroupByPayload<T extends UserProgressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserProgressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserProgressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserProgressGroupByOutputType[P]>
            : GetScalarType<T[P], UserProgressGroupByOutputType[P]>
        }
      >
    >


  export type UserProgressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    learningPathId?: boolean
    moduleId?: boolean
    status?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    learningPath?: boolean | LearningPathDefaultArgs<ExtArgs>
    module?: boolean | LearningPathItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userProgress"]>

  export type UserProgressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    learningPathId?: boolean
    moduleId?: boolean
    status?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    learningPath?: boolean | LearningPathDefaultArgs<ExtArgs>
    module?: boolean | LearningPathItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userProgress"]>

  export type UserProgressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    learningPathId?: boolean
    moduleId?: boolean
    status?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    learningPath?: boolean | LearningPathDefaultArgs<ExtArgs>
    module?: boolean | LearningPathItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userProgress"]>

  export type UserProgressSelectScalar = {
    id?: boolean
    userId?: boolean
    learningPathId?: boolean
    moduleId?: boolean
    status?: boolean
    updatedAt?: boolean
  }

  export type UserProgressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "learningPathId" | "moduleId" | "status" | "updatedAt", ExtArgs["result"]["userProgress"]>
  export type UserProgressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    learningPath?: boolean | LearningPathDefaultArgs<ExtArgs>
    module?: boolean | LearningPathItemDefaultArgs<ExtArgs>
  }
  export type UserProgressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    learningPath?: boolean | LearningPathDefaultArgs<ExtArgs>
    module?: boolean | LearningPathItemDefaultArgs<ExtArgs>
  }
  export type UserProgressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    learningPath?: boolean | LearningPathDefaultArgs<ExtArgs>
    module?: boolean | LearningPathItemDefaultArgs<ExtArgs>
  }

  export type $UserProgressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserProgress"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      learningPath: Prisma.$LearningPathPayload<ExtArgs>
      module: Prisma.$LearningPathItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      learningPathId: string
      moduleId: string
      status: string
      updatedAt: Date
    }, ExtArgs["result"]["userProgress"]>
    composites: {}
  }

  type UserProgressGetPayload<S extends boolean | null | undefined | UserProgressDefaultArgs> = $Result.GetResult<Prisma.$UserProgressPayload, S>

  type UserProgressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserProgressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserProgressCountAggregateInputType | true
    }

  export interface UserProgressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserProgress'], meta: { name: 'UserProgress' } }
    /**
     * Find zero or one UserProgress that matches the filter.
     * @param {UserProgressFindUniqueArgs} args - Arguments to find a UserProgress
     * @example
     * // Get one UserProgress
     * const userProgress = await prisma.userProgress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserProgressFindUniqueArgs>(args: SelectSubset<T, UserProgressFindUniqueArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one UserProgress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserProgressFindUniqueOrThrowArgs} args - Arguments to find a UserProgress
     * @example
     * // Get one UserProgress
     * const userProgress = await prisma.userProgress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserProgressFindUniqueOrThrowArgs>(args: SelectSubset<T, UserProgressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first UserProgress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProgressFindFirstArgs} args - Arguments to find a UserProgress
     * @example
     * // Get one UserProgress
     * const userProgress = await prisma.userProgress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserProgressFindFirstArgs>(args?: SelectSubset<T, UserProgressFindFirstArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first UserProgress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProgressFindFirstOrThrowArgs} args - Arguments to find a UserProgress
     * @example
     * // Get one UserProgress
     * const userProgress = await prisma.userProgress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserProgressFindFirstOrThrowArgs>(args?: SelectSubset<T, UserProgressFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more UserProgresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProgressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserProgresses
     * const userProgresses = await prisma.userProgress.findMany()
     * 
     * // Get first 10 UserProgresses
     * const userProgresses = await prisma.userProgress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userProgressWithIdOnly = await prisma.userProgress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserProgressFindManyArgs>(args?: SelectSubset<T, UserProgressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a UserProgress.
     * @param {UserProgressCreateArgs} args - Arguments to create a UserProgress.
     * @example
     * // Create one UserProgress
     * const UserProgress = await prisma.userProgress.create({
     *   data: {
     *     // ... data to create a UserProgress
     *   }
     * })
     * 
     */
    create<T extends UserProgressCreateArgs>(args: SelectSubset<T, UserProgressCreateArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many UserProgresses.
     * @param {UserProgressCreateManyArgs} args - Arguments to create many UserProgresses.
     * @example
     * // Create many UserProgresses
     * const userProgress = await prisma.userProgress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserProgressCreateManyArgs>(args?: SelectSubset<T, UserProgressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserProgresses and returns the data saved in the database.
     * @param {UserProgressCreateManyAndReturnArgs} args - Arguments to create many UserProgresses.
     * @example
     * // Create many UserProgresses
     * const userProgress = await prisma.userProgress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserProgresses and only return the `id`
     * const userProgressWithIdOnly = await prisma.userProgress.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserProgressCreateManyAndReturnArgs>(args?: SelectSubset<T, UserProgressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a UserProgress.
     * @param {UserProgressDeleteArgs} args - Arguments to delete one UserProgress.
     * @example
     * // Delete one UserProgress
     * const UserProgress = await prisma.userProgress.delete({
     *   where: {
     *     // ... filter to delete one UserProgress
     *   }
     * })
     * 
     */
    delete<T extends UserProgressDeleteArgs>(args: SelectSubset<T, UserProgressDeleteArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one UserProgress.
     * @param {UserProgressUpdateArgs} args - Arguments to update one UserProgress.
     * @example
     * // Update one UserProgress
     * const userProgress = await prisma.userProgress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserProgressUpdateArgs>(args: SelectSubset<T, UserProgressUpdateArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more UserProgresses.
     * @param {UserProgressDeleteManyArgs} args - Arguments to filter UserProgresses to delete.
     * @example
     * // Delete a few UserProgresses
     * const { count } = await prisma.userProgress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserProgressDeleteManyArgs>(args?: SelectSubset<T, UserProgressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProgressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserProgresses
     * const userProgress = await prisma.userProgress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserProgressUpdateManyArgs>(args: SelectSubset<T, UserProgressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProgresses and returns the data updated in the database.
     * @param {UserProgressUpdateManyAndReturnArgs} args - Arguments to update many UserProgresses.
     * @example
     * // Update many UserProgresses
     * const userProgress = await prisma.userProgress.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserProgresses and only return the `id`
     * const userProgressWithIdOnly = await prisma.userProgress.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserProgressUpdateManyAndReturnArgs>(args: SelectSubset<T, UserProgressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one UserProgress.
     * @param {UserProgressUpsertArgs} args - Arguments to update or create a UserProgress.
     * @example
     * // Update or create a UserProgress
     * const userProgress = await prisma.userProgress.upsert({
     *   create: {
     *     // ... data to create a UserProgress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserProgress we want to update
     *   }
     * })
     */
    upsert<T extends UserProgressUpsertArgs>(args: SelectSubset<T, UserProgressUpsertArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of UserProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProgressCountArgs} args - Arguments to filter UserProgresses to count.
     * @example
     * // Count the number of UserProgresses
     * const count = await prisma.userProgress.count({
     *   where: {
     *     // ... the filter for the UserProgresses we want to count
     *   }
     * })
    **/
    count<T extends UserProgressCountArgs>(
      args?: Subset<T, UserProgressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserProgressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProgressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserProgressAggregateArgs>(args: Subset<T, UserProgressAggregateArgs>): Prisma.PrismaPromise<GetUserProgressAggregateType<T>>

    /**
     * Group by UserProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProgressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserProgressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserProgressGroupByArgs['orderBy'] }
        : { orderBy?: UserProgressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserProgressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserProgressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserProgress model
   */
  readonly fields: UserProgressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserProgress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserProgressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    learningPath<T extends LearningPathDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LearningPathDefaultArgs<ExtArgs>>): Prisma__LearningPathClient<$Result.GetResult<Prisma.$LearningPathPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    module<T extends LearningPathItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LearningPathItemDefaultArgs<ExtArgs>>): Prisma__LearningPathItemClient<$Result.GetResult<Prisma.$LearningPathItemPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserProgress model
   */ 
  interface UserProgressFieldRefs {
    readonly id: FieldRef<"UserProgress", 'String'>
    readonly userId: FieldRef<"UserProgress", 'String'>
    readonly learningPathId: FieldRef<"UserProgress", 'String'>
    readonly moduleId: FieldRef<"UserProgress", 'String'>
    readonly status: FieldRef<"UserProgress", 'String'>
    readonly updatedAt: FieldRef<"UserProgress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserProgress findUnique
   */
  export type UserProgressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserProgress to fetch.
     */
    where: UserProgressWhereUniqueInput
  }

  /**
   * UserProgress findUniqueOrThrow
   */
  export type UserProgressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserProgress to fetch.
     */
    where: UserProgressWhereUniqueInput
  }

  /**
   * UserProgress findFirst
   */
  export type UserProgressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserProgress to fetch.
     */
    where?: UserProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProgresses to fetch.
     */
    orderBy?: UserProgressOrderByWithRelationInput | UserProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProgresses.
     */
    cursor?: UserProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProgresses.
     */
    distinct?: UserProgressScalarFieldEnum | UserProgressScalarFieldEnum[]
  }

  /**
   * UserProgress findFirstOrThrow
   */
  export type UserProgressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserProgress to fetch.
     */
    where?: UserProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProgresses to fetch.
     */
    orderBy?: UserProgressOrderByWithRelationInput | UserProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProgresses.
     */
    cursor?: UserProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProgresses.
     */
    distinct?: UserProgressScalarFieldEnum | UserProgressScalarFieldEnum[]
  }

  /**
   * UserProgress findMany
   */
  export type UserProgressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserProgresses to fetch.
     */
    where?: UserProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProgresses to fetch.
     */
    orderBy?: UserProgressOrderByWithRelationInput | UserProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserProgresses.
     */
    cursor?: UserProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProgresses.
     */
    skip?: number
    distinct?: UserProgressScalarFieldEnum | UserProgressScalarFieldEnum[]
  }

  /**
   * UserProgress create
   */
  export type UserProgressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    /**
     * The data needed to create a UserProgress.
     */
    data: XOR<UserProgressCreateInput, UserProgressUncheckedCreateInput>
  }

  /**
   * UserProgress createMany
   */
  export type UserProgressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserProgresses.
     */
    data: UserProgressCreateManyInput | UserProgressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserProgress createManyAndReturn
   */
  export type UserProgressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * The data used to create many UserProgresses.
     */
    data: UserProgressCreateManyInput | UserProgressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserProgress update
   */
  export type UserProgressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    /**
     * The data needed to update a UserProgress.
     */
    data: XOR<UserProgressUpdateInput, UserProgressUncheckedUpdateInput>
    /**
     * Choose, which UserProgress to update.
     */
    where: UserProgressWhereUniqueInput
  }

  /**
   * UserProgress updateMany
   */
  export type UserProgressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserProgresses.
     */
    data: XOR<UserProgressUpdateManyMutationInput, UserProgressUncheckedUpdateManyInput>
    /**
     * Filter which UserProgresses to update
     */
    where?: UserProgressWhereInput
    /**
     * Limit how many UserProgresses to update.
     */
    limit?: number
  }

  /**
   * UserProgress updateManyAndReturn
   */
  export type UserProgressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * The data used to update UserProgresses.
     */
    data: XOR<UserProgressUpdateManyMutationInput, UserProgressUncheckedUpdateManyInput>
    /**
     * Filter which UserProgresses to update
     */
    where?: UserProgressWhereInput
    /**
     * Limit how many UserProgresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserProgress upsert
   */
  export type UserProgressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    /**
     * The filter to search for the UserProgress to update in case it exists.
     */
    where: UserProgressWhereUniqueInput
    /**
     * In case the UserProgress found by the `where` argument doesn't exist, create a new UserProgress with this data.
     */
    create: XOR<UserProgressCreateInput, UserProgressUncheckedCreateInput>
    /**
     * In case the UserProgress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserProgressUpdateInput, UserProgressUncheckedUpdateInput>
  }

  /**
   * UserProgress delete
   */
  export type UserProgressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    /**
     * Filter which UserProgress to delete.
     */
    where: UserProgressWhereUniqueInput
  }

  /**
   * UserProgress deleteMany
   */
  export type UserProgressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProgresses to delete
     */
    where?: UserProgressWhereInput
    /**
     * Limit how many UserProgresses to delete.
     */
    limit?: number
  }

  /**
   * UserProgress without action
   */
  export type UserProgressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
  }


  /**
   * Model AIChat
   */

  export type AggregateAIChat = {
    _count: AIChatCountAggregateOutputType | null
    _min: AIChatMinAggregateOutputType | null
    _max: AIChatMaxAggregateOutputType | null
  }

  export type AIChatMinAggregateOutputType = {
    id: string | null
    title: string | null
    createdAt: Date | null
    userId: string | null
  }

  export type AIChatMaxAggregateOutputType = {
    id: string | null
    title: string | null
    createdAt: Date | null
    userId: string | null
  }

  export type AIChatCountAggregateOutputType = {
    id: number
    title: number
    createdAt: number
    userId: number
    _all: number
  }


  export type AIChatMinAggregateInputType = {
    id?: true
    title?: true
    createdAt?: true
    userId?: true
  }

  export type AIChatMaxAggregateInputType = {
    id?: true
    title?: true
    createdAt?: true
    userId?: true
  }

  export type AIChatCountAggregateInputType = {
    id?: true
    title?: true
    createdAt?: true
    userId?: true
    _all?: true
  }

  export type AIChatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIChat to aggregate.
     */
    where?: AIChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIChats to fetch.
     */
    orderBy?: AIChatOrderByWithRelationInput | AIChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AIChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIChats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIChats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AIChats
    **/
    _count?: true | AIChatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AIChatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AIChatMaxAggregateInputType
  }

  export type GetAIChatAggregateType<T extends AIChatAggregateArgs> = {
        [P in keyof T & keyof AggregateAIChat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAIChat[P]>
      : GetScalarType<T[P], AggregateAIChat[P]>
  }




  export type AIChatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIChatWhereInput
    orderBy?: AIChatOrderByWithAggregationInput | AIChatOrderByWithAggregationInput[]
    by: AIChatScalarFieldEnum[] | AIChatScalarFieldEnum
    having?: AIChatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AIChatCountAggregateInputType | true
    _min?: AIChatMinAggregateInputType
    _max?: AIChatMaxAggregateInputType
  }

  export type AIChatGroupByOutputType = {
    id: string
    title: string | null
    createdAt: Date
    userId: string
    _count: AIChatCountAggregateOutputType | null
    _min: AIChatMinAggregateOutputType | null
    _max: AIChatMaxAggregateOutputType | null
  }

  type GetAIChatGroupByPayload<T extends AIChatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AIChatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AIChatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AIChatGroupByOutputType[P]>
            : GetScalarType<T[P], AIChatGroupByOutputType[P]>
        }
      >
    >


  export type AIChatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    createdAt?: boolean
    userId?: boolean
    messages?: boolean | AIChat$messagesArgs<ExtArgs>
    user?: boolean | AIChat$userArgs<ExtArgs>
    _count?: boolean | AIChatCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIChat"]>

  export type AIChatSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    createdAt?: boolean
    userId?: boolean
    user?: boolean | AIChat$userArgs<ExtArgs>
  }, ExtArgs["result"]["aIChat"]>

  export type AIChatSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    createdAt?: boolean
    userId?: boolean
    user?: boolean | AIChat$userArgs<ExtArgs>
  }, ExtArgs["result"]["aIChat"]>

  export type AIChatSelectScalar = {
    id?: boolean
    title?: boolean
    createdAt?: boolean
    userId?: boolean
  }

  export type AIChatOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "createdAt" | "userId", ExtArgs["result"]["aIChat"]>
  export type AIChatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | AIChat$messagesArgs<ExtArgs>
    user?: boolean | AIChat$userArgs<ExtArgs>
    _count?: boolean | AIChatCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AIChatIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AIChat$userArgs<ExtArgs>
  }
  export type AIChatIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AIChat$userArgs<ExtArgs>
  }

  export type $AIChatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AIChat"
    objects: {
      messages: Prisma.$AIChatMessagePayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string | null
      createdAt: Date
      userId: string
    }, ExtArgs["result"]["aIChat"]>
    composites: {}
  }

  type AIChatGetPayload<S extends boolean | null | undefined | AIChatDefaultArgs> = $Result.GetResult<Prisma.$AIChatPayload, S>

  type AIChatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AIChatFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AIChatCountAggregateInputType | true
    }

  export interface AIChatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AIChat'], meta: { name: 'AIChat' } }
    /**
     * Find zero or one AIChat that matches the filter.
     * @param {AIChatFindUniqueArgs} args - Arguments to find a AIChat
     * @example
     * // Get one AIChat
     * const aIChat = await prisma.aIChat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AIChatFindUniqueArgs>(args: SelectSubset<T, AIChatFindUniqueArgs<ExtArgs>>): Prisma__AIChatClient<$Result.GetResult<Prisma.$AIChatPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one AIChat that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AIChatFindUniqueOrThrowArgs} args - Arguments to find a AIChat
     * @example
     * // Get one AIChat
     * const aIChat = await prisma.aIChat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AIChatFindUniqueOrThrowArgs>(args: SelectSubset<T, AIChatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AIChatClient<$Result.GetResult<Prisma.$AIChatPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first AIChat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIChatFindFirstArgs} args - Arguments to find a AIChat
     * @example
     * // Get one AIChat
     * const aIChat = await prisma.aIChat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AIChatFindFirstArgs>(args?: SelectSubset<T, AIChatFindFirstArgs<ExtArgs>>): Prisma__AIChatClient<$Result.GetResult<Prisma.$AIChatPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first AIChat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIChatFindFirstOrThrowArgs} args - Arguments to find a AIChat
     * @example
     * // Get one AIChat
     * const aIChat = await prisma.aIChat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AIChatFindFirstOrThrowArgs>(args?: SelectSubset<T, AIChatFindFirstOrThrowArgs<ExtArgs>>): Prisma__AIChatClient<$Result.GetResult<Prisma.$AIChatPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more AIChats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIChatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AIChats
     * const aIChats = await prisma.aIChat.findMany()
     * 
     * // Get first 10 AIChats
     * const aIChats = await prisma.aIChat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aIChatWithIdOnly = await prisma.aIChat.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AIChatFindManyArgs>(args?: SelectSubset<T, AIChatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIChatPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a AIChat.
     * @param {AIChatCreateArgs} args - Arguments to create a AIChat.
     * @example
     * // Create one AIChat
     * const AIChat = await prisma.aIChat.create({
     *   data: {
     *     // ... data to create a AIChat
     *   }
     * })
     * 
     */
    create<T extends AIChatCreateArgs>(args: SelectSubset<T, AIChatCreateArgs<ExtArgs>>): Prisma__AIChatClient<$Result.GetResult<Prisma.$AIChatPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many AIChats.
     * @param {AIChatCreateManyArgs} args - Arguments to create many AIChats.
     * @example
     * // Create many AIChats
     * const aIChat = await prisma.aIChat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AIChatCreateManyArgs>(args?: SelectSubset<T, AIChatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AIChats and returns the data saved in the database.
     * @param {AIChatCreateManyAndReturnArgs} args - Arguments to create many AIChats.
     * @example
     * // Create many AIChats
     * const aIChat = await prisma.aIChat.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AIChats and only return the `id`
     * const aIChatWithIdOnly = await prisma.aIChat.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AIChatCreateManyAndReturnArgs>(args?: SelectSubset<T, AIChatCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIChatPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a AIChat.
     * @param {AIChatDeleteArgs} args - Arguments to delete one AIChat.
     * @example
     * // Delete one AIChat
     * const AIChat = await prisma.aIChat.delete({
     *   where: {
     *     // ... filter to delete one AIChat
     *   }
     * })
     * 
     */
    delete<T extends AIChatDeleteArgs>(args: SelectSubset<T, AIChatDeleteArgs<ExtArgs>>): Prisma__AIChatClient<$Result.GetResult<Prisma.$AIChatPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one AIChat.
     * @param {AIChatUpdateArgs} args - Arguments to update one AIChat.
     * @example
     * // Update one AIChat
     * const aIChat = await prisma.aIChat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AIChatUpdateArgs>(args: SelectSubset<T, AIChatUpdateArgs<ExtArgs>>): Prisma__AIChatClient<$Result.GetResult<Prisma.$AIChatPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more AIChats.
     * @param {AIChatDeleteManyArgs} args - Arguments to filter AIChats to delete.
     * @example
     * // Delete a few AIChats
     * const { count } = await prisma.aIChat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AIChatDeleteManyArgs>(args?: SelectSubset<T, AIChatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIChats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIChatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AIChats
     * const aIChat = await prisma.aIChat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AIChatUpdateManyArgs>(args: SelectSubset<T, AIChatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIChats and returns the data updated in the database.
     * @param {AIChatUpdateManyAndReturnArgs} args - Arguments to update many AIChats.
     * @example
     * // Update many AIChats
     * const aIChat = await prisma.aIChat.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AIChats and only return the `id`
     * const aIChatWithIdOnly = await prisma.aIChat.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AIChatUpdateManyAndReturnArgs>(args: SelectSubset<T, AIChatUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIChatPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one AIChat.
     * @param {AIChatUpsertArgs} args - Arguments to update or create a AIChat.
     * @example
     * // Update or create a AIChat
     * const aIChat = await prisma.aIChat.upsert({
     *   create: {
     *     // ... data to create a AIChat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AIChat we want to update
     *   }
     * })
     */
    upsert<T extends AIChatUpsertArgs>(args: SelectSubset<T, AIChatUpsertArgs<ExtArgs>>): Prisma__AIChatClient<$Result.GetResult<Prisma.$AIChatPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of AIChats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIChatCountArgs} args - Arguments to filter AIChats to count.
     * @example
     * // Count the number of AIChats
     * const count = await prisma.aIChat.count({
     *   where: {
     *     // ... the filter for the AIChats we want to count
     *   }
     * })
    **/
    count<T extends AIChatCountArgs>(
      args?: Subset<T, AIChatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AIChatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AIChat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIChatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AIChatAggregateArgs>(args: Subset<T, AIChatAggregateArgs>): Prisma.PrismaPromise<GetAIChatAggregateType<T>>

    /**
     * Group by AIChat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIChatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AIChatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AIChatGroupByArgs['orderBy'] }
        : { orderBy?: AIChatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AIChatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAIChatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AIChat model
   */
  readonly fields: AIChatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AIChat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AIChatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    messages<T extends AIChat$messagesArgs<ExtArgs> = {}>(args?: Subset<T, AIChat$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIChatMessagePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    user<T extends AIChat$userArgs<ExtArgs> = {}>(args?: Subset<T, AIChat$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AIChat model
   */ 
  interface AIChatFieldRefs {
    readonly id: FieldRef<"AIChat", 'String'>
    readonly title: FieldRef<"AIChat", 'String'>
    readonly createdAt: FieldRef<"AIChat", 'DateTime'>
    readonly userId: FieldRef<"AIChat", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AIChat findUnique
   */
  export type AIChatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIChat
     */
    select?: AIChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIChat
     */
    omit?: AIChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIChatInclude<ExtArgs> | null
    /**
     * Filter, which AIChat to fetch.
     */
    where: AIChatWhereUniqueInput
  }

  /**
   * AIChat findUniqueOrThrow
   */
  export type AIChatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIChat
     */
    select?: AIChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIChat
     */
    omit?: AIChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIChatInclude<ExtArgs> | null
    /**
     * Filter, which AIChat to fetch.
     */
    where: AIChatWhereUniqueInput
  }

  /**
   * AIChat findFirst
   */
  export type AIChatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIChat
     */
    select?: AIChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIChat
     */
    omit?: AIChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIChatInclude<ExtArgs> | null
    /**
     * Filter, which AIChat to fetch.
     */
    where?: AIChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIChats to fetch.
     */
    orderBy?: AIChatOrderByWithRelationInput | AIChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIChats.
     */
    cursor?: AIChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIChats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIChats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIChats.
     */
    distinct?: AIChatScalarFieldEnum | AIChatScalarFieldEnum[]
  }

  /**
   * AIChat findFirstOrThrow
   */
  export type AIChatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIChat
     */
    select?: AIChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIChat
     */
    omit?: AIChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIChatInclude<ExtArgs> | null
    /**
     * Filter, which AIChat to fetch.
     */
    where?: AIChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIChats to fetch.
     */
    orderBy?: AIChatOrderByWithRelationInput | AIChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIChats.
     */
    cursor?: AIChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIChats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIChats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIChats.
     */
    distinct?: AIChatScalarFieldEnum | AIChatScalarFieldEnum[]
  }

  /**
   * AIChat findMany
   */
  export type AIChatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIChat
     */
    select?: AIChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIChat
     */
    omit?: AIChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIChatInclude<ExtArgs> | null
    /**
     * Filter, which AIChats to fetch.
     */
    where?: AIChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIChats to fetch.
     */
    orderBy?: AIChatOrderByWithRelationInput | AIChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AIChats.
     */
    cursor?: AIChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIChats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIChats.
     */
    skip?: number
    distinct?: AIChatScalarFieldEnum | AIChatScalarFieldEnum[]
  }

  /**
   * AIChat create
   */
  export type AIChatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIChat
     */
    select?: AIChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIChat
     */
    omit?: AIChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIChatInclude<ExtArgs> | null
    /**
     * The data needed to create a AIChat.
     */
    data: XOR<AIChatCreateInput, AIChatUncheckedCreateInput>
  }

  /**
   * AIChat createMany
   */
  export type AIChatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AIChats.
     */
    data: AIChatCreateManyInput | AIChatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIChat createManyAndReturn
   */
  export type AIChatCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIChat
     */
    select?: AIChatSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIChat
     */
    omit?: AIChatOmit<ExtArgs> | null
    /**
     * The data used to create many AIChats.
     */
    data: AIChatCreateManyInput | AIChatCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIChatIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIChat update
   */
  export type AIChatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIChat
     */
    select?: AIChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIChat
     */
    omit?: AIChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIChatInclude<ExtArgs> | null
    /**
     * The data needed to update a AIChat.
     */
    data: XOR<AIChatUpdateInput, AIChatUncheckedUpdateInput>
    /**
     * Choose, which AIChat to update.
     */
    where: AIChatWhereUniqueInput
  }

  /**
   * AIChat updateMany
   */
  export type AIChatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AIChats.
     */
    data: XOR<AIChatUpdateManyMutationInput, AIChatUncheckedUpdateManyInput>
    /**
     * Filter which AIChats to update
     */
    where?: AIChatWhereInput
    /**
     * Limit how many AIChats to update.
     */
    limit?: number
  }

  /**
   * AIChat updateManyAndReturn
   */
  export type AIChatUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIChat
     */
    select?: AIChatSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIChat
     */
    omit?: AIChatOmit<ExtArgs> | null
    /**
     * The data used to update AIChats.
     */
    data: XOR<AIChatUpdateManyMutationInput, AIChatUncheckedUpdateManyInput>
    /**
     * Filter which AIChats to update
     */
    where?: AIChatWhereInput
    /**
     * Limit how many AIChats to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIChatIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIChat upsert
   */
  export type AIChatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIChat
     */
    select?: AIChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIChat
     */
    omit?: AIChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIChatInclude<ExtArgs> | null
    /**
     * The filter to search for the AIChat to update in case it exists.
     */
    where: AIChatWhereUniqueInput
    /**
     * In case the AIChat found by the `where` argument doesn't exist, create a new AIChat with this data.
     */
    create: XOR<AIChatCreateInput, AIChatUncheckedCreateInput>
    /**
     * In case the AIChat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AIChatUpdateInput, AIChatUncheckedUpdateInput>
  }

  /**
   * AIChat delete
   */
  export type AIChatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIChat
     */
    select?: AIChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIChat
     */
    omit?: AIChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIChatInclude<ExtArgs> | null
    /**
     * Filter which AIChat to delete.
     */
    where: AIChatWhereUniqueInput
  }

  /**
   * AIChat deleteMany
   */
  export type AIChatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIChats to delete
     */
    where?: AIChatWhereInput
    /**
     * Limit how many AIChats to delete.
     */
    limit?: number
  }

  /**
   * AIChat.messages
   */
  export type AIChat$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIChatMessage
     */
    select?: AIChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIChatMessage
     */
    omit?: AIChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIChatMessageInclude<ExtArgs> | null
    where?: AIChatMessageWhereInput
    orderBy?: AIChatMessageOrderByWithRelationInput | AIChatMessageOrderByWithRelationInput[]
    cursor?: AIChatMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AIChatMessageScalarFieldEnum | AIChatMessageScalarFieldEnum[]
  }

  /**
   * AIChat.user
   */
  export type AIChat$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AIChat without action
   */
  export type AIChatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIChat
     */
    select?: AIChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIChat
     */
    omit?: AIChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIChatInclude<ExtArgs> | null
  }


  /**
   * Model AIChatMessage
   */

  export type AggregateAIChatMessage = {
    _count: AIChatMessageCountAggregateOutputType | null
    _min: AIChatMessageMinAggregateOutputType | null
    _max: AIChatMessageMaxAggregateOutputType | null
  }

  export type AIChatMessageMinAggregateOutputType = {
    id: string | null
    chatId: string | null
    display: string | null
    role: string | null
    content: string | null
    createdAt: Date | null
  }

  export type AIChatMessageMaxAggregateOutputType = {
    id: string | null
    chatId: string | null
    display: string | null
    role: string | null
    content: string | null
    createdAt: Date | null
  }

  export type AIChatMessageCountAggregateOutputType = {
    id: number
    chatId: number
    display: number
    role: number
    content: number
    createdAt: number
    _all: number
  }


  export type AIChatMessageMinAggregateInputType = {
    id?: true
    chatId?: true
    display?: true
    role?: true
    content?: true
    createdAt?: true
  }

  export type AIChatMessageMaxAggregateInputType = {
    id?: true
    chatId?: true
    display?: true
    role?: true
    content?: true
    createdAt?: true
  }

  export type AIChatMessageCountAggregateInputType = {
    id?: true
    chatId?: true
    display?: true
    role?: true
    content?: true
    createdAt?: true
    _all?: true
  }

  export type AIChatMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIChatMessage to aggregate.
     */
    where?: AIChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIChatMessages to fetch.
     */
    orderBy?: AIChatMessageOrderByWithRelationInput | AIChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AIChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AIChatMessages
    **/
    _count?: true | AIChatMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AIChatMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AIChatMessageMaxAggregateInputType
  }

  export type GetAIChatMessageAggregateType<T extends AIChatMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateAIChatMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAIChatMessage[P]>
      : GetScalarType<T[P], AggregateAIChatMessage[P]>
  }




  export type AIChatMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIChatMessageWhereInput
    orderBy?: AIChatMessageOrderByWithAggregationInput | AIChatMessageOrderByWithAggregationInput[]
    by: AIChatMessageScalarFieldEnum[] | AIChatMessageScalarFieldEnum
    having?: AIChatMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AIChatMessageCountAggregateInputType | true
    _min?: AIChatMessageMinAggregateInputType
    _max?: AIChatMessageMaxAggregateInputType
  }

  export type AIChatMessageGroupByOutputType = {
    id: string
    chatId: string
    display: string | null
    role: string
    content: string
    createdAt: Date
    _count: AIChatMessageCountAggregateOutputType | null
    _min: AIChatMessageMinAggregateOutputType | null
    _max: AIChatMessageMaxAggregateOutputType | null
  }

  type GetAIChatMessageGroupByPayload<T extends AIChatMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AIChatMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AIChatMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AIChatMessageGroupByOutputType[P]>
            : GetScalarType<T[P], AIChatMessageGroupByOutputType[P]>
        }
      >
    >


  export type AIChatMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chatId?: boolean
    display?: boolean
    role?: boolean
    content?: boolean
    createdAt?: boolean
    chat?: boolean | AIChatDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIChatMessage"]>

  export type AIChatMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chatId?: boolean
    display?: boolean
    role?: boolean
    content?: boolean
    createdAt?: boolean
    chat?: boolean | AIChatDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIChatMessage"]>

  export type AIChatMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chatId?: boolean
    display?: boolean
    role?: boolean
    content?: boolean
    createdAt?: boolean
    chat?: boolean | AIChatDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIChatMessage"]>

  export type AIChatMessageSelectScalar = {
    id?: boolean
    chatId?: boolean
    display?: boolean
    role?: boolean
    content?: boolean
    createdAt?: boolean
  }

  export type AIChatMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "chatId" | "display" | "role" | "content" | "createdAt", ExtArgs["result"]["aIChatMessage"]>
  export type AIChatMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chat?: boolean | AIChatDefaultArgs<ExtArgs>
  }
  export type AIChatMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chat?: boolean | AIChatDefaultArgs<ExtArgs>
  }
  export type AIChatMessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chat?: boolean | AIChatDefaultArgs<ExtArgs>
  }

  export type $AIChatMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AIChatMessage"
    objects: {
      chat: Prisma.$AIChatPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      chatId: string
      display: string | null
      role: string
      content: string
      createdAt: Date
    }, ExtArgs["result"]["aIChatMessage"]>
    composites: {}
  }

  type AIChatMessageGetPayload<S extends boolean | null | undefined | AIChatMessageDefaultArgs> = $Result.GetResult<Prisma.$AIChatMessagePayload, S>

  type AIChatMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AIChatMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AIChatMessageCountAggregateInputType | true
    }

  export interface AIChatMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AIChatMessage'], meta: { name: 'AIChatMessage' } }
    /**
     * Find zero or one AIChatMessage that matches the filter.
     * @param {AIChatMessageFindUniqueArgs} args - Arguments to find a AIChatMessage
     * @example
     * // Get one AIChatMessage
     * const aIChatMessage = await prisma.aIChatMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AIChatMessageFindUniqueArgs>(args: SelectSubset<T, AIChatMessageFindUniqueArgs<ExtArgs>>): Prisma__AIChatMessageClient<$Result.GetResult<Prisma.$AIChatMessagePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one AIChatMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AIChatMessageFindUniqueOrThrowArgs} args - Arguments to find a AIChatMessage
     * @example
     * // Get one AIChatMessage
     * const aIChatMessage = await prisma.aIChatMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AIChatMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, AIChatMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AIChatMessageClient<$Result.GetResult<Prisma.$AIChatMessagePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first AIChatMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIChatMessageFindFirstArgs} args - Arguments to find a AIChatMessage
     * @example
     * // Get one AIChatMessage
     * const aIChatMessage = await prisma.aIChatMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AIChatMessageFindFirstArgs>(args?: SelectSubset<T, AIChatMessageFindFirstArgs<ExtArgs>>): Prisma__AIChatMessageClient<$Result.GetResult<Prisma.$AIChatMessagePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first AIChatMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIChatMessageFindFirstOrThrowArgs} args - Arguments to find a AIChatMessage
     * @example
     * // Get one AIChatMessage
     * const aIChatMessage = await prisma.aIChatMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AIChatMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, AIChatMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__AIChatMessageClient<$Result.GetResult<Prisma.$AIChatMessagePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more AIChatMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIChatMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AIChatMessages
     * const aIChatMessages = await prisma.aIChatMessage.findMany()
     * 
     * // Get first 10 AIChatMessages
     * const aIChatMessages = await prisma.aIChatMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aIChatMessageWithIdOnly = await prisma.aIChatMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AIChatMessageFindManyArgs>(args?: SelectSubset<T, AIChatMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIChatMessagePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a AIChatMessage.
     * @param {AIChatMessageCreateArgs} args - Arguments to create a AIChatMessage.
     * @example
     * // Create one AIChatMessage
     * const AIChatMessage = await prisma.aIChatMessage.create({
     *   data: {
     *     // ... data to create a AIChatMessage
     *   }
     * })
     * 
     */
    create<T extends AIChatMessageCreateArgs>(args: SelectSubset<T, AIChatMessageCreateArgs<ExtArgs>>): Prisma__AIChatMessageClient<$Result.GetResult<Prisma.$AIChatMessagePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many AIChatMessages.
     * @param {AIChatMessageCreateManyArgs} args - Arguments to create many AIChatMessages.
     * @example
     * // Create many AIChatMessages
     * const aIChatMessage = await prisma.aIChatMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AIChatMessageCreateManyArgs>(args?: SelectSubset<T, AIChatMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AIChatMessages and returns the data saved in the database.
     * @param {AIChatMessageCreateManyAndReturnArgs} args - Arguments to create many AIChatMessages.
     * @example
     * // Create many AIChatMessages
     * const aIChatMessage = await prisma.aIChatMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AIChatMessages and only return the `id`
     * const aIChatMessageWithIdOnly = await prisma.aIChatMessage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AIChatMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, AIChatMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIChatMessagePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a AIChatMessage.
     * @param {AIChatMessageDeleteArgs} args - Arguments to delete one AIChatMessage.
     * @example
     * // Delete one AIChatMessage
     * const AIChatMessage = await prisma.aIChatMessage.delete({
     *   where: {
     *     // ... filter to delete one AIChatMessage
     *   }
     * })
     * 
     */
    delete<T extends AIChatMessageDeleteArgs>(args: SelectSubset<T, AIChatMessageDeleteArgs<ExtArgs>>): Prisma__AIChatMessageClient<$Result.GetResult<Prisma.$AIChatMessagePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one AIChatMessage.
     * @param {AIChatMessageUpdateArgs} args - Arguments to update one AIChatMessage.
     * @example
     * // Update one AIChatMessage
     * const aIChatMessage = await prisma.aIChatMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AIChatMessageUpdateArgs>(args: SelectSubset<T, AIChatMessageUpdateArgs<ExtArgs>>): Prisma__AIChatMessageClient<$Result.GetResult<Prisma.$AIChatMessagePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more AIChatMessages.
     * @param {AIChatMessageDeleteManyArgs} args - Arguments to filter AIChatMessages to delete.
     * @example
     * // Delete a few AIChatMessages
     * const { count } = await prisma.aIChatMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AIChatMessageDeleteManyArgs>(args?: SelectSubset<T, AIChatMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIChatMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIChatMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AIChatMessages
     * const aIChatMessage = await prisma.aIChatMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AIChatMessageUpdateManyArgs>(args: SelectSubset<T, AIChatMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIChatMessages and returns the data updated in the database.
     * @param {AIChatMessageUpdateManyAndReturnArgs} args - Arguments to update many AIChatMessages.
     * @example
     * // Update many AIChatMessages
     * const aIChatMessage = await prisma.aIChatMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AIChatMessages and only return the `id`
     * const aIChatMessageWithIdOnly = await prisma.aIChatMessage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AIChatMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, AIChatMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIChatMessagePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one AIChatMessage.
     * @param {AIChatMessageUpsertArgs} args - Arguments to update or create a AIChatMessage.
     * @example
     * // Update or create a AIChatMessage
     * const aIChatMessage = await prisma.aIChatMessage.upsert({
     *   create: {
     *     // ... data to create a AIChatMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AIChatMessage we want to update
     *   }
     * })
     */
    upsert<T extends AIChatMessageUpsertArgs>(args: SelectSubset<T, AIChatMessageUpsertArgs<ExtArgs>>): Prisma__AIChatMessageClient<$Result.GetResult<Prisma.$AIChatMessagePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of AIChatMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIChatMessageCountArgs} args - Arguments to filter AIChatMessages to count.
     * @example
     * // Count the number of AIChatMessages
     * const count = await prisma.aIChatMessage.count({
     *   where: {
     *     // ... the filter for the AIChatMessages we want to count
     *   }
     * })
    **/
    count<T extends AIChatMessageCountArgs>(
      args?: Subset<T, AIChatMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AIChatMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AIChatMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIChatMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AIChatMessageAggregateArgs>(args: Subset<T, AIChatMessageAggregateArgs>): Prisma.PrismaPromise<GetAIChatMessageAggregateType<T>>

    /**
     * Group by AIChatMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIChatMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AIChatMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AIChatMessageGroupByArgs['orderBy'] }
        : { orderBy?: AIChatMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AIChatMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAIChatMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AIChatMessage model
   */
  readonly fields: AIChatMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AIChatMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AIChatMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chat<T extends AIChatDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AIChatDefaultArgs<ExtArgs>>): Prisma__AIChatClient<$Result.GetResult<Prisma.$AIChatPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AIChatMessage model
   */ 
  interface AIChatMessageFieldRefs {
    readonly id: FieldRef<"AIChatMessage", 'String'>
    readonly chatId: FieldRef<"AIChatMessage", 'String'>
    readonly display: FieldRef<"AIChatMessage", 'String'>
    readonly role: FieldRef<"AIChatMessage", 'String'>
    readonly content: FieldRef<"AIChatMessage", 'String'>
    readonly createdAt: FieldRef<"AIChatMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AIChatMessage findUnique
   */
  export type AIChatMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIChatMessage
     */
    select?: AIChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIChatMessage
     */
    omit?: AIChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which AIChatMessage to fetch.
     */
    where: AIChatMessageWhereUniqueInput
  }

  /**
   * AIChatMessage findUniqueOrThrow
   */
  export type AIChatMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIChatMessage
     */
    select?: AIChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIChatMessage
     */
    omit?: AIChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which AIChatMessage to fetch.
     */
    where: AIChatMessageWhereUniqueInput
  }

  /**
   * AIChatMessage findFirst
   */
  export type AIChatMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIChatMessage
     */
    select?: AIChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIChatMessage
     */
    omit?: AIChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which AIChatMessage to fetch.
     */
    where?: AIChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIChatMessages to fetch.
     */
    orderBy?: AIChatMessageOrderByWithRelationInput | AIChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIChatMessages.
     */
    cursor?: AIChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIChatMessages.
     */
    distinct?: AIChatMessageScalarFieldEnum | AIChatMessageScalarFieldEnum[]
  }

  /**
   * AIChatMessage findFirstOrThrow
   */
  export type AIChatMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIChatMessage
     */
    select?: AIChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIChatMessage
     */
    omit?: AIChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which AIChatMessage to fetch.
     */
    where?: AIChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIChatMessages to fetch.
     */
    orderBy?: AIChatMessageOrderByWithRelationInput | AIChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIChatMessages.
     */
    cursor?: AIChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIChatMessages.
     */
    distinct?: AIChatMessageScalarFieldEnum | AIChatMessageScalarFieldEnum[]
  }

  /**
   * AIChatMessage findMany
   */
  export type AIChatMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIChatMessage
     */
    select?: AIChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIChatMessage
     */
    omit?: AIChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which AIChatMessages to fetch.
     */
    where?: AIChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIChatMessages to fetch.
     */
    orderBy?: AIChatMessageOrderByWithRelationInput | AIChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AIChatMessages.
     */
    cursor?: AIChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIChatMessages.
     */
    skip?: number
    distinct?: AIChatMessageScalarFieldEnum | AIChatMessageScalarFieldEnum[]
  }

  /**
   * AIChatMessage create
   */
  export type AIChatMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIChatMessage
     */
    select?: AIChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIChatMessage
     */
    omit?: AIChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIChatMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a AIChatMessage.
     */
    data: XOR<AIChatMessageCreateInput, AIChatMessageUncheckedCreateInput>
  }

  /**
   * AIChatMessage createMany
   */
  export type AIChatMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AIChatMessages.
     */
    data: AIChatMessageCreateManyInput | AIChatMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIChatMessage createManyAndReturn
   */
  export type AIChatMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIChatMessage
     */
    select?: AIChatMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIChatMessage
     */
    omit?: AIChatMessageOmit<ExtArgs> | null
    /**
     * The data used to create many AIChatMessages.
     */
    data: AIChatMessageCreateManyInput | AIChatMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIChatMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIChatMessage update
   */
  export type AIChatMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIChatMessage
     */
    select?: AIChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIChatMessage
     */
    omit?: AIChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIChatMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a AIChatMessage.
     */
    data: XOR<AIChatMessageUpdateInput, AIChatMessageUncheckedUpdateInput>
    /**
     * Choose, which AIChatMessage to update.
     */
    where: AIChatMessageWhereUniqueInput
  }

  /**
   * AIChatMessage updateMany
   */
  export type AIChatMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AIChatMessages.
     */
    data: XOR<AIChatMessageUpdateManyMutationInput, AIChatMessageUncheckedUpdateManyInput>
    /**
     * Filter which AIChatMessages to update
     */
    where?: AIChatMessageWhereInput
    /**
     * Limit how many AIChatMessages to update.
     */
    limit?: number
  }

  /**
   * AIChatMessage updateManyAndReturn
   */
  export type AIChatMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIChatMessage
     */
    select?: AIChatMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIChatMessage
     */
    omit?: AIChatMessageOmit<ExtArgs> | null
    /**
     * The data used to update AIChatMessages.
     */
    data: XOR<AIChatMessageUpdateManyMutationInput, AIChatMessageUncheckedUpdateManyInput>
    /**
     * Filter which AIChatMessages to update
     */
    where?: AIChatMessageWhereInput
    /**
     * Limit how many AIChatMessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIChatMessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIChatMessage upsert
   */
  export type AIChatMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIChatMessage
     */
    select?: AIChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIChatMessage
     */
    omit?: AIChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIChatMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the AIChatMessage to update in case it exists.
     */
    where: AIChatMessageWhereUniqueInput
    /**
     * In case the AIChatMessage found by the `where` argument doesn't exist, create a new AIChatMessage with this data.
     */
    create: XOR<AIChatMessageCreateInput, AIChatMessageUncheckedCreateInput>
    /**
     * In case the AIChatMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AIChatMessageUpdateInput, AIChatMessageUncheckedUpdateInput>
  }

  /**
   * AIChatMessage delete
   */
  export type AIChatMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIChatMessage
     */
    select?: AIChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIChatMessage
     */
    omit?: AIChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIChatMessageInclude<ExtArgs> | null
    /**
     * Filter which AIChatMessage to delete.
     */
    where: AIChatMessageWhereUniqueInput
  }

  /**
   * AIChatMessage deleteMany
   */
  export type AIChatMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIChatMessages to delete
     */
    where?: AIChatMessageWhereInput
    /**
     * Limit how many AIChatMessages to delete.
     */
    limit?: number
  }

  /**
   * AIChatMessage without action
   */
  export type AIChatMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIChatMessage
     */
    select?: AIChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIChatMessage
     */
    omit?: AIChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIChatMessageInclude<ExtArgs> | null
  }


  /**
   * Model PracticeAttempt
   */

  export type AggregatePracticeAttempt = {
    _count: PracticeAttemptCountAggregateOutputType | null
    _avg: PracticeAttemptAvgAggregateOutputType | null
    _sum: PracticeAttemptSumAggregateOutputType | null
    _min: PracticeAttemptMinAggregateOutputType | null
    _max: PracticeAttemptMaxAggregateOutputType | null
  }

  export type PracticeAttemptAvgAggregateOutputType = {
    score: number | null
    averageEase: number | null
  }

  export type PracticeAttemptSumAggregateOutputType = {
    score: number | null
    averageEase: number | null
  }

  export type PracticeAttemptMinAggregateOutputType = {
    id: string | null
    userId: string | null
    aiModuleId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    score: number | null
    averageEase: number | null
    completedAt: Date | null
  }

  export type PracticeAttemptMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    aiModuleId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    score: number | null
    averageEase: number | null
    completedAt: Date | null
  }

  export type PracticeAttemptCountAggregateOutputType = {
    id: number
    userId: number
    aiModuleId: number
    questions: number
    createdAt: number
    updatedAt: number
    score: number
    averageEase: number
    completedAt: number
    _all: number
  }


  export type PracticeAttemptAvgAggregateInputType = {
    score?: true
    averageEase?: true
  }

  export type PracticeAttemptSumAggregateInputType = {
    score?: true
    averageEase?: true
  }

  export type PracticeAttemptMinAggregateInputType = {
    id?: true
    userId?: true
    aiModuleId?: true
    createdAt?: true
    updatedAt?: true
    score?: true
    averageEase?: true
    completedAt?: true
  }

  export type PracticeAttemptMaxAggregateInputType = {
    id?: true
    userId?: true
    aiModuleId?: true
    createdAt?: true
    updatedAt?: true
    score?: true
    averageEase?: true
    completedAt?: true
  }

  export type PracticeAttemptCountAggregateInputType = {
    id?: true
    userId?: true
    aiModuleId?: true
    questions?: true
    createdAt?: true
    updatedAt?: true
    score?: true
    averageEase?: true
    completedAt?: true
    _all?: true
  }

  export type PracticeAttemptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PracticeAttempt to aggregate.
     */
    where?: PracticeAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PracticeAttempts to fetch.
     */
    orderBy?: PracticeAttemptOrderByWithRelationInput | PracticeAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PracticeAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PracticeAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PracticeAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PracticeAttempts
    **/
    _count?: true | PracticeAttemptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PracticeAttemptAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PracticeAttemptSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PracticeAttemptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PracticeAttemptMaxAggregateInputType
  }

  export type GetPracticeAttemptAggregateType<T extends PracticeAttemptAggregateArgs> = {
        [P in keyof T & keyof AggregatePracticeAttempt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePracticeAttempt[P]>
      : GetScalarType<T[P], AggregatePracticeAttempt[P]>
  }




  export type PracticeAttemptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PracticeAttemptWhereInput
    orderBy?: PracticeAttemptOrderByWithAggregationInput | PracticeAttemptOrderByWithAggregationInput[]
    by: PracticeAttemptScalarFieldEnum[] | PracticeAttemptScalarFieldEnum
    having?: PracticeAttemptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PracticeAttemptCountAggregateInputType | true
    _avg?: PracticeAttemptAvgAggregateInputType
    _sum?: PracticeAttemptSumAggregateInputType
    _min?: PracticeAttemptMinAggregateInputType
    _max?: PracticeAttemptMaxAggregateInputType
  }

  export type PracticeAttemptGroupByOutputType = {
    id: string
    userId: string
    aiModuleId: string
    questions: JsonValue
    createdAt: Date
    updatedAt: Date
    score: number | null
    averageEase: number | null
    completedAt: Date | null
    _count: PracticeAttemptCountAggregateOutputType | null
    _avg: PracticeAttemptAvgAggregateOutputType | null
    _sum: PracticeAttemptSumAggregateOutputType | null
    _min: PracticeAttemptMinAggregateOutputType | null
    _max: PracticeAttemptMaxAggregateOutputType | null
  }

  type GetPracticeAttemptGroupByPayload<T extends PracticeAttemptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PracticeAttemptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PracticeAttemptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PracticeAttemptGroupByOutputType[P]>
            : GetScalarType<T[P], PracticeAttemptGroupByOutputType[P]>
        }
      >
    >


  export type PracticeAttemptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    aiModuleId?: boolean
    questions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    score?: boolean
    averageEase?: boolean
    completedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    aiModule?: boolean | AIModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["practiceAttempt"]>

  export type PracticeAttemptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    aiModuleId?: boolean
    questions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    score?: boolean
    averageEase?: boolean
    completedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    aiModule?: boolean | AIModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["practiceAttempt"]>

  export type PracticeAttemptSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    aiModuleId?: boolean
    questions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    score?: boolean
    averageEase?: boolean
    completedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    aiModule?: boolean | AIModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["practiceAttempt"]>

  export type PracticeAttemptSelectScalar = {
    id?: boolean
    userId?: boolean
    aiModuleId?: boolean
    questions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    score?: boolean
    averageEase?: boolean
    completedAt?: boolean
  }

  export type PracticeAttemptOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "aiModuleId" | "questions" | "createdAt" | "updatedAt" | "score" | "averageEase" | "completedAt", ExtArgs["result"]["practiceAttempt"]>
  export type PracticeAttemptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    aiModule?: boolean | AIModuleDefaultArgs<ExtArgs>
  }
  export type PracticeAttemptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    aiModule?: boolean | AIModuleDefaultArgs<ExtArgs>
  }
  export type PracticeAttemptIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    aiModule?: boolean | AIModuleDefaultArgs<ExtArgs>
  }

  export type $PracticeAttemptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PracticeAttempt"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      aiModule: Prisma.$AIModulePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      aiModuleId: string
      questions: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
      score: number | null
      averageEase: number | null
      completedAt: Date | null
    }, ExtArgs["result"]["practiceAttempt"]>
    composites: {}
  }

  type PracticeAttemptGetPayload<S extends boolean | null | undefined | PracticeAttemptDefaultArgs> = $Result.GetResult<Prisma.$PracticeAttemptPayload, S>

  type PracticeAttemptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PracticeAttemptFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PracticeAttemptCountAggregateInputType | true
    }

  export interface PracticeAttemptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PracticeAttempt'], meta: { name: 'PracticeAttempt' } }
    /**
     * Find zero or one PracticeAttempt that matches the filter.
     * @param {PracticeAttemptFindUniqueArgs} args - Arguments to find a PracticeAttempt
     * @example
     * // Get one PracticeAttempt
     * const practiceAttempt = await prisma.practiceAttempt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PracticeAttemptFindUniqueArgs>(args: SelectSubset<T, PracticeAttemptFindUniqueArgs<ExtArgs>>): Prisma__PracticeAttemptClient<$Result.GetResult<Prisma.$PracticeAttemptPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one PracticeAttempt that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PracticeAttemptFindUniqueOrThrowArgs} args - Arguments to find a PracticeAttempt
     * @example
     * // Get one PracticeAttempt
     * const practiceAttempt = await prisma.practiceAttempt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PracticeAttemptFindUniqueOrThrowArgs>(args: SelectSubset<T, PracticeAttemptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PracticeAttemptClient<$Result.GetResult<Prisma.$PracticeAttemptPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first PracticeAttempt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PracticeAttemptFindFirstArgs} args - Arguments to find a PracticeAttempt
     * @example
     * // Get one PracticeAttempt
     * const practiceAttempt = await prisma.practiceAttempt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PracticeAttemptFindFirstArgs>(args?: SelectSubset<T, PracticeAttemptFindFirstArgs<ExtArgs>>): Prisma__PracticeAttemptClient<$Result.GetResult<Prisma.$PracticeAttemptPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first PracticeAttempt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PracticeAttemptFindFirstOrThrowArgs} args - Arguments to find a PracticeAttempt
     * @example
     * // Get one PracticeAttempt
     * const practiceAttempt = await prisma.practiceAttempt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PracticeAttemptFindFirstOrThrowArgs>(args?: SelectSubset<T, PracticeAttemptFindFirstOrThrowArgs<ExtArgs>>): Prisma__PracticeAttemptClient<$Result.GetResult<Prisma.$PracticeAttemptPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more PracticeAttempts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PracticeAttemptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PracticeAttempts
     * const practiceAttempts = await prisma.practiceAttempt.findMany()
     * 
     * // Get first 10 PracticeAttempts
     * const practiceAttempts = await prisma.practiceAttempt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const practiceAttemptWithIdOnly = await prisma.practiceAttempt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PracticeAttemptFindManyArgs>(args?: SelectSubset<T, PracticeAttemptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PracticeAttemptPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a PracticeAttempt.
     * @param {PracticeAttemptCreateArgs} args - Arguments to create a PracticeAttempt.
     * @example
     * // Create one PracticeAttempt
     * const PracticeAttempt = await prisma.practiceAttempt.create({
     *   data: {
     *     // ... data to create a PracticeAttempt
     *   }
     * })
     * 
     */
    create<T extends PracticeAttemptCreateArgs>(args: SelectSubset<T, PracticeAttemptCreateArgs<ExtArgs>>): Prisma__PracticeAttemptClient<$Result.GetResult<Prisma.$PracticeAttemptPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many PracticeAttempts.
     * @param {PracticeAttemptCreateManyArgs} args - Arguments to create many PracticeAttempts.
     * @example
     * // Create many PracticeAttempts
     * const practiceAttempt = await prisma.practiceAttempt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PracticeAttemptCreateManyArgs>(args?: SelectSubset<T, PracticeAttemptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PracticeAttempts and returns the data saved in the database.
     * @param {PracticeAttemptCreateManyAndReturnArgs} args - Arguments to create many PracticeAttempts.
     * @example
     * // Create many PracticeAttempts
     * const practiceAttempt = await prisma.practiceAttempt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PracticeAttempts and only return the `id`
     * const practiceAttemptWithIdOnly = await prisma.practiceAttempt.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PracticeAttemptCreateManyAndReturnArgs>(args?: SelectSubset<T, PracticeAttemptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PracticeAttemptPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a PracticeAttempt.
     * @param {PracticeAttemptDeleteArgs} args - Arguments to delete one PracticeAttempt.
     * @example
     * // Delete one PracticeAttempt
     * const PracticeAttempt = await prisma.practiceAttempt.delete({
     *   where: {
     *     // ... filter to delete one PracticeAttempt
     *   }
     * })
     * 
     */
    delete<T extends PracticeAttemptDeleteArgs>(args: SelectSubset<T, PracticeAttemptDeleteArgs<ExtArgs>>): Prisma__PracticeAttemptClient<$Result.GetResult<Prisma.$PracticeAttemptPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one PracticeAttempt.
     * @param {PracticeAttemptUpdateArgs} args - Arguments to update one PracticeAttempt.
     * @example
     * // Update one PracticeAttempt
     * const practiceAttempt = await prisma.practiceAttempt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PracticeAttemptUpdateArgs>(args: SelectSubset<T, PracticeAttemptUpdateArgs<ExtArgs>>): Prisma__PracticeAttemptClient<$Result.GetResult<Prisma.$PracticeAttemptPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more PracticeAttempts.
     * @param {PracticeAttemptDeleteManyArgs} args - Arguments to filter PracticeAttempts to delete.
     * @example
     * // Delete a few PracticeAttempts
     * const { count } = await prisma.practiceAttempt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PracticeAttemptDeleteManyArgs>(args?: SelectSubset<T, PracticeAttemptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PracticeAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PracticeAttemptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PracticeAttempts
     * const practiceAttempt = await prisma.practiceAttempt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PracticeAttemptUpdateManyArgs>(args: SelectSubset<T, PracticeAttemptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PracticeAttempts and returns the data updated in the database.
     * @param {PracticeAttemptUpdateManyAndReturnArgs} args - Arguments to update many PracticeAttempts.
     * @example
     * // Update many PracticeAttempts
     * const practiceAttempt = await prisma.practiceAttempt.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PracticeAttempts and only return the `id`
     * const practiceAttemptWithIdOnly = await prisma.practiceAttempt.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PracticeAttemptUpdateManyAndReturnArgs>(args: SelectSubset<T, PracticeAttemptUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PracticeAttemptPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one PracticeAttempt.
     * @param {PracticeAttemptUpsertArgs} args - Arguments to update or create a PracticeAttempt.
     * @example
     * // Update or create a PracticeAttempt
     * const practiceAttempt = await prisma.practiceAttempt.upsert({
     *   create: {
     *     // ... data to create a PracticeAttempt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PracticeAttempt we want to update
     *   }
     * })
     */
    upsert<T extends PracticeAttemptUpsertArgs>(args: SelectSubset<T, PracticeAttemptUpsertArgs<ExtArgs>>): Prisma__PracticeAttemptClient<$Result.GetResult<Prisma.$PracticeAttemptPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of PracticeAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PracticeAttemptCountArgs} args - Arguments to filter PracticeAttempts to count.
     * @example
     * // Count the number of PracticeAttempts
     * const count = await prisma.practiceAttempt.count({
     *   where: {
     *     // ... the filter for the PracticeAttempts we want to count
     *   }
     * })
    **/
    count<T extends PracticeAttemptCountArgs>(
      args?: Subset<T, PracticeAttemptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PracticeAttemptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PracticeAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PracticeAttemptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PracticeAttemptAggregateArgs>(args: Subset<T, PracticeAttemptAggregateArgs>): Prisma.PrismaPromise<GetPracticeAttemptAggregateType<T>>

    /**
     * Group by PracticeAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PracticeAttemptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PracticeAttemptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PracticeAttemptGroupByArgs['orderBy'] }
        : { orderBy?: PracticeAttemptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PracticeAttemptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPracticeAttemptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PracticeAttempt model
   */
  readonly fields: PracticeAttemptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PracticeAttempt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PracticeAttemptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    aiModule<T extends AIModuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AIModuleDefaultArgs<ExtArgs>>): Prisma__AIModuleClient<$Result.GetResult<Prisma.$AIModulePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PracticeAttempt model
   */ 
  interface PracticeAttemptFieldRefs {
    readonly id: FieldRef<"PracticeAttempt", 'String'>
    readonly userId: FieldRef<"PracticeAttempt", 'String'>
    readonly aiModuleId: FieldRef<"PracticeAttempt", 'String'>
    readonly questions: FieldRef<"PracticeAttempt", 'Json'>
    readonly createdAt: FieldRef<"PracticeAttempt", 'DateTime'>
    readonly updatedAt: FieldRef<"PracticeAttempt", 'DateTime'>
    readonly score: FieldRef<"PracticeAttempt", 'Float'>
    readonly averageEase: FieldRef<"PracticeAttempt", 'Float'>
    readonly completedAt: FieldRef<"PracticeAttempt", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PracticeAttempt findUnique
   */
  export type PracticeAttemptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticeAttempt
     */
    select?: PracticeAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PracticeAttempt
     */
    omit?: PracticeAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PracticeAttemptInclude<ExtArgs> | null
    /**
     * Filter, which PracticeAttempt to fetch.
     */
    where: PracticeAttemptWhereUniqueInput
  }

  /**
   * PracticeAttempt findUniqueOrThrow
   */
  export type PracticeAttemptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticeAttempt
     */
    select?: PracticeAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PracticeAttempt
     */
    omit?: PracticeAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PracticeAttemptInclude<ExtArgs> | null
    /**
     * Filter, which PracticeAttempt to fetch.
     */
    where: PracticeAttemptWhereUniqueInput
  }

  /**
   * PracticeAttempt findFirst
   */
  export type PracticeAttemptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticeAttempt
     */
    select?: PracticeAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PracticeAttempt
     */
    omit?: PracticeAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PracticeAttemptInclude<ExtArgs> | null
    /**
     * Filter, which PracticeAttempt to fetch.
     */
    where?: PracticeAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PracticeAttempts to fetch.
     */
    orderBy?: PracticeAttemptOrderByWithRelationInput | PracticeAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PracticeAttempts.
     */
    cursor?: PracticeAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PracticeAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PracticeAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PracticeAttempts.
     */
    distinct?: PracticeAttemptScalarFieldEnum | PracticeAttemptScalarFieldEnum[]
  }

  /**
   * PracticeAttempt findFirstOrThrow
   */
  export type PracticeAttemptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticeAttempt
     */
    select?: PracticeAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PracticeAttempt
     */
    omit?: PracticeAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PracticeAttemptInclude<ExtArgs> | null
    /**
     * Filter, which PracticeAttempt to fetch.
     */
    where?: PracticeAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PracticeAttempts to fetch.
     */
    orderBy?: PracticeAttemptOrderByWithRelationInput | PracticeAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PracticeAttempts.
     */
    cursor?: PracticeAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PracticeAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PracticeAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PracticeAttempts.
     */
    distinct?: PracticeAttemptScalarFieldEnum | PracticeAttemptScalarFieldEnum[]
  }

  /**
   * PracticeAttempt findMany
   */
  export type PracticeAttemptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticeAttempt
     */
    select?: PracticeAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PracticeAttempt
     */
    omit?: PracticeAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PracticeAttemptInclude<ExtArgs> | null
    /**
     * Filter, which PracticeAttempts to fetch.
     */
    where?: PracticeAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PracticeAttempts to fetch.
     */
    orderBy?: PracticeAttemptOrderByWithRelationInput | PracticeAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PracticeAttempts.
     */
    cursor?: PracticeAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PracticeAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PracticeAttempts.
     */
    skip?: number
    distinct?: PracticeAttemptScalarFieldEnum | PracticeAttemptScalarFieldEnum[]
  }

  /**
   * PracticeAttempt create
   */
  export type PracticeAttemptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticeAttempt
     */
    select?: PracticeAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PracticeAttempt
     */
    omit?: PracticeAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PracticeAttemptInclude<ExtArgs> | null
    /**
     * The data needed to create a PracticeAttempt.
     */
    data: XOR<PracticeAttemptCreateInput, PracticeAttemptUncheckedCreateInput>
  }

  /**
   * PracticeAttempt createMany
   */
  export type PracticeAttemptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PracticeAttempts.
     */
    data: PracticeAttemptCreateManyInput | PracticeAttemptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PracticeAttempt createManyAndReturn
   */
  export type PracticeAttemptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticeAttempt
     */
    select?: PracticeAttemptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PracticeAttempt
     */
    omit?: PracticeAttemptOmit<ExtArgs> | null
    /**
     * The data used to create many PracticeAttempts.
     */
    data: PracticeAttemptCreateManyInput | PracticeAttemptCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PracticeAttemptIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PracticeAttempt update
   */
  export type PracticeAttemptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticeAttempt
     */
    select?: PracticeAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PracticeAttempt
     */
    omit?: PracticeAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PracticeAttemptInclude<ExtArgs> | null
    /**
     * The data needed to update a PracticeAttempt.
     */
    data: XOR<PracticeAttemptUpdateInput, PracticeAttemptUncheckedUpdateInput>
    /**
     * Choose, which PracticeAttempt to update.
     */
    where: PracticeAttemptWhereUniqueInput
  }

  /**
   * PracticeAttempt updateMany
   */
  export type PracticeAttemptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PracticeAttempts.
     */
    data: XOR<PracticeAttemptUpdateManyMutationInput, PracticeAttemptUncheckedUpdateManyInput>
    /**
     * Filter which PracticeAttempts to update
     */
    where?: PracticeAttemptWhereInput
    /**
     * Limit how many PracticeAttempts to update.
     */
    limit?: number
  }

  /**
   * PracticeAttempt updateManyAndReturn
   */
  export type PracticeAttemptUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticeAttempt
     */
    select?: PracticeAttemptSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PracticeAttempt
     */
    omit?: PracticeAttemptOmit<ExtArgs> | null
    /**
     * The data used to update PracticeAttempts.
     */
    data: XOR<PracticeAttemptUpdateManyMutationInput, PracticeAttemptUncheckedUpdateManyInput>
    /**
     * Filter which PracticeAttempts to update
     */
    where?: PracticeAttemptWhereInput
    /**
     * Limit how many PracticeAttempts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PracticeAttemptIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PracticeAttempt upsert
   */
  export type PracticeAttemptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticeAttempt
     */
    select?: PracticeAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PracticeAttempt
     */
    omit?: PracticeAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PracticeAttemptInclude<ExtArgs> | null
    /**
     * The filter to search for the PracticeAttempt to update in case it exists.
     */
    where: PracticeAttemptWhereUniqueInput
    /**
     * In case the PracticeAttempt found by the `where` argument doesn't exist, create a new PracticeAttempt with this data.
     */
    create: XOR<PracticeAttemptCreateInput, PracticeAttemptUncheckedCreateInput>
    /**
     * In case the PracticeAttempt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PracticeAttemptUpdateInput, PracticeAttemptUncheckedUpdateInput>
  }

  /**
   * PracticeAttempt delete
   */
  export type PracticeAttemptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticeAttempt
     */
    select?: PracticeAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PracticeAttempt
     */
    omit?: PracticeAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PracticeAttemptInclude<ExtArgs> | null
    /**
     * Filter which PracticeAttempt to delete.
     */
    where: PracticeAttemptWhereUniqueInput
  }

  /**
   * PracticeAttempt deleteMany
   */
  export type PracticeAttemptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PracticeAttempts to delete
     */
    where?: PracticeAttemptWhereInput
    /**
     * Limit how many PracticeAttempts to delete.
     */
    limit?: number
  }

  /**
   * PracticeAttempt without action
   */
  export type PracticeAttemptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticeAttempt
     */
    select?: PracticeAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PracticeAttempt
     */
    omit?: PracticeAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PracticeAttemptInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    emailVerified: 'emailVerified',
    image: 'image',
    bio: 'bio',
    avatarUrl: 'avatarUrl',
    password: 'password',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    xp: 'xp',
    level: 'level',
    streak: 'streak',
    lastStreakUpdate: 'lastStreakUpdate',
    lastLoginDate: 'lastLoginDate',
    isAdmin: 'isAdmin',
    role: 'role',
    interests: 'interests',
    learningStyle: 'learningStyle',
    cramMode: 'cramMode'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state',
    oauth_token_secret: 'oauth_token_secret',
    oauth_token: 'oauth_token'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    identifier: 'identifier',
    token: 'token',
    expires: 'expires'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const ActivityScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    description: 'description',
    createdAt: 'createdAt'
  };

  export type ActivityScalarFieldEnum = (typeof ActivityScalarFieldEnum)[keyof typeof ActivityScalarFieldEnum]


  export const LearningPreferencesScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    visualLearning: 'visualLearning',
    auditoryLearning: 'auditoryLearning',
    kinestheticLearning: 'kinestheticLearning'
  };

  export type LearningPreferencesScalarFieldEnum = (typeof LearningPreferencesScalarFieldEnum)[keyof typeof LearningPreferencesScalarFieldEnum]


  export const TopicScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    userId: 'userId'
  };

  export type TopicScalarFieldEnum = (typeof TopicScalarFieldEnum)[keyof typeof TopicScalarFieldEnum]


  export const ProgressScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    topicId: 'topicId',
    completed: 'completed'
  };

  export type ProgressScalarFieldEnum = (typeof ProgressScalarFieldEnum)[keyof typeof ProgressScalarFieldEnum]


  export const BadgeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    imageUrl: 'imageUrl',
    userId: 'userId',
    earnedAt: 'earnedAt'
  };

  export type BadgeScalarFieldEnum = (typeof BadgeScalarFieldEnum)[keyof typeof BadgeScalarFieldEnum]


  export const UpcomingReviewScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    topicId: 'topicId',
    dueDate: 'dueDate'
  };

  export type UpcomingReviewScalarFieldEnum = (typeof UpcomingReviewScalarFieldEnum)[keyof typeof UpcomingReviewScalarFieldEnum]


  export const LearningPathScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    userId: 'userId',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    shareId: 'shareId',
    sharedAt: 'sharedAt'
  };

  export type LearningPathScalarFieldEnum = (typeof LearningPathScalarFieldEnum)[keyof typeof LearningPathScalarFieldEnum]


  export const LearningPathItemScalarFieldEnum: {
    id: 'id',
    order: 'order',
    learningPathId: 'learningPathId',
    topicId: 'topicId',
    confidence: 'confidence'
  };

  export type LearningPathItemScalarFieldEnum = (typeof LearningPathItemScalarFieldEnum)[keyof typeof LearningPathItemScalarFieldEnum]


  export const ContentItemScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    content: 'content',
    type: 'type',
    difficulty: 'difficulty',
    topicId: 'topicId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    version: 'version'
  };

  export type ContentItemScalarFieldEnum = (typeof ContentItemScalarFieldEnum)[keyof typeof ContentItemScalarFieldEnum]


  export const ContentRatingScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    contentItemId: 'contentItemId',
    rating: 'rating',
    createdAt: 'createdAt'
  };

  export type ContentRatingScalarFieldEnum = (typeof ContentRatingScalarFieldEnum)[keyof typeof ContentRatingScalarFieldEnum]


  export const BookmarkScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    contentItemId: 'contentItemId',
    createdAt: 'createdAt'
  };

  export type BookmarkScalarFieldEnum = (typeof BookmarkScalarFieldEnum)[keyof typeof BookmarkScalarFieldEnum]


  export const QuizAttemptScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    contentItemId: 'contentItemId',
    score: 'score',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    answers: 'answers'
  };

  export type QuizAttemptScalarFieldEnum = (typeof QuizAttemptScalarFieldEnum)[keyof typeof QuizAttemptScalarFieldEnum]


  export const KnowledgeNodeScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    userId: 'userId',
    parentId: 'parentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type KnowledgeNodeScalarFieldEnum = (typeof KnowledgeNodeScalarFieldEnum)[keyof typeof KnowledgeNodeScalarFieldEnum]


  export const LeaderboardEntryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    score: 'score',
    type: 'type',
    startDate: 'startDate',
    endDate: 'endDate'
  };

  export type LeaderboardEntryScalarFieldEnum = (typeof LeaderboardEntryScalarFieldEnum)[keyof typeof LeaderboardEntryScalarFieldEnum]


  export const ReviewSessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    dueDate: 'dueDate',
    completed: 'completed',
    isUrgent: 'isUrgent'
  };

  export type ReviewSessionScalarFieldEnum = (typeof ReviewSessionScalarFieldEnum)[keyof typeof ReviewSessionScalarFieldEnum]


  export const ReviewItemScalarFieldEnum: {
    id: 'id',
    reviewSessionId: 'reviewSessionId',
    contentItemId: 'contentItemId',
    type: 'type',
    question: 'question',
    answer: 'answer',
    userAnswer: 'userAnswer',
    isCorrect: 'isCorrect',
    answeredAt: 'answeredAt'
  };

  export type ReviewItemScalarFieldEnum = (typeof ReviewItemScalarFieldEnum)[keyof typeof ReviewItemScalarFieldEnum]


  export const WorkspaceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    ownerId: 'ownerId'
  };

  export type WorkspaceScalarFieldEnum = (typeof WorkspaceScalarFieldEnum)[keyof typeof WorkspaceScalarFieldEnum]


  export const WorkspaceMemberScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    workspaceId: 'workspaceId',
    role: 'role',
    joinedAt: 'joinedAt'
  };

  export type WorkspaceMemberScalarFieldEnum = (typeof WorkspaceMemberScalarFieldEnum)[keyof typeof WorkspaceMemberScalarFieldEnum]


  export const WhiteboardScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WhiteboardScalarFieldEnum = (typeof WhiteboardScalarFieldEnum)[keyof typeof WhiteboardScalarFieldEnum]


  export const WhiteboardVersionScalarFieldEnum: {
    id: 'id',
    whiteboardId: 'whiteboardId',
    content: 'content',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    versionNumber: 'versionNumber'
  };

  export type WhiteboardVersionScalarFieldEnum = (typeof WhiteboardVersionScalarFieldEnum)[keyof typeof WhiteboardVersionScalarFieldEnum]


  export const BreakoutRoomScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    name: 'name',
    createdAt: 'createdAt',
    endedAt: 'endedAt'
  };

  export type BreakoutRoomScalarFieldEnum = (typeof BreakoutRoomScalarFieldEnum)[keyof typeof BreakoutRoomScalarFieldEnum]


  export const LivePollScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    question: 'question',
    options: 'options',
    createdAt: 'createdAt',
    endedAt: 'endedAt'
  };

  export type LivePollScalarFieldEnum = (typeof LivePollScalarFieldEnum)[keyof typeof LivePollScalarFieldEnum]


  export const PollVoteScalarFieldEnum: {
    id: 'id',
    livePoolId: 'livePoolId',
    userId: 'userId',
    option: 'option',
    createdAt: 'createdAt'
  };

  export type PollVoteScalarFieldEnum = (typeof PollVoteScalarFieldEnum)[keyof typeof PollVoteScalarFieldEnum]


  export const SessionSummaryScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    content: 'content',
    createdAt: 'createdAt',
    createdBy: 'createdBy'
  };

  export type SessionSummaryScalarFieldEnum = (typeof SessionSummaryScalarFieldEnum)[keyof typeof SessionSummaryScalarFieldEnum]


  export const ChatScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId'
  };

  export type ChatScalarFieldEnum = (typeof ChatScalarFieldEnum)[keyof typeof ChatScalarFieldEnum]


  export const ChatMessageScalarFieldEnum: {
    id: 'id',
    chatId: 'chatId',
    userId: 'userId',
    content: 'content',
    createdAt: 'createdAt'
  };

  export type ChatMessageScalarFieldEnum = (typeof ChatMessageScalarFieldEnum)[keyof typeof ChatMessageScalarFieldEnum]


  export const UserSettingsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    notificationPreferences: 'notificationPreferences',
    voiceSettings: 'voiceSettings',
    privacySettings: 'privacySettings',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserSettingsScalarFieldEnum = (typeof UserSettingsScalarFieldEnum)[keyof typeof UserSettingsScalarFieldEnum]


  export const AnalyticsEntryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    topicId: 'topicId',
    timeSpent: 'timeSpent',
    score: 'score',
    date: 'date'
  };

  export type AnalyticsEntryScalarFieldEnum = (typeof AnalyticsEntryScalarFieldEnum)[keyof typeof AnalyticsEntryScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    message: 'message',
    read: 'read',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const PasswordlessTokenScalarFieldEnum: {
    id: 'id',
    token: 'token',
    expiresAt: 'expiresAt',
    userId: 'userId'
  };

  export type PasswordlessTokenScalarFieldEnum = (typeof PasswordlessTokenScalarFieldEnum)[keyof typeof PasswordlessTokenScalarFieldEnum]


  export const DailyChallengeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    description: 'description',
    reward: 'reward',
    completed: 'completed',
    createdAt: 'createdAt',
    completedAt: 'completedAt'
  };

  export type DailyChallengeScalarFieldEnum = (typeof DailyChallengeScalarFieldEnum)[keyof typeof DailyChallengeScalarFieldEnum]


  export const ExternalGoalScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    platform: 'platform',
    title: 'title',
    progress: 'progress',
    dueDate: 'dueDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExternalGoalScalarFieldEnum = (typeof ExternalGoalScalarFieldEnum)[keyof typeof ExternalGoalScalarFieldEnum]


  export const PrerequisiteScalarFieldEnum: {
    id: 'id',
    learningPathId: 'learningPathId',
    topicId: 'topicId',
    completed: 'completed'
  };

  export type PrerequisiteScalarFieldEnum = (typeof PrerequisiteScalarFieldEnum)[keyof typeof PrerequisiteScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    content: 'content',
    userId: 'userId',
    topicId: 'topicId',
    createdAt: 'createdAt'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const AIPlaylistScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AIPlaylistScalarFieldEnum = (typeof AIPlaylistScalarFieldEnum)[keyof typeof AIPlaylistScalarFieldEnum]


  export const AIPlaylistItemScalarFieldEnum: {
    id: 'id',
    playlistId: 'playlistId',
    contentItemId: 'contentItemId',
    order: 'order'
  };

  export type AIPlaylistItemScalarFieldEnum = (typeof AIPlaylistItemScalarFieldEnum)[keyof typeof AIPlaylistItemScalarFieldEnum]


  export const ChallengeScoreScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    score: 'score',
    createdAt: 'createdAt'
  };

  export type ChallengeScoreScalarFieldEnum = (typeof ChallengeScoreScalarFieldEnum)[keyof typeof ChallengeScoreScalarFieldEnum]


  export const AIRecommendationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    content: 'content',
    createdAt: 'createdAt'
  };

  export type AIRecommendationScalarFieldEnum = (typeof AIRecommendationScalarFieldEnum)[keyof typeof AIRecommendationScalarFieldEnum]


  export const AIModuleScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    content: 'content',
    tags: 'tags',
    difficulty: 'difficulty',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId',
    topicId: 'topicId'
  };

  export type AIModuleScalarFieldEnum = (typeof AIModuleScalarFieldEnum)[keyof typeof AIModuleScalarFieldEnum]


  export const AIModuleLearningPathItemScalarFieldEnum: {
    id: 'id',
    order: 'order',
    learningPathId: 'learningPathId',
    aiModuleId: 'aiModuleId',
    confidence: 'confidence'
  };

  export type AIModuleLearningPathItemScalarFieldEnum = (typeof AIModuleLearningPathItemScalarFieldEnum)[keyof typeof AIModuleLearningPathItemScalarFieldEnum]


  export const AIModuleQuizAttemptScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    aiModuleId: 'aiModuleId',
    topicId: 'topicId',
    score: 'score',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    answers: 'answers'
  };

  export type AIModuleQuizAttemptScalarFieldEnum = (typeof AIModuleQuizAttemptScalarFieldEnum)[keyof typeof AIModuleQuizAttemptScalarFieldEnum]


  export const AIModuleRatingScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    aiModuleId: 'aiModuleId',
    topicId: 'topicId',
    rating: 'rating',
    feedback: 'feedback',
    createdAt: 'createdAt'
  };

  export type AIModuleRatingScalarFieldEnum = (typeof AIModuleRatingScalarFieldEnum)[keyof typeof AIModuleRatingScalarFieldEnum]


  export const UserProgressScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    learningPathId: 'learningPathId',
    moduleId: 'moduleId',
    status: 'status',
    updatedAt: 'updatedAt'
  };

  export type UserProgressScalarFieldEnum = (typeof UserProgressScalarFieldEnum)[keyof typeof UserProgressScalarFieldEnum]


  export const AIChatScalarFieldEnum: {
    id: 'id',
    title: 'title',
    createdAt: 'createdAt',
    userId: 'userId'
  };

  export type AIChatScalarFieldEnum = (typeof AIChatScalarFieldEnum)[keyof typeof AIChatScalarFieldEnum]


  export const AIChatMessageScalarFieldEnum: {
    id: 'id',
    chatId: 'chatId',
    display: 'display',
    role: 'role',
    content: 'content',
    createdAt: 'createdAt'
  };

  export type AIChatMessageScalarFieldEnum = (typeof AIChatMessageScalarFieldEnum)[keyof typeof AIChatMessageScalarFieldEnum]


  export const PracticeAttemptScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    aiModuleId: 'aiModuleId',
    questions: 'questions',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    score: 'score',
    averageEase: 'averageEase',
    completedAt: 'completedAt'
  };

  export type PracticeAttemptScalarFieldEnum = (typeof PracticeAttemptScalarFieldEnum)[keyof typeof PracticeAttemptScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    password?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    xp?: IntFilter<"User"> | number
    level?: IntFilter<"User"> | number
    streak?: IntFilter<"User"> | number
    lastStreakUpdate?: DateTimeNullableFilter<"User"> | Date | string | null
    lastLoginDate?: DateTimeFilter<"User"> | Date | string
    isAdmin?: BoolFilter<"User"> | boolean
    role?: StringNullableFilter<"User"> | string | null
    interests?: StringNullableListFilter<"User">
    learningStyle?: JsonNullableFilter<"User">
    cramMode?: BoolFilter<"User"> | boolean
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    activities?: ActivityListRelationFilter
    learningPreferences?: XOR<LearningPreferencesNullableScalarRelationFilter, LearningPreferencesWhereInput> | null
    topics?: TopicListRelationFilter
    progress?: ProgressListRelationFilter
    badges?: BadgeListRelationFilter
    upcomingReviews?: UpcomingReviewListRelationFilter
    learningPaths?: LearningPathListRelationFilter
    bookmarks?: BookmarkListRelationFilter
    quizAttempts?: QuizAttemptListRelationFilter
    knowledgeNodes?: KnowledgeNodeListRelationFilter
    leaderboardEntries?: LeaderboardEntryListRelationFilter
    reviewSessions?: ReviewSessionListRelationFilter
    workspaces?: WorkspaceMemberListRelationFilter
    chatMessages?: ChatMessageListRelationFilter
    ownedWorkspaces?: WorkspaceListRelationFilter
    settings?: XOR<UserSettingsNullableScalarRelationFilter, UserSettingsWhereInput> | null
    analyticsEntries?: AnalyticsEntryListRelationFilter
    notifications?: NotificationListRelationFilter
    passwordlessTokens?: PasswordlessTokenListRelationFilter
    dailyChallenges?: DailyChallengeListRelationFilter
    externalGoals?: ExternalGoalListRelationFilter
    comments?: CommentListRelationFilter
    contentRatings?: ContentRatingListRelationFilter
    challengeScores?: ChallengeScoreListRelationFilter
    pollVotes?: PollVoteListRelationFilter
    aiRecommendations?: AIRecommendationListRelationFilter
    aiModules?: AIModuleListRelationFilter
    aiModuleQuizAttempts?: AIModuleQuizAttemptListRelationFilter
    aiModuleRatings?: AIModuleRatingListRelationFilter
    UserProgress?: UserProgressListRelationFilter
    AIChat?: AIChatListRelationFilter
    PracticeAttempts?: PracticeAttemptListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    password?: SortOrder
    name?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    xp?: SortOrder
    level?: SortOrder
    streak?: SortOrder
    lastStreakUpdate?: SortOrderInput | SortOrder
    lastLoginDate?: SortOrder
    isAdmin?: SortOrder
    role?: SortOrderInput | SortOrder
    interests?: SortOrder
    learningStyle?: SortOrderInput | SortOrder
    cramMode?: SortOrder
    accounts?: AccountOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    activities?: ActivityOrderByRelationAggregateInput
    learningPreferences?: LearningPreferencesOrderByWithRelationInput
    topics?: TopicOrderByRelationAggregateInput
    progress?: ProgressOrderByRelationAggregateInput
    badges?: BadgeOrderByRelationAggregateInput
    upcomingReviews?: UpcomingReviewOrderByRelationAggregateInput
    learningPaths?: LearningPathOrderByRelationAggregateInput
    bookmarks?: BookmarkOrderByRelationAggregateInput
    quizAttempts?: QuizAttemptOrderByRelationAggregateInput
    knowledgeNodes?: KnowledgeNodeOrderByRelationAggregateInput
    leaderboardEntries?: LeaderboardEntryOrderByRelationAggregateInput
    reviewSessions?: ReviewSessionOrderByRelationAggregateInput
    workspaces?: WorkspaceMemberOrderByRelationAggregateInput
    chatMessages?: ChatMessageOrderByRelationAggregateInput
    ownedWorkspaces?: WorkspaceOrderByRelationAggregateInput
    settings?: UserSettingsOrderByWithRelationInput
    analyticsEntries?: AnalyticsEntryOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    passwordlessTokens?: PasswordlessTokenOrderByRelationAggregateInput
    dailyChallenges?: DailyChallengeOrderByRelationAggregateInput
    externalGoals?: ExternalGoalOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    contentRatings?: ContentRatingOrderByRelationAggregateInput
    challengeScores?: ChallengeScoreOrderByRelationAggregateInput
    pollVotes?: PollVoteOrderByRelationAggregateInput
    aiRecommendations?: AIRecommendationOrderByRelationAggregateInput
    aiModules?: AIModuleOrderByRelationAggregateInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptOrderByRelationAggregateInput
    aiModuleRatings?: AIModuleRatingOrderByRelationAggregateInput
    UserProgress?: UserProgressOrderByRelationAggregateInput
    AIChat?: AIChatOrderByRelationAggregateInput
    PracticeAttempts?: PracticeAttemptOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    password?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    xp?: IntFilter<"User"> | number
    level?: IntFilter<"User"> | number
    streak?: IntFilter<"User"> | number
    lastStreakUpdate?: DateTimeNullableFilter<"User"> | Date | string | null
    lastLoginDate?: DateTimeFilter<"User"> | Date | string
    isAdmin?: BoolFilter<"User"> | boolean
    role?: StringNullableFilter<"User"> | string | null
    interests?: StringNullableListFilter<"User">
    learningStyle?: JsonNullableFilter<"User">
    cramMode?: BoolFilter<"User"> | boolean
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    activities?: ActivityListRelationFilter
    learningPreferences?: XOR<LearningPreferencesNullableScalarRelationFilter, LearningPreferencesWhereInput> | null
    topics?: TopicListRelationFilter
    progress?: ProgressListRelationFilter
    badges?: BadgeListRelationFilter
    upcomingReviews?: UpcomingReviewListRelationFilter
    learningPaths?: LearningPathListRelationFilter
    bookmarks?: BookmarkListRelationFilter
    quizAttempts?: QuizAttemptListRelationFilter
    knowledgeNodes?: KnowledgeNodeListRelationFilter
    leaderboardEntries?: LeaderboardEntryListRelationFilter
    reviewSessions?: ReviewSessionListRelationFilter
    workspaces?: WorkspaceMemberListRelationFilter
    chatMessages?: ChatMessageListRelationFilter
    ownedWorkspaces?: WorkspaceListRelationFilter
    settings?: XOR<UserSettingsNullableScalarRelationFilter, UserSettingsWhereInput> | null
    analyticsEntries?: AnalyticsEntryListRelationFilter
    notifications?: NotificationListRelationFilter
    passwordlessTokens?: PasswordlessTokenListRelationFilter
    dailyChallenges?: DailyChallengeListRelationFilter
    externalGoals?: ExternalGoalListRelationFilter
    comments?: CommentListRelationFilter
    contentRatings?: ContentRatingListRelationFilter
    challengeScores?: ChallengeScoreListRelationFilter
    pollVotes?: PollVoteListRelationFilter
    aiRecommendations?: AIRecommendationListRelationFilter
    aiModules?: AIModuleListRelationFilter
    aiModuleQuizAttempts?: AIModuleQuizAttemptListRelationFilter
    aiModuleRatings?: AIModuleRatingListRelationFilter
    UserProgress?: UserProgressListRelationFilter
    AIChat?: AIChatListRelationFilter
    PracticeAttempts?: PracticeAttemptListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    password?: SortOrder
    name?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    xp?: SortOrder
    level?: SortOrder
    streak?: SortOrder
    lastStreakUpdate?: SortOrderInput | SortOrder
    lastLoginDate?: SortOrder
    isAdmin?: SortOrder
    role?: SortOrderInput | SortOrder
    interests?: SortOrder
    learningStyle?: SortOrderInput | SortOrder
    cramMode?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    bio?: StringNullableWithAggregatesFilter<"User"> | string | null
    avatarUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    xp?: IntWithAggregatesFilter<"User"> | number
    level?: IntWithAggregatesFilter<"User"> | number
    streak?: IntWithAggregatesFilter<"User"> | number
    lastStreakUpdate?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    lastLoginDate?: DateTimeWithAggregatesFilter<"User"> | Date | string
    isAdmin?: BoolWithAggregatesFilter<"User"> | boolean
    role?: StringNullableWithAggregatesFilter<"User"> | string | null
    interests?: StringNullableListFilter<"User">
    learningStyle?: JsonNullableWithAggregatesFilter<"User">
    cramMode?: BoolWithAggregatesFilter<"User"> | boolean
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    oauth_token_secret?: StringNullableFilter<"Account"> | string | null
    oauth_token?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    oauth_token_secret?: SortOrderInput | SortOrder
    oauth_token?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    oauth_token_secret?: StringNullableFilter<"Account"> | string | null
    oauth_token?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "provider_providerAccountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    oauth_token_secret?: SortOrderInput | SortOrder
    oauth_token?: SortOrderInput | SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    type?: StringWithAggregatesFilter<"Account"> | string
    provider?: StringWithAggregatesFilter<"Account"> | string
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string
    refresh_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"Account"> | string | null
    oauth_token_secret?: StringNullableWithAggregatesFilter<"Account"> | string | null
    oauth_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "sessionToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    sessionToken?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }

  export type VerificationTokenOrderByWithRelationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    token?: string
    identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }, "token" | "identifier_token">

  export type VerificationTokenOrderByWithAggregationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    OR?: VerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    identifier?: StringWithAggregatesFilter<"VerificationToken"> | string
    token?: StringWithAggregatesFilter<"VerificationToken"> | string
    expires?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
  }

  export type ActivityWhereInput = {
    AND?: ActivityWhereInput | ActivityWhereInput[]
    OR?: ActivityWhereInput[]
    NOT?: ActivityWhereInput | ActivityWhereInput[]
    id?: StringFilter<"Activity"> | string
    userId?: StringFilter<"Activity"> | string
    type?: StringFilter<"Activity"> | string
    description?: StringFilter<"Activity"> | string
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ActivityOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ActivityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ActivityWhereInput | ActivityWhereInput[]
    OR?: ActivityWhereInput[]
    NOT?: ActivityWhereInput | ActivityWhereInput[]
    userId?: StringFilter<"Activity"> | string
    type?: StringFilter<"Activity"> | string
    description?: StringFilter<"Activity"> | string
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ActivityOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    _count?: ActivityCountOrderByAggregateInput
    _max?: ActivityMaxOrderByAggregateInput
    _min?: ActivityMinOrderByAggregateInput
  }

  export type ActivityScalarWhereWithAggregatesInput = {
    AND?: ActivityScalarWhereWithAggregatesInput | ActivityScalarWhereWithAggregatesInput[]
    OR?: ActivityScalarWhereWithAggregatesInput[]
    NOT?: ActivityScalarWhereWithAggregatesInput | ActivityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Activity"> | string
    userId?: StringWithAggregatesFilter<"Activity"> | string
    type?: StringWithAggregatesFilter<"Activity"> | string
    description?: StringWithAggregatesFilter<"Activity"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Activity"> | Date | string
  }

  export type LearningPreferencesWhereInput = {
    AND?: LearningPreferencesWhereInput | LearningPreferencesWhereInput[]
    OR?: LearningPreferencesWhereInput[]
    NOT?: LearningPreferencesWhereInput | LearningPreferencesWhereInput[]
    id?: StringFilter<"LearningPreferences"> | string
    userId?: StringFilter<"LearningPreferences"> | string
    visualLearning?: IntFilter<"LearningPreferences"> | number
    auditoryLearning?: IntFilter<"LearningPreferences"> | number
    kinestheticLearning?: IntFilter<"LearningPreferences"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type LearningPreferencesOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    visualLearning?: SortOrder
    auditoryLearning?: SortOrder
    kinestheticLearning?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type LearningPreferencesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: LearningPreferencesWhereInput | LearningPreferencesWhereInput[]
    OR?: LearningPreferencesWhereInput[]
    NOT?: LearningPreferencesWhereInput | LearningPreferencesWhereInput[]
    visualLearning?: IntFilter<"LearningPreferences"> | number
    auditoryLearning?: IntFilter<"LearningPreferences"> | number
    kinestheticLearning?: IntFilter<"LearningPreferences"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type LearningPreferencesOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    visualLearning?: SortOrder
    auditoryLearning?: SortOrder
    kinestheticLearning?: SortOrder
    _count?: LearningPreferencesCountOrderByAggregateInput
    _avg?: LearningPreferencesAvgOrderByAggregateInput
    _max?: LearningPreferencesMaxOrderByAggregateInput
    _min?: LearningPreferencesMinOrderByAggregateInput
    _sum?: LearningPreferencesSumOrderByAggregateInput
  }

  export type LearningPreferencesScalarWhereWithAggregatesInput = {
    AND?: LearningPreferencesScalarWhereWithAggregatesInput | LearningPreferencesScalarWhereWithAggregatesInput[]
    OR?: LearningPreferencesScalarWhereWithAggregatesInput[]
    NOT?: LearningPreferencesScalarWhereWithAggregatesInput | LearningPreferencesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LearningPreferences"> | string
    userId?: StringWithAggregatesFilter<"LearningPreferences"> | string
    visualLearning?: IntWithAggregatesFilter<"LearningPreferences"> | number
    auditoryLearning?: IntWithAggregatesFilter<"LearningPreferences"> | number
    kinestheticLearning?: IntWithAggregatesFilter<"LearningPreferences"> | number
  }

  export type TopicWhereInput = {
    AND?: TopicWhereInput | TopicWhereInput[]
    OR?: TopicWhereInput[]
    NOT?: TopicWhereInput | TopicWhereInput[]
    id?: StringFilter<"Topic"> | string
    title?: StringFilter<"Topic"> | string
    description?: StringNullableFilter<"Topic"> | string | null
    userId?: StringFilter<"Topic"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    progress?: ProgressListRelationFilter
    learningPathItems?: LearningPathItemListRelationFilter
    contentItems?: ContentItemListRelationFilter
    analyticsEntries?: AnalyticsEntryListRelationFilter
    comments?: CommentListRelationFilter
    prerequisites?: PrerequisiteListRelationFilter
    aiModules?: AIModuleListRelationFilter
    aiModuleQuizAttempts?: AIModuleQuizAttemptListRelationFilter
    aiModuleRatings?: AIModuleRatingListRelationFilter
  }

  export type TopicOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
    progress?: ProgressOrderByRelationAggregateInput
    learningPathItems?: LearningPathItemOrderByRelationAggregateInput
    contentItems?: ContentItemOrderByRelationAggregateInput
    analyticsEntries?: AnalyticsEntryOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    prerequisites?: PrerequisiteOrderByRelationAggregateInput
    aiModules?: AIModuleOrderByRelationAggregateInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptOrderByRelationAggregateInput
    aiModuleRatings?: AIModuleRatingOrderByRelationAggregateInput
  }

  export type TopicWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TopicWhereInput | TopicWhereInput[]
    OR?: TopicWhereInput[]
    NOT?: TopicWhereInput | TopicWhereInput[]
    title?: StringFilter<"Topic"> | string
    description?: StringNullableFilter<"Topic"> | string | null
    userId?: StringFilter<"Topic"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    progress?: ProgressListRelationFilter
    learningPathItems?: LearningPathItemListRelationFilter
    contentItems?: ContentItemListRelationFilter
    analyticsEntries?: AnalyticsEntryListRelationFilter
    comments?: CommentListRelationFilter
    prerequisites?: PrerequisiteListRelationFilter
    aiModules?: AIModuleListRelationFilter
    aiModuleQuizAttempts?: AIModuleQuizAttemptListRelationFilter
    aiModuleRatings?: AIModuleRatingListRelationFilter
  }, "id">

  export type TopicOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    userId?: SortOrder
    _count?: TopicCountOrderByAggregateInput
    _max?: TopicMaxOrderByAggregateInput
    _min?: TopicMinOrderByAggregateInput
  }

  export type TopicScalarWhereWithAggregatesInput = {
    AND?: TopicScalarWhereWithAggregatesInput | TopicScalarWhereWithAggregatesInput[]
    OR?: TopicScalarWhereWithAggregatesInput[]
    NOT?: TopicScalarWhereWithAggregatesInput | TopicScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Topic"> | string
    title?: StringWithAggregatesFilter<"Topic"> | string
    description?: StringNullableWithAggregatesFilter<"Topic"> | string | null
    userId?: StringWithAggregatesFilter<"Topic"> | string
  }

  export type ProgressWhereInput = {
    AND?: ProgressWhereInput | ProgressWhereInput[]
    OR?: ProgressWhereInput[]
    NOT?: ProgressWhereInput | ProgressWhereInput[]
    id?: StringFilter<"Progress"> | string
    userId?: StringFilter<"Progress"> | string
    topicId?: StringFilter<"Progress"> | string
    completed?: FloatFilter<"Progress"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    topic?: XOR<TopicScalarRelationFilter, TopicWhereInput>
  }

  export type ProgressOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    topicId?: SortOrder
    completed?: SortOrder
    user?: UserOrderByWithRelationInput
    topic?: TopicOrderByWithRelationInput
  }

  export type ProgressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProgressWhereInput | ProgressWhereInput[]
    OR?: ProgressWhereInput[]
    NOT?: ProgressWhereInput | ProgressWhereInput[]
    userId?: StringFilter<"Progress"> | string
    topicId?: StringFilter<"Progress"> | string
    completed?: FloatFilter<"Progress"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    topic?: XOR<TopicScalarRelationFilter, TopicWhereInput>
  }, "id">

  export type ProgressOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    topicId?: SortOrder
    completed?: SortOrder
    _count?: ProgressCountOrderByAggregateInput
    _avg?: ProgressAvgOrderByAggregateInput
    _max?: ProgressMaxOrderByAggregateInput
    _min?: ProgressMinOrderByAggregateInput
    _sum?: ProgressSumOrderByAggregateInput
  }

  export type ProgressScalarWhereWithAggregatesInput = {
    AND?: ProgressScalarWhereWithAggregatesInput | ProgressScalarWhereWithAggregatesInput[]
    OR?: ProgressScalarWhereWithAggregatesInput[]
    NOT?: ProgressScalarWhereWithAggregatesInput | ProgressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Progress"> | string
    userId?: StringWithAggregatesFilter<"Progress"> | string
    topicId?: StringWithAggregatesFilter<"Progress"> | string
    completed?: FloatWithAggregatesFilter<"Progress"> | number
  }

  export type BadgeWhereInput = {
    AND?: BadgeWhereInput | BadgeWhereInput[]
    OR?: BadgeWhereInput[]
    NOT?: BadgeWhereInput | BadgeWhereInput[]
    id?: StringFilter<"Badge"> | string
    name?: StringFilter<"Badge"> | string
    description?: StringNullableFilter<"Badge"> | string | null
    imageUrl?: StringNullableFilter<"Badge"> | string | null
    userId?: StringFilter<"Badge"> | string
    earnedAt?: DateTimeFilter<"Badge"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type BadgeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    userId?: SortOrder
    earnedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type BadgeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BadgeWhereInput | BadgeWhereInput[]
    OR?: BadgeWhereInput[]
    NOT?: BadgeWhereInput | BadgeWhereInput[]
    name?: StringFilter<"Badge"> | string
    description?: StringNullableFilter<"Badge"> | string | null
    imageUrl?: StringNullableFilter<"Badge"> | string | null
    userId?: StringFilter<"Badge"> | string
    earnedAt?: DateTimeFilter<"Badge"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type BadgeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    userId?: SortOrder
    earnedAt?: SortOrder
    _count?: BadgeCountOrderByAggregateInput
    _max?: BadgeMaxOrderByAggregateInput
    _min?: BadgeMinOrderByAggregateInput
  }

  export type BadgeScalarWhereWithAggregatesInput = {
    AND?: BadgeScalarWhereWithAggregatesInput | BadgeScalarWhereWithAggregatesInput[]
    OR?: BadgeScalarWhereWithAggregatesInput[]
    NOT?: BadgeScalarWhereWithAggregatesInput | BadgeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Badge"> | string
    name?: StringWithAggregatesFilter<"Badge"> | string
    description?: StringNullableWithAggregatesFilter<"Badge"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"Badge"> | string | null
    userId?: StringWithAggregatesFilter<"Badge"> | string
    earnedAt?: DateTimeWithAggregatesFilter<"Badge"> | Date | string
  }

  export type UpcomingReviewWhereInput = {
    AND?: UpcomingReviewWhereInput | UpcomingReviewWhereInput[]
    OR?: UpcomingReviewWhereInput[]
    NOT?: UpcomingReviewWhereInput | UpcomingReviewWhereInput[]
    id?: StringFilter<"UpcomingReview"> | string
    userId?: StringFilter<"UpcomingReview"> | string
    topicId?: StringFilter<"UpcomingReview"> | string
    dueDate?: DateTimeFilter<"UpcomingReview"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UpcomingReviewOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    topicId?: SortOrder
    dueDate?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UpcomingReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UpcomingReviewWhereInput | UpcomingReviewWhereInput[]
    OR?: UpcomingReviewWhereInput[]
    NOT?: UpcomingReviewWhereInput | UpcomingReviewWhereInput[]
    userId?: StringFilter<"UpcomingReview"> | string
    topicId?: StringFilter<"UpcomingReview"> | string
    dueDate?: DateTimeFilter<"UpcomingReview"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type UpcomingReviewOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    topicId?: SortOrder
    dueDate?: SortOrder
    _count?: UpcomingReviewCountOrderByAggregateInput
    _max?: UpcomingReviewMaxOrderByAggregateInput
    _min?: UpcomingReviewMinOrderByAggregateInput
  }

  export type UpcomingReviewScalarWhereWithAggregatesInput = {
    AND?: UpcomingReviewScalarWhereWithAggregatesInput | UpcomingReviewScalarWhereWithAggregatesInput[]
    OR?: UpcomingReviewScalarWhereWithAggregatesInput[]
    NOT?: UpcomingReviewScalarWhereWithAggregatesInput | UpcomingReviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UpcomingReview"> | string
    userId?: StringWithAggregatesFilter<"UpcomingReview"> | string
    topicId?: StringWithAggregatesFilter<"UpcomingReview"> | string
    dueDate?: DateTimeWithAggregatesFilter<"UpcomingReview"> | Date | string
  }

  export type LearningPathWhereInput = {
    AND?: LearningPathWhereInput | LearningPathWhereInput[]
    OR?: LearningPathWhereInput[]
    NOT?: LearningPathWhereInput | LearningPathWhereInput[]
    id?: StringFilter<"LearningPath"> | string
    title?: StringFilter<"LearningPath"> | string
    description?: StringNullableFilter<"LearningPath"> | string | null
    userId?: StringFilter<"LearningPath"> | string
    content?: JsonFilter<"LearningPath">
    createdAt?: DateTimeFilter<"LearningPath"> | Date | string
    updatedAt?: DateTimeFilter<"LearningPath"> | Date | string
    shareId?: StringNullableFilter<"LearningPath"> | string | null
    sharedAt?: DateTimeNullableFilter<"LearningPath"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    items?: LearningPathItemListRelationFilter
    prerequisites?: PrerequisiteListRelationFilter
    aiModuleItems?: AIModuleLearningPathItemListRelationFilter
    UserProgress?: UserProgressListRelationFilter
  }

  export type LearningPathOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    shareId?: SortOrderInput | SortOrder
    sharedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    items?: LearningPathItemOrderByRelationAggregateInput
    prerequisites?: PrerequisiteOrderByRelationAggregateInput
    aiModuleItems?: AIModuleLearningPathItemOrderByRelationAggregateInput
    UserProgress?: UserProgressOrderByRelationAggregateInput
  }

  export type LearningPathWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    shareId?: string
    AND?: LearningPathWhereInput | LearningPathWhereInput[]
    OR?: LearningPathWhereInput[]
    NOT?: LearningPathWhereInput | LearningPathWhereInput[]
    title?: StringFilter<"LearningPath"> | string
    description?: StringNullableFilter<"LearningPath"> | string | null
    userId?: StringFilter<"LearningPath"> | string
    content?: JsonFilter<"LearningPath">
    createdAt?: DateTimeFilter<"LearningPath"> | Date | string
    updatedAt?: DateTimeFilter<"LearningPath"> | Date | string
    sharedAt?: DateTimeNullableFilter<"LearningPath"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    items?: LearningPathItemListRelationFilter
    prerequisites?: PrerequisiteListRelationFilter
    aiModuleItems?: AIModuleLearningPathItemListRelationFilter
    UserProgress?: UserProgressListRelationFilter
  }, "id" | "shareId">

  export type LearningPathOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    shareId?: SortOrderInput | SortOrder
    sharedAt?: SortOrderInput | SortOrder
    _count?: LearningPathCountOrderByAggregateInput
    _max?: LearningPathMaxOrderByAggregateInput
    _min?: LearningPathMinOrderByAggregateInput
  }

  export type LearningPathScalarWhereWithAggregatesInput = {
    AND?: LearningPathScalarWhereWithAggregatesInput | LearningPathScalarWhereWithAggregatesInput[]
    OR?: LearningPathScalarWhereWithAggregatesInput[]
    NOT?: LearningPathScalarWhereWithAggregatesInput | LearningPathScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LearningPath"> | string
    title?: StringWithAggregatesFilter<"LearningPath"> | string
    description?: StringNullableWithAggregatesFilter<"LearningPath"> | string | null
    userId?: StringWithAggregatesFilter<"LearningPath"> | string
    content?: JsonWithAggregatesFilter<"LearningPath">
    createdAt?: DateTimeWithAggregatesFilter<"LearningPath"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LearningPath"> | Date | string
    shareId?: StringNullableWithAggregatesFilter<"LearningPath"> | string | null
    sharedAt?: DateTimeNullableWithAggregatesFilter<"LearningPath"> | Date | string | null
  }

  export type LearningPathItemWhereInput = {
    AND?: LearningPathItemWhereInput | LearningPathItemWhereInput[]
    OR?: LearningPathItemWhereInput[]
    NOT?: LearningPathItemWhereInput | LearningPathItemWhereInput[]
    id?: StringFilter<"LearningPathItem"> | string
    order?: IntFilter<"LearningPathItem"> | number
    learningPathId?: StringFilter<"LearningPathItem"> | string
    topicId?: StringFilter<"LearningPathItem"> | string
    confidence?: IntFilter<"LearningPathItem"> | number
    learningPath?: XOR<LearningPathScalarRelationFilter, LearningPathWhereInput>
    topic?: XOR<TopicScalarRelationFilter, TopicWhereInput>
    UserProgress?: UserProgressListRelationFilter
  }

  export type LearningPathItemOrderByWithRelationInput = {
    id?: SortOrder
    order?: SortOrder
    learningPathId?: SortOrder
    topicId?: SortOrder
    confidence?: SortOrder
    learningPath?: LearningPathOrderByWithRelationInput
    topic?: TopicOrderByWithRelationInput
    UserProgress?: UserProgressOrderByRelationAggregateInput
  }

  export type LearningPathItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LearningPathItemWhereInput | LearningPathItemWhereInput[]
    OR?: LearningPathItemWhereInput[]
    NOT?: LearningPathItemWhereInput | LearningPathItemWhereInput[]
    order?: IntFilter<"LearningPathItem"> | number
    learningPathId?: StringFilter<"LearningPathItem"> | string
    topicId?: StringFilter<"LearningPathItem"> | string
    confidence?: IntFilter<"LearningPathItem"> | number
    learningPath?: XOR<LearningPathScalarRelationFilter, LearningPathWhereInput>
    topic?: XOR<TopicScalarRelationFilter, TopicWhereInput>
    UserProgress?: UserProgressListRelationFilter
  }, "id">

  export type LearningPathItemOrderByWithAggregationInput = {
    id?: SortOrder
    order?: SortOrder
    learningPathId?: SortOrder
    topicId?: SortOrder
    confidence?: SortOrder
    _count?: LearningPathItemCountOrderByAggregateInput
    _avg?: LearningPathItemAvgOrderByAggregateInput
    _max?: LearningPathItemMaxOrderByAggregateInput
    _min?: LearningPathItemMinOrderByAggregateInput
    _sum?: LearningPathItemSumOrderByAggregateInput
  }

  export type LearningPathItemScalarWhereWithAggregatesInput = {
    AND?: LearningPathItemScalarWhereWithAggregatesInput | LearningPathItemScalarWhereWithAggregatesInput[]
    OR?: LearningPathItemScalarWhereWithAggregatesInput[]
    NOT?: LearningPathItemScalarWhereWithAggregatesInput | LearningPathItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LearningPathItem"> | string
    order?: IntWithAggregatesFilter<"LearningPathItem"> | number
    learningPathId?: StringWithAggregatesFilter<"LearningPathItem"> | string
    topicId?: StringWithAggregatesFilter<"LearningPathItem"> | string
    confidence?: IntWithAggregatesFilter<"LearningPathItem"> | number
  }

  export type ContentItemWhereInput = {
    AND?: ContentItemWhereInput | ContentItemWhereInput[]
    OR?: ContentItemWhereInput[]
    NOT?: ContentItemWhereInput | ContentItemWhereInput[]
    id?: StringFilter<"ContentItem"> | string
    title?: StringFilter<"ContentItem"> | string
    description?: StringNullableFilter<"ContentItem"> | string | null
    content?: StringFilter<"ContentItem"> | string
    type?: StringFilter<"ContentItem"> | string
    difficulty?: StringFilter<"ContentItem"> | string
    topicId?: StringFilter<"ContentItem"> | string
    createdAt?: DateTimeFilter<"ContentItem"> | Date | string
    updatedAt?: DateTimeFilter<"ContentItem"> | Date | string
    version?: StringFilter<"ContentItem"> | string
    topic?: XOR<TopicScalarRelationFilter, TopicWhereInput>
    bookmarks?: BookmarkListRelationFilter
    quizAttempts?: QuizAttemptListRelationFilter
    reviewItems?: ReviewItemListRelationFilter
    ratings?: ContentRatingListRelationFilter
    aiPlaylistItems?: AIPlaylistItemListRelationFilter
  }

  export type ContentItemOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    content?: SortOrder
    type?: SortOrder
    difficulty?: SortOrder
    topicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    version?: SortOrder
    topic?: TopicOrderByWithRelationInput
    bookmarks?: BookmarkOrderByRelationAggregateInput
    quizAttempts?: QuizAttemptOrderByRelationAggregateInput
    reviewItems?: ReviewItemOrderByRelationAggregateInput
    ratings?: ContentRatingOrderByRelationAggregateInput
    aiPlaylistItems?: AIPlaylistItemOrderByRelationAggregateInput
  }

  export type ContentItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContentItemWhereInput | ContentItemWhereInput[]
    OR?: ContentItemWhereInput[]
    NOT?: ContentItemWhereInput | ContentItemWhereInput[]
    title?: StringFilter<"ContentItem"> | string
    description?: StringNullableFilter<"ContentItem"> | string | null
    content?: StringFilter<"ContentItem"> | string
    type?: StringFilter<"ContentItem"> | string
    difficulty?: StringFilter<"ContentItem"> | string
    topicId?: StringFilter<"ContentItem"> | string
    createdAt?: DateTimeFilter<"ContentItem"> | Date | string
    updatedAt?: DateTimeFilter<"ContentItem"> | Date | string
    version?: StringFilter<"ContentItem"> | string
    topic?: XOR<TopicScalarRelationFilter, TopicWhereInput>
    bookmarks?: BookmarkListRelationFilter
    quizAttempts?: QuizAttemptListRelationFilter
    reviewItems?: ReviewItemListRelationFilter
    ratings?: ContentRatingListRelationFilter
    aiPlaylistItems?: AIPlaylistItemListRelationFilter
  }, "id">

  export type ContentItemOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    content?: SortOrder
    type?: SortOrder
    difficulty?: SortOrder
    topicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    version?: SortOrder
    _count?: ContentItemCountOrderByAggregateInput
    _max?: ContentItemMaxOrderByAggregateInput
    _min?: ContentItemMinOrderByAggregateInput
  }

  export type ContentItemScalarWhereWithAggregatesInput = {
    AND?: ContentItemScalarWhereWithAggregatesInput | ContentItemScalarWhereWithAggregatesInput[]
    OR?: ContentItemScalarWhereWithAggregatesInput[]
    NOT?: ContentItemScalarWhereWithAggregatesInput | ContentItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContentItem"> | string
    title?: StringWithAggregatesFilter<"ContentItem"> | string
    description?: StringNullableWithAggregatesFilter<"ContentItem"> | string | null
    content?: StringWithAggregatesFilter<"ContentItem"> | string
    type?: StringWithAggregatesFilter<"ContentItem"> | string
    difficulty?: StringWithAggregatesFilter<"ContentItem"> | string
    topicId?: StringWithAggregatesFilter<"ContentItem"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ContentItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContentItem"> | Date | string
    version?: StringWithAggregatesFilter<"ContentItem"> | string
  }

  export type ContentRatingWhereInput = {
    AND?: ContentRatingWhereInput | ContentRatingWhereInput[]
    OR?: ContentRatingWhereInput[]
    NOT?: ContentRatingWhereInput | ContentRatingWhereInput[]
    id?: StringFilter<"ContentRating"> | string
    userId?: StringFilter<"ContentRating"> | string
    contentItemId?: StringFilter<"ContentRating"> | string
    rating?: IntFilter<"ContentRating"> | number
    createdAt?: DateTimeFilter<"ContentRating"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    contentItem?: XOR<ContentItemScalarRelationFilter, ContentItemWhereInput>
  }

  export type ContentRatingOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    contentItemId?: SortOrder
    rating?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    contentItem?: ContentItemOrderByWithRelationInput
  }

  export type ContentRatingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_contentItemId?: ContentRatingUserIdContentItemIdCompoundUniqueInput
    AND?: ContentRatingWhereInput | ContentRatingWhereInput[]
    OR?: ContentRatingWhereInput[]
    NOT?: ContentRatingWhereInput | ContentRatingWhereInput[]
    userId?: StringFilter<"ContentRating"> | string
    contentItemId?: StringFilter<"ContentRating"> | string
    rating?: IntFilter<"ContentRating"> | number
    createdAt?: DateTimeFilter<"ContentRating"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    contentItem?: XOR<ContentItemScalarRelationFilter, ContentItemWhereInput>
  }, "id" | "userId_contentItemId">

  export type ContentRatingOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    contentItemId?: SortOrder
    rating?: SortOrder
    createdAt?: SortOrder
    _count?: ContentRatingCountOrderByAggregateInput
    _avg?: ContentRatingAvgOrderByAggregateInput
    _max?: ContentRatingMaxOrderByAggregateInput
    _min?: ContentRatingMinOrderByAggregateInput
    _sum?: ContentRatingSumOrderByAggregateInput
  }

  export type ContentRatingScalarWhereWithAggregatesInput = {
    AND?: ContentRatingScalarWhereWithAggregatesInput | ContentRatingScalarWhereWithAggregatesInput[]
    OR?: ContentRatingScalarWhereWithAggregatesInput[]
    NOT?: ContentRatingScalarWhereWithAggregatesInput | ContentRatingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContentRating"> | string
    userId?: StringWithAggregatesFilter<"ContentRating"> | string
    contentItemId?: StringWithAggregatesFilter<"ContentRating"> | string
    rating?: IntWithAggregatesFilter<"ContentRating"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ContentRating"> | Date | string
  }

  export type BookmarkWhereInput = {
    AND?: BookmarkWhereInput | BookmarkWhereInput[]
    OR?: BookmarkWhereInput[]
    NOT?: BookmarkWhereInput | BookmarkWhereInput[]
    id?: StringFilter<"Bookmark"> | string
    userId?: StringFilter<"Bookmark"> | string
    contentItemId?: StringFilter<"Bookmark"> | string
    createdAt?: DateTimeFilter<"Bookmark"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    contentItem?: XOR<ContentItemScalarRelationFilter, ContentItemWhereInput>
  }

  export type BookmarkOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    contentItemId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    contentItem?: ContentItemOrderByWithRelationInput
  }

  export type BookmarkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BookmarkWhereInput | BookmarkWhereInput[]
    OR?: BookmarkWhereInput[]
    NOT?: BookmarkWhereInput | BookmarkWhereInput[]
    userId?: StringFilter<"Bookmark"> | string
    contentItemId?: StringFilter<"Bookmark"> | string
    createdAt?: DateTimeFilter<"Bookmark"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    contentItem?: XOR<ContentItemScalarRelationFilter, ContentItemWhereInput>
  }, "id">

  export type BookmarkOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    contentItemId?: SortOrder
    createdAt?: SortOrder
    _count?: BookmarkCountOrderByAggregateInput
    _max?: BookmarkMaxOrderByAggregateInput
    _min?: BookmarkMinOrderByAggregateInput
  }

  export type BookmarkScalarWhereWithAggregatesInput = {
    AND?: BookmarkScalarWhereWithAggregatesInput | BookmarkScalarWhereWithAggregatesInput[]
    OR?: BookmarkScalarWhereWithAggregatesInput[]
    NOT?: BookmarkScalarWhereWithAggregatesInput | BookmarkScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Bookmark"> | string
    userId?: StringWithAggregatesFilter<"Bookmark"> | string
    contentItemId?: StringWithAggregatesFilter<"Bookmark"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Bookmark"> | Date | string
  }

  export type QuizAttemptWhereInput = {
    AND?: QuizAttemptWhereInput | QuizAttemptWhereInput[]
    OR?: QuizAttemptWhereInput[]
    NOT?: QuizAttemptWhereInput | QuizAttemptWhereInput[]
    id?: StringFilter<"QuizAttempt"> | string
    userId?: StringFilter<"QuizAttempt"> | string
    contentItemId?: StringFilter<"QuizAttempt"> | string
    score?: FloatFilter<"QuizAttempt"> | number
    startedAt?: DateTimeFilter<"QuizAttempt"> | Date | string
    completedAt?: DateTimeNullableFilter<"QuizAttempt"> | Date | string | null
    answers?: JsonNullableFilter<"QuizAttempt">
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    contentItem?: XOR<ContentItemScalarRelationFilter, ContentItemWhereInput>
  }

  export type QuizAttemptOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    contentItemId?: SortOrder
    score?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    answers?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    contentItem?: ContentItemOrderByWithRelationInput
  }

  export type QuizAttemptWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QuizAttemptWhereInput | QuizAttemptWhereInput[]
    OR?: QuizAttemptWhereInput[]
    NOT?: QuizAttemptWhereInput | QuizAttemptWhereInput[]
    userId?: StringFilter<"QuizAttempt"> | string
    contentItemId?: StringFilter<"QuizAttempt"> | string
    score?: FloatFilter<"QuizAttempt"> | number
    startedAt?: DateTimeFilter<"QuizAttempt"> | Date | string
    completedAt?: DateTimeNullableFilter<"QuizAttempt"> | Date | string | null
    answers?: JsonNullableFilter<"QuizAttempt">
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    contentItem?: XOR<ContentItemScalarRelationFilter, ContentItemWhereInput>
  }, "id">

  export type QuizAttemptOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    contentItemId?: SortOrder
    score?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    answers?: SortOrderInput | SortOrder
    _count?: QuizAttemptCountOrderByAggregateInput
    _avg?: QuizAttemptAvgOrderByAggregateInput
    _max?: QuizAttemptMaxOrderByAggregateInput
    _min?: QuizAttemptMinOrderByAggregateInput
    _sum?: QuizAttemptSumOrderByAggregateInput
  }

  export type QuizAttemptScalarWhereWithAggregatesInput = {
    AND?: QuizAttemptScalarWhereWithAggregatesInput | QuizAttemptScalarWhereWithAggregatesInput[]
    OR?: QuizAttemptScalarWhereWithAggregatesInput[]
    NOT?: QuizAttemptScalarWhereWithAggregatesInput | QuizAttemptScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QuizAttempt"> | string
    userId?: StringWithAggregatesFilter<"QuizAttempt"> | string
    contentItemId?: StringWithAggregatesFilter<"QuizAttempt"> | string
    score?: FloatWithAggregatesFilter<"QuizAttempt"> | number
    startedAt?: DateTimeWithAggregatesFilter<"QuizAttempt"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"QuizAttempt"> | Date | string | null
    answers?: JsonNullableWithAggregatesFilter<"QuizAttempt">
  }

  export type KnowledgeNodeWhereInput = {
    AND?: KnowledgeNodeWhereInput | KnowledgeNodeWhereInput[]
    OR?: KnowledgeNodeWhereInput[]
    NOT?: KnowledgeNodeWhereInput | KnowledgeNodeWhereInput[]
    id?: StringFilter<"KnowledgeNode"> | string
    title?: StringFilter<"KnowledgeNode"> | string
    description?: StringNullableFilter<"KnowledgeNode"> | string | null
    userId?: StringFilter<"KnowledgeNode"> | string
    parentId?: StringNullableFilter<"KnowledgeNode"> | string | null
    createdAt?: DateTimeFilter<"KnowledgeNode"> | Date | string
    updatedAt?: DateTimeFilter<"KnowledgeNode"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    parent?: XOR<KnowledgeNodeNullableScalarRelationFilter, KnowledgeNodeWhereInput> | null
    children?: KnowledgeNodeListRelationFilter
  }

  export type KnowledgeNodeOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    userId?: SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    parent?: KnowledgeNodeOrderByWithRelationInput
    children?: KnowledgeNodeOrderByRelationAggregateInput
  }

  export type KnowledgeNodeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: KnowledgeNodeWhereInput | KnowledgeNodeWhereInput[]
    OR?: KnowledgeNodeWhereInput[]
    NOT?: KnowledgeNodeWhereInput | KnowledgeNodeWhereInput[]
    title?: StringFilter<"KnowledgeNode"> | string
    description?: StringNullableFilter<"KnowledgeNode"> | string | null
    userId?: StringFilter<"KnowledgeNode"> | string
    parentId?: StringNullableFilter<"KnowledgeNode"> | string | null
    createdAt?: DateTimeFilter<"KnowledgeNode"> | Date | string
    updatedAt?: DateTimeFilter<"KnowledgeNode"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    parent?: XOR<KnowledgeNodeNullableScalarRelationFilter, KnowledgeNodeWhereInput> | null
    children?: KnowledgeNodeListRelationFilter
  }, "id">

  export type KnowledgeNodeOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    userId?: SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: KnowledgeNodeCountOrderByAggregateInput
    _max?: KnowledgeNodeMaxOrderByAggregateInput
    _min?: KnowledgeNodeMinOrderByAggregateInput
  }

  export type KnowledgeNodeScalarWhereWithAggregatesInput = {
    AND?: KnowledgeNodeScalarWhereWithAggregatesInput | KnowledgeNodeScalarWhereWithAggregatesInput[]
    OR?: KnowledgeNodeScalarWhereWithAggregatesInput[]
    NOT?: KnowledgeNodeScalarWhereWithAggregatesInput | KnowledgeNodeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"KnowledgeNode"> | string
    title?: StringWithAggregatesFilter<"KnowledgeNode"> | string
    description?: StringNullableWithAggregatesFilter<"KnowledgeNode"> | string | null
    userId?: StringWithAggregatesFilter<"KnowledgeNode"> | string
    parentId?: StringNullableWithAggregatesFilter<"KnowledgeNode"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"KnowledgeNode"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"KnowledgeNode"> | Date | string
  }

  export type LeaderboardEntryWhereInput = {
    AND?: LeaderboardEntryWhereInput | LeaderboardEntryWhereInput[]
    OR?: LeaderboardEntryWhereInput[]
    NOT?: LeaderboardEntryWhereInput | LeaderboardEntryWhereInput[]
    id?: StringFilter<"LeaderboardEntry"> | string
    userId?: StringFilter<"LeaderboardEntry"> | string
    score?: IntFilter<"LeaderboardEntry"> | number
    type?: StringFilter<"LeaderboardEntry"> | string
    startDate?: DateTimeFilter<"LeaderboardEntry"> | Date | string
    endDate?: DateTimeFilter<"LeaderboardEntry"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type LeaderboardEntryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    score?: SortOrder
    type?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type LeaderboardEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LeaderboardEntryWhereInput | LeaderboardEntryWhereInput[]
    OR?: LeaderboardEntryWhereInput[]
    NOT?: LeaderboardEntryWhereInput | LeaderboardEntryWhereInput[]
    userId?: StringFilter<"LeaderboardEntry"> | string
    score?: IntFilter<"LeaderboardEntry"> | number
    type?: StringFilter<"LeaderboardEntry"> | string
    startDate?: DateTimeFilter<"LeaderboardEntry"> | Date | string
    endDate?: DateTimeFilter<"LeaderboardEntry"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type LeaderboardEntryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    score?: SortOrder
    type?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    _count?: LeaderboardEntryCountOrderByAggregateInput
    _avg?: LeaderboardEntryAvgOrderByAggregateInput
    _max?: LeaderboardEntryMaxOrderByAggregateInput
    _min?: LeaderboardEntryMinOrderByAggregateInput
    _sum?: LeaderboardEntrySumOrderByAggregateInput
  }

  export type LeaderboardEntryScalarWhereWithAggregatesInput = {
    AND?: LeaderboardEntryScalarWhereWithAggregatesInput | LeaderboardEntryScalarWhereWithAggregatesInput[]
    OR?: LeaderboardEntryScalarWhereWithAggregatesInput[]
    NOT?: LeaderboardEntryScalarWhereWithAggregatesInput | LeaderboardEntryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LeaderboardEntry"> | string
    userId?: StringWithAggregatesFilter<"LeaderboardEntry"> | string
    score?: IntWithAggregatesFilter<"LeaderboardEntry"> | number
    type?: StringWithAggregatesFilter<"LeaderboardEntry"> | string
    startDate?: DateTimeWithAggregatesFilter<"LeaderboardEntry"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"LeaderboardEntry"> | Date | string
  }

  export type ReviewSessionWhereInput = {
    AND?: ReviewSessionWhereInput | ReviewSessionWhereInput[]
    OR?: ReviewSessionWhereInput[]
    NOT?: ReviewSessionWhereInput | ReviewSessionWhereInput[]
    id?: StringFilter<"ReviewSession"> | string
    userId?: StringFilter<"ReviewSession"> | string
    dueDate?: DateTimeFilter<"ReviewSession"> | Date | string
    completed?: BoolFilter<"ReviewSession"> | boolean
    isUrgent?: BoolFilter<"ReviewSession"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    items?: ReviewItemListRelationFilter
  }

  export type ReviewSessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    dueDate?: SortOrder
    completed?: SortOrder
    isUrgent?: SortOrder
    user?: UserOrderByWithRelationInput
    items?: ReviewItemOrderByRelationAggregateInput
  }

  export type ReviewSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReviewSessionWhereInput | ReviewSessionWhereInput[]
    OR?: ReviewSessionWhereInput[]
    NOT?: ReviewSessionWhereInput | ReviewSessionWhereInput[]
    userId?: StringFilter<"ReviewSession"> | string
    dueDate?: DateTimeFilter<"ReviewSession"> | Date | string
    completed?: BoolFilter<"ReviewSession"> | boolean
    isUrgent?: BoolFilter<"ReviewSession"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    items?: ReviewItemListRelationFilter
  }, "id">

  export type ReviewSessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    dueDate?: SortOrder
    completed?: SortOrder
    isUrgent?: SortOrder
    _count?: ReviewSessionCountOrderByAggregateInput
    _max?: ReviewSessionMaxOrderByAggregateInput
    _min?: ReviewSessionMinOrderByAggregateInput
  }

  export type ReviewSessionScalarWhereWithAggregatesInput = {
    AND?: ReviewSessionScalarWhereWithAggregatesInput | ReviewSessionScalarWhereWithAggregatesInput[]
    OR?: ReviewSessionScalarWhereWithAggregatesInput[]
    NOT?: ReviewSessionScalarWhereWithAggregatesInput | ReviewSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReviewSession"> | string
    userId?: StringWithAggregatesFilter<"ReviewSession"> | string
    dueDate?: DateTimeWithAggregatesFilter<"ReviewSession"> | Date | string
    completed?: BoolWithAggregatesFilter<"ReviewSession"> | boolean
    isUrgent?: BoolWithAggregatesFilter<"ReviewSession"> | boolean
  }

  export type ReviewItemWhereInput = {
    AND?: ReviewItemWhereInput | ReviewItemWhereInput[]
    OR?: ReviewItemWhereInput[]
    NOT?: ReviewItemWhereInput | ReviewItemWhereInput[]
    id?: StringFilter<"ReviewItem"> | string
    reviewSessionId?: StringFilter<"ReviewItem"> | string
    contentItemId?: StringFilter<"ReviewItem"> | string
    type?: StringFilter<"ReviewItem"> | string
    question?: StringFilter<"ReviewItem"> | string
    answer?: StringFilter<"ReviewItem"> | string
    userAnswer?: StringNullableFilter<"ReviewItem"> | string | null
    isCorrect?: BoolNullableFilter<"ReviewItem"> | boolean | null
    answeredAt?: DateTimeNullableFilter<"ReviewItem"> | Date | string | null
    reviewSession?: XOR<ReviewSessionScalarRelationFilter, ReviewSessionWhereInput>
    contentItem?: XOR<ContentItemScalarRelationFilter, ContentItemWhereInput>
  }

  export type ReviewItemOrderByWithRelationInput = {
    id?: SortOrder
    reviewSessionId?: SortOrder
    contentItemId?: SortOrder
    type?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    userAnswer?: SortOrderInput | SortOrder
    isCorrect?: SortOrderInput | SortOrder
    answeredAt?: SortOrderInput | SortOrder
    reviewSession?: ReviewSessionOrderByWithRelationInput
    contentItem?: ContentItemOrderByWithRelationInput
  }

  export type ReviewItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReviewItemWhereInput | ReviewItemWhereInput[]
    OR?: ReviewItemWhereInput[]
    NOT?: ReviewItemWhereInput | ReviewItemWhereInput[]
    reviewSessionId?: StringFilter<"ReviewItem"> | string
    contentItemId?: StringFilter<"ReviewItem"> | string
    type?: StringFilter<"ReviewItem"> | string
    question?: StringFilter<"ReviewItem"> | string
    answer?: StringFilter<"ReviewItem"> | string
    userAnswer?: StringNullableFilter<"ReviewItem"> | string | null
    isCorrect?: BoolNullableFilter<"ReviewItem"> | boolean | null
    answeredAt?: DateTimeNullableFilter<"ReviewItem"> | Date | string | null
    reviewSession?: XOR<ReviewSessionScalarRelationFilter, ReviewSessionWhereInput>
    contentItem?: XOR<ContentItemScalarRelationFilter, ContentItemWhereInput>
  }, "id">

  export type ReviewItemOrderByWithAggregationInput = {
    id?: SortOrder
    reviewSessionId?: SortOrder
    contentItemId?: SortOrder
    type?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    userAnswer?: SortOrderInput | SortOrder
    isCorrect?: SortOrderInput | SortOrder
    answeredAt?: SortOrderInput | SortOrder
    _count?: ReviewItemCountOrderByAggregateInput
    _max?: ReviewItemMaxOrderByAggregateInput
    _min?: ReviewItemMinOrderByAggregateInput
  }

  export type ReviewItemScalarWhereWithAggregatesInput = {
    AND?: ReviewItemScalarWhereWithAggregatesInput | ReviewItemScalarWhereWithAggregatesInput[]
    OR?: ReviewItemScalarWhereWithAggregatesInput[]
    NOT?: ReviewItemScalarWhereWithAggregatesInput | ReviewItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReviewItem"> | string
    reviewSessionId?: StringWithAggregatesFilter<"ReviewItem"> | string
    contentItemId?: StringWithAggregatesFilter<"ReviewItem"> | string
    type?: StringWithAggregatesFilter<"ReviewItem"> | string
    question?: StringWithAggregatesFilter<"ReviewItem"> | string
    answer?: StringWithAggregatesFilter<"ReviewItem"> | string
    userAnswer?: StringNullableWithAggregatesFilter<"ReviewItem"> | string | null
    isCorrect?: BoolNullableWithAggregatesFilter<"ReviewItem"> | boolean | null
    answeredAt?: DateTimeNullableWithAggregatesFilter<"ReviewItem"> | Date | string | null
  }

  export type WorkspaceWhereInput = {
    AND?: WorkspaceWhereInput | WorkspaceWhereInput[]
    OR?: WorkspaceWhereInput[]
    NOT?: WorkspaceWhereInput | WorkspaceWhereInput[]
    id?: StringFilter<"Workspace"> | string
    name?: StringFilter<"Workspace"> | string
    description?: StringNullableFilter<"Workspace"> | string | null
    createdAt?: DateTimeFilter<"Workspace"> | Date | string
    updatedAt?: DateTimeFilter<"Workspace"> | Date | string
    ownerId?: StringFilter<"Workspace"> | string
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    members?: WorkspaceMemberListRelationFilter
    whiteboards?: WhiteboardListRelationFilter
    chats?: ChatListRelationFilter
    breakoutRooms?: BreakoutRoomListRelationFilter
    livePolls?: LivePollListRelationFilter
    sessionSummaries?: SessionSummaryListRelationFilter
  }

  export type WorkspaceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ownerId?: SortOrder
    owner?: UserOrderByWithRelationInput
    members?: WorkspaceMemberOrderByRelationAggregateInput
    whiteboards?: WhiteboardOrderByRelationAggregateInput
    chats?: ChatOrderByRelationAggregateInput
    breakoutRooms?: BreakoutRoomOrderByRelationAggregateInput
    livePolls?: LivePollOrderByRelationAggregateInput
    sessionSummaries?: SessionSummaryOrderByRelationAggregateInput
  }

  export type WorkspaceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkspaceWhereInput | WorkspaceWhereInput[]
    OR?: WorkspaceWhereInput[]
    NOT?: WorkspaceWhereInput | WorkspaceWhereInput[]
    name?: StringFilter<"Workspace"> | string
    description?: StringNullableFilter<"Workspace"> | string | null
    createdAt?: DateTimeFilter<"Workspace"> | Date | string
    updatedAt?: DateTimeFilter<"Workspace"> | Date | string
    ownerId?: StringFilter<"Workspace"> | string
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    members?: WorkspaceMemberListRelationFilter
    whiteboards?: WhiteboardListRelationFilter
    chats?: ChatListRelationFilter
    breakoutRooms?: BreakoutRoomListRelationFilter
    livePolls?: LivePollListRelationFilter
    sessionSummaries?: SessionSummaryListRelationFilter
  }, "id">

  export type WorkspaceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ownerId?: SortOrder
    _count?: WorkspaceCountOrderByAggregateInput
    _max?: WorkspaceMaxOrderByAggregateInput
    _min?: WorkspaceMinOrderByAggregateInput
  }

  export type WorkspaceScalarWhereWithAggregatesInput = {
    AND?: WorkspaceScalarWhereWithAggregatesInput | WorkspaceScalarWhereWithAggregatesInput[]
    OR?: WorkspaceScalarWhereWithAggregatesInput[]
    NOT?: WorkspaceScalarWhereWithAggregatesInput | WorkspaceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Workspace"> | string
    name?: StringWithAggregatesFilter<"Workspace"> | string
    description?: StringNullableWithAggregatesFilter<"Workspace"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Workspace"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Workspace"> | Date | string
    ownerId?: StringWithAggregatesFilter<"Workspace"> | string
  }

  export type WorkspaceMemberWhereInput = {
    AND?: WorkspaceMemberWhereInput | WorkspaceMemberWhereInput[]
    OR?: WorkspaceMemberWhereInput[]
    NOT?: WorkspaceMemberWhereInput | WorkspaceMemberWhereInput[]
    id?: StringFilter<"WorkspaceMember"> | string
    userId?: StringFilter<"WorkspaceMember"> | string
    workspaceId?: StringFilter<"WorkspaceMember"> | string
    role?: StringFilter<"WorkspaceMember"> | string
    joinedAt?: DateTimeFilter<"WorkspaceMember"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    breakoutRooms?: BreakoutRoomListRelationFilter
  }

  export type WorkspaceMemberOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    workspace?: WorkspaceOrderByWithRelationInput
    breakoutRooms?: BreakoutRoomOrderByRelationAggregateInput
  }

  export type WorkspaceMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkspaceMemberWhereInput | WorkspaceMemberWhereInput[]
    OR?: WorkspaceMemberWhereInput[]
    NOT?: WorkspaceMemberWhereInput | WorkspaceMemberWhereInput[]
    userId?: StringFilter<"WorkspaceMember"> | string
    workspaceId?: StringFilter<"WorkspaceMember"> | string
    role?: StringFilter<"WorkspaceMember"> | string
    joinedAt?: DateTimeFilter<"WorkspaceMember"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    breakoutRooms?: BreakoutRoomListRelationFilter
  }, "id">

  export type WorkspaceMemberOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    _count?: WorkspaceMemberCountOrderByAggregateInput
    _max?: WorkspaceMemberMaxOrderByAggregateInput
    _min?: WorkspaceMemberMinOrderByAggregateInput
  }

  export type WorkspaceMemberScalarWhereWithAggregatesInput = {
    AND?: WorkspaceMemberScalarWhereWithAggregatesInput | WorkspaceMemberScalarWhereWithAggregatesInput[]
    OR?: WorkspaceMemberScalarWhereWithAggregatesInput[]
    NOT?: WorkspaceMemberScalarWhereWithAggregatesInput | WorkspaceMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkspaceMember"> | string
    userId?: StringWithAggregatesFilter<"WorkspaceMember"> | string
    workspaceId?: StringWithAggregatesFilter<"WorkspaceMember"> | string
    role?: StringWithAggregatesFilter<"WorkspaceMember"> | string
    joinedAt?: DateTimeWithAggregatesFilter<"WorkspaceMember"> | Date | string
  }

  export type WhiteboardWhereInput = {
    AND?: WhiteboardWhereInput | WhiteboardWhereInput[]
    OR?: WhiteboardWhereInput[]
    NOT?: WhiteboardWhereInput | WhiteboardWhereInput[]
    id?: StringFilter<"Whiteboard"> | string
    workspaceId?: StringFilter<"Whiteboard"> | string
    content?: JsonFilter<"Whiteboard">
    createdAt?: DateTimeFilter<"Whiteboard"> | Date | string
    updatedAt?: DateTimeFilter<"Whiteboard"> | Date | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    versions?: WhiteboardVersionListRelationFilter
  }

  export type WhiteboardOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
    versions?: WhiteboardVersionOrderByRelationAggregateInput
  }

  export type WhiteboardWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WhiteboardWhereInput | WhiteboardWhereInput[]
    OR?: WhiteboardWhereInput[]
    NOT?: WhiteboardWhereInput | WhiteboardWhereInput[]
    workspaceId?: StringFilter<"Whiteboard"> | string
    content?: JsonFilter<"Whiteboard">
    createdAt?: DateTimeFilter<"Whiteboard"> | Date | string
    updatedAt?: DateTimeFilter<"Whiteboard"> | Date | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    versions?: WhiteboardVersionListRelationFilter
  }, "id">

  export type WhiteboardOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WhiteboardCountOrderByAggregateInput
    _max?: WhiteboardMaxOrderByAggregateInput
    _min?: WhiteboardMinOrderByAggregateInput
  }

  export type WhiteboardScalarWhereWithAggregatesInput = {
    AND?: WhiteboardScalarWhereWithAggregatesInput | WhiteboardScalarWhereWithAggregatesInput[]
    OR?: WhiteboardScalarWhereWithAggregatesInput[]
    NOT?: WhiteboardScalarWhereWithAggregatesInput | WhiteboardScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Whiteboard"> | string
    workspaceId?: StringWithAggregatesFilter<"Whiteboard"> | string
    content?: JsonWithAggregatesFilter<"Whiteboard">
    createdAt?: DateTimeWithAggregatesFilter<"Whiteboard"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Whiteboard"> | Date | string
  }

  export type WhiteboardVersionWhereInput = {
    AND?: WhiteboardVersionWhereInput | WhiteboardVersionWhereInput[]
    OR?: WhiteboardVersionWhereInput[]
    NOT?: WhiteboardVersionWhereInput | WhiteboardVersionWhereInput[]
    id?: StringFilter<"WhiteboardVersion"> | string
    whiteboardId?: StringFilter<"WhiteboardVersion"> | string
    content?: JsonFilter<"WhiteboardVersion">
    createdAt?: DateTimeFilter<"WhiteboardVersion"> | Date | string
    createdBy?: StringFilter<"WhiteboardVersion"> | string
    versionNumber?: IntFilter<"WhiteboardVersion"> | number
    whiteboard?: XOR<WhiteboardScalarRelationFilter, WhiteboardWhereInput>
  }

  export type WhiteboardVersionOrderByWithRelationInput = {
    id?: SortOrder
    whiteboardId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    versionNumber?: SortOrder
    whiteboard?: WhiteboardOrderByWithRelationInput
  }

  export type WhiteboardVersionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WhiteboardVersionWhereInput | WhiteboardVersionWhereInput[]
    OR?: WhiteboardVersionWhereInput[]
    NOT?: WhiteboardVersionWhereInput | WhiteboardVersionWhereInput[]
    whiteboardId?: StringFilter<"WhiteboardVersion"> | string
    content?: JsonFilter<"WhiteboardVersion">
    createdAt?: DateTimeFilter<"WhiteboardVersion"> | Date | string
    createdBy?: StringFilter<"WhiteboardVersion"> | string
    versionNumber?: IntFilter<"WhiteboardVersion"> | number
    whiteboard?: XOR<WhiteboardScalarRelationFilter, WhiteboardWhereInput>
  }, "id">

  export type WhiteboardVersionOrderByWithAggregationInput = {
    id?: SortOrder
    whiteboardId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    versionNumber?: SortOrder
    _count?: WhiteboardVersionCountOrderByAggregateInput
    _avg?: WhiteboardVersionAvgOrderByAggregateInput
    _max?: WhiteboardVersionMaxOrderByAggregateInput
    _min?: WhiteboardVersionMinOrderByAggregateInput
    _sum?: WhiteboardVersionSumOrderByAggregateInput
  }

  export type WhiteboardVersionScalarWhereWithAggregatesInput = {
    AND?: WhiteboardVersionScalarWhereWithAggregatesInput | WhiteboardVersionScalarWhereWithAggregatesInput[]
    OR?: WhiteboardVersionScalarWhereWithAggregatesInput[]
    NOT?: WhiteboardVersionScalarWhereWithAggregatesInput | WhiteboardVersionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WhiteboardVersion"> | string
    whiteboardId?: StringWithAggregatesFilter<"WhiteboardVersion"> | string
    content?: JsonWithAggregatesFilter<"WhiteboardVersion">
    createdAt?: DateTimeWithAggregatesFilter<"WhiteboardVersion"> | Date | string
    createdBy?: StringWithAggregatesFilter<"WhiteboardVersion"> | string
    versionNumber?: IntWithAggregatesFilter<"WhiteboardVersion"> | number
  }

  export type BreakoutRoomWhereInput = {
    AND?: BreakoutRoomWhereInput | BreakoutRoomWhereInput[]
    OR?: BreakoutRoomWhereInput[]
    NOT?: BreakoutRoomWhereInput | BreakoutRoomWhereInput[]
    id?: StringFilter<"BreakoutRoom"> | string
    workspaceId?: StringFilter<"BreakoutRoom"> | string
    name?: StringFilter<"BreakoutRoom"> | string
    createdAt?: DateTimeFilter<"BreakoutRoom"> | Date | string
    endedAt?: DateTimeNullableFilter<"BreakoutRoom"> | Date | string | null
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    participants?: WorkspaceMemberListRelationFilter
  }

  export type BreakoutRoomOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
    participants?: WorkspaceMemberOrderByRelationAggregateInput
  }

  export type BreakoutRoomWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BreakoutRoomWhereInput | BreakoutRoomWhereInput[]
    OR?: BreakoutRoomWhereInput[]
    NOT?: BreakoutRoomWhereInput | BreakoutRoomWhereInput[]
    workspaceId?: StringFilter<"BreakoutRoom"> | string
    name?: StringFilter<"BreakoutRoom"> | string
    createdAt?: DateTimeFilter<"BreakoutRoom"> | Date | string
    endedAt?: DateTimeNullableFilter<"BreakoutRoom"> | Date | string | null
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    participants?: WorkspaceMemberListRelationFilter
  }, "id">

  export type BreakoutRoomOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    _count?: BreakoutRoomCountOrderByAggregateInput
    _max?: BreakoutRoomMaxOrderByAggregateInput
    _min?: BreakoutRoomMinOrderByAggregateInput
  }

  export type BreakoutRoomScalarWhereWithAggregatesInput = {
    AND?: BreakoutRoomScalarWhereWithAggregatesInput | BreakoutRoomScalarWhereWithAggregatesInput[]
    OR?: BreakoutRoomScalarWhereWithAggregatesInput[]
    NOT?: BreakoutRoomScalarWhereWithAggregatesInput | BreakoutRoomScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BreakoutRoom"> | string
    workspaceId?: StringWithAggregatesFilter<"BreakoutRoom"> | string
    name?: StringWithAggregatesFilter<"BreakoutRoom"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BreakoutRoom"> | Date | string
    endedAt?: DateTimeNullableWithAggregatesFilter<"BreakoutRoom"> | Date | string | null
  }

  export type LivePollWhereInput = {
    AND?: LivePollWhereInput | LivePollWhereInput[]
    OR?: LivePollWhereInput[]
    NOT?: LivePollWhereInput | LivePollWhereInput[]
    id?: StringFilter<"LivePoll"> | string
    workspaceId?: StringFilter<"LivePoll"> | string
    question?: StringFilter<"LivePoll"> | string
    options?: JsonFilter<"LivePoll">
    createdAt?: DateTimeFilter<"LivePoll"> | Date | string
    endedAt?: DateTimeNullableFilter<"LivePoll"> | Date | string | null
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    votes?: PollVoteListRelationFilter
  }

  export type LivePollOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    question?: SortOrder
    options?: SortOrder
    createdAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
    votes?: PollVoteOrderByRelationAggregateInput
  }

  export type LivePollWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LivePollWhereInput | LivePollWhereInput[]
    OR?: LivePollWhereInput[]
    NOT?: LivePollWhereInput | LivePollWhereInput[]
    workspaceId?: StringFilter<"LivePoll"> | string
    question?: StringFilter<"LivePoll"> | string
    options?: JsonFilter<"LivePoll">
    createdAt?: DateTimeFilter<"LivePoll"> | Date | string
    endedAt?: DateTimeNullableFilter<"LivePoll"> | Date | string | null
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    votes?: PollVoteListRelationFilter
  }, "id">

  export type LivePollOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    question?: SortOrder
    options?: SortOrder
    createdAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    _count?: LivePollCountOrderByAggregateInput
    _max?: LivePollMaxOrderByAggregateInput
    _min?: LivePollMinOrderByAggregateInput
  }

  export type LivePollScalarWhereWithAggregatesInput = {
    AND?: LivePollScalarWhereWithAggregatesInput | LivePollScalarWhereWithAggregatesInput[]
    OR?: LivePollScalarWhereWithAggregatesInput[]
    NOT?: LivePollScalarWhereWithAggregatesInput | LivePollScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LivePoll"> | string
    workspaceId?: StringWithAggregatesFilter<"LivePoll"> | string
    question?: StringWithAggregatesFilter<"LivePoll"> | string
    options?: JsonWithAggregatesFilter<"LivePoll">
    createdAt?: DateTimeWithAggregatesFilter<"LivePoll"> | Date | string
    endedAt?: DateTimeNullableWithAggregatesFilter<"LivePoll"> | Date | string | null
  }

  export type PollVoteWhereInput = {
    AND?: PollVoteWhereInput | PollVoteWhereInput[]
    OR?: PollVoteWhereInput[]
    NOT?: PollVoteWhereInput | PollVoteWhereInput[]
    id?: StringFilter<"PollVote"> | string
    livePoolId?: StringFilter<"PollVote"> | string
    userId?: StringFilter<"PollVote"> | string
    option?: StringFilter<"PollVote"> | string
    createdAt?: DateTimeFilter<"PollVote"> | Date | string
    livePoll?: XOR<LivePollScalarRelationFilter, LivePollWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PollVoteOrderByWithRelationInput = {
    id?: SortOrder
    livePoolId?: SortOrder
    userId?: SortOrder
    option?: SortOrder
    createdAt?: SortOrder
    livePoll?: LivePollOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type PollVoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PollVoteWhereInput | PollVoteWhereInput[]
    OR?: PollVoteWhereInput[]
    NOT?: PollVoteWhereInput | PollVoteWhereInput[]
    livePoolId?: StringFilter<"PollVote"> | string
    userId?: StringFilter<"PollVote"> | string
    option?: StringFilter<"PollVote"> | string
    createdAt?: DateTimeFilter<"PollVote"> | Date | string
    livePoll?: XOR<LivePollScalarRelationFilter, LivePollWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type PollVoteOrderByWithAggregationInput = {
    id?: SortOrder
    livePoolId?: SortOrder
    userId?: SortOrder
    option?: SortOrder
    createdAt?: SortOrder
    _count?: PollVoteCountOrderByAggregateInput
    _max?: PollVoteMaxOrderByAggregateInput
    _min?: PollVoteMinOrderByAggregateInput
  }

  export type PollVoteScalarWhereWithAggregatesInput = {
    AND?: PollVoteScalarWhereWithAggregatesInput | PollVoteScalarWhereWithAggregatesInput[]
    OR?: PollVoteScalarWhereWithAggregatesInput[]
    NOT?: PollVoteScalarWhereWithAggregatesInput | PollVoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PollVote"> | string
    livePoolId?: StringWithAggregatesFilter<"PollVote"> | string
    userId?: StringWithAggregatesFilter<"PollVote"> | string
    option?: StringWithAggregatesFilter<"PollVote"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PollVote"> | Date | string
  }

  export type SessionSummaryWhereInput = {
    AND?: SessionSummaryWhereInput | SessionSummaryWhereInput[]
    OR?: SessionSummaryWhereInput[]
    NOT?: SessionSummaryWhereInput | SessionSummaryWhereInput[]
    id?: StringFilter<"SessionSummary"> | string
    workspaceId?: StringFilter<"SessionSummary"> | string
    content?: StringFilter<"SessionSummary"> | string
    createdAt?: DateTimeFilter<"SessionSummary"> | Date | string
    createdBy?: StringFilter<"SessionSummary"> | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
  }

  export type SessionSummaryOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
  }

  export type SessionSummaryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SessionSummaryWhereInput | SessionSummaryWhereInput[]
    OR?: SessionSummaryWhereInput[]
    NOT?: SessionSummaryWhereInput | SessionSummaryWhereInput[]
    workspaceId?: StringFilter<"SessionSummary"> | string
    content?: StringFilter<"SessionSummary"> | string
    createdAt?: DateTimeFilter<"SessionSummary"> | Date | string
    createdBy?: StringFilter<"SessionSummary"> | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
  }, "id">

  export type SessionSummaryOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    _count?: SessionSummaryCountOrderByAggregateInput
    _max?: SessionSummaryMaxOrderByAggregateInput
    _min?: SessionSummaryMinOrderByAggregateInput
  }

  export type SessionSummaryScalarWhereWithAggregatesInput = {
    AND?: SessionSummaryScalarWhereWithAggregatesInput | SessionSummaryScalarWhereWithAggregatesInput[]
    OR?: SessionSummaryScalarWhereWithAggregatesInput[]
    NOT?: SessionSummaryScalarWhereWithAggregatesInput | SessionSummaryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SessionSummary"> | string
    workspaceId?: StringWithAggregatesFilter<"SessionSummary"> | string
    content?: StringWithAggregatesFilter<"SessionSummary"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SessionSummary"> | Date | string
    createdBy?: StringWithAggregatesFilter<"SessionSummary"> | string
  }

  export type ChatWhereInput = {
    AND?: ChatWhereInput | ChatWhereInput[]
    OR?: ChatWhereInput[]
    NOT?: ChatWhereInput | ChatWhereInput[]
    id?: StringFilter<"Chat"> | string
    workspaceId?: StringFilter<"Chat"> | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    messages?: ChatMessageListRelationFilter
  }

  export type ChatOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
    messages?: ChatMessageOrderByRelationAggregateInput
  }

  export type ChatWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChatWhereInput | ChatWhereInput[]
    OR?: ChatWhereInput[]
    NOT?: ChatWhereInput | ChatWhereInput[]
    workspaceId?: StringFilter<"Chat"> | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    messages?: ChatMessageListRelationFilter
  }, "id">

  export type ChatOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    _count?: ChatCountOrderByAggregateInput
    _max?: ChatMaxOrderByAggregateInput
    _min?: ChatMinOrderByAggregateInput
  }

  export type ChatScalarWhereWithAggregatesInput = {
    AND?: ChatScalarWhereWithAggregatesInput | ChatScalarWhereWithAggregatesInput[]
    OR?: ChatScalarWhereWithAggregatesInput[]
    NOT?: ChatScalarWhereWithAggregatesInput | ChatScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Chat"> | string
    workspaceId?: StringWithAggregatesFilter<"Chat"> | string
  }

  export type ChatMessageWhereInput = {
    AND?: ChatMessageWhereInput | ChatMessageWhereInput[]
    OR?: ChatMessageWhereInput[]
    NOT?: ChatMessageWhereInput | ChatMessageWhereInput[]
    id?: StringFilter<"ChatMessage"> | string
    chatId?: StringFilter<"ChatMessage"> | string
    userId?: StringFilter<"ChatMessage"> | string
    content?: StringFilter<"ChatMessage"> | string
    createdAt?: DateTimeFilter<"ChatMessage"> | Date | string
    chat?: XOR<ChatScalarRelationFilter, ChatWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ChatMessageOrderByWithRelationInput = {
    id?: SortOrder
    chatId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    chat?: ChatOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ChatMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChatMessageWhereInput | ChatMessageWhereInput[]
    OR?: ChatMessageWhereInput[]
    NOT?: ChatMessageWhereInput | ChatMessageWhereInput[]
    chatId?: StringFilter<"ChatMessage"> | string
    userId?: StringFilter<"ChatMessage"> | string
    content?: StringFilter<"ChatMessage"> | string
    createdAt?: DateTimeFilter<"ChatMessage"> | Date | string
    chat?: XOR<ChatScalarRelationFilter, ChatWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ChatMessageOrderByWithAggregationInput = {
    id?: SortOrder
    chatId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    _count?: ChatMessageCountOrderByAggregateInput
    _max?: ChatMessageMaxOrderByAggregateInput
    _min?: ChatMessageMinOrderByAggregateInput
  }

  export type ChatMessageScalarWhereWithAggregatesInput = {
    AND?: ChatMessageScalarWhereWithAggregatesInput | ChatMessageScalarWhereWithAggregatesInput[]
    OR?: ChatMessageScalarWhereWithAggregatesInput[]
    NOT?: ChatMessageScalarWhereWithAggregatesInput | ChatMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChatMessage"> | string
    chatId?: StringWithAggregatesFilter<"ChatMessage"> | string
    userId?: StringWithAggregatesFilter<"ChatMessage"> | string
    content?: StringWithAggregatesFilter<"ChatMessage"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ChatMessage"> | Date | string
  }

  export type UserSettingsWhereInput = {
    AND?: UserSettingsWhereInput | UserSettingsWhereInput[]
    OR?: UserSettingsWhereInput[]
    NOT?: UserSettingsWhereInput | UserSettingsWhereInput[]
    id?: StringFilter<"UserSettings"> | string
    userId?: StringFilter<"UserSettings"> | string
    notificationPreferences?: JsonFilter<"UserSettings">
    voiceSettings?: JsonFilter<"UserSettings">
    privacySettings?: JsonFilter<"UserSettings">
    createdAt?: DateTimeFilter<"UserSettings"> | Date | string
    updatedAt?: DateTimeFilter<"UserSettings"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserSettingsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    notificationPreferences?: SortOrder
    voiceSettings?: SortOrder
    privacySettings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserSettingsWhereInput | UserSettingsWhereInput[]
    OR?: UserSettingsWhereInput[]
    NOT?: UserSettingsWhereInput | UserSettingsWhereInput[]
    notificationPreferences?: JsonFilter<"UserSettings">
    voiceSettings?: JsonFilter<"UserSettings">
    privacySettings?: JsonFilter<"UserSettings">
    createdAt?: DateTimeFilter<"UserSettings"> | Date | string
    updatedAt?: DateTimeFilter<"UserSettings"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type UserSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    notificationPreferences?: SortOrder
    voiceSettings?: SortOrder
    privacySettings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserSettingsCountOrderByAggregateInput
    _max?: UserSettingsMaxOrderByAggregateInput
    _min?: UserSettingsMinOrderByAggregateInput
  }

  export type UserSettingsScalarWhereWithAggregatesInput = {
    AND?: UserSettingsScalarWhereWithAggregatesInput | UserSettingsScalarWhereWithAggregatesInput[]
    OR?: UserSettingsScalarWhereWithAggregatesInput[]
    NOT?: UserSettingsScalarWhereWithAggregatesInput | UserSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserSettings"> | string
    userId?: StringWithAggregatesFilter<"UserSettings"> | string
    notificationPreferences?: JsonWithAggregatesFilter<"UserSettings">
    voiceSettings?: JsonWithAggregatesFilter<"UserSettings">
    privacySettings?: JsonWithAggregatesFilter<"UserSettings">
    createdAt?: DateTimeWithAggregatesFilter<"UserSettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserSettings"> | Date | string
  }

  export type AnalyticsEntryWhereInput = {
    AND?: AnalyticsEntryWhereInput | AnalyticsEntryWhereInput[]
    OR?: AnalyticsEntryWhereInput[]
    NOT?: AnalyticsEntryWhereInput | AnalyticsEntryWhereInput[]
    id?: StringFilter<"AnalyticsEntry"> | string
    userId?: StringFilter<"AnalyticsEntry"> | string
    topicId?: StringFilter<"AnalyticsEntry"> | string
    timeSpent?: IntFilter<"AnalyticsEntry"> | number
    score?: FloatNullableFilter<"AnalyticsEntry"> | number | null
    date?: DateTimeFilter<"AnalyticsEntry"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    topic?: XOR<TopicScalarRelationFilter, TopicWhereInput>
  }

  export type AnalyticsEntryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    topicId?: SortOrder
    timeSpent?: SortOrder
    score?: SortOrderInput | SortOrder
    date?: SortOrder
    user?: UserOrderByWithRelationInput
    topic?: TopicOrderByWithRelationInput
  }

  export type AnalyticsEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AnalyticsEntryWhereInput | AnalyticsEntryWhereInput[]
    OR?: AnalyticsEntryWhereInput[]
    NOT?: AnalyticsEntryWhereInput | AnalyticsEntryWhereInput[]
    userId?: StringFilter<"AnalyticsEntry"> | string
    topicId?: StringFilter<"AnalyticsEntry"> | string
    timeSpent?: IntFilter<"AnalyticsEntry"> | number
    score?: FloatNullableFilter<"AnalyticsEntry"> | number | null
    date?: DateTimeFilter<"AnalyticsEntry"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    topic?: XOR<TopicScalarRelationFilter, TopicWhereInput>
  }, "id">

  export type AnalyticsEntryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    topicId?: SortOrder
    timeSpent?: SortOrder
    score?: SortOrderInput | SortOrder
    date?: SortOrder
    _count?: AnalyticsEntryCountOrderByAggregateInput
    _avg?: AnalyticsEntryAvgOrderByAggregateInput
    _max?: AnalyticsEntryMaxOrderByAggregateInput
    _min?: AnalyticsEntryMinOrderByAggregateInput
    _sum?: AnalyticsEntrySumOrderByAggregateInput
  }

  export type AnalyticsEntryScalarWhereWithAggregatesInput = {
    AND?: AnalyticsEntryScalarWhereWithAggregatesInput | AnalyticsEntryScalarWhereWithAggregatesInput[]
    OR?: AnalyticsEntryScalarWhereWithAggregatesInput[]
    NOT?: AnalyticsEntryScalarWhereWithAggregatesInput | AnalyticsEntryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AnalyticsEntry"> | string
    userId?: StringWithAggregatesFilter<"AnalyticsEntry"> | string
    topicId?: StringWithAggregatesFilter<"AnalyticsEntry"> | string
    timeSpent?: IntWithAggregatesFilter<"AnalyticsEntry"> | number
    score?: FloatNullableWithAggregatesFilter<"AnalyticsEntry"> | number | null
    date?: DateTimeWithAggregatesFilter<"AnalyticsEntry"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    type?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type PasswordlessTokenWhereInput = {
    AND?: PasswordlessTokenWhereInput | PasswordlessTokenWhereInput[]
    OR?: PasswordlessTokenWhereInput[]
    NOT?: PasswordlessTokenWhereInput | PasswordlessTokenWhereInput[]
    id?: StringFilter<"PasswordlessToken"> | string
    token?: StringFilter<"PasswordlessToken"> | string
    expiresAt?: DateTimeFilter<"PasswordlessToken"> | Date | string
    userId?: StringFilter<"PasswordlessToken"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PasswordlessTokenOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PasswordlessTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: PasswordlessTokenWhereInput | PasswordlessTokenWhereInput[]
    OR?: PasswordlessTokenWhereInput[]
    NOT?: PasswordlessTokenWhereInput | PasswordlessTokenWhereInput[]
    expiresAt?: DateTimeFilter<"PasswordlessToken"> | Date | string
    userId?: StringFilter<"PasswordlessToken"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type PasswordlessTokenOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    userId?: SortOrder
    _count?: PasswordlessTokenCountOrderByAggregateInput
    _max?: PasswordlessTokenMaxOrderByAggregateInput
    _min?: PasswordlessTokenMinOrderByAggregateInput
  }

  export type PasswordlessTokenScalarWhereWithAggregatesInput = {
    AND?: PasswordlessTokenScalarWhereWithAggregatesInput | PasswordlessTokenScalarWhereWithAggregatesInput[]
    OR?: PasswordlessTokenScalarWhereWithAggregatesInput[]
    NOT?: PasswordlessTokenScalarWhereWithAggregatesInput | PasswordlessTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PasswordlessToken"> | string
    token?: StringWithAggregatesFilter<"PasswordlessToken"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"PasswordlessToken"> | Date | string
    userId?: StringWithAggregatesFilter<"PasswordlessToken"> | string
  }

  export type DailyChallengeWhereInput = {
    AND?: DailyChallengeWhereInput | DailyChallengeWhereInput[]
    OR?: DailyChallengeWhereInput[]
    NOT?: DailyChallengeWhereInput | DailyChallengeWhereInput[]
    id?: StringFilter<"DailyChallenge"> | string
    userId?: StringFilter<"DailyChallenge"> | string
    title?: StringFilter<"DailyChallenge"> | string
    description?: StringFilter<"DailyChallenge"> | string
    reward?: StringFilter<"DailyChallenge"> | string
    completed?: BoolFilter<"DailyChallenge"> | boolean
    createdAt?: DateTimeFilter<"DailyChallenge"> | Date | string
    completedAt?: DateTimeNullableFilter<"DailyChallenge"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type DailyChallengeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    reward?: SortOrder
    completed?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type DailyChallengeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DailyChallengeWhereInput | DailyChallengeWhereInput[]
    OR?: DailyChallengeWhereInput[]
    NOT?: DailyChallengeWhereInput | DailyChallengeWhereInput[]
    userId?: StringFilter<"DailyChallenge"> | string
    title?: StringFilter<"DailyChallenge"> | string
    description?: StringFilter<"DailyChallenge"> | string
    reward?: StringFilter<"DailyChallenge"> | string
    completed?: BoolFilter<"DailyChallenge"> | boolean
    createdAt?: DateTimeFilter<"DailyChallenge"> | Date | string
    completedAt?: DateTimeNullableFilter<"DailyChallenge"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type DailyChallengeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    reward?: SortOrder
    completed?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: DailyChallengeCountOrderByAggregateInput
    _max?: DailyChallengeMaxOrderByAggregateInput
    _min?: DailyChallengeMinOrderByAggregateInput
  }

  export type DailyChallengeScalarWhereWithAggregatesInput = {
    AND?: DailyChallengeScalarWhereWithAggregatesInput | DailyChallengeScalarWhereWithAggregatesInput[]
    OR?: DailyChallengeScalarWhereWithAggregatesInput[]
    NOT?: DailyChallengeScalarWhereWithAggregatesInput | DailyChallengeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DailyChallenge"> | string
    userId?: StringWithAggregatesFilter<"DailyChallenge"> | string
    title?: StringWithAggregatesFilter<"DailyChallenge"> | string
    description?: StringWithAggregatesFilter<"DailyChallenge"> | string
    reward?: StringWithAggregatesFilter<"DailyChallenge"> | string
    completed?: BoolWithAggregatesFilter<"DailyChallenge"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"DailyChallenge"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"DailyChallenge"> | Date | string | null
  }

  export type ExternalGoalWhereInput = {
    AND?: ExternalGoalWhereInput | ExternalGoalWhereInput[]
    OR?: ExternalGoalWhereInput[]
    NOT?: ExternalGoalWhereInput | ExternalGoalWhereInput[]
    id?: StringFilter<"ExternalGoal"> | string
    userId?: StringFilter<"ExternalGoal"> | string
    platform?: StringFilter<"ExternalGoal"> | string
    title?: StringFilter<"ExternalGoal"> | string
    progress?: FloatFilter<"ExternalGoal"> | number
    dueDate?: DateTimeFilter<"ExternalGoal"> | Date | string
    createdAt?: DateTimeFilter<"ExternalGoal"> | Date | string
    updatedAt?: DateTimeFilter<"ExternalGoal"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ExternalGoalOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    platform?: SortOrder
    title?: SortOrder
    progress?: SortOrder
    dueDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ExternalGoalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExternalGoalWhereInput | ExternalGoalWhereInput[]
    OR?: ExternalGoalWhereInput[]
    NOT?: ExternalGoalWhereInput | ExternalGoalWhereInput[]
    userId?: StringFilter<"ExternalGoal"> | string
    platform?: StringFilter<"ExternalGoal"> | string
    title?: StringFilter<"ExternalGoal"> | string
    progress?: FloatFilter<"ExternalGoal"> | number
    dueDate?: DateTimeFilter<"ExternalGoal"> | Date | string
    createdAt?: DateTimeFilter<"ExternalGoal"> | Date | string
    updatedAt?: DateTimeFilter<"ExternalGoal"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ExternalGoalOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    platform?: SortOrder
    title?: SortOrder
    progress?: SortOrder
    dueDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExternalGoalCountOrderByAggregateInput
    _avg?: ExternalGoalAvgOrderByAggregateInput
    _max?: ExternalGoalMaxOrderByAggregateInput
    _min?: ExternalGoalMinOrderByAggregateInput
    _sum?: ExternalGoalSumOrderByAggregateInput
  }

  export type ExternalGoalScalarWhereWithAggregatesInput = {
    AND?: ExternalGoalScalarWhereWithAggregatesInput | ExternalGoalScalarWhereWithAggregatesInput[]
    OR?: ExternalGoalScalarWhereWithAggregatesInput[]
    NOT?: ExternalGoalScalarWhereWithAggregatesInput | ExternalGoalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExternalGoal"> | string
    userId?: StringWithAggregatesFilter<"ExternalGoal"> | string
    platform?: StringWithAggregatesFilter<"ExternalGoal"> | string
    title?: StringWithAggregatesFilter<"ExternalGoal"> | string
    progress?: FloatWithAggregatesFilter<"ExternalGoal"> | number
    dueDate?: DateTimeWithAggregatesFilter<"ExternalGoal"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"ExternalGoal"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ExternalGoal"> | Date | string
  }

  export type PrerequisiteWhereInput = {
    AND?: PrerequisiteWhereInput | PrerequisiteWhereInput[]
    OR?: PrerequisiteWhereInput[]
    NOT?: PrerequisiteWhereInput | PrerequisiteWhereInput[]
    id?: StringFilter<"Prerequisite"> | string
    learningPathId?: StringFilter<"Prerequisite"> | string
    topicId?: StringFilter<"Prerequisite"> | string
    completed?: BoolFilter<"Prerequisite"> | boolean
    learningPath?: XOR<LearningPathScalarRelationFilter, LearningPathWhereInput>
    topic?: XOR<TopicScalarRelationFilter, TopicWhereInput>
  }

  export type PrerequisiteOrderByWithRelationInput = {
    id?: SortOrder
    learningPathId?: SortOrder
    topicId?: SortOrder
    completed?: SortOrder
    learningPath?: LearningPathOrderByWithRelationInput
    topic?: TopicOrderByWithRelationInput
  }

  export type PrerequisiteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PrerequisiteWhereInput | PrerequisiteWhereInput[]
    OR?: PrerequisiteWhereInput[]
    NOT?: PrerequisiteWhereInput | PrerequisiteWhereInput[]
    learningPathId?: StringFilter<"Prerequisite"> | string
    topicId?: StringFilter<"Prerequisite"> | string
    completed?: BoolFilter<"Prerequisite"> | boolean
    learningPath?: XOR<LearningPathScalarRelationFilter, LearningPathWhereInput>
    topic?: XOR<TopicScalarRelationFilter, TopicWhereInput>
  }, "id">

  export type PrerequisiteOrderByWithAggregationInput = {
    id?: SortOrder
    learningPathId?: SortOrder
    topicId?: SortOrder
    completed?: SortOrder
    _count?: PrerequisiteCountOrderByAggregateInput
    _max?: PrerequisiteMaxOrderByAggregateInput
    _min?: PrerequisiteMinOrderByAggregateInput
  }

  export type PrerequisiteScalarWhereWithAggregatesInput = {
    AND?: PrerequisiteScalarWhereWithAggregatesInput | PrerequisiteScalarWhereWithAggregatesInput[]
    OR?: PrerequisiteScalarWhereWithAggregatesInput[]
    NOT?: PrerequisiteScalarWhereWithAggregatesInput | PrerequisiteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Prerequisite"> | string
    learningPathId?: StringWithAggregatesFilter<"Prerequisite"> | string
    topicId?: StringWithAggregatesFilter<"Prerequisite"> | string
    completed?: BoolWithAggregatesFilter<"Prerequisite"> | boolean
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    userId?: StringFilter<"Comment"> | string
    topicId?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    topic?: XOR<TopicScalarRelationFilter, TopicWhereInput>
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    userId?: SortOrder
    topicId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    topic?: TopicOrderByWithRelationInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    content?: StringFilter<"Comment"> | string
    userId?: StringFilter<"Comment"> | string
    topicId?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    topic?: XOR<TopicScalarRelationFilter, TopicWhereInput>
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    userId?: SortOrder
    topicId?: SortOrder
    createdAt?: SortOrder
    _count?: CommentCountOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Comment"> | string
    content?: StringWithAggregatesFilter<"Comment"> | string
    userId?: StringWithAggregatesFilter<"Comment"> | string
    topicId?: StringWithAggregatesFilter<"Comment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
  }

  export type AIPlaylistWhereInput = {
    AND?: AIPlaylistWhereInput | AIPlaylistWhereInput[]
    OR?: AIPlaylistWhereInput[]
    NOT?: AIPlaylistWhereInput | AIPlaylistWhereInput[]
    id?: StringFilter<"AIPlaylist"> | string
    title?: StringFilter<"AIPlaylist"> | string
    description?: StringNullableFilter<"AIPlaylist"> | string | null
    createdAt?: DateTimeFilter<"AIPlaylist"> | Date | string
    updatedAt?: DateTimeFilter<"AIPlaylist"> | Date | string
    items?: AIPlaylistItemListRelationFilter
  }

  export type AIPlaylistOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    items?: AIPlaylistItemOrderByRelationAggregateInput
  }

  export type AIPlaylistWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AIPlaylistWhereInput | AIPlaylistWhereInput[]
    OR?: AIPlaylistWhereInput[]
    NOT?: AIPlaylistWhereInput | AIPlaylistWhereInput[]
    title?: StringFilter<"AIPlaylist"> | string
    description?: StringNullableFilter<"AIPlaylist"> | string | null
    createdAt?: DateTimeFilter<"AIPlaylist"> | Date | string
    updatedAt?: DateTimeFilter<"AIPlaylist"> | Date | string
    items?: AIPlaylistItemListRelationFilter
  }, "id">

  export type AIPlaylistOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AIPlaylistCountOrderByAggregateInput
    _max?: AIPlaylistMaxOrderByAggregateInput
    _min?: AIPlaylistMinOrderByAggregateInput
  }

  export type AIPlaylistScalarWhereWithAggregatesInput = {
    AND?: AIPlaylistScalarWhereWithAggregatesInput | AIPlaylistScalarWhereWithAggregatesInput[]
    OR?: AIPlaylistScalarWhereWithAggregatesInput[]
    NOT?: AIPlaylistScalarWhereWithAggregatesInput | AIPlaylistScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AIPlaylist"> | string
    title?: StringWithAggregatesFilter<"AIPlaylist"> | string
    description?: StringNullableWithAggregatesFilter<"AIPlaylist"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AIPlaylist"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AIPlaylist"> | Date | string
  }

  export type AIPlaylistItemWhereInput = {
    AND?: AIPlaylistItemWhereInput | AIPlaylistItemWhereInput[]
    OR?: AIPlaylistItemWhereInput[]
    NOT?: AIPlaylistItemWhereInput | AIPlaylistItemWhereInput[]
    id?: StringFilter<"AIPlaylistItem"> | string
    playlistId?: StringFilter<"AIPlaylistItem"> | string
    contentItemId?: StringFilter<"AIPlaylistItem"> | string
    order?: IntFilter<"AIPlaylistItem"> | number
    playlist?: XOR<AIPlaylistScalarRelationFilter, AIPlaylistWhereInput>
    contentItem?: XOR<ContentItemScalarRelationFilter, ContentItemWhereInput>
  }

  export type AIPlaylistItemOrderByWithRelationInput = {
    id?: SortOrder
    playlistId?: SortOrder
    contentItemId?: SortOrder
    order?: SortOrder
    playlist?: AIPlaylistOrderByWithRelationInput
    contentItem?: ContentItemOrderByWithRelationInput
  }

  export type AIPlaylistItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AIPlaylistItemWhereInput | AIPlaylistItemWhereInput[]
    OR?: AIPlaylistItemWhereInput[]
    NOT?: AIPlaylistItemWhereInput | AIPlaylistItemWhereInput[]
    playlistId?: StringFilter<"AIPlaylistItem"> | string
    contentItemId?: StringFilter<"AIPlaylistItem"> | string
    order?: IntFilter<"AIPlaylistItem"> | number
    playlist?: XOR<AIPlaylistScalarRelationFilter, AIPlaylistWhereInput>
    contentItem?: XOR<ContentItemScalarRelationFilter, ContentItemWhereInput>
  }, "id">

  export type AIPlaylistItemOrderByWithAggregationInput = {
    id?: SortOrder
    playlistId?: SortOrder
    contentItemId?: SortOrder
    order?: SortOrder
    _count?: AIPlaylistItemCountOrderByAggregateInput
    _avg?: AIPlaylistItemAvgOrderByAggregateInput
    _max?: AIPlaylistItemMaxOrderByAggregateInput
    _min?: AIPlaylistItemMinOrderByAggregateInput
    _sum?: AIPlaylistItemSumOrderByAggregateInput
  }

  export type AIPlaylistItemScalarWhereWithAggregatesInput = {
    AND?: AIPlaylistItemScalarWhereWithAggregatesInput | AIPlaylistItemScalarWhereWithAggregatesInput[]
    OR?: AIPlaylistItemScalarWhereWithAggregatesInput[]
    NOT?: AIPlaylistItemScalarWhereWithAggregatesInput | AIPlaylistItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AIPlaylistItem"> | string
    playlistId?: StringWithAggregatesFilter<"AIPlaylistItem"> | string
    contentItemId?: StringWithAggregatesFilter<"AIPlaylistItem"> | string
    order?: IntWithAggregatesFilter<"AIPlaylistItem"> | number
  }

  export type ChallengeScoreWhereInput = {
    AND?: ChallengeScoreWhereInput | ChallengeScoreWhereInput[]
    OR?: ChallengeScoreWhereInput[]
    NOT?: ChallengeScoreWhereInput | ChallengeScoreWhereInput[]
    id?: StringFilter<"ChallengeScore"> | string
    userId?: StringFilter<"ChallengeScore"> | string
    score?: IntFilter<"ChallengeScore"> | number
    createdAt?: DateTimeFilter<"ChallengeScore"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ChallengeScoreOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    score?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ChallengeScoreWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChallengeScoreWhereInput | ChallengeScoreWhereInput[]
    OR?: ChallengeScoreWhereInput[]
    NOT?: ChallengeScoreWhereInput | ChallengeScoreWhereInput[]
    userId?: StringFilter<"ChallengeScore"> | string
    score?: IntFilter<"ChallengeScore"> | number
    createdAt?: DateTimeFilter<"ChallengeScore"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ChallengeScoreOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    score?: SortOrder
    createdAt?: SortOrder
    _count?: ChallengeScoreCountOrderByAggregateInput
    _avg?: ChallengeScoreAvgOrderByAggregateInput
    _max?: ChallengeScoreMaxOrderByAggregateInput
    _min?: ChallengeScoreMinOrderByAggregateInput
    _sum?: ChallengeScoreSumOrderByAggregateInput
  }

  export type ChallengeScoreScalarWhereWithAggregatesInput = {
    AND?: ChallengeScoreScalarWhereWithAggregatesInput | ChallengeScoreScalarWhereWithAggregatesInput[]
    OR?: ChallengeScoreScalarWhereWithAggregatesInput[]
    NOT?: ChallengeScoreScalarWhereWithAggregatesInput | ChallengeScoreScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChallengeScore"> | string
    userId?: StringWithAggregatesFilter<"ChallengeScore"> | string
    score?: IntWithAggregatesFilter<"ChallengeScore"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ChallengeScore"> | Date | string
  }

  export type AIRecommendationWhereInput = {
    AND?: AIRecommendationWhereInput | AIRecommendationWhereInput[]
    OR?: AIRecommendationWhereInput[]
    NOT?: AIRecommendationWhereInput | AIRecommendationWhereInput[]
    id?: StringFilter<"AIRecommendation"> | string
    userId?: StringFilter<"AIRecommendation"> | string
    content?: StringFilter<"AIRecommendation"> | string
    createdAt?: DateTimeFilter<"AIRecommendation"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AIRecommendationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AIRecommendationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AIRecommendationWhereInput | AIRecommendationWhereInput[]
    OR?: AIRecommendationWhereInput[]
    NOT?: AIRecommendationWhereInput | AIRecommendationWhereInput[]
    userId?: StringFilter<"AIRecommendation"> | string
    content?: StringFilter<"AIRecommendation"> | string
    createdAt?: DateTimeFilter<"AIRecommendation"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AIRecommendationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    _count?: AIRecommendationCountOrderByAggregateInput
    _max?: AIRecommendationMaxOrderByAggregateInput
    _min?: AIRecommendationMinOrderByAggregateInput
  }

  export type AIRecommendationScalarWhereWithAggregatesInput = {
    AND?: AIRecommendationScalarWhereWithAggregatesInput | AIRecommendationScalarWhereWithAggregatesInput[]
    OR?: AIRecommendationScalarWhereWithAggregatesInput[]
    NOT?: AIRecommendationScalarWhereWithAggregatesInput | AIRecommendationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AIRecommendation"> | string
    userId?: StringWithAggregatesFilter<"AIRecommendation"> | string
    content?: StringWithAggregatesFilter<"AIRecommendation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AIRecommendation"> | Date | string
  }

  export type AIModuleWhereInput = {
    AND?: AIModuleWhereInput | AIModuleWhereInput[]
    OR?: AIModuleWhereInput[]
    NOT?: AIModuleWhereInput | AIModuleWhereInput[]
    id?: StringFilter<"AIModule"> | string
    title?: StringFilter<"AIModule"> | string
    description?: StringNullableFilter<"AIModule"> | string | null
    content?: JsonFilter<"AIModule">
    tags?: StringNullableListFilter<"AIModule">
    difficulty?: StringNullableFilter<"AIModule"> | string | null
    status?: StringFilter<"AIModule"> | string
    createdAt?: DateTimeFilter<"AIModule"> | Date | string
    updatedAt?: DateTimeFilter<"AIModule"> | Date | string
    userId?: StringNullableFilter<"AIModule"> | string | null
    topicId?: StringNullableFilter<"AIModule"> | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    topic?: XOR<TopicNullableScalarRelationFilter, TopicWhereInput> | null
    learningPathItems?: AIModuleLearningPathItemListRelationFilter
    quizAttempts?: AIModuleQuizAttemptListRelationFilter
    ratings?: AIModuleRatingListRelationFilter
    PracticeAttempts?: PracticeAttemptListRelationFilter
  }

  export type AIModuleOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    content?: SortOrder
    tags?: SortOrder
    difficulty?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    topicId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    topic?: TopicOrderByWithRelationInput
    learningPathItems?: AIModuleLearningPathItemOrderByRelationAggregateInput
    quizAttempts?: AIModuleQuizAttemptOrderByRelationAggregateInput
    ratings?: AIModuleRatingOrderByRelationAggregateInput
    PracticeAttempts?: PracticeAttemptOrderByRelationAggregateInput
  }

  export type AIModuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AIModuleWhereInput | AIModuleWhereInput[]
    OR?: AIModuleWhereInput[]
    NOT?: AIModuleWhereInput | AIModuleWhereInput[]
    title?: StringFilter<"AIModule"> | string
    description?: StringNullableFilter<"AIModule"> | string | null
    content?: JsonFilter<"AIModule">
    tags?: StringNullableListFilter<"AIModule">
    difficulty?: StringNullableFilter<"AIModule"> | string | null
    status?: StringFilter<"AIModule"> | string
    createdAt?: DateTimeFilter<"AIModule"> | Date | string
    updatedAt?: DateTimeFilter<"AIModule"> | Date | string
    userId?: StringNullableFilter<"AIModule"> | string | null
    topicId?: StringNullableFilter<"AIModule"> | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    topic?: XOR<TopicNullableScalarRelationFilter, TopicWhereInput> | null
    learningPathItems?: AIModuleLearningPathItemListRelationFilter
    quizAttempts?: AIModuleQuizAttemptListRelationFilter
    ratings?: AIModuleRatingListRelationFilter
    PracticeAttempts?: PracticeAttemptListRelationFilter
  }, "id">

  export type AIModuleOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    content?: SortOrder
    tags?: SortOrder
    difficulty?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    topicId?: SortOrderInput | SortOrder
    _count?: AIModuleCountOrderByAggregateInput
    _max?: AIModuleMaxOrderByAggregateInput
    _min?: AIModuleMinOrderByAggregateInput
  }

  export type AIModuleScalarWhereWithAggregatesInput = {
    AND?: AIModuleScalarWhereWithAggregatesInput | AIModuleScalarWhereWithAggregatesInput[]
    OR?: AIModuleScalarWhereWithAggregatesInput[]
    NOT?: AIModuleScalarWhereWithAggregatesInput | AIModuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AIModule"> | string
    title?: StringWithAggregatesFilter<"AIModule"> | string
    description?: StringNullableWithAggregatesFilter<"AIModule"> | string | null
    content?: JsonWithAggregatesFilter<"AIModule">
    tags?: StringNullableListFilter<"AIModule">
    difficulty?: StringNullableWithAggregatesFilter<"AIModule"> | string | null
    status?: StringWithAggregatesFilter<"AIModule"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AIModule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AIModule"> | Date | string
    userId?: StringNullableWithAggregatesFilter<"AIModule"> | string | null
    topicId?: StringNullableWithAggregatesFilter<"AIModule"> | string | null
  }

  export type AIModuleLearningPathItemWhereInput = {
    AND?: AIModuleLearningPathItemWhereInput | AIModuleLearningPathItemWhereInput[]
    OR?: AIModuleLearningPathItemWhereInput[]
    NOT?: AIModuleLearningPathItemWhereInput | AIModuleLearningPathItemWhereInput[]
    id?: StringFilter<"AIModuleLearningPathItem"> | string
    order?: IntFilter<"AIModuleLearningPathItem"> | number
    learningPathId?: StringFilter<"AIModuleLearningPathItem"> | string
    aiModuleId?: StringFilter<"AIModuleLearningPathItem"> | string
    confidence?: IntFilter<"AIModuleLearningPathItem"> | number
    learningPath?: XOR<LearningPathScalarRelationFilter, LearningPathWhereInput>
    aiModule?: XOR<AIModuleScalarRelationFilter, AIModuleWhereInput>
  }

  export type AIModuleLearningPathItemOrderByWithRelationInput = {
    id?: SortOrder
    order?: SortOrder
    learningPathId?: SortOrder
    aiModuleId?: SortOrder
    confidence?: SortOrder
    learningPath?: LearningPathOrderByWithRelationInput
    aiModule?: AIModuleOrderByWithRelationInput
  }

  export type AIModuleLearningPathItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AIModuleLearningPathItemWhereInput | AIModuleLearningPathItemWhereInput[]
    OR?: AIModuleLearningPathItemWhereInput[]
    NOT?: AIModuleLearningPathItemWhereInput | AIModuleLearningPathItemWhereInput[]
    order?: IntFilter<"AIModuleLearningPathItem"> | number
    learningPathId?: StringFilter<"AIModuleLearningPathItem"> | string
    aiModuleId?: StringFilter<"AIModuleLearningPathItem"> | string
    confidence?: IntFilter<"AIModuleLearningPathItem"> | number
    learningPath?: XOR<LearningPathScalarRelationFilter, LearningPathWhereInput>
    aiModule?: XOR<AIModuleScalarRelationFilter, AIModuleWhereInput>
  }, "id">

  export type AIModuleLearningPathItemOrderByWithAggregationInput = {
    id?: SortOrder
    order?: SortOrder
    learningPathId?: SortOrder
    aiModuleId?: SortOrder
    confidence?: SortOrder
    _count?: AIModuleLearningPathItemCountOrderByAggregateInput
    _avg?: AIModuleLearningPathItemAvgOrderByAggregateInput
    _max?: AIModuleLearningPathItemMaxOrderByAggregateInput
    _min?: AIModuleLearningPathItemMinOrderByAggregateInput
    _sum?: AIModuleLearningPathItemSumOrderByAggregateInput
  }

  export type AIModuleLearningPathItemScalarWhereWithAggregatesInput = {
    AND?: AIModuleLearningPathItemScalarWhereWithAggregatesInput | AIModuleLearningPathItemScalarWhereWithAggregatesInput[]
    OR?: AIModuleLearningPathItemScalarWhereWithAggregatesInput[]
    NOT?: AIModuleLearningPathItemScalarWhereWithAggregatesInput | AIModuleLearningPathItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AIModuleLearningPathItem"> | string
    order?: IntWithAggregatesFilter<"AIModuleLearningPathItem"> | number
    learningPathId?: StringWithAggregatesFilter<"AIModuleLearningPathItem"> | string
    aiModuleId?: StringWithAggregatesFilter<"AIModuleLearningPathItem"> | string
    confidence?: IntWithAggregatesFilter<"AIModuleLearningPathItem"> | number
  }

  export type AIModuleQuizAttemptWhereInput = {
    AND?: AIModuleQuizAttemptWhereInput | AIModuleQuizAttemptWhereInput[]
    OR?: AIModuleQuizAttemptWhereInput[]
    NOT?: AIModuleQuizAttemptWhereInput | AIModuleQuizAttemptWhereInput[]
    id?: StringFilter<"AIModuleQuizAttempt"> | string
    userId?: StringFilter<"AIModuleQuizAttempt"> | string
    aiModuleId?: StringFilter<"AIModuleQuizAttempt"> | string
    topicId?: StringFilter<"AIModuleQuizAttempt"> | string
    score?: FloatFilter<"AIModuleQuizAttempt"> | number
    startedAt?: DateTimeFilter<"AIModuleQuizAttempt"> | Date | string
    completedAt?: DateTimeNullableFilter<"AIModuleQuizAttempt"> | Date | string | null
    answers?: JsonFilter<"AIModuleQuizAttempt">
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    aiModule?: XOR<AIModuleScalarRelationFilter, AIModuleWhereInput>
    topic?: XOR<TopicScalarRelationFilter, TopicWhereInput>
  }

  export type AIModuleQuizAttemptOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    aiModuleId?: SortOrder
    topicId?: SortOrder
    score?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    answers?: SortOrder
    user?: UserOrderByWithRelationInput
    aiModule?: AIModuleOrderByWithRelationInput
    topic?: TopicOrderByWithRelationInput
  }

  export type AIModuleQuizAttemptWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AIModuleQuizAttemptWhereInput | AIModuleQuizAttemptWhereInput[]
    OR?: AIModuleQuizAttemptWhereInput[]
    NOT?: AIModuleQuizAttemptWhereInput | AIModuleQuizAttemptWhereInput[]
    userId?: StringFilter<"AIModuleQuizAttempt"> | string
    aiModuleId?: StringFilter<"AIModuleQuizAttempt"> | string
    topicId?: StringFilter<"AIModuleQuizAttempt"> | string
    score?: FloatFilter<"AIModuleQuizAttempt"> | number
    startedAt?: DateTimeFilter<"AIModuleQuizAttempt"> | Date | string
    completedAt?: DateTimeNullableFilter<"AIModuleQuizAttempt"> | Date | string | null
    answers?: JsonFilter<"AIModuleQuizAttempt">
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    aiModule?: XOR<AIModuleScalarRelationFilter, AIModuleWhereInput>
    topic?: XOR<TopicScalarRelationFilter, TopicWhereInput>
  }, "id">

  export type AIModuleQuizAttemptOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    aiModuleId?: SortOrder
    topicId?: SortOrder
    score?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    answers?: SortOrder
    _count?: AIModuleQuizAttemptCountOrderByAggregateInput
    _avg?: AIModuleQuizAttemptAvgOrderByAggregateInput
    _max?: AIModuleQuizAttemptMaxOrderByAggregateInput
    _min?: AIModuleQuizAttemptMinOrderByAggregateInput
    _sum?: AIModuleQuizAttemptSumOrderByAggregateInput
  }

  export type AIModuleQuizAttemptScalarWhereWithAggregatesInput = {
    AND?: AIModuleQuizAttemptScalarWhereWithAggregatesInput | AIModuleQuizAttemptScalarWhereWithAggregatesInput[]
    OR?: AIModuleQuizAttemptScalarWhereWithAggregatesInput[]
    NOT?: AIModuleQuizAttemptScalarWhereWithAggregatesInput | AIModuleQuizAttemptScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AIModuleQuizAttempt"> | string
    userId?: StringWithAggregatesFilter<"AIModuleQuizAttempt"> | string
    aiModuleId?: StringWithAggregatesFilter<"AIModuleQuizAttempt"> | string
    topicId?: StringWithAggregatesFilter<"AIModuleQuizAttempt"> | string
    score?: FloatWithAggregatesFilter<"AIModuleQuizAttempt"> | number
    startedAt?: DateTimeWithAggregatesFilter<"AIModuleQuizAttempt"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"AIModuleQuizAttempt"> | Date | string | null
    answers?: JsonWithAggregatesFilter<"AIModuleQuizAttempt">
  }

  export type AIModuleRatingWhereInput = {
    AND?: AIModuleRatingWhereInput | AIModuleRatingWhereInput[]
    OR?: AIModuleRatingWhereInput[]
    NOT?: AIModuleRatingWhereInput | AIModuleRatingWhereInput[]
    id?: StringFilter<"AIModuleRating"> | string
    userId?: StringFilter<"AIModuleRating"> | string
    aiModuleId?: StringFilter<"AIModuleRating"> | string
    topicId?: StringFilter<"AIModuleRating"> | string
    rating?: IntFilter<"AIModuleRating"> | number
    feedback?: StringNullableFilter<"AIModuleRating"> | string | null
    createdAt?: DateTimeFilter<"AIModuleRating"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    aiModule?: XOR<AIModuleScalarRelationFilter, AIModuleWhereInput>
    topic?: XOR<TopicScalarRelationFilter, TopicWhereInput>
  }

  export type AIModuleRatingOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    aiModuleId?: SortOrder
    topicId?: SortOrder
    rating?: SortOrder
    feedback?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    aiModule?: AIModuleOrderByWithRelationInput
    topic?: TopicOrderByWithRelationInput
  }

  export type AIModuleRatingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_aiModuleId?: AIModuleRatingUserIdAiModuleIdCompoundUniqueInput
    AND?: AIModuleRatingWhereInput | AIModuleRatingWhereInput[]
    OR?: AIModuleRatingWhereInput[]
    NOT?: AIModuleRatingWhereInput | AIModuleRatingWhereInput[]
    userId?: StringFilter<"AIModuleRating"> | string
    aiModuleId?: StringFilter<"AIModuleRating"> | string
    topicId?: StringFilter<"AIModuleRating"> | string
    rating?: IntFilter<"AIModuleRating"> | number
    feedback?: StringNullableFilter<"AIModuleRating"> | string | null
    createdAt?: DateTimeFilter<"AIModuleRating"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    aiModule?: XOR<AIModuleScalarRelationFilter, AIModuleWhereInput>
    topic?: XOR<TopicScalarRelationFilter, TopicWhereInput>
  }, "id" | "userId_aiModuleId">

  export type AIModuleRatingOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    aiModuleId?: SortOrder
    topicId?: SortOrder
    rating?: SortOrder
    feedback?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AIModuleRatingCountOrderByAggregateInput
    _avg?: AIModuleRatingAvgOrderByAggregateInput
    _max?: AIModuleRatingMaxOrderByAggregateInput
    _min?: AIModuleRatingMinOrderByAggregateInput
    _sum?: AIModuleRatingSumOrderByAggregateInput
  }

  export type AIModuleRatingScalarWhereWithAggregatesInput = {
    AND?: AIModuleRatingScalarWhereWithAggregatesInput | AIModuleRatingScalarWhereWithAggregatesInput[]
    OR?: AIModuleRatingScalarWhereWithAggregatesInput[]
    NOT?: AIModuleRatingScalarWhereWithAggregatesInput | AIModuleRatingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AIModuleRating"> | string
    userId?: StringWithAggregatesFilter<"AIModuleRating"> | string
    aiModuleId?: StringWithAggregatesFilter<"AIModuleRating"> | string
    topicId?: StringWithAggregatesFilter<"AIModuleRating"> | string
    rating?: IntWithAggregatesFilter<"AIModuleRating"> | number
    feedback?: StringNullableWithAggregatesFilter<"AIModuleRating"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AIModuleRating"> | Date | string
  }

  export type UserProgressWhereInput = {
    AND?: UserProgressWhereInput | UserProgressWhereInput[]
    OR?: UserProgressWhereInput[]
    NOT?: UserProgressWhereInput | UserProgressWhereInput[]
    id?: StringFilter<"UserProgress"> | string
    userId?: StringFilter<"UserProgress"> | string
    learningPathId?: StringFilter<"UserProgress"> | string
    moduleId?: StringFilter<"UserProgress"> | string
    status?: StringFilter<"UserProgress"> | string
    updatedAt?: DateTimeFilter<"UserProgress"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    learningPath?: XOR<LearningPathScalarRelationFilter, LearningPathWhereInput>
    module?: XOR<LearningPathItemScalarRelationFilter, LearningPathItemWhereInput>
  }

  export type UserProgressOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    learningPathId?: SortOrder
    moduleId?: SortOrder
    status?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    learningPath?: LearningPathOrderByWithRelationInput
    module?: LearningPathItemOrderByWithRelationInput
  }

  export type UserProgressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_moduleId?: UserProgressUserIdModuleIdCompoundUniqueInput
    AND?: UserProgressWhereInput | UserProgressWhereInput[]
    OR?: UserProgressWhereInput[]
    NOT?: UserProgressWhereInput | UserProgressWhereInput[]
    userId?: StringFilter<"UserProgress"> | string
    learningPathId?: StringFilter<"UserProgress"> | string
    moduleId?: StringFilter<"UserProgress"> | string
    status?: StringFilter<"UserProgress"> | string
    updatedAt?: DateTimeFilter<"UserProgress"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    learningPath?: XOR<LearningPathScalarRelationFilter, LearningPathWhereInput>
    module?: XOR<LearningPathItemScalarRelationFilter, LearningPathItemWhereInput>
  }, "id" | "userId_moduleId">

  export type UserProgressOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    learningPathId?: SortOrder
    moduleId?: SortOrder
    status?: SortOrder
    updatedAt?: SortOrder
    _count?: UserProgressCountOrderByAggregateInput
    _max?: UserProgressMaxOrderByAggregateInput
    _min?: UserProgressMinOrderByAggregateInput
  }

  export type UserProgressScalarWhereWithAggregatesInput = {
    AND?: UserProgressScalarWhereWithAggregatesInput | UserProgressScalarWhereWithAggregatesInput[]
    OR?: UserProgressScalarWhereWithAggregatesInput[]
    NOT?: UserProgressScalarWhereWithAggregatesInput | UserProgressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserProgress"> | string
    userId?: StringWithAggregatesFilter<"UserProgress"> | string
    learningPathId?: StringWithAggregatesFilter<"UserProgress"> | string
    moduleId?: StringWithAggregatesFilter<"UserProgress"> | string
    status?: StringWithAggregatesFilter<"UserProgress"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserProgress"> | Date | string
  }

  export type AIChatWhereInput = {
    AND?: AIChatWhereInput | AIChatWhereInput[]
    OR?: AIChatWhereInput[]
    NOT?: AIChatWhereInput | AIChatWhereInput[]
    id?: StringFilter<"AIChat"> | string
    title?: StringNullableFilter<"AIChat"> | string | null
    createdAt?: DateTimeFilter<"AIChat"> | Date | string
    userId?: StringFilter<"AIChat"> | string
    messages?: AIChatMessageListRelationFilter
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type AIChatOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    messages?: AIChatMessageOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
  }

  export type AIChatWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AIChatWhereInput | AIChatWhereInput[]
    OR?: AIChatWhereInput[]
    NOT?: AIChatWhereInput | AIChatWhereInput[]
    title?: StringNullableFilter<"AIChat"> | string | null
    createdAt?: DateTimeFilter<"AIChat"> | Date | string
    userId?: StringFilter<"AIChat"> | string
    messages?: AIChatMessageListRelationFilter
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type AIChatOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    _count?: AIChatCountOrderByAggregateInput
    _max?: AIChatMaxOrderByAggregateInput
    _min?: AIChatMinOrderByAggregateInput
  }

  export type AIChatScalarWhereWithAggregatesInput = {
    AND?: AIChatScalarWhereWithAggregatesInput | AIChatScalarWhereWithAggregatesInput[]
    OR?: AIChatScalarWhereWithAggregatesInput[]
    NOT?: AIChatScalarWhereWithAggregatesInput | AIChatScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AIChat"> | string
    title?: StringNullableWithAggregatesFilter<"AIChat"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AIChat"> | Date | string
    userId?: StringWithAggregatesFilter<"AIChat"> | string
  }

  export type AIChatMessageWhereInput = {
    AND?: AIChatMessageWhereInput | AIChatMessageWhereInput[]
    OR?: AIChatMessageWhereInput[]
    NOT?: AIChatMessageWhereInput | AIChatMessageWhereInput[]
    id?: StringFilter<"AIChatMessage"> | string
    chatId?: StringFilter<"AIChatMessage"> | string
    display?: StringNullableFilter<"AIChatMessage"> | string | null
    role?: StringFilter<"AIChatMessage"> | string
    content?: StringFilter<"AIChatMessage"> | string
    createdAt?: DateTimeFilter<"AIChatMessage"> | Date | string
    chat?: XOR<AIChatScalarRelationFilter, AIChatWhereInput>
  }

  export type AIChatMessageOrderByWithRelationInput = {
    id?: SortOrder
    chatId?: SortOrder
    display?: SortOrderInput | SortOrder
    role?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    chat?: AIChatOrderByWithRelationInput
  }

  export type AIChatMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AIChatMessageWhereInput | AIChatMessageWhereInput[]
    OR?: AIChatMessageWhereInput[]
    NOT?: AIChatMessageWhereInput | AIChatMessageWhereInput[]
    chatId?: StringFilter<"AIChatMessage"> | string
    display?: StringNullableFilter<"AIChatMessage"> | string | null
    role?: StringFilter<"AIChatMessage"> | string
    content?: StringFilter<"AIChatMessage"> | string
    createdAt?: DateTimeFilter<"AIChatMessage"> | Date | string
    chat?: XOR<AIChatScalarRelationFilter, AIChatWhereInput>
  }, "id">

  export type AIChatMessageOrderByWithAggregationInput = {
    id?: SortOrder
    chatId?: SortOrder
    display?: SortOrderInput | SortOrder
    role?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    _count?: AIChatMessageCountOrderByAggregateInput
    _max?: AIChatMessageMaxOrderByAggregateInput
    _min?: AIChatMessageMinOrderByAggregateInput
  }

  export type AIChatMessageScalarWhereWithAggregatesInput = {
    AND?: AIChatMessageScalarWhereWithAggregatesInput | AIChatMessageScalarWhereWithAggregatesInput[]
    OR?: AIChatMessageScalarWhereWithAggregatesInput[]
    NOT?: AIChatMessageScalarWhereWithAggregatesInput | AIChatMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AIChatMessage"> | string
    chatId?: StringWithAggregatesFilter<"AIChatMessage"> | string
    display?: StringNullableWithAggregatesFilter<"AIChatMessage"> | string | null
    role?: StringWithAggregatesFilter<"AIChatMessage"> | string
    content?: StringWithAggregatesFilter<"AIChatMessage"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AIChatMessage"> | Date | string
  }

  export type PracticeAttemptWhereInput = {
    AND?: PracticeAttemptWhereInput | PracticeAttemptWhereInput[]
    OR?: PracticeAttemptWhereInput[]
    NOT?: PracticeAttemptWhereInput | PracticeAttemptWhereInput[]
    id?: StringFilter<"PracticeAttempt"> | string
    userId?: StringFilter<"PracticeAttempt"> | string
    aiModuleId?: StringFilter<"PracticeAttempt"> | string
    questions?: JsonFilter<"PracticeAttempt">
    createdAt?: DateTimeFilter<"PracticeAttempt"> | Date | string
    updatedAt?: DateTimeFilter<"PracticeAttempt"> | Date | string
    score?: FloatNullableFilter<"PracticeAttempt"> | number | null
    averageEase?: FloatNullableFilter<"PracticeAttempt"> | number | null
    completedAt?: DateTimeNullableFilter<"PracticeAttempt"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    aiModule?: XOR<AIModuleScalarRelationFilter, AIModuleWhereInput>
  }

  export type PracticeAttemptOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    aiModuleId?: SortOrder
    questions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    score?: SortOrderInput | SortOrder
    averageEase?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    aiModule?: AIModuleOrderByWithRelationInput
  }

  export type PracticeAttemptWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PracticeAttemptWhereInput | PracticeAttemptWhereInput[]
    OR?: PracticeAttemptWhereInput[]
    NOT?: PracticeAttemptWhereInput | PracticeAttemptWhereInput[]
    userId?: StringFilter<"PracticeAttempt"> | string
    aiModuleId?: StringFilter<"PracticeAttempt"> | string
    questions?: JsonFilter<"PracticeAttempt">
    createdAt?: DateTimeFilter<"PracticeAttempt"> | Date | string
    updatedAt?: DateTimeFilter<"PracticeAttempt"> | Date | string
    score?: FloatNullableFilter<"PracticeAttempt"> | number | null
    averageEase?: FloatNullableFilter<"PracticeAttempt"> | number | null
    completedAt?: DateTimeNullableFilter<"PracticeAttempt"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    aiModule?: XOR<AIModuleScalarRelationFilter, AIModuleWhereInput>
  }, "id">

  export type PracticeAttemptOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    aiModuleId?: SortOrder
    questions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    score?: SortOrderInput | SortOrder
    averageEase?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: PracticeAttemptCountOrderByAggregateInput
    _avg?: PracticeAttemptAvgOrderByAggregateInput
    _max?: PracticeAttemptMaxOrderByAggregateInput
    _min?: PracticeAttemptMinOrderByAggregateInput
    _sum?: PracticeAttemptSumOrderByAggregateInput
  }

  export type PracticeAttemptScalarWhereWithAggregatesInput = {
    AND?: PracticeAttemptScalarWhereWithAggregatesInput | PracticeAttemptScalarWhereWithAggregatesInput[]
    OR?: PracticeAttemptScalarWhereWithAggregatesInput[]
    NOT?: PracticeAttemptScalarWhereWithAggregatesInput | PracticeAttemptScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PracticeAttempt"> | string
    userId?: StringWithAggregatesFilter<"PracticeAttempt"> | string
    aiModuleId?: StringWithAggregatesFilter<"PracticeAttempt"> | string
    questions?: JsonWithAggregatesFilter<"PracticeAttempt">
    createdAt?: DateTimeWithAggregatesFilter<"PracticeAttempt"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PracticeAttempt"> | Date | string
    score?: FloatNullableWithAggregatesFilter<"PracticeAttempt"> | number | null
    averageEase?: FloatNullableWithAggregatesFilter<"PracticeAttempt"> | number | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"PracticeAttempt"> | Date | string | null
  }

  export type UserCreateInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesCreateNestedOneWithoutUserInput
    topics?: TopicCreateNestedManyWithoutUserInput
    progress?: ProgressCreateNestedManyWithoutUserInput
    badges?: BadgeCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutUserInput
    aiModules?: AIModuleCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressCreateNestedManyWithoutUserInput
    AIChat?: AIChatCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesUncheckedCreateNestedOneWithoutUserInput
    topics?: TopicUncheckedCreateNestedManyWithoutUserInput
    progress?: ProgressUncheckedCreateNestedManyWithoutUserInput
    badges?: BadgeUncheckedCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewUncheckedCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathUncheckedCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionUncheckedCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceUncheckedCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenUncheckedCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeUncheckedCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingUncheckedCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreUncheckedCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutUserInput
    aiModules?: AIModuleUncheckedCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingUncheckedCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    AIChat?: AIChatUncheckedCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUpdateOneWithoutUserNestedInput
    topics?: TopicUpdateManyWithoutUserNestedInput
    progress?: ProgressUpdateManyWithoutUserNestedInput
    badges?: BadgeUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUncheckedUpdateOneWithoutUserNestedInput
    topics?: TopicUncheckedUpdateManyWithoutUserNestedInput
    progress?: ProgressUncheckedUpdateManyWithoutUserNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUncheckedUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUncheckedUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUncheckedUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUncheckedUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUncheckedUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUncheckedUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUncheckedUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUncheckedUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUncheckedUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUncheckedUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUncheckedUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AccountCreateInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    oauth_token_secret?: string | null
    oauth_token?: string | null
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    oauth_token_secret?: string | null
    oauth_token?: string | null
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_token_secret?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_token?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_token_secret?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_token?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    oauth_token_secret?: string | null
    oauth_token?: string | null
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_token_secret?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_token?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_token_secret?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_token?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityCreateInput = {
    id?: string
    type: string
    description: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    description: string
    createdAt?: Date | string
  }

  export type ActivityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityCreateManyInput = {
    id?: string
    userId: string
    type: string
    description: string
    createdAt?: Date | string
  }

  export type ActivityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearningPreferencesCreateInput = {
    id?: string
    visualLearning: number
    auditoryLearning: number
    kinestheticLearning: number
    user: UserCreateNestedOneWithoutLearningPreferencesInput
  }

  export type LearningPreferencesUncheckedCreateInput = {
    id?: string
    userId: string
    visualLearning: number
    auditoryLearning: number
    kinestheticLearning: number
  }

  export type LearningPreferencesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    visualLearning?: IntFieldUpdateOperationsInput | number
    auditoryLearning?: IntFieldUpdateOperationsInput | number
    kinestheticLearning?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutLearningPreferencesNestedInput
  }

  export type LearningPreferencesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    visualLearning?: IntFieldUpdateOperationsInput | number
    auditoryLearning?: IntFieldUpdateOperationsInput | number
    kinestheticLearning?: IntFieldUpdateOperationsInput | number
  }

  export type LearningPreferencesCreateManyInput = {
    id?: string
    userId: string
    visualLearning: number
    auditoryLearning: number
    kinestheticLearning: number
  }

  export type LearningPreferencesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    visualLearning?: IntFieldUpdateOperationsInput | number
    auditoryLearning?: IntFieldUpdateOperationsInput | number
    kinestheticLearning?: IntFieldUpdateOperationsInput | number
  }

  export type LearningPreferencesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    visualLearning?: IntFieldUpdateOperationsInput | number
    auditoryLearning?: IntFieldUpdateOperationsInput | number
    kinestheticLearning?: IntFieldUpdateOperationsInput | number
  }

  export type TopicCreateInput = {
    id?: string
    title: string
    description?: string | null
    user: UserCreateNestedOneWithoutTopicsInput
    progress?: ProgressCreateNestedManyWithoutTopicInput
    learningPathItems?: LearningPathItemCreateNestedManyWithoutTopicInput
    contentItems?: ContentItemCreateNestedManyWithoutTopicInput
    analyticsEntries?: AnalyticsEntryCreateNestedManyWithoutTopicInput
    comments?: CommentCreateNestedManyWithoutTopicInput
    prerequisites?: PrerequisiteCreateNestedManyWithoutTopicInput
    aiModules?: AIModuleCreateNestedManyWithoutTopicInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptCreateNestedManyWithoutTopicInput
    aiModuleRatings?: AIModuleRatingCreateNestedManyWithoutTopicInput
  }

  export type TopicUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    userId: string
    progress?: ProgressUncheckedCreateNestedManyWithoutTopicInput
    learningPathItems?: LearningPathItemUncheckedCreateNestedManyWithoutTopicInput
    contentItems?: ContentItemUncheckedCreateNestedManyWithoutTopicInput
    analyticsEntries?: AnalyticsEntryUncheckedCreateNestedManyWithoutTopicInput
    comments?: CommentUncheckedCreateNestedManyWithoutTopicInput
    prerequisites?: PrerequisiteUncheckedCreateNestedManyWithoutTopicInput
    aiModules?: AIModuleUncheckedCreateNestedManyWithoutTopicInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedCreateNestedManyWithoutTopicInput
    aiModuleRatings?: AIModuleRatingUncheckedCreateNestedManyWithoutTopicInput
  }

  export type TopicUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutTopicsNestedInput
    progress?: ProgressUpdateManyWithoutTopicNestedInput
    learningPathItems?: LearningPathItemUpdateManyWithoutTopicNestedInput
    contentItems?: ContentItemUpdateManyWithoutTopicNestedInput
    analyticsEntries?: AnalyticsEntryUpdateManyWithoutTopicNestedInput
    comments?: CommentUpdateManyWithoutTopicNestedInput
    prerequisites?: PrerequisiteUpdateManyWithoutTopicNestedInput
    aiModules?: AIModuleUpdateManyWithoutTopicNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUpdateManyWithoutTopicNestedInput
    aiModuleRatings?: AIModuleRatingUpdateManyWithoutTopicNestedInput
  }

  export type TopicUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    progress?: ProgressUncheckedUpdateManyWithoutTopicNestedInput
    learningPathItems?: LearningPathItemUncheckedUpdateManyWithoutTopicNestedInput
    contentItems?: ContentItemUncheckedUpdateManyWithoutTopicNestedInput
    analyticsEntries?: AnalyticsEntryUncheckedUpdateManyWithoutTopicNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTopicNestedInput
    prerequisites?: PrerequisiteUncheckedUpdateManyWithoutTopicNestedInput
    aiModules?: AIModuleUncheckedUpdateManyWithoutTopicNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedUpdateManyWithoutTopicNestedInput
    aiModuleRatings?: AIModuleRatingUncheckedUpdateManyWithoutTopicNestedInput
  }

  export type TopicCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    userId: string
  }

  export type TopicUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TopicUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ProgressCreateInput = {
    id?: string
    completed: number
    user: UserCreateNestedOneWithoutProgressInput
    topic: TopicCreateNestedOneWithoutProgressInput
  }

  export type ProgressUncheckedCreateInput = {
    id?: string
    userId: string
    topicId: string
    completed: number
  }

  export type ProgressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed?: FloatFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutProgressNestedInput
    topic?: TopicUpdateOneRequiredWithoutProgressNestedInput
  }

  export type ProgressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    completed?: FloatFieldUpdateOperationsInput | number
  }

  export type ProgressCreateManyInput = {
    id?: string
    userId: string
    topicId: string
    completed: number
  }

  export type ProgressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed?: FloatFieldUpdateOperationsInput | number
  }

  export type ProgressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    completed?: FloatFieldUpdateOperationsInput | number
  }

  export type BadgeCreateInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    earnedAt?: Date | string
    user: UserCreateNestedOneWithoutBadgesInput
  }

  export type BadgeUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    userId: string
    earnedAt?: Date | string
  }

  export type BadgeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBadgesNestedInput
  }

  export type BadgeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BadgeCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    userId: string
    earnedAt?: Date | string
  }

  export type BadgeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BadgeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UpcomingReviewCreateInput = {
    id?: string
    topicId: string
    dueDate: Date | string
    user: UserCreateNestedOneWithoutUpcomingReviewsInput
  }

  export type UpcomingReviewUncheckedCreateInput = {
    id?: string
    userId: string
    topicId: string
    dueDate: Date | string
  }

  export type UpcomingReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUpcomingReviewsNestedInput
  }

  export type UpcomingReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UpcomingReviewCreateManyInput = {
    id?: string
    userId: string
    topicId: string
    dueDate: Date | string
  }

  export type UpcomingReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UpcomingReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearningPathCreateInput = {
    id?: string
    title: string
    description?: string | null
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    shareId?: string | null
    sharedAt?: Date | string | null
    user: UserCreateNestedOneWithoutLearningPathsInput
    items?: LearningPathItemCreateNestedManyWithoutLearningPathInput
    prerequisites?: PrerequisiteCreateNestedManyWithoutLearningPathInput
    aiModuleItems?: AIModuleLearningPathItemCreateNestedManyWithoutLearningPathInput
    UserProgress?: UserProgressCreateNestedManyWithoutLearningPathInput
  }

  export type LearningPathUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    userId: string
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    shareId?: string | null
    sharedAt?: Date | string | null
    items?: LearningPathItemUncheckedCreateNestedManyWithoutLearningPathInput
    prerequisites?: PrerequisiteUncheckedCreateNestedManyWithoutLearningPathInput
    aiModuleItems?: AIModuleLearningPathItemUncheckedCreateNestedManyWithoutLearningPathInput
    UserProgress?: UserProgressUncheckedCreateNestedManyWithoutLearningPathInput
  }

  export type LearningPathUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shareId?: NullableStringFieldUpdateOperationsInput | string | null
    sharedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutLearningPathsNestedInput
    items?: LearningPathItemUpdateManyWithoutLearningPathNestedInput
    prerequisites?: PrerequisiteUpdateManyWithoutLearningPathNestedInput
    aiModuleItems?: AIModuleLearningPathItemUpdateManyWithoutLearningPathNestedInput
    UserProgress?: UserProgressUpdateManyWithoutLearningPathNestedInput
  }

  export type LearningPathUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shareId?: NullableStringFieldUpdateOperationsInput | string | null
    sharedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: LearningPathItemUncheckedUpdateManyWithoutLearningPathNestedInput
    prerequisites?: PrerequisiteUncheckedUpdateManyWithoutLearningPathNestedInput
    aiModuleItems?: AIModuleLearningPathItemUncheckedUpdateManyWithoutLearningPathNestedInput
    UserProgress?: UserProgressUncheckedUpdateManyWithoutLearningPathNestedInput
  }

  export type LearningPathCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    userId: string
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    shareId?: string | null
    sharedAt?: Date | string | null
  }

  export type LearningPathUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shareId?: NullableStringFieldUpdateOperationsInput | string | null
    sharedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LearningPathUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shareId?: NullableStringFieldUpdateOperationsInput | string | null
    sharedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LearningPathItemCreateInput = {
    id?: string
    order: number
    confidence?: number
    learningPath: LearningPathCreateNestedOneWithoutItemsInput
    topic: TopicCreateNestedOneWithoutLearningPathItemsInput
    UserProgress?: UserProgressCreateNestedManyWithoutModuleInput
  }

  export type LearningPathItemUncheckedCreateInput = {
    id?: string
    order: number
    learningPathId: string
    topicId: string
    confidence?: number
    UserProgress?: UserProgressUncheckedCreateNestedManyWithoutModuleInput
  }

  export type LearningPathItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    confidence?: IntFieldUpdateOperationsInput | number
    learningPath?: LearningPathUpdateOneRequiredWithoutItemsNestedInput
    topic?: TopicUpdateOneRequiredWithoutLearningPathItemsNestedInput
    UserProgress?: UserProgressUpdateManyWithoutModuleNestedInput
  }

  export type LearningPathItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    learningPathId?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    confidence?: IntFieldUpdateOperationsInput | number
    UserProgress?: UserProgressUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type LearningPathItemCreateManyInput = {
    id?: string
    order: number
    learningPathId: string
    topicId: string
    confidence?: number
  }

  export type LearningPathItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    confidence?: IntFieldUpdateOperationsInput | number
  }

  export type LearningPathItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    learningPathId?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    confidence?: IntFieldUpdateOperationsInput | number
  }

  export type ContentItemCreateInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    type: string
    difficulty: string
    createdAt?: Date | string
    updatedAt?: Date | string
    version?: string
    topic: TopicCreateNestedOneWithoutContentItemsInput
    bookmarks?: BookmarkCreateNestedManyWithoutContentItemInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutContentItemInput
    reviewItems?: ReviewItemCreateNestedManyWithoutContentItemInput
    ratings?: ContentRatingCreateNestedManyWithoutContentItemInput
    aiPlaylistItems?: AIPlaylistItemCreateNestedManyWithoutContentItemInput
  }

  export type ContentItemUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    type: string
    difficulty: string
    topicId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    version?: string
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutContentItemInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutContentItemInput
    reviewItems?: ReviewItemUncheckedCreateNestedManyWithoutContentItemInput
    ratings?: ContentRatingUncheckedCreateNestedManyWithoutContentItemInput
    aiPlaylistItems?: AIPlaylistItemUncheckedCreateNestedManyWithoutContentItemInput
  }

  export type ContentItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: StringFieldUpdateOperationsInput | string
    topic?: TopicUpdateOneRequiredWithoutContentItemsNestedInput
    bookmarks?: BookmarkUpdateManyWithoutContentItemNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutContentItemNestedInput
    reviewItems?: ReviewItemUpdateManyWithoutContentItemNestedInput
    ratings?: ContentRatingUpdateManyWithoutContentItemNestedInput
    aiPlaylistItems?: AIPlaylistItemUpdateManyWithoutContentItemNestedInput
  }

  export type ContentItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: StringFieldUpdateOperationsInput | string
    bookmarks?: BookmarkUncheckedUpdateManyWithoutContentItemNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutContentItemNestedInput
    reviewItems?: ReviewItemUncheckedUpdateManyWithoutContentItemNestedInput
    ratings?: ContentRatingUncheckedUpdateManyWithoutContentItemNestedInput
    aiPlaylistItems?: AIPlaylistItemUncheckedUpdateManyWithoutContentItemNestedInput
  }

  export type ContentItemCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    type: string
    difficulty: string
    topicId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    version?: string
  }

  export type ContentItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: StringFieldUpdateOperationsInput | string
  }

  export type ContentItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: StringFieldUpdateOperationsInput | string
  }

  export type ContentRatingCreateInput = {
    id?: string
    rating: number
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutContentRatingsInput
    contentItem: ContentItemCreateNestedOneWithoutRatingsInput
  }

  export type ContentRatingUncheckedCreateInput = {
    id?: string
    userId: string
    contentItemId: string
    rating: number
    createdAt?: Date | string
  }

  export type ContentRatingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutContentRatingsNestedInput
    contentItem?: ContentItemUpdateOneRequiredWithoutRatingsNestedInput
  }

  export type ContentRatingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    contentItemId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentRatingCreateManyInput = {
    id?: string
    userId: string
    contentItemId: string
    rating: number
    createdAt?: Date | string
  }

  export type ContentRatingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentRatingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    contentItemId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookmarkCreateInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutBookmarksInput
    contentItem: ContentItemCreateNestedOneWithoutBookmarksInput
  }

  export type BookmarkUncheckedCreateInput = {
    id?: string
    userId: string
    contentItemId: string
    createdAt?: Date | string
  }

  export type BookmarkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBookmarksNestedInput
    contentItem?: ContentItemUpdateOneRequiredWithoutBookmarksNestedInput
  }

  export type BookmarkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    contentItemId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookmarkCreateManyInput = {
    id?: string
    userId: string
    contentItemId: string
    createdAt?: Date | string
  }

  export type BookmarkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookmarkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    contentItemId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizAttemptCreateInput = {
    id?: string
    score: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    answers?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutQuizAttemptsInput
    contentItem: ContentItemCreateNestedOneWithoutQuizAttemptsInput
  }

  export type QuizAttemptUncheckedCreateInput = {
    id?: string
    userId: string
    contentItemId: string
    score: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    answers?: NullableJsonNullValueInput | InputJsonValue
  }

  export type QuizAttemptUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutQuizAttemptsNestedInput
    contentItem?: ContentItemUpdateOneRequiredWithoutQuizAttemptsNestedInput
  }

  export type QuizAttemptUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    contentItemId?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: NullableJsonNullValueInput | InputJsonValue
  }

  export type QuizAttemptCreateManyInput = {
    id?: string
    userId: string
    contentItemId: string
    score: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    answers?: NullableJsonNullValueInput | InputJsonValue
  }

  export type QuizAttemptUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: NullableJsonNullValueInput | InputJsonValue
  }

  export type QuizAttemptUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    contentItemId?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: NullableJsonNullValueInput | InputJsonValue
  }

  export type KnowledgeNodeCreateInput = {
    id?: string
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutKnowledgeNodesInput
    parent?: KnowledgeNodeCreateNestedOneWithoutChildrenInput
    children?: KnowledgeNodeCreateNestedManyWithoutParentInput
  }

  export type KnowledgeNodeUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    userId: string
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: KnowledgeNodeUncheckedCreateNestedManyWithoutParentInput
  }

  export type KnowledgeNodeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutKnowledgeNodesNestedInput
    parent?: KnowledgeNodeUpdateOneWithoutChildrenNestedInput
    children?: KnowledgeNodeUpdateManyWithoutParentNestedInput
  }

  export type KnowledgeNodeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: KnowledgeNodeUncheckedUpdateManyWithoutParentNestedInput
  }

  export type KnowledgeNodeCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    userId: string
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KnowledgeNodeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeNodeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaderboardEntryCreateInput = {
    id?: string
    score: number
    type: string
    startDate: Date | string
    endDate: Date | string
    user: UserCreateNestedOneWithoutLeaderboardEntriesInput
  }

  export type LeaderboardEntryUncheckedCreateInput = {
    id?: string
    userId: string
    score: number
    type: string
    startDate: Date | string
    endDate: Date | string
  }

  export type LeaderboardEntryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLeaderboardEntriesNestedInput
  }

  export type LeaderboardEntryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaderboardEntryCreateManyInput = {
    id?: string
    userId: string
    score: number
    type: string
    startDate: Date | string
    endDate: Date | string
  }

  export type LeaderboardEntryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaderboardEntryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewSessionCreateInput = {
    id?: string
    dueDate: Date | string
    completed?: boolean
    isUrgent?: boolean
    user: UserCreateNestedOneWithoutReviewSessionsInput
    items?: ReviewItemCreateNestedManyWithoutReviewSessionInput
  }

  export type ReviewSessionUncheckedCreateInput = {
    id?: string
    userId: string
    dueDate: Date | string
    completed?: boolean
    isUrgent?: boolean
    items?: ReviewItemUncheckedCreateNestedManyWithoutReviewSessionInput
  }

  export type ReviewSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    isUrgent?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutReviewSessionsNestedInput
    items?: ReviewItemUpdateManyWithoutReviewSessionNestedInput
  }

  export type ReviewSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    isUrgent?: BoolFieldUpdateOperationsInput | boolean
    items?: ReviewItemUncheckedUpdateManyWithoutReviewSessionNestedInput
  }

  export type ReviewSessionCreateManyInput = {
    id?: string
    userId: string
    dueDate: Date | string
    completed?: boolean
    isUrgent?: boolean
  }

  export type ReviewSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    isUrgent?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ReviewSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    isUrgent?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ReviewItemCreateInput = {
    id?: string
    type: string
    question: string
    answer: string
    userAnswer?: string | null
    isCorrect?: boolean | null
    answeredAt?: Date | string | null
    reviewSession: ReviewSessionCreateNestedOneWithoutItemsInput
    contentItem: ContentItemCreateNestedOneWithoutReviewItemsInput
  }

  export type ReviewItemUncheckedCreateInput = {
    id?: string
    reviewSessionId: string
    contentItemId: string
    type: string
    question: string
    answer: string
    userAnswer?: string | null
    isCorrect?: boolean | null
    answeredAt?: Date | string | null
  }

  export type ReviewItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    userAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    isCorrect?: NullableBoolFieldUpdateOperationsInput | boolean | null
    answeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewSession?: ReviewSessionUpdateOneRequiredWithoutItemsNestedInput
    contentItem?: ContentItemUpdateOneRequiredWithoutReviewItemsNestedInput
  }

  export type ReviewItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewSessionId?: StringFieldUpdateOperationsInput | string
    contentItemId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    userAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    isCorrect?: NullableBoolFieldUpdateOperationsInput | boolean | null
    answeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReviewItemCreateManyInput = {
    id?: string
    reviewSessionId: string
    contentItemId: string
    type: string
    question: string
    answer: string
    userAnswer?: string | null
    isCorrect?: boolean | null
    answeredAt?: Date | string | null
  }

  export type ReviewItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    userAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    isCorrect?: NullableBoolFieldUpdateOperationsInput | boolean | null
    answeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReviewItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewSessionId?: StringFieldUpdateOperationsInput | string
    contentItemId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    userAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    isCorrect?: NullableBoolFieldUpdateOperationsInput | boolean | null
    answeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkspaceCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedWorkspacesInput
    members?: WorkspaceMemberCreateNestedManyWithoutWorkspaceInput
    whiteboards?: WhiteboardCreateNestedManyWithoutWorkspaceInput
    chats?: ChatCreateNestedManyWithoutWorkspaceInput
    breakoutRooms?: BreakoutRoomCreateNestedManyWithoutWorkspaceInput
    livePolls?: LivePollCreateNestedManyWithoutWorkspaceInput
    sessionSummaries?: SessionSummaryCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    members?: WorkspaceMemberUncheckedCreateNestedManyWithoutWorkspaceInput
    whiteboards?: WhiteboardUncheckedCreateNestedManyWithoutWorkspaceInput
    chats?: ChatUncheckedCreateNestedManyWithoutWorkspaceInput
    breakoutRooms?: BreakoutRoomUncheckedCreateNestedManyWithoutWorkspaceInput
    livePolls?: LivePollUncheckedCreateNestedManyWithoutWorkspaceInput
    sessionSummaries?: SessionSummaryUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedWorkspacesNestedInput
    members?: WorkspaceMemberUpdateManyWithoutWorkspaceNestedInput
    whiteboards?: WhiteboardUpdateManyWithoutWorkspaceNestedInput
    chats?: ChatUpdateManyWithoutWorkspaceNestedInput
    breakoutRooms?: BreakoutRoomUpdateManyWithoutWorkspaceNestedInput
    livePolls?: LivePollUpdateManyWithoutWorkspaceNestedInput
    sessionSummaries?: SessionSummaryUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    members?: WorkspaceMemberUncheckedUpdateManyWithoutWorkspaceNestedInput
    whiteboards?: WhiteboardUncheckedUpdateManyWithoutWorkspaceNestedInput
    chats?: ChatUncheckedUpdateManyWithoutWorkspaceNestedInput
    breakoutRooms?: BreakoutRoomUncheckedUpdateManyWithoutWorkspaceNestedInput
    livePolls?: LivePollUncheckedUpdateManyWithoutWorkspaceNestedInput
    sessionSummaries?: SessionSummaryUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
  }

  export type WorkspaceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
  }

  export type WorkspaceMemberCreateInput = {
    id?: string
    role: string
    joinedAt?: Date | string
    user: UserCreateNestedOneWithoutWorkspacesInput
    workspace: WorkspaceCreateNestedOneWithoutMembersInput
    breakoutRooms?: BreakoutRoomCreateNestedManyWithoutParticipantsInput
  }

  export type WorkspaceMemberUncheckedCreateInput = {
    id?: string
    userId: string
    workspaceId: string
    role: string
    joinedAt?: Date | string
    breakoutRooms?: BreakoutRoomUncheckedCreateNestedManyWithoutParticipantsInput
  }

  export type WorkspaceMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWorkspacesNestedInput
    workspace?: WorkspaceUpdateOneRequiredWithoutMembersNestedInput
    breakoutRooms?: BreakoutRoomUpdateManyWithoutParticipantsNestedInput
  }

  export type WorkspaceMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    breakoutRooms?: BreakoutRoomUncheckedUpdateManyWithoutParticipantsNestedInput
  }

  export type WorkspaceMemberCreateManyInput = {
    id?: string
    userId: string
    workspaceId: string
    role: string
    joinedAt?: Date | string
  }

  export type WorkspaceMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhiteboardCreateInput = {
    id?: string
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutWhiteboardsInput
    versions?: WhiteboardVersionCreateNestedManyWithoutWhiteboardInput
  }

  export type WhiteboardUncheckedCreateInput = {
    id?: string
    workspaceId: string
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: WhiteboardVersionUncheckedCreateNestedManyWithoutWhiteboardInput
  }

  export type WhiteboardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutWhiteboardsNestedInput
    versions?: WhiteboardVersionUpdateManyWithoutWhiteboardNestedInput
  }

  export type WhiteboardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: WhiteboardVersionUncheckedUpdateManyWithoutWhiteboardNestedInput
  }

  export type WhiteboardCreateManyInput = {
    id?: string
    workspaceId: string
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhiteboardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhiteboardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhiteboardVersionCreateInput = {
    id?: string
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy: string
    versionNumber: number
    whiteboard: WhiteboardCreateNestedOneWithoutVersionsInput
  }

  export type WhiteboardVersionUncheckedCreateInput = {
    id?: string
    whiteboardId: string
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy: string
    versionNumber: number
  }

  export type WhiteboardVersionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    whiteboard?: WhiteboardUpdateOneRequiredWithoutVersionsNestedInput
  }

  export type WhiteboardVersionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    whiteboardId?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
  }

  export type WhiteboardVersionCreateManyInput = {
    id?: string
    whiteboardId: string
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy: string
    versionNumber: number
  }

  export type WhiteboardVersionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
  }

  export type WhiteboardVersionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    whiteboardId?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
  }

  export type BreakoutRoomCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    endedAt?: Date | string | null
    workspace: WorkspaceCreateNestedOneWithoutBreakoutRoomsInput
    participants?: WorkspaceMemberCreateNestedManyWithoutBreakoutRoomsInput
  }

  export type BreakoutRoomUncheckedCreateInput = {
    id?: string
    workspaceId: string
    name: string
    createdAt?: Date | string
    endedAt?: Date | string | null
    participants?: WorkspaceMemberUncheckedCreateNestedManyWithoutBreakoutRoomsInput
  }

  export type BreakoutRoomUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workspace?: WorkspaceUpdateOneRequiredWithoutBreakoutRoomsNestedInput
    participants?: WorkspaceMemberUpdateManyWithoutBreakoutRoomsNestedInput
  }

  export type BreakoutRoomUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    participants?: WorkspaceMemberUncheckedUpdateManyWithoutBreakoutRoomsNestedInput
  }

  export type BreakoutRoomCreateManyInput = {
    id?: string
    workspaceId: string
    name: string
    createdAt?: Date | string
    endedAt?: Date | string | null
  }

  export type BreakoutRoomUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BreakoutRoomUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LivePollCreateInput = {
    id?: string
    question: string
    options: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    endedAt?: Date | string | null
    workspace: WorkspaceCreateNestedOneWithoutLivePollsInput
    votes?: PollVoteCreateNestedManyWithoutLivePollInput
  }

  export type LivePollUncheckedCreateInput = {
    id?: string
    workspaceId: string
    question: string
    options: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    endedAt?: Date | string | null
    votes?: PollVoteUncheckedCreateNestedManyWithoutLivePollInput
  }

  export type LivePollUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workspace?: WorkspaceUpdateOneRequiredWithoutLivePollsNestedInput
    votes?: PollVoteUpdateManyWithoutLivePollNestedInput
  }

  export type LivePollUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    votes?: PollVoteUncheckedUpdateManyWithoutLivePollNestedInput
  }

  export type LivePollCreateManyInput = {
    id?: string
    workspaceId: string
    question: string
    options: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    endedAt?: Date | string | null
  }

  export type LivePollUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LivePollUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PollVoteCreateInput = {
    id?: string
    option: string
    createdAt?: Date | string
    livePoll: LivePollCreateNestedOneWithoutVotesInput
    user: UserCreateNestedOneWithoutPollVotesInput
  }

  export type PollVoteUncheckedCreateInput = {
    id?: string
    livePoolId: string
    userId: string
    option: string
    createdAt?: Date | string
  }

  export type PollVoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    option?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    livePoll?: LivePollUpdateOneRequiredWithoutVotesNestedInput
    user?: UserUpdateOneRequiredWithoutPollVotesNestedInput
  }

  export type PollVoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    livePoolId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    option?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PollVoteCreateManyInput = {
    id?: string
    livePoolId: string
    userId: string
    option: string
    createdAt?: Date | string
  }

  export type PollVoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    option?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PollVoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    livePoolId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    option?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionSummaryCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    createdBy: string
    workspace: WorkspaceCreateNestedOneWithoutSessionSummariesInput
  }

  export type SessionSummaryUncheckedCreateInput = {
    id?: string
    workspaceId: string
    content: string
    createdAt?: Date | string
    createdBy: string
  }

  export type SessionSummaryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    workspace?: WorkspaceUpdateOneRequiredWithoutSessionSummariesNestedInput
  }

  export type SessionSummaryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type SessionSummaryCreateManyInput = {
    id?: string
    workspaceId: string
    content: string
    createdAt?: Date | string
    createdBy: string
  }

  export type SessionSummaryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type SessionSummaryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChatCreateInput = {
    id?: string
    workspace: WorkspaceCreateNestedOneWithoutChatsInput
    messages?: ChatMessageCreateNestedManyWithoutChatInput
  }

  export type ChatUncheckedCreateInput = {
    id?: string
    workspaceId: string
    messages?: ChatMessageUncheckedCreateNestedManyWithoutChatInput
  }

  export type ChatUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspace?: WorkspaceUpdateOneRequiredWithoutChatsNestedInput
    messages?: ChatMessageUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    messages?: ChatMessageUncheckedUpdateManyWithoutChatNestedInput
  }

  export type ChatCreateManyInput = {
    id?: string
    workspaceId: string
  }

  export type ChatUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type ChatUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
  }

  export type ChatMessageCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    chat: ChatCreateNestedOneWithoutMessagesInput
    user: UserCreateNestedOneWithoutChatMessagesInput
  }

  export type ChatMessageUncheckedCreateInput = {
    id?: string
    chatId: string
    userId: string
    content: string
    createdAt?: Date | string
  }

  export type ChatMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chat?: ChatUpdateOneRequiredWithoutMessagesNestedInput
    user?: UserUpdateOneRequiredWithoutChatMessagesNestedInput
  }

  export type ChatMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    chatId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageCreateManyInput = {
    id?: string
    chatId: string
    userId: string
    content: string
    createdAt?: Date | string
  }

  export type ChatMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    chatId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsCreateInput = {
    id?: string
    notificationPreferences: JsonNullValueInput | InputJsonValue
    voiceSettings: JsonNullValueInput | InputJsonValue
    privacySettings: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSettingsInput
  }

  export type UserSettingsUncheckedCreateInput = {
    id?: string
    userId: string
    notificationPreferences: JsonNullValueInput | InputJsonValue
    voiceSettings: JsonNullValueInput | InputJsonValue
    privacySettings: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationPreferences?: JsonNullValueInput | InputJsonValue
    voiceSettings?: JsonNullValueInput | InputJsonValue
    privacySettings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSettingsNestedInput
  }

  export type UserSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    notificationPreferences?: JsonNullValueInput | InputJsonValue
    voiceSettings?: JsonNullValueInput | InputJsonValue
    privacySettings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsCreateManyInput = {
    id?: string
    userId: string
    notificationPreferences: JsonNullValueInput | InputJsonValue
    voiceSettings: JsonNullValueInput | InputJsonValue
    privacySettings: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationPreferences?: JsonNullValueInput | InputJsonValue
    voiceSettings?: JsonNullValueInput | InputJsonValue
    privacySettings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    notificationPreferences?: JsonNullValueInput | InputJsonValue
    voiceSettings?: JsonNullValueInput | InputJsonValue
    privacySettings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsEntryCreateInput = {
    id?: string
    timeSpent: number
    score?: number | null
    date?: Date | string
    user: UserCreateNestedOneWithoutAnalyticsEntriesInput
    topic: TopicCreateNestedOneWithoutAnalyticsEntriesInput
  }

  export type AnalyticsEntryUncheckedCreateInput = {
    id?: string
    userId: string
    topicId: string
    timeSpent: number
    score?: number | null
    date?: Date | string
  }

  export type AnalyticsEntryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timeSpent?: IntFieldUpdateOperationsInput | number
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAnalyticsEntriesNestedInput
    topic?: TopicUpdateOneRequiredWithoutAnalyticsEntriesNestedInput
  }

  export type AnalyticsEntryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    timeSpent?: IntFieldUpdateOperationsInput | number
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsEntryCreateManyInput = {
    id?: string
    userId: string
    topicId: string
    timeSpent: number
    score?: number | null
    date?: Date | string
  }

  export type AnalyticsEntryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    timeSpent?: IntFieldUpdateOperationsInput | number
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsEntryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    timeSpent?: IntFieldUpdateOperationsInput | number
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    type: string
    message: string
    read?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    message: string
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    type: string
    message: string
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordlessTokenCreateInput = {
    id?: string
    token: string
    expiresAt: Date | string
    user: UserCreateNestedOneWithoutPasswordlessTokensInput
  }

  export type PasswordlessTokenUncheckedCreateInput = {
    id?: string
    token: string
    expiresAt: Date | string
    userId: string
  }

  export type PasswordlessTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPasswordlessTokensNestedInput
  }

  export type PasswordlessTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type PasswordlessTokenCreateManyInput = {
    id?: string
    token: string
    expiresAt: Date | string
    userId: string
  }

  export type PasswordlessTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordlessTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type DailyChallengeCreateInput = {
    id?: string
    title: string
    description: string
    reward: string
    completed?: boolean
    createdAt?: Date | string
    completedAt?: Date | string | null
    user: UserCreateNestedOneWithoutDailyChallengesInput
  }

  export type DailyChallengeUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    description: string
    reward: string
    completed?: boolean
    createdAt?: Date | string
    completedAt?: Date | string | null
  }

  export type DailyChallengeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    reward?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutDailyChallengesNestedInput
  }

  export type DailyChallengeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    reward?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DailyChallengeCreateManyInput = {
    id?: string
    userId: string
    title: string
    description: string
    reward: string
    completed?: boolean
    createdAt?: Date | string
    completedAt?: Date | string | null
  }

  export type DailyChallengeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    reward?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DailyChallengeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    reward?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ExternalGoalCreateInput = {
    id?: string
    platform: string
    title: string
    progress: number
    dueDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutExternalGoalsInput
  }

  export type ExternalGoalUncheckedCreateInput = {
    id?: string
    userId: string
    platform: string
    title: string
    progress: number
    dueDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExternalGoalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutExternalGoalsNestedInput
  }

  export type ExternalGoalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExternalGoalCreateManyInput = {
    id?: string
    userId: string
    platform: string
    title: string
    progress: number
    dueDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExternalGoalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExternalGoalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrerequisiteCreateInput = {
    id?: string
    completed?: boolean
    learningPath: LearningPathCreateNestedOneWithoutPrerequisitesInput
    topic: TopicCreateNestedOneWithoutPrerequisitesInput
  }

  export type PrerequisiteUncheckedCreateInput = {
    id?: string
    learningPathId: string
    topicId: string
    completed?: boolean
  }

  export type PrerequisiteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    learningPath?: LearningPathUpdateOneRequiredWithoutPrerequisitesNestedInput
    topic?: TopicUpdateOneRequiredWithoutPrerequisitesNestedInput
  }

  export type PrerequisiteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    learningPathId?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PrerequisiteCreateManyInput = {
    id?: string
    learningPathId: string
    topicId: string
    completed?: boolean
  }

  export type PrerequisiteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PrerequisiteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    learningPathId?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CommentCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutCommentsInput
    topic: TopicCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateInput = {
    id?: string
    content: string
    userId: string
    topicId: string
    createdAt?: Date | string
  }

  export type CommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
    topic?: TopicUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyInput = {
    id?: string
    content: string
    userId: string
    topicId: string
    createdAt?: Date | string
  }

  export type CommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIPlaylistCreateInput = {
    id?: string
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: AIPlaylistItemCreateNestedManyWithoutPlaylistInput
  }

  export type AIPlaylistUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: AIPlaylistItemUncheckedCreateNestedManyWithoutPlaylistInput
  }

  export type AIPlaylistUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: AIPlaylistItemUpdateManyWithoutPlaylistNestedInput
  }

  export type AIPlaylistUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: AIPlaylistItemUncheckedUpdateManyWithoutPlaylistNestedInput
  }

  export type AIPlaylistCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIPlaylistUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIPlaylistUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIPlaylistItemCreateInput = {
    id?: string
    order: number
    playlist: AIPlaylistCreateNestedOneWithoutItemsInput
    contentItem: ContentItemCreateNestedOneWithoutAiPlaylistItemsInput
  }

  export type AIPlaylistItemUncheckedCreateInput = {
    id?: string
    playlistId: string
    contentItemId: string
    order: number
  }

  export type AIPlaylistItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    playlist?: AIPlaylistUpdateOneRequiredWithoutItemsNestedInput
    contentItem?: ContentItemUpdateOneRequiredWithoutAiPlaylistItemsNestedInput
  }

  export type AIPlaylistItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    playlistId?: StringFieldUpdateOperationsInput | string
    contentItemId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type AIPlaylistItemCreateManyInput = {
    id?: string
    playlistId: string
    contentItemId: string
    order: number
  }

  export type AIPlaylistItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type AIPlaylistItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    playlistId?: StringFieldUpdateOperationsInput | string
    contentItemId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type ChallengeScoreCreateInput = {
    id?: string
    score: number
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutChallengeScoresInput
  }

  export type ChallengeScoreUncheckedCreateInput = {
    id?: string
    userId: string
    score: number
    createdAt?: Date | string
  }

  export type ChallengeScoreUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutChallengeScoresNestedInput
  }

  export type ChallengeScoreUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeScoreCreateManyInput = {
    id?: string
    userId: string
    score: number
    createdAt?: Date | string
  }

  export type ChallengeScoreUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeScoreUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIRecommendationCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAiRecommendationsInput
  }

  export type AIRecommendationUncheckedCreateInput = {
    id?: string
    userId: string
    content: string
    createdAt?: Date | string
  }

  export type AIRecommendationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAiRecommendationsNestedInput
  }

  export type AIRecommendationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIRecommendationCreateManyInput = {
    id?: string
    userId: string
    content: string
    createdAt?: Date | string
  }

  export type AIRecommendationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIRecommendationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIModuleCreateInput = {
    id?: string
    title: string
    description?: string | null
    content: JsonNullValueInput | InputJsonValue
    tags?: AIModuleCreatetagsInput | string[]
    difficulty?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutAiModulesInput
    topic?: TopicCreateNestedOneWithoutAiModulesInput
    learningPathItems?: AIModuleLearningPathItemCreateNestedManyWithoutAiModuleInput
    quizAttempts?: AIModuleQuizAttemptCreateNestedManyWithoutAiModuleInput
    ratings?: AIModuleRatingCreateNestedManyWithoutAiModuleInput
    PracticeAttempts?: PracticeAttemptCreateNestedManyWithoutAiModuleInput
  }

  export type AIModuleUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    content: JsonNullValueInput | InputJsonValue
    tags?: AIModuleCreatetagsInput | string[]
    difficulty?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    topicId?: string | null
    learningPathItems?: AIModuleLearningPathItemUncheckedCreateNestedManyWithoutAiModuleInput
    quizAttempts?: AIModuleQuizAttemptUncheckedCreateNestedManyWithoutAiModuleInput
    ratings?: AIModuleRatingUncheckedCreateNestedManyWithoutAiModuleInput
    PracticeAttempts?: PracticeAttemptUncheckedCreateNestedManyWithoutAiModuleInput
  }

  export type AIModuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    tags?: AIModuleUpdatetagsInput | string[]
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAiModulesNestedInput
    topic?: TopicUpdateOneWithoutAiModulesNestedInput
    learningPathItems?: AIModuleLearningPathItemUpdateManyWithoutAiModuleNestedInput
    quizAttempts?: AIModuleQuizAttemptUpdateManyWithoutAiModuleNestedInput
    ratings?: AIModuleRatingUpdateManyWithoutAiModuleNestedInput
    PracticeAttempts?: PracticeAttemptUpdateManyWithoutAiModuleNestedInput
  }

  export type AIModuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    tags?: AIModuleUpdatetagsInput | string[]
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    learningPathItems?: AIModuleLearningPathItemUncheckedUpdateManyWithoutAiModuleNestedInput
    quizAttempts?: AIModuleQuizAttemptUncheckedUpdateManyWithoutAiModuleNestedInput
    ratings?: AIModuleRatingUncheckedUpdateManyWithoutAiModuleNestedInput
    PracticeAttempts?: PracticeAttemptUncheckedUpdateManyWithoutAiModuleNestedInput
  }

  export type AIModuleCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    content: JsonNullValueInput | InputJsonValue
    tags?: AIModuleCreatetagsInput | string[]
    difficulty?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    topicId?: string | null
  }

  export type AIModuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    tags?: AIModuleUpdatetagsInput | string[]
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIModuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    tags?: AIModuleUpdatetagsInput | string[]
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AIModuleLearningPathItemCreateInput = {
    id?: string
    order: number
    confidence?: number
    learningPath: LearningPathCreateNestedOneWithoutAiModuleItemsInput
    aiModule: AIModuleCreateNestedOneWithoutLearningPathItemsInput
  }

  export type AIModuleLearningPathItemUncheckedCreateInput = {
    id?: string
    order: number
    learningPathId: string
    aiModuleId: string
    confidence?: number
  }

  export type AIModuleLearningPathItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    confidence?: IntFieldUpdateOperationsInput | number
    learningPath?: LearningPathUpdateOneRequiredWithoutAiModuleItemsNestedInput
    aiModule?: AIModuleUpdateOneRequiredWithoutLearningPathItemsNestedInput
  }

  export type AIModuleLearningPathItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    learningPathId?: StringFieldUpdateOperationsInput | string
    aiModuleId?: StringFieldUpdateOperationsInput | string
    confidence?: IntFieldUpdateOperationsInput | number
  }

  export type AIModuleLearningPathItemCreateManyInput = {
    id?: string
    order: number
    learningPathId: string
    aiModuleId: string
    confidence?: number
  }

  export type AIModuleLearningPathItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    confidence?: IntFieldUpdateOperationsInput | number
  }

  export type AIModuleLearningPathItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    learningPathId?: StringFieldUpdateOperationsInput | string
    aiModuleId?: StringFieldUpdateOperationsInput | string
    confidence?: IntFieldUpdateOperationsInput | number
  }

  export type AIModuleQuizAttemptCreateInput = {
    id?: string
    score: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    answers: JsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutAiModuleQuizAttemptsInput
    aiModule: AIModuleCreateNestedOneWithoutQuizAttemptsInput
    topic: TopicCreateNestedOneWithoutAiModuleQuizAttemptsInput
  }

  export type AIModuleQuizAttemptUncheckedCreateInput = {
    id?: string
    userId: string
    aiModuleId: string
    topicId: string
    score: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    answers: JsonNullValueInput | InputJsonValue
  }

  export type AIModuleQuizAttemptUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: JsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutAiModuleQuizAttemptsNestedInput
    aiModule?: AIModuleUpdateOneRequiredWithoutQuizAttemptsNestedInput
    topic?: TopicUpdateOneRequiredWithoutAiModuleQuizAttemptsNestedInput
  }

  export type AIModuleQuizAttemptUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    aiModuleId?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: JsonNullValueInput | InputJsonValue
  }

  export type AIModuleQuizAttemptCreateManyInput = {
    id?: string
    userId: string
    aiModuleId: string
    topicId: string
    score: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    answers: JsonNullValueInput | InputJsonValue
  }

  export type AIModuleQuizAttemptUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: JsonNullValueInput | InputJsonValue
  }

  export type AIModuleQuizAttemptUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    aiModuleId?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: JsonNullValueInput | InputJsonValue
  }

  export type AIModuleRatingCreateInput = {
    id?: string
    rating: number
    feedback?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAiModuleRatingsInput
    aiModule: AIModuleCreateNestedOneWithoutRatingsInput
    topic: TopicCreateNestedOneWithoutAiModuleRatingsInput
  }

  export type AIModuleRatingUncheckedCreateInput = {
    id?: string
    userId: string
    aiModuleId: string
    topicId: string
    rating: number
    feedback?: string | null
    createdAt?: Date | string
  }

  export type AIModuleRatingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAiModuleRatingsNestedInput
    aiModule?: AIModuleUpdateOneRequiredWithoutRatingsNestedInput
    topic?: TopicUpdateOneRequiredWithoutAiModuleRatingsNestedInput
  }

  export type AIModuleRatingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    aiModuleId?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIModuleRatingCreateManyInput = {
    id?: string
    userId: string
    aiModuleId: string
    topicId: string
    rating: number
    feedback?: string | null
    createdAt?: Date | string
  }

  export type AIModuleRatingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIModuleRatingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    aiModuleId?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProgressCreateInput = {
    id?: string
    status?: string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserProgressInput
    learningPath: LearningPathCreateNestedOneWithoutUserProgressInput
    module: LearningPathItemCreateNestedOneWithoutUserProgressInput
  }

  export type UserProgressUncheckedCreateInput = {
    id?: string
    userId: string
    learningPathId: string
    moduleId: string
    status?: string
    updatedAt?: Date | string
  }

  export type UserProgressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserProgressNestedInput
    learningPath?: LearningPathUpdateOneRequiredWithoutUserProgressNestedInput
    module?: LearningPathItemUpdateOneRequiredWithoutUserProgressNestedInput
  }

  export type UserProgressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    learningPathId?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProgressCreateManyInput = {
    id?: string
    userId: string
    learningPathId: string
    moduleId: string
    status?: string
    updatedAt?: Date | string
  }

  export type UserProgressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProgressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    learningPathId?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIChatCreateInput = {
    id?: string
    title?: string | null
    createdAt?: Date | string
    messages?: AIChatMessageCreateNestedManyWithoutChatInput
    user?: UserCreateNestedOneWithoutAIChatInput
  }

  export type AIChatUncheckedCreateInput = {
    id?: string
    title?: string | null
    createdAt?: Date | string
    userId: string
    messages?: AIChatMessageUncheckedCreateNestedManyWithoutChatInput
  }

  export type AIChatUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: AIChatMessageUpdateManyWithoutChatNestedInput
    user?: UserUpdateOneWithoutAIChatNestedInput
  }

  export type AIChatUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    messages?: AIChatMessageUncheckedUpdateManyWithoutChatNestedInput
  }

  export type AIChatCreateManyInput = {
    id?: string
    title?: string | null
    createdAt?: Date | string
    userId: string
  }

  export type AIChatUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIChatUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type AIChatMessageCreateInput = {
    id?: string
    display?: string | null
    role: string
    content: string
    createdAt?: Date | string
    chat: AIChatCreateNestedOneWithoutMessagesInput
  }

  export type AIChatMessageUncheckedCreateInput = {
    id?: string
    chatId: string
    display?: string | null
    role: string
    content: string
    createdAt?: Date | string
  }

  export type AIChatMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    display?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chat?: AIChatUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type AIChatMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    chatId?: StringFieldUpdateOperationsInput | string
    display?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIChatMessageCreateManyInput = {
    id?: string
    chatId: string
    display?: string | null
    role: string
    content: string
    createdAt?: Date | string
  }

  export type AIChatMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    display?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIChatMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    chatId?: StringFieldUpdateOperationsInput | string
    display?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PracticeAttemptCreateInput = {
    id?: string
    questions: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    score?: number | null
    averageEase?: number | null
    completedAt?: Date | string | null
    user: UserCreateNestedOneWithoutPracticeAttemptsInput
    aiModule: AIModuleCreateNestedOneWithoutPracticeAttemptsInput
  }

  export type PracticeAttemptUncheckedCreateInput = {
    id?: string
    userId: string
    aiModuleId: string
    questions: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    score?: number | null
    averageEase?: number | null
    completedAt?: Date | string | null
  }

  export type PracticeAttemptUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    questions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    averageEase?: NullableFloatFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutPracticeAttemptsNestedInput
    aiModule?: AIModuleUpdateOneRequiredWithoutPracticeAttemptsNestedInput
  }

  export type PracticeAttemptUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    aiModuleId?: StringFieldUpdateOperationsInput | string
    questions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    averageEase?: NullableFloatFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PracticeAttemptCreateManyInput = {
    id?: string
    userId: string
    aiModuleId: string
    questions: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    score?: number | null
    averageEase?: number | null
    completedAt?: Date | string | null
  }

  export type PracticeAttemptUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    questions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    averageEase?: NullableFloatFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PracticeAttemptUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    aiModuleId?: StringFieldUpdateOperationsInput | string
    questions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    averageEase?: NullableFloatFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type ActivityListRelationFilter = {
    every?: ActivityWhereInput
    some?: ActivityWhereInput
    none?: ActivityWhereInput
  }

  export type LearningPreferencesNullableScalarRelationFilter = {
    is?: LearningPreferencesWhereInput | null
    isNot?: LearningPreferencesWhereInput | null
  }

  export type TopicListRelationFilter = {
    every?: TopicWhereInput
    some?: TopicWhereInput
    none?: TopicWhereInput
  }

  export type ProgressListRelationFilter = {
    every?: ProgressWhereInput
    some?: ProgressWhereInput
    none?: ProgressWhereInput
  }

  export type BadgeListRelationFilter = {
    every?: BadgeWhereInput
    some?: BadgeWhereInput
    none?: BadgeWhereInput
  }

  export type UpcomingReviewListRelationFilter = {
    every?: UpcomingReviewWhereInput
    some?: UpcomingReviewWhereInput
    none?: UpcomingReviewWhereInput
  }

  export type LearningPathListRelationFilter = {
    every?: LearningPathWhereInput
    some?: LearningPathWhereInput
    none?: LearningPathWhereInput
  }

  export type BookmarkListRelationFilter = {
    every?: BookmarkWhereInput
    some?: BookmarkWhereInput
    none?: BookmarkWhereInput
  }

  export type QuizAttemptListRelationFilter = {
    every?: QuizAttemptWhereInput
    some?: QuizAttemptWhereInput
    none?: QuizAttemptWhereInput
  }

  export type KnowledgeNodeListRelationFilter = {
    every?: KnowledgeNodeWhereInput
    some?: KnowledgeNodeWhereInput
    none?: KnowledgeNodeWhereInput
  }

  export type LeaderboardEntryListRelationFilter = {
    every?: LeaderboardEntryWhereInput
    some?: LeaderboardEntryWhereInput
    none?: LeaderboardEntryWhereInput
  }

  export type ReviewSessionListRelationFilter = {
    every?: ReviewSessionWhereInput
    some?: ReviewSessionWhereInput
    none?: ReviewSessionWhereInput
  }

  export type WorkspaceMemberListRelationFilter = {
    every?: WorkspaceMemberWhereInput
    some?: WorkspaceMemberWhereInput
    none?: WorkspaceMemberWhereInput
  }

  export type ChatMessageListRelationFilter = {
    every?: ChatMessageWhereInput
    some?: ChatMessageWhereInput
    none?: ChatMessageWhereInput
  }

  export type WorkspaceListRelationFilter = {
    every?: WorkspaceWhereInput
    some?: WorkspaceWhereInput
    none?: WorkspaceWhereInput
  }

  export type UserSettingsNullableScalarRelationFilter = {
    is?: UserSettingsWhereInput | null
    isNot?: UserSettingsWhereInput | null
  }

  export type AnalyticsEntryListRelationFilter = {
    every?: AnalyticsEntryWhereInput
    some?: AnalyticsEntryWhereInput
    none?: AnalyticsEntryWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type PasswordlessTokenListRelationFilter = {
    every?: PasswordlessTokenWhereInput
    some?: PasswordlessTokenWhereInput
    none?: PasswordlessTokenWhereInput
  }

  export type DailyChallengeListRelationFilter = {
    every?: DailyChallengeWhereInput
    some?: DailyChallengeWhereInput
    none?: DailyChallengeWhereInput
  }

  export type ExternalGoalListRelationFilter = {
    every?: ExternalGoalWhereInput
    some?: ExternalGoalWhereInput
    none?: ExternalGoalWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type ContentRatingListRelationFilter = {
    every?: ContentRatingWhereInput
    some?: ContentRatingWhereInput
    none?: ContentRatingWhereInput
  }

  export type ChallengeScoreListRelationFilter = {
    every?: ChallengeScoreWhereInput
    some?: ChallengeScoreWhereInput
    none?: ChallengeScoreWhereInput
  }

  export type PollVoteListRelationFilter = {
    every?: PollVoteWhereInput
    some?: PollVoteWhereInput
    none?: PollVoteWhereInput
  }

  export type AIRecommendationListRelationFilter = {
    every?: AIRecommendationWhereInput
    some?: AIRecommendationWhereInput
    none?: AIRecommendationWhereInput
  }

  export type AIModuleListRelationFilter = {
    every?: AIModuleWhereInput
    some?: AIModuleWhereInput
    none?: AIModuleWhereInput
  }

  export type AIModuleQuizAttemptListRelationFilter = {
    every?: AIModuleQuizAttemptWhereInput
    some?: AIModuleQuizAttemptWhereInput
    none?: AIModuleQuizAttemptWhereInput
  }

  export type AIModuleRatingListRelationFilter = {
    every?: AIModuleRatingWhereInput
    some?: AIModuleRatingWhereInput
    none?: AIModuleRatingWhereInput
  }

  export type UserProgressListRelationFilter = {
    every?: UserProgressWhereInput
    some?: UserProgressWhereInput
    none?: UserProgressWhereInput
  }

  export type AIChatListRelationFilter = {
    every?: AIChatWhereInput
    some?: AIChatWhereInput
    none?: AIChatWhereInput
  }

  export type PracticeAttemptListRelationFilter = {
    every?: PracticeAttemptWhereInput
    some?: PracticeAttemptWhereInput
    none?: PracticeAttemptWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActivityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TopicOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProgressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BadgeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UpcomingReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LearningPathOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookmarkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuizAttemptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KnowledgeNodeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeaderboardEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkspaceMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChatMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkspaceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AnalyticsEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PasswordlessTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DailyChallengeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExternalGoalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContentRatingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChallengeScoreOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PollVoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AIRecommendationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AIModuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AIModuleQuizAttemptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AIModuleRatingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserProgressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AIChatOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PracticeAttemptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    bio?: SortOrder
    avatarUrl?: SortOrder
    password?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    xp?: SortOrder
    level?: SortOrder
    streak?: SortOrder
    lastStreakUpdate?: SortOrder
    lastLoginDate?: SortOrder
    isAdmin?: SortOrder
    role?: SortOrder
    interests?: SortOrder
    learningStyle?: SortOrder
    cramMode?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    xp?: SortOrder
    level?: SortOrder
    streak?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    bio?: SortOrder
    avatarUrl?: SortOrder
    password?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    xp?: SortOrder
    level?: SortOrder
    streak?: SortOrder
    lastStreakUpdate?: SortOrder
    lastLoginDate?: SortOrder
    isAdmin?: SortOrder
    role?: SortOrder
    cramMode?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    bio?: SortOrder
    avatarUrl?: SortOrder
    password?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    xp?: SortOrder
    level?: SortOrder
    streak?: SortOrder
    lastStreakUpdate?: SortOrder
    lastLoginDate?: SortOrder
    isAdmin?: SortOrder
    role?: SortOrder
    cramMode?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    xp?: SortOrder
    level?: SortOrder
    streak?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    oauth_token_secret?: SortOrder
    oauth_token?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    oauth_token_secret?: SortOrder
    oauth_token?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    oauth_token_secret?: SortOrder
    oauth_token?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type ActivityCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type LearningPreferencesCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    visualLearning?: SortOrder
    auditoryLearning?: SortOrder
    kinestheticLearning?: SortOrder
  }

  export type LearningPreferencesAvgOrderByAggregateInput = {
    visualLearning?: SortOrder
    auditoryLearning?: SortOrder
    kinestheticLearning?: SortOrder
  }

  export type LearningPreferencesMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    visualLearning?: SortOrder
    auditoryLearning?: SortOrder
    kinestheticLearning?: SortOrder
  }

  export type LearningPreferencesMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    visualLearning?: SortOrder
    auditoryLearning?: SortOrder
    kinestheticLearning?: SortOrder
  }

  export type LearningPreferencesSumOrderByAggregateInput = {
    visualLearning?: SortOrder
    auditoryLearning?: SortOrder
    kinestheticLearning?: SortOrder
  }

  export type LearningPathItemListRelationFilter = {
    every?: LearningPathItemWhereInput
    some?: LearningPathItemWhereInput
    none?: LearningPathItemWhereInput
  }

  export type ContentItemListRelationFilter = {
    every?: ContentItemWhereInput
    some?: ContentItemWhereInput
    none?: ContentItemWhereInput
  }

  export type PrerequisiteListRelationFilter = {
    every?: PrerequisiteWhereInput
    some?: PrerequisiteWhereInput
    none?: PrerequisiteWhereInput
  }

  export type LearningPathItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContentItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PrerequisiteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TopicCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    userId?: SortOrder
  }

  export type TopicMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    userId?: SortOrder
  }

  export type TopicMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    userId?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type TopicScalarRelationFilter = {
    is?: TopicWhereInput
    isNot?: TopicWhereInput
  }

  export type ProgressCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    topicId?: SortOrder
    completed?: SortOrder
  }

  export type ProgressAvgOrderByAggregateInput = {
    completed?: SortOrder
  }

  export type ProgressMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    topicId?: SortOrder
    completed?: SortOrder
  }

  export type ProgressMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    topicId?: SortOrder
    completed?: SortOrder
  }

  export type ProgressSumOrderByAggregateInput = {
    completed?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type BadgeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    userId?: SortOrder
    earnedAt?: SortOrder
  }

  export type BadgeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    userId?: SortOrder
    earnedAt?: SortOrder
  }

  export type BadgeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    userId?: SortOrder
    earnedAt?: SortOrder
  }

  export type UpcomingReviewCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    topicId?: SortOrder
    dueDate?: SortOrder
  }

  export type UpcomingReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    topicId?: SortOrder
    dueDate?: SortOrder
  }

  export type UpcomingReviewMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    topicId?: SortOrder
    dueDate?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AIModuleLearningPathItemListRelationFilter = {
    every?: AIModuleLearningPathItemWhereInput
    some?: AIModuleLearningPathItemWhereInput
    none?: AIModuleLearningPathItemWhereInput
  }

  export type AIModuleLearningPathItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LearningPathCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    shareId?: SortOrder
    sharedAt?: SortOrder
  }

  export type LearningPathMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    shareId?: SortOrder
    sharedAt?: SortOrder
  }

  export type LearningPathMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    shareId?: SortOrder
    sharedAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type LearningPathScalarRelationFilter = {
    is?: LearningPathWhereInput
    isNot?: LearningPathWhereInput
  }

  export type LearningPathItemCountOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
    learningPathId?: SortOrder
    topicId?: SortOrder
    confidence?: SortOrder
  }

  export type LearningPathItemAvgOrderByAggregateInput = {
    order?: SortOrder
    confidence?: SortOrder
  }

  export type LearningPathItemMaxOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
    learningPathId?: SortOrder
    topicId?: SortOrder
    confidence?: SortOrder
  }

  export type LearningPathItemMinOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
    learningPathId?: SortOrder
    topicId?: SortOrder
    confidence?: SortOrder
  }

  export type LearningPathItemSumOrderByAggregateInput = {
    order?: SortOrder
    confidence?: SortOrder
  }

  export type ReviewItemListRelationFilter = {
    every?: ReviewItemWhereInput
    some?: ReviewItemWhereInput
    none?: ReviewItemWhereInput
  }

  export type AIPlaylistItemListRelationFilter = {
    every?: AIPlaylistItemWhereInput
    some?: AIPlaylistItemWhereInput
    none?: AIPlaylistItemWhereInput
  }

  export type ReviewItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AIPlaylistItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContentItemCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    content?: SortOrder
    type?: SortOrder
    difficulty?: SortOrder
    topicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    version?: SortOrder
  }

  export type ContentItemMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    content?: SortOrder
    type?: SortOrder
    difficulty?: SortOrder
    topicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    version?: SortOrder
  }

  export type ContentItemMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    content?: SortOrder
    type?: SortOrder
    difficulty?: SortOrder
    topicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    version?: SortOrder
  }

  export type ContentItemScalarRelationFilter = {
    is?: ContentItemWhereInput
    isNot?: ContentItemWhereInput
  }

  export type ContentRatingUserIdContentItemIdCompoundUniqueInput = {
    userId: string
    contentItemId: string
  }

  export type ContentRatingCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    contentItemId?: SortOrder
    rating?: SortOrder
    createdAt?: SortOrder
  }

  export type ContentRatingAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type ContentRatingMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    contentItemId?: SortOrder
    rating?: SortOrder
    createdAt?: SortOrder
  }

  export type ContentRatingMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    contentItemId?: SortOrder
    rating?: SortOrder
    createdAt?: SortOrder
  }

  export type ContentRatingSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type BookmarkCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    contentItemId?: SortOrder
    createdAt?: SortOrder
  }

  export type BookmarkMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    contentItemId?: SortOrder
    createdAt?: SortOrder
  }

  export type BookmarkMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    contentItemId?: SortOrder
    createdAt?: SortOrder
  }

  export type QuizAttemptCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    contentItemId?: SortOrder
    score?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    answers?: SortOrder
  }

  export type QuizAttemptAvgOrderByAggregateInput = {
    score?: SortOrder
  }

  export type QuizAttemptMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    contentItemId?: SortOrder
    score?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type QuizAttemptMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    contentItemId?: SortOrder
    score?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type QuizAttemptSumOrderByAggregateInput = {
    score?: SortOrder
  }

  export type KnowledgeNodeNullableScalarRelationFilter = {
    is?: KnowledgeNodeWhereInput | null
    isNot?: KnowledgeNodeWhereInput | null
  }

  export type KnowledgeNodeCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KnowledgeNodeMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KnowledgeNodeMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaderboardEntryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    score?: SortOrder
    type?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
  }

  export type LeaderboardEntryAvgOrderByAggregateInput = {
    score?: SortOrder
  }

  export type LeaderboardEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    score?: SortOrder
    type?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
  }

  export type LeaderboardEntryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    score?: SortOrder
    type?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
  }

  export type LeaderboardEntrySumOrderByAggregateInput = {
    score?: SortOrder
  }

  export type ReviewSessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    dueDate?: SortOrder
    completed?: SortOrder
    isUrgent?: SortOrder
  }

  export type ReviewSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    dueDate?: SortOrder
    completed?: SortOrder
    isUrgent?: SortOrder
  }

  export type ReviewSessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    dueDate?: SortOrder
    completed?: SortOrder
    isUrgent?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type ReviewSessionScalarRelationFilter = {
    is?: ReviewSessionWhereInput
    isNot?: ReviewSessionWhereInput
  }

  export type ReviewItemCountOrderByAggregateInput = {
    id?: SortOrder
    reviewSessionId?: SortOrder
    contentItemId?: SortOrder
    type?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    userAnswer?: SortOrder
    isCorrect?: SortOrder
    answeredAt?: SortOrder
  }

  export type ReviewItemMaxOrderByAggregateInput = {
    id?: SortOrder
    reviewSessionId?: SortOrder
    contentItemId?: SortOrder
    type?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    userAnswer?: SortOrder
    isCorrect?: SortOrder
    answeredAt?: SortOrder
  }

  export type ReviewItemMinOrderByAggregateInput = {
    id?: SortOrder
    reviewSessionId?: SortOrder
    contentItemId?: SortOrder
    type?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    userAnswer?: SortOrder
    isCorrect?: SortOrder
    answeredAt?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type WhiteboardListRelationFilter = {
    every?: WhiteboardWhereInput
    some?: WhiteboardWhereInput
    none?: WhiteboardWhereInput
  }

  export type ChatListRelationFilter = {
    every?: ChatWhereInput
    some?: ChatWhereInput
    none?: ChatWhereInput
  }

  export type BreakoutRoomListRelationFilter = {
    every?: BreakoutRoomWhereInput
    some?: BreakoutRoomWhereInput
    none?: BreakoutRoomWhereInput
  }

  export type LivePollListRelationFilter = {
    every?: LivePollWhereInput
    some?: LivePollWhereInput
    none?: LivePollWhereInput
  }

  export type SessionSummaryListRelationFilter = {
    every?: SessionSummaryWhereInput
    some?: SessionSummaryWhereInput
    none?: SessionSummaryWhereInput
  }

  export type WhiteboardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChatOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BreakoutRoomOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LivePollOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionSummaryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkspaceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ownerId?: SortOrder
  }

  export type WorkspaceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ownerId?: SortOrder
  }

  export type WorkspaceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ownerId?: SortOrder
  }

  export type WorkspaceScalarRelationFilter = {
    is?: WorkspaceWhereInput
    isNot?: WorkspaceWhereInput
  }

  export type WorkspaceMemberCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type WorkspaceMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type WorkspaceMemberMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type WhiteboardVersionListRelationFilter = {
    every?: WhiteboardVersionWhereInput
    some?: WhiteboardVersionWhereInput
    none?: WhiteboardVersionWhereInput
  }

  export type WhiteboardVersionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WhiteboardCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WhiteboardMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WhiteboardMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WhiteboardScalarRelationFilter = {
    is?: WhiteboardWhereInput
    isNot?: WhiteboardWhereInput
  }

  export type WhiteboardVersionCountOrderByAggregateInput = {
    id?: SortOrder
    whiteboardId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    versionNumber?: SortOrder
  }

  export type WhiteboardVersionAvgOrderByAggregateInput = {
    versionNumber?: SortOrder
  }

  export type WhiteboardVersionMaxOrderByAggregateInput = {
    id?: SortOrder
    whiteboardId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    versionNumber?: SortOrder
  }

  export type WhiteboardVersionMinOrderByAggregateInput = {
    id?: SortOrder
    whiteboardId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    versionNumber?: SortOrder
  }

  export type WhiteboardVersionSumOrderByAggregateInput = {
    versionNumber?: SortOrder
  }

  export type BreakoutRoomCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    endedAt?: SortOrder
  }

  export type BreakoutRoomMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    endedAt?: SortOrder
  }

  export type BreakoutRoomMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    endedAt?: SortOrder
  }

  export type LivePollCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    question?: SortOrder
    options?: SortOrder
    createdAt?: SortOrder
    endedAt?: SortOrder
  }

  export type LivePollMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    question?: SortOrder
    createdAt?: SortOrder
    endedAt?: SortOrder
  }

  export type LivePollMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    question?: SortOrder
    createdAt?: SortOrder
    endedAt?: SortOrder
  }

  export type LivePollScalarRelationFilter = {
    is?: LivePollWhereInput
    isNot?: LivePollWhereInput
  }

  export type PollVoteCountOrderByAggregateInput = {
    id?: SortOrder
    livePoolId?: SortOrder
    userId?: SortOrder
    option?: SortOrder
    createdAt?: SortOrder
  }

  export type PollVoteMaxOrderByAggregateInput = {
    id?: SortOrder
    livePoolId?: SortOrder
    userId?: SortOrder
    option?: SortOrder
    createdAt?: SortOrder
  }

  export type PollVoteMinOrderByAggregateInput = {
    id?: SortOrder
    livePoolId?: SortOrder
    userId?: SortOrder
    option?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionSummaryCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
  }

  export type SessionSummaryMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
  }

  export type SessionSummaryMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
  }

  export type ChatCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
  }

  export type ChatMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
  }

  export type ChatMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
  }

  export type ChatScalarRelationFilter = {
    is?: ChatWhereInput
    isNot?: ChatWhereInput
  }

  export type ChatMessageCountOrderByAggregateInput = {
    id?: SortOrder
    chatId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type ChatMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    chatId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type ChatMessageMinOrderByAggregateInput = {
    id?: SortOrder
    chatId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type UserSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    notificationPreferences?: SortOrder
    voiceSettings?: SortOrder
    privacySettings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type AnalyticsEntryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    topicId?: SortOrder
    timeSpent?: SortOrder
    score?: SortOrder
    date?: SortOrder
  }

  export type AnalyticsEntryAvgOrderByAggregateInput = {
    timeSpent?: SortOrder
    score?: SortOrder
  }

  export type AnalyticsEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    topicId?: SortOrder
    timeSpent?: SortOrder
    score?: SortOrder
    date?: SortOrder
  }

  export type AnalyticsEntryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    topicId?: SortOrder
    timeSpent?: SortOrder
    score?: SortOrder
    date?: SortOrder
  }

  export type AnalyticsEntrySumOrderByAggregateInput = {
    timeSpent?: SortOrder
    score?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordlessTokenCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    userId?: SortOrder
  }

  export type PasswordlessTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    userId?: SortOrder
  }

  export type PasswordlessTokenMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    userId?: SortOrder
  }

  export type DailyChallengeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    reward?: SortOrder
    completed?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrder
  }

  export type DailyChallengeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    reward?: SortOrder
    completed?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrder
  }

  export type DailyChallengeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    reward?: SortOrder
    completed?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrder
  }

  export type ExternalGoalCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    platform?: SortOrder
    title?: SortOrder
    progress?: SortOrder
    dueDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExternalGoalAvgOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type ExternalGoalMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    platform?: SortOrder
    title?: SortOrder
    progress?: SortOrder
    dueDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExternalGoalMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    platform?: SortOrder
    title?: SortOrder
    progress?: SortOrder
    dueDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExternalGoalSumOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type PrerequisiteCountOrderByAggregateInput = {
    id?: SortOrder
    learningPathId?: SortOrder
    topicId?: SortOrder
    completed?: SortOrder
  }

  export type PrerequisiteMaxOrderByAggregateInput = {
    id?: SortOrder
    learningPathId?: SortOrder
    topicId?: SortOrder
    completed?: SortOrder
  }

  export type PrerequisiteMinOrderByAggregateInput = {
    id?: SortOrder
    learningPathId?: SortOrder
    topicId?: SortOrder
    completed?: SortOrder
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    userId?: SortOrder
    topicId?: SortOrder
    createdAt?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    userId?: SortOrder
    topicId?: SortOrder
    createdAt?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    userId?: SortOrder
    topicId?: SortOrder
    createdAt?: SortOrder
  }

  export type AIPlaylistCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIPlaylistMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIPlaylistMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIPlaylistScalarRelationFilter = {
    is?: AIPlaylistWhereInput
    isNot?: AIPlaylistWhereInput
  }

  export type AIPlaylistItemCountOrderByAggregateInput = {
    id?: SortOrder
    playlistId?: SortOrder
    contentItemId?: SortOrder
    order?: SortOrder
  }

  export type AIPlaylistItemAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type AIPlaylistItemMaxOrderByAggregateInput = {
    id?: SortOrder
    playlistId?: SortOrder
    contentItemId?: SortOrder
    order?: SortOrder
  }

  export type AIPlaylistItemMinOrderByAggregateInput = {
    id?: SortOrder
    playlistId?: SortOrder
    contentItemId?: SortOrder
    order?: SortOrder
  }

  export type AIPlaylistItemSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type ChallengeScoreCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    score?: SortOrder
    createdAt?: SortOrder
  }

  export type ChallengeScoreAvgOrderByAggregateInput = {
    score?: SortOrder
  }

  export type ChallengeScoreMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    score?: SortOrder
    createdAt?: SortOrder
  }

  export type ChallengeScoreMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    score?: SortOrder
    createdAt?: SortOrder
  }

  export type ChallengeScoreSumOrderByAggregateInput = {
    score?: SortOrder
  }

  export type AIRecommendationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type AIRecommendationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type AIRecommendationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type TopicNullableScalarRelationFilter = {
    is?: TopicWhereInput | null
    isNot?: TopicWhereInput | null
  }

  export type AIModuleCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    content?: SortOrder
    tags?: SortOrder
    difficulty?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    topicId?: SortOrder
  }

  export type AIModuleMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    difficulty?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    topicId?: SortOrder
  }

  export type AIModuleMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    difficulty?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    topicId?: SortOrder
  }

  export type AIModuleScalarRelationFilter = {
    is?: AIModuleWhereInput
    isNot?: AIModuleWhereInput
  }

  export type AIModuleLearningPathItemCountOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
    learningPathId?: SortOrder
    aiModuleId?: SortOrder
    confidence?: SortOrder
  }

  export type AIModuleLearningPathItemAvgOrderByAggregateInput = {
    order?: SortOrder
    confidence?: SortOrder
  }

  export type AIModuleLearningPathItemMaxOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
    learningPathId?: SortOrder
    aiModuleId?: SortOrder
    confidence?: SortOrder
  }

  export type AIModuleLearningPathItemMinOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
    learningPathId?: SortOrder
    aiModuleId?: SortOrder
    confidence?: SortOrder
  }

  export type AIModuleLearningPathItemSumOrderByAggregateInput = {
    order?: SortOrder
    confidence?: SortOrder
  }

  export type AIModuleQuizAttemptCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    aiModuleId?: SortOrder
    topicId?: SortOrder
    score?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    answers?: SortOrder
  }

  export type AIModuleQuizAttemptAvgOrderByAggregateInput = {
    score?: SortOrder
  }

  export type AIModuleQuizAttemptMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    aiModuleId?: SortOrder
    topicId?: SortOrder
    score?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type AIModuleQuizAttemptMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    aiModuleId?: SortOrder
    topicId?: SortOrder
    score?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type AIModuleQuizAttemptSumOrderByAggregateInput = {
    score?: SortOrder
  }

  export type AIModuleRatingUserIdAiModuleIdCompoundUniqueInput = {
    userId: string
    aiModuleId: string
  }

  export type AIModuleRatingCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    aiModuleId?: SortOrder
    topicId?: SortOrder
    rating?: SortOrder
    feedback?: SortOrder
    createdAt?: SortOrder
  }

  export type AIModuleRatingAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type AIModuleRatingMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    aiModuleId?: SortOrder
    topicId?: SortOrder
    rating?: SortOrder
    feedback?: SortOrder
    createdAt?: SortOrder
  }

  export type AIModuleRatingMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    aiModuleId?: SortOrder
    topicId?: SortOrder
    rating?: SortOrder
    feedback?: SortOrder
    createdAt?: SortOrder
  }

  export type AIModuleRatingSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type LearningPathItemScalarRelationFilter = {
    is?: LearningPathItemWhereInput
    isNot?: LearningPathItemWhereInput
  }

  export type UserProgressUserIdModuleIdCompoundUniqueInput = {
    userId: string
    moduleId: string
  }

  export type UserProgressCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    learningPathId?: SortOrder
    moduleId?: SortOrder
    status?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserProgressMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    learningPathId?: SortOrder
    moduleId?: SortOrder
    status?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserProgressMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    learningPathId?: SortOrder
    moduleId?: SortOrder
    status?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIChatMessageListRelationFilter = {
    every?: AIChatMessageWhereInput
    some?: AIChatMessageWhereInput
    none?: AIChatMessageWhereInput
  }

  export type AIChatMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AIChatCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type AIChatMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type AIChatMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type AIChatScalarRelationFilter = {
    is?: AIChatWhereInput
    isNot?: AIChatWhereInput
  }

  export type AIChatMessageCountOrderByAggregateInput = {
    id?: SortOrder
    chatId?: SortOrder
    display?: SortOrder
    role?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type AIChatMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    chatId?: SortOrder
    display?: SortOrder
    role?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type AIChatMessageMinOrderByAggregateInput = {
    id?: SortOrder
    chatId?: SortOrder
    display?: SortOrder
    role?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type PracticeAttemptCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    aiModuleId?: SortOrder
    questions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    score?: SortOrder
    averageEase?: SortOrder
    completedAt?: SortOrder
  }

  export type PracticeAttemptAvgOrderByAggregateInput = {
    score?: SortOrder
    averageEase?: SortOrder
  }

  export type PracticeAttemptMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    aiModuleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    score?: SortOrder
    averageEase?: SortOrder
    completedAt?: SortOrder
  }

  export type PracticeAttemptMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    aiModuleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    score?: SortOrder
    averageEase?: SortOrder
    completedAt?: SortOrder
  }

  export type PracticeAttemptSumOrderByAggregateInput = {
    score?: SortOrder
    averageEase?: SortOrder
  }

  export type UserCreateinterestsInput = {
    set: string[]
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type ActivityCreateNestedManyWithoutUserInput = {
    create?: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput> | ActivityCreateWithoutUserInput[] | ActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutUserInput | ActivityCreateOrConnectWithoutUserInput[]
    createMany?: ActivityCreateManyUserInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type LearningPreferencesCreateNestedOneWithoutUserInput = {
    create?: XOR<LearningPreferencesCreateWithoutUserInput, LearningPreferencesUncheckedCreateWithoutUserInput>
    connectOrCreate?: LearningPreferencesCreateOrConnectWithoutUserInput
    connect?: LearningPreferencesWhereUniqueInput
  }

  export type TopicCreateNestedManyWithoutUserInput = {
    create?: XOR<TopicCreateWithoutUserInput, TopicUncheckedCreateWithoutUserInput> | TopicCreateWithoutUserInput[] | TopicUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutUserInput | TopicCreateOrConnectWithoutUserInput[]
    createMany?: TopicCreateManyUserInputEnvelope
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
  }

  export type ProgressCreateNestedManyWithoutUserInput = {
    create?: XOR<ProgressCreateWithoutUserInput, ProgressUncheckedCreateWithoutUserInput> | ProgressCreateWithoutUserInput[] | ProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProgressCreateOrConnectWithoutUserInput | ProgressCreateOrConnectWithoutUserInput[]
    createMany?: ProgressCreateManyUserInputEnvelope
    connect?: ProgressWhereUniqueInput | ProgressWhereUniqueInput[]
  }

  export type BadgeCreateNestedManyWithoutUserInput = {
    create?: XOR<BadgeCreateWithoutUserInput, BadgeUncheckedCreateWithoutUserInput> | BadgeCreateWithoutUserInput[] | BadgeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BadgeCreateOrConnectWithoutUserInput | BadgeCreateOrConnectWithoutUserInput[]
    createMany?: BadgeCreateManyUserInputEnvelope
    connect?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
  }

  export type UpcomingReviewCreateNestedManyWithoutUserInput = {
    create?: XOR<UpcomingReviewCreateWithoutUserInput, UpcomingReviewUncheckedCreateWithoutUserInput> | UpcomingReviewCreateWithoutUserInput[] | UpcomingReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UpcomingReviewCreateOrConnectWithoutUserInput | UpcomingReviewCreateOrConnectWithoutUserInput[]
    createMany?: UpcomingReviewCreateManyUserInputEnvelope
    connect?: UpcomingReviewWhereUniqueInput | UpcomingReviewWhereUniqueInput[]
  }

  export type LearningPathCreateNestedManyWithoutUserInput = {
    create?: XOR<LearningPathCreateWithoutUserInput, LearningPathUncheckedCreateWithoutUserInput> | LearningPathCreateWithoutUserInput[] | LearningPathUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LearningPathCreateOrConnectWithoutUserInput | LearningPathCreateOrConnectWithoutUserInput[]
    createMany?: LearningPathCreateManyUserInputEnvelope
    connect?: LearningPathWhereUniqueInput | LearningPathWhereUniqueInput[]
  }

  export type BookmarkCreateNestedManyWithoutUserInput = {
    create?: XOR<BookmarkCreateWithoutUserInput, BookmarkUncheckedCreateWithoutUserInput> | BookmarkCreateWithoutUserInput[] | BookmarkUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookmarkCreateOrConnectWithoutUserInput | BookmarkCreateOrConnectWithoutUserInput[]
    createMany?: BookmarkCreateManyUserInputEnvelope
    connect?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
  }

  export type QuizAttemptCreateNestedManyWithoutUserInput = {
    create?: XOR<QuizAttemptCreateWithoutUserInput, QuizAttemptUncheckedCreateWithoutUserInput> | QuizAttemptCreateWithoutUserInput[] | QuizAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutUserInput | QuizAttemptCreateOrConnectWithoutUserInput[]
    createMany?: QuizAttemptCreateManyUserInputEnvelope
    connect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
  }

  export type KnowledgeNodeCreateNestedManyWithoutUserInput = {
    create?: XOR<KnowledgeNodeCreateWithoutUserInput, KnowledgeNodeUncheckedCreateWithoutUserInput> | KnowledgeNodeCreateWithoutUserInput[] | KnowledgeNodeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: KnowledgeNodeCreateOrConnectWithoutUserInput | KnowledgeNodeCreateOrConnectWithoutUserInput[]
    createMany?: KnowledgeNodeCreateManyUserInputEnvelope
    connect?: KnowledgeNodeWhereUniqueInput | KnowledgeNodeWhereUniqueInput[]
  }

  export type LeaderboardEntryCreateNestedManyWithoutUserInput = {
    create?: XOR<LeaderboardEntryCreateWithoutUserInput, LeaderboardEntryUncheckedCreateWithoutUserInput> | LeaderboardEntryCreateWithoutUserInput[] | LeaderboardEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaderboardEntryCreateOrConnectWithoutUserInput | LeaderboardEntryCreateOrConnectWithoutUserInput[]
    createMany?: LeaderboardEntryCreateManyUserInputEnvelope
    connect?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
  }

  export type ReviewSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewSessionCreateWithoutUserInput, ReviewSessionUncheckedCreateWithoutUserInput> | ReviewSessionCreateWithoutUserInput[] | ReviewSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewSessionCreateOrConnectWithoutUserInput | ReviewSessionCreateOrConnectWithoutUserInput[]
    createMany?: ReviewSessionCreateManyUserInputEnvelope
    connect?: ReviewSessionWhereUniqueInput | ReviewSessionWhereUniqueInput[]
  }

  export type WorkspaceMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<WorkspaceMemberCreateWithoutUserInput, WorkspaceMemberUncheckedCreateWithoutUserInput> | WorkspaceMemberCreateWithoutUserInput[] | WorkspaceMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkspaceMemberCreateOrConnectWithoutUserInput | WorkspaceMemberCreateOrConnectWithoutUserInput[]
    createMany?: WorkspaceMemberCreateManyUserInputEnvelope
    connect?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
  }

  export type ChatMessageCreateNestedManyWithoutUserInput = {
    create?: XOR<ChatMessageCreateWithoutUserInput, ChatMessageUncheckedCreateWithoutUserInput> | ChatMessageCreateWithoutUserInput[] | ChatMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutUserInput | ChatMessageCreateOrConnectWithoutUserInput[]
    createMany?: ChatMessageCreateManyUserInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type WorkspaceCreateNestedManyWithoutOwnerInput = {
    create?: XOR<WorkspaceCreateWithoutOwnerInput, WorkspaceUncheckedCreateWithoutOwnerInput> | WorkspaceCreateWithoutOwnerInput[] | WorkspaceUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: WorkspaceCreateOrConnectWithoutOwnerInput | WorkspaceCreateOrConnectWithoutOwnerInput[]
    createMany?: WorkspaceCreateManyOwnerInputEnvelope
    connect?: WorkspaceWhereUniqueInput | WorkspaceWhereUniqueInput[]
  }

  export type UserSettingsCreateNestedOneWithoutUserInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    connect?: UserSettingsWhereUniqueInput
  }

  export type AnalyticsEntryCreateNestedManyWithoutUserInput = {
    create?: XOR<AnalyticsEntryCreateWithoutUserInput, AnalyticsEntryUncheckedCreateWithoutUserInput> | AnalyticsEntryCreateWithoutUserInput[] | AnalyticsEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AnalyticsEntryCreateOrConnectWithoutUserInput | AnalyticsEntryCreateOrConnectWithoutUserInput[]
    createMany?: AnalyticsEntryCreateManyUserInputEnvelope
    connect?: AnalyticsEntryWhereUniqueInput | AnalyticsEntryWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type PasswordlessTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<PasswordlessTokenCreateWithoutUserInput, PasswordlessTokenUncheckedCreateWithoutUserInput> | PasswordlessTokenCreateWithoutUserInput[] | PasswordlessTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordlessTokenCreateOrConnectWithoutUserInput | PasswordlessTokenCreateOrConnectWithoutUserInput[]
    createMany?: PasswordlessTokenCreateManyUserInputEnvelope
    connect?: PasswordlessTokenWhereUniqueInput | PasswordlessTokenWhereUniqueInput[]
  }

  export type DailyChallengeCreateNestedManyWithoutUserInput = {
    create?: XOR<DailyChallengeCreateWithoutUserInput, DailyChallengeUncheckedCreateWithoutUserInput> | DailyChallengeCreateWithoutUserInput[] | DailyChallengeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DailyChallengeCreateOrConnectWithoutUserInput | DailyChallengeCreateOrConnectWithoutUserInput[]
    createMany?: DailyChallengeCreateManyUserInputEnvelope
    connect?: DailyChallengeWhereUniqueInput | DailyChallengeWhereUniqueInput[]
  }

  export type ExternalGoalCreateNestedManyWithoutUserInput = {
    create?: XOR<ExternalGoalCreateWithoutUserInput, ExternalGoalUncheckedCreateWithoutUserInput> | ExternalGoalCreateWithoutUserInput[] | ExternalGoalUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExternalGoalCreateOrConnectWithoutUserInput | ExternalGoalCreateOrConnectWithoutUserInput[]
    createMany?: ExternalGoalCreateManyUserInputEnvelope
    connect?: ExternalGoalWhereUniqueInput | ExternalGoalWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ContentRatingCreateNestedManyWithoutUserInput = {
    create?: XOR<ContentRatingCreateWithoutUserInput, ContentRatingUncheckedCreateWithoutUserInput> | ContentRatingCreateWithoutUserInput[] | ContentRatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContentRatingCreateOrConnectWithoutUserInput | ContentRatingCreateOrConnectWithoutUserInput[]
    createMany?: ContentRatingCreateManyUserInputEnvelope
    connect?: ContentRatingWhereUniqueInput | ContentRatingWhereUniqueInput[]
  }

  export type ChallengeScoreCreateNestedManyWithoutUserInput = {
    create?: XOR<ChallengeScoreCreateWithoutUserInput, ChallengeScoreUncheckedCreateWithoutUserInput> | ChallengeScoreCreateWithoutUserInput[] | ChallengeScoreUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChallengeScoreCreateOrConnectWithoutUserInput | ChallengeScoreCreateOrConnectWithoutUserInput[]
    createMany?: ChallengeScoreCreateManyUserInputEnvelope
    connect?: ChallengeScoreWhereUniqueInput | ChallengeScoreWhereUniqueInput[]
  }

  export type PollVoteCreateNestedManyWithoutUserInput = {
    create?: XOR<PollVoteCreateWithoutUserInput, PollVoteUncheckedCreateWithoutUserInput> | PollVoteCreateWithoutUserInput[] | PollVoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PollVoteCreateOrConnectWithoutUserInput | PollVoteCreateOrConnectWithoutUserInput[]
    createMany?: PollVoteCreateManyUserInputEnvelope
    connect?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[]
  }

  export type AIRecommendationCreateNestedManyWithoutUserInput = {
    create?: XOR<AIRecommendationCreateWithoutUserInput, AIRecommendationUncheckedCreateWithoutUserInput> | AIRecommendationCreateWithoutUserInput[] | AIRecommendationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AIRecommendationCreateOrConnectWithoutUserInput | AIRecommendationCreateOrConnectWithoutUserInput[]
    createMany?: AIRecommendationCreateManyUserInputEnvelope
    connect?: AIRecommendationWhereUniqueInput | AIRecommendationWhereUniqueInput[]
  }

  export type AIModuleCreateNestedManyWithoutUserInput = {
    create?: XOR<AIModuleCreateWithoutUserInput, AIModuleUncheckedCreateWithoutUserInput> | AIModuleCreateWithoutUserInput[] | AIModuleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AIModuleCreateOrConnectWithoutUserInput | AIModuleCreateOrConnectWithoutUserInput[]
    createMany?: AIModuleCreateManyUserInputEnvelope
    connect?: AIModuleWhereUniqueInput | AIModuleWhereUniqueInput[]
  }

  export type AIModuleQuizAttemptCreateNestedManyWithoutUserInput = {
    create?: XOR<AIModuleQuizAttemptCreateWithoutUserInput, AIModuleQuizAttemptUncheckedCreateWithoutUserInput> | AIModuleQuizAttemptCreateWithoutUserInput[] | AIModuleQuizAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AIModuleQuizAttemptCreateOrConnectWithoutUserInput | AIModuleQuizAttemptCreateOrConnectWithoutUserInput[]
    createMany?: AIModuleQuizAttemptCreateManyUserInputEnvelope
    connect?: AIModuleQuizAttemptWhereUniqueInput | AIModuleQuizAttemptWhereUniqueInput[]
  }

  export type AIModuleRatingCreateNestedManyWithoutUserInput = {
    create?: XOR<AIModuleRatingCreateWithoutUserInput, AIModuleRatingUncheckedCreateWithoutUserInput> | AIModuleRatingCreateWithoutUserInput[] | AIModuleRatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AIModuleRatingCreateOrConnectWithoutUserInput | AIModuleRatingCreateOrConnectWithoutUserInput[]
    createMany?: AIModuleRatingCreateManyUserInputEnvelope
    connect?: AIModuleRatingWhereUniqueInput | AIModuleRatingWhereUniqueInput[]
  }

  export type UserProgressCreateNestedManyWithoutUserInput = {
    create?: XOR<UserProgressCreateWithoutUserInput, UserProgressUncheckedCreateWithoutUserInput> | UserProgressCreateWithoutUserInput[] | UserProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserProgressCreateOrConnectWithoutUserInput | UserProgressCreateOrConnectWithoutUserInput[]
    createMany?: UserProgressCreateManyUserInputEnvelope
    connect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
  }

  export type AIChatCreateNestedManyWithoutUserInput = {
    create?: XOR<AIChatCreateWithoutUserInput, AIChatUncheckedCreateWithoutUserInput> | AIChatCreateWithoutUserInput[] | AIChatUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AIChatCreateOrConnectWithoutUserInput | AIChatCreateOrConnectWithoutUserInput[]
    createMany?: AIChatCreateManyUserInputEnvelope
    connect?: AIChatWhereUniqueInput | AIChatWhereUniqueInput[]
  }

  export type PracticeAttemptCreateNestedManyWithoutUserInput = {
    create?: XOR<PracticeAttemptCreateWithoutUserInput, PracticeAttemptUncheckedCreateWithoutUserInput> | PracticeAttemptCreateWithoutUserInput[] | PracticeAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PracticeAttemptCreateOrConnectWithoutUserInput | PracticeAttemptCreateOrConnectWithoutUserInput[]
    createMany?: PracticeAttemptCreateManyUserInputEnvelope
    connect?: PracticeAttemptWhereUniqueInput | PracticeAttemptWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type ActivityUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput> | ActivityCreateWithoutUserInput[] | ActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutUserInput | ActivityCreateOrConnectWithoutUserInput[]
    createMany?: ActivityCreateManyUserInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type LearningPreferencesUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<LearningPreferencesCreateWithoutUserInput, LearningPreferencesUncheckedCreateWithoutUserInput>
    connectOrCreate?: LearningPreferencesCreateOrConnectWithoutUserInput
    connect?: LearningPreferencesWhereUniqueInput
  }

  export type TopicUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TopicCreateWithoutUserInput, TopicUncheckedCreateWithoutUserInput> | TopicCreateWithoutUserInput[] | TopicUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutUserInput | TopicCreateOrConnectWithoutUserInput[]
    createMany?: TopicCreateManyUserInputEnvelope
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
  }

  export type ProgressUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProgressCreateWithoutUserInput, ProgressUncheckedCreateWithoutUserInput> | ProgressCreateWithoutUserInput[] | ProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProgressCreateOrConnectWithoutUserInput | ProgressCreateOrConnectWithoutUserInput[]
    createMany?: ProgressCreateManyUserInputEnvelope
    connect?: ProgressWhereUniqueInput | ProgressWhereUniqueInput[]
  }

  export type BadgeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BadgeCreateWithoutUserInput, BadgeUncheckedCreateWithoutUserInput> | BadgeCreateWithoutUserInput[] | BadgeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BadgeCreateOrConnectWithoutUserInput | BadgeCreateOrConnectWithoutUserInput[]
    createMany?: BadgeCreateManyUserInputEnvelope
    connect?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
  }

  export type UpcomingReviewUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UpcomingReviewCreateWithoutUserInput, UpcomingReviewUncheckedCreateWithoutUserInput> | UpcomingReviewCreateWithoutUserInput[] | UpcomingReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UpcomingReviewCreateOrConnectWithoutUserInput | UpcomingReviewCreateOrConnectWithoutUserInput[]
    createMany?: UpcomingReviewCreateManyUserInputEnvelope
    connect?: UpcomingReviewWhereUniqueInput | UpcomingReviewWhereUniqueInput[]
  }

  export type LearningPathUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LearningPathCreateWithoutUserInput, LearningPathUncheckedCreateWithoutUserInput> | LearningPathCreateWithoutUserInput[] | LearningPathUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LearningPathCreateOrConnectWithoutUserInput | LearningPathCreateOrConnectWithoutUserInput[]
    createMany?: LearningPathCreateManyUserInputEnvelope
    connect?: LearningPathWhereUniqueInput | LearningPathWhereUniqueInput[]
  }

  export type BookmarkUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BookmarkCreateWithoutUserInput, BookmarkUncheckedCreateWithoutUserInput> | BookmarkCreateWithoutUserInput[] | BookmarkUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookmarkCreateOrConnectWithoutUserInput | BookmarkCreateOrConnectWithoutUserInput[]
    createMany?: BookmarkCreateManyUserInputEnvelope
    connect?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
  }

  export type QuizAttemptUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<QuizAttemptCreateWithoutUserInput, QuizAttemptUncheckedCreateWithoutUserInput> | QuizAttemptCreateWithoutUserInput[] | QuizAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutUserInput | QuizAttemptCreateOrConnectWithoutUserInput[]
    createMany?: QuizAttemptCreateManyUserInputEnvelope
    connect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
  }

  export type KnowledgeNodeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<KnowledgeNodeCreateWithoutUserInput, KnowledgeNodeUncheckedCreateWithoutUserInput> | KnowledgeNodeCreateWithoutUserInput[] | KnowledgeNodeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: KnowledgeNodeCreateOrConnectWithoutUserInput | KnowledgeNodeCreateOrConnectWithoutUserInput[]
    createMany?: KnowledgeNodeCreateManyUserInputEnvelope
    connect?: KnowledgeNodeWhereUniqueInput | KnowledgeNodeWhereUniqueInput[]
  }

  export type LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LeaderboardEntryCreateWithoutUserInput, LeaderboardEntryUncheckedCreateWithoutUserInput> | LeaderboardEntryCreateWithoutUserInput[] | LeaderboardEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaderboardEntryCreateOrConnectWithoutUserInput | LeaderboardEntryCreateOrConnectWithoutUserInput[]
    createMany?: LeaderboardEntryCreateManyUserInputEnvelope
    connect?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
  }

  export type ReviewSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewSessionCreateWithoutUserInput, ReviewSessionUncheckedCreateWithoutUserInput> | ReviewSessionCreateWithoutUserInput[] | ReviewSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewSessionCreateOrConnectWithoutUserInput | ReviewSessionCreateOrConnectWithoutUserInput[]
    createMany?: ReviewSessionCreateManyUserInputEnvelope
    connect?: ReviewSessionWhereUniqueInput | ReviewSessionWhereUniqueInput[]
  }

  export type WorkspaceMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WorkspaceMemberCreateWithoutUserInput, WorkspaceMemberUncheckedCreateWithoutUserInput> | WorkspaceMemberCreateWithoutUserInput[] | WorkspaceMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkspaceMemberCreateOrConnectWithoutUserInput | WorkspaceMemberCreateOrConnectWithoutUserInput[]
    createMany?: WorkspaceMemberCreateManyUserInputEnvelope
    connect?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
  }

  export type ChatMessageUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ChatMessageCreateWithoutUserInput, ChatMessageUncheckedCreateWithoutUserInput> | ChatMessageCreateWithoutUserInput[] | ChatMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutUserInput | ChatMessageCreateOrConnectWithoutUserInput[]
    createMany?: ChatMessageCreateManyUserInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type WorkspaceUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<WorkspaceCreateWithoutOwnerInput, WorkspaceUncheckedCreateWithoutOwnerInput> | WorkspaceCreateWithoutOwnerInput[] | WorkspaceUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: WorkspaceCreateOrConnectWithoutOwnerInput | WorkspaceCreateOrConnectWithoutOwnerInput[]
    createMany?: WorkspaceCreateManyOwnerInputEnvelope
    connect?: WorkspaceWhereUniqueInput | WorkspaceWhereUniqueInput[]
  }

  export type UserSettingsUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    connect?: UserSettingsWhereUniqueInput
  }

  export type AnalyticsEntryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AnalyticsEntryCreateWithoutUserInput, AnalyticsEntryUncheckedCreateWithoutUserInput> | AnalyticsEntryCreateWithoutUserInput[] | AnalyticsEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AnalyticsEntryCreateOrConnectWithoutUserInput | AnalyticsEntryCreateOrConnectWithoutUserInput[]
    createMany?: AnalyticsEntryCreateManyUserInputEnvelope
    connect?: AnalyticsEntryWhereUniqueInput | AnalyticsEntryWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type PasswordlessTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PasswordlessTokenCreateWithoutUserInput, PasswordlessTokenUncheckedCreateWithoutUserInput> | PasswordlessTokenCreateWithoutUserInput[] | PasswordlessTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordlessTokenCreateOrConnectWithoutUserInput | PasswordlessTokenCreateOrConnectWithoutUserInput[]
    createMany?: PasswordlessTokenCreateManyUserInputEnvelope
    connect?: PasswordlessTokenWhereUniqueInput | PasswordlessTokenWhereUniqueInput[]
  }

  export type DailyChallengeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DailyChallengeCreateWithoutUserInput, DailyChallengeUncheckedCreateWithoutUserInput> | DailyChallengeCreateWithoutUserInput[] | DailyChallengeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DailyChallengeCreateOrConnectWithoutUserInput | DailyChallengeCreateOrConnectWithoutUserInput[]
    createMany?: DailyChallengeCreateManyUserInputEnvelope
    connect?: DailyChallengeWhereUniqueInput | DailyChallengeWhereUniqueInput[]
  }

  export type ExternalGoalUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ExternalGoalCreateWithoutUserInput, ExternalGoalUncheckedCreateWithoutUserInput> | ExternalGoalCreateWithoutUserInput[] | ExternalGoalUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExternalGoalCreateOrConnectWithoutUserInput | ExternalGoalCreateOrConnectWithoutUserInput[]
    createMany?: ExternalGoalCreateManyUserInputEnvelope
    connect?: ExternalGoalWhereUniqueInput | ExternalGoalWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ContentRatingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ContentRatingCreateWithoutUserInput, ContentRatingUncheckedCreateWithoutUserInput> | ContentRatingCreateWithoutUserInput[] | ContentRatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContentRatingCreateOrConnectWithoutUserInput | ContentRatingCreateOrConnectWithoutUserInput[]
    createMany?: ContentRatingCreateManyUserInputEnvelope
    connect?: ContentRatingWhereUniqueInput | ContentRatingWhereUniqueInput[]
  }

  export type ChallengeScoreUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ChallengeScoreCreateWithoutUserInput, ChallengeScoreUncheckedCreateWithoutUserInput> | ChallengeScoreCreateWithoutUserInput[] | ChallengeScoreUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChallengeScoreCreateOrConnectWithoutUserInput | ChallengeScoreCreateOrConnectWithoutUserInput[]
    createMany?: ChallengeScoreCreateManyUserInputEnvelope
    connect?: ChallengeScoreWhereUniqueInput | ChallengeScoreWhereUniqueInput[]
  }

  export type PollVoteUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PollVoteCreateWithoutUserInput, PollVoteUncheckedCreateWithoutUserInput> | PollVoteCreateWithoutUserInput[] | PollVoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PollVoteCreateOrConnectWithoutUserInput | PollVoteCreateOrConnectWithoutUserInput[]
    createMany?: PollVoteCreateManyUserInputEnvelope
    connect?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[]
  }

  export type AIRecommendationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AIRecommendationCreateWithoutUserInput, AIRecommendationUncheckedCreateWithoutUserInput> | AIRecommendationCreateWithoutUserInput[] | AIRecommendationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AIRecommendationCreateOrConnectWithoutUserInput | AIRecommendationCreateOrConnectWithoutUserInput[]
    createMany?: AIRecommendationCreateManyUserInputEnvelope
    connect?: AIRecommendationWhereUniqueInput | AIRecommendationWhereUniqueInput[]
  }

  export type AIModuleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AIModuleCreateWithoutUserInput, AIModuleUncheckedCreateWithoutUserInput> | AIModuleCreateWithoutUserInput[] | AIModuleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AIModuleCreateOrConnectWithoutUserInput | AIModuleCreateOrConnectWithoutUserInput[]
    createMany?: AIModuleCreateManyUserInputEnvelope
    connect?: AIModuleWhereUniqueInput | AIModuleWhereUniqueInput[]
  }

  export type AIModuleQuizAttemptUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AIModuleQuizAttemptCreateWithoutUserInput, AIModuleQuizAttemptUncheckedCreateWithoutUserInput> | AIModuleQuizAttemptCreateWithoutUserInput[] | AIModuleQuizAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AIModuleQuizAttemptCreateOrConnectWithoutUserInput | AIModuleQuizAttemptCreateOrConnectWithoutUserInput[]
    createMany?: AIModuleQuizAttemptCreateManyUserInputEnvelope
    connect?: AIModuleQuizAttemptWhereUniqueInput | AIModuleQuizAttemptWhereUniqueInput[]
  }

  export type AIModuleRatingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AIModuleRatingCreateWithoutUserInput, AIModuleRatingUncheckedCreateWithoutUserInput> | AIModuleRatingCreateWithoutUserInput[] | AIModuleRatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AIModuleRatingCreateOrConnectWithoutUserInput | AIModuleRatingCreateOrConnectWithoutUserInput[]
    createMany?: AIModuleRatingCreateManyUserInputEnvelope
    connect?: AIModuleRatingWhereUniqueInput | AIModuleRatingWhereUniqueInput[]
  }

  export type UserProgressUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserProgressCreateWithoutUserInput, UserProgressUncheckedCreateWithoutUserInput> | UserProgressCreateWithoutUserInput[] | UserProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserProgressCreateOrConnectWithoutUserInput | UserProgressCreateOrConnectWithoutUserInput[]
    createMany?: UserProgressCreateManyUserInputEnvelope
    connect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
  }

  export type AIChatUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AIChatCreateWithoutUserInput, AIChatUncheckedCreateWithoutUserInput> | AIChatCreateWithoutUserInput[] | AIChatUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AIChatCreateOrConnectWithoutUserInput | AIChatCreateOrConnectWithoutUserInput[]
    createMany?: AIChatCreateManyUserInputEnvelope
    connect?: AIChatWhereUniqueInput | AIChatWhereUniqueInput[]
  }

  export type PracticeAttemptUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PracticeAttemptCreateWithoutUserInput, PracticeAttemptUncheckedCreateWithoutUserInput> | PracticeAttemptCreateWithoutUserInput[] | PracticeAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PracticeAttemptCreateOrConnectWithoutUserInput | PracticeAttemptCreateOrConnectWithoutUserInput[]
    createMany?: PracticeAttemptCreateManyUserInputEnvelope
    connect?: PracticeAttemptWhereUniqueInput | PracticeAttemptWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateinterestsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type ActivityUpdateManyWithoutUserNestedInput = {
    create?: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput> | ActivityCreateWithoutUserInput[] | ActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutUserInput | ActivityCreateOrConnectWithoutUserInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutUserInput | ActivityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ActivityCreateManyUserInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutUserInput | ActivityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutUserInput | ActivityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type LearningPreferencesUpdateOneWithoutUserNestedInput = {
    create?: XOR<LearningPreferencesCreateWithoutUserInput, LearningPreferencesUncheckedCreateWithoutUserInput>
    connectOrCreate?: LearningPreferencesCreateOrConnectWithoutUserInput
    upsert?: LearningPreferencesUpsertWithoutUserInput
    disconnect?: LearningPreferencesWhereInput | boolean
    delete?: LearningPreferencesWhereInput | boolean
    connect?: LearningPreferencesWhereUniqueInput
    update?: XOR<XOR<LearningPreferencesUpdateToOneWithWhereWithoutUserInput, LearningPreferencesUpdateWithoutUserInput>, LearningPreferencesUncheckedUpdateWithoutUserInput>
  }

  export type TopicUpdateManyWithoutUserNestedInput = {
    create?: XOR<TopicCreateWithoutUserInput, TopicUncheckedCreateWithoutUserInput> | TopicCreateWithoutUserInput[] | TopicUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutUserInput | TopicCreateOrConnectWithoutUserInput[]
    upsert?: TopicUpsertWithWhereUniqueWithoutUserInput | TopicUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TopicCreateManyUserInputEnvelope
    set?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    disconnect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    delete?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    update?: TopicUpdateWithWhereUniqueWithoutUserInput | TopicUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TopicUpdateManyWithWhereWithoutUserInput | TopicUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TopicScalarWhereInput | TopicScalarWhereInput[]
  }

  export type ProgressUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProgressCreateWithoutUserInput, ProgressUncheckedCreateWithoutUserInput> | ProgressCreateWithoutUserInput[] | ProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProgressCreateOrConnectWithoutUserInput | ProgressCreateOrConnectWithoutUserInput[]
    upsert?: ProgressUpsertWithWhereUniqueWithoutUserInput | ProgressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProgressCreateManyUserInputEnvelope
    set?: ProgressWhereUniqueInput | ProgressWhereUniqueInput[]
    disconnect?: ProgressWhereUniqueInput | ProgressWhereUniqueInput[]
    delete?: ProgressWhereUniqueInput | ProgressWhereUniqueInput[]
    connect?: ProgressWhereUniqueInput | ProgressWhereUniqueInput[]
    update?: ProgressUpdateWithWhereUniqueWithoutUserInput | ProgressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProgressUpdateManyWithWhereWithoutUserInput | ProgressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProgressScalarWhereInput | ProgressScalarWhereInput[]
  }

  export type BadgeUpdateManyWithoutUserNestedInput = {
    create?: XOR<BadgeCreateWithoutUserInput, BadgeUncheckedCreateWithoutUserInput> | BadgeCreateWithoutUserInput[] | BadgeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BadgeCreateOrConnectWithoutUserInput | BadgeCreateOrConnectWithoutUserInput[]
    upsert?: BadgeUpsertWithWhereUniqueWithoutUserInput | BadgeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BadgeCreateManyUserInputEnvelope
    set?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    disconnect?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    delete?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    connect?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    update?: BadgeUpdateWithWhereUniqueWithoutUserInput | BadgeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BadgeUpdateManyWithWhereWithoutUserInput | BadgeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BadgeScalarWhereInput | BadgeScalarWhereInput[]
  }

  export type UpcomingReviewUpdateManyWithoutUserNestedInput = {
    create?: XOR<UpcomingReviewCreateWithoutUserInput, UpcomingReviewUncheckedCreateWithoutUserInput> | UpcomingReviewCreateWithoutUserInput[] | UpcomingReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UpcomingReviewCreateOrConnectWithoutUserInput | UpcomingReviewCreateOrConnectWithoutUserInput[]
    upsert?: UpcomingReviewUpsertWithWhereUniqueWithoutUserInput | UpcomingReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UpcomingReviewCreateManyUserInputEnvelope
    set?: UpcomingReviewWhereUniqueInput | UpcomingReviewWhereUniqueInput[]
    disconnect?: UpcomingReviewWhereUniqueInput | UpcomingReviewWhereUniqueInput[]
    delete?: UpcomingReviewWhereUniqueInput | UpcomingReviewWhereUniqueInput[]
    connect?: UpcomingReviewWhereUniqueInput | UpcomingReviewWhereUniqueInput[]
    update?: UpcomingReviewUpdateWithWhereUniqueWithoutUserInput | UpcomingReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UpcomingReviewUpdateManyWithWhereWithoutUserInput | UpcomingReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UpcomingReviewScalarWhereInput | UpcomingReviewScalarWhereInput[]
  }

  export type LearningPathUpdateManyWithoutUserNestedInput = {
    create?: XOR<LearningPathCreateWithoutUserInput, LearningPathUncheckedCreateWithoutUserInput> | LearningPathCreateWithoutUserInput[] | LearningPathUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LearningPathCreateOrConnectWithoutUserInput | LearningPathCreateOrConnectWithoutUserInput[]
    upsert?: LearningPathUpsertWithWhereUniqueWithoutUserInput | LearningPathUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LearningPathCreateManyUserInputEnvelope
    set?: LearningPathWhereUniqueInput | LearningPathWhereUniqueInput[]
    disconnect?: LearningPathWhereUniqueInput | LearningPathWhereUniqueInput[]
    delete?: LearningPathWhereUniqueInput | LearningPathWhereUniqueInput[]
    connect?: LearningPathWhereUniqueInput | LearningPathWhereUniqueInput[]
    update?: LearningPathUpdateWithWhereUniqueWithoutUserInput | LearningPathUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LearningPathUpdateManyWithWhereWithoutUserInput | LearningPathUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LearningPathScalarWhereInput | LearningPathScalarWhereInput[]
  }

  export type BookmarkUpdateManyWithoutUserNestedInput = {
    create?: XOR<BookmarkCreateWithoutUserInput, BookmarkUncheckedCreateWithoutUserInput> | BookmarkCreateWithoutUserInput[] | BookmarkUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookmarkCreateOrConnectWithoutUserInput | BookmarkCreateOrConnectWithoutUserInput[]
    upsert?: BookmarkUpsertWithWhereUniqueWithoutUserInput | BookmarkUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BookmarkCreateManyUserInputEnvelope
    set?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    disconnect?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    delete?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    connect?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    update?: BookmarkUpdateWithWhereUniqueWithoutUserInput | BookmarkUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BookmarkUpdateManyWithWhereWithoutUserInput | BookmarkUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BookmarkScalarWhereInput | BookmarkScalarWhereInput[]
  }

  export type QuizAttemptUpdateManyWithoutUserNestedInput = {
    create?: XOR<QuizAttemptCreateWithoutUserInput, QuizAttemptUncheckedCreateWithoutUserInput> | QuizAttemptCreateWithoutUserInput[] | QuizAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutUserInput | QuizAttemptCreateOrConnectWithoutUserInput[]
    upsert?: QuizAttemptUpsertWithWhereUniqueWithoutUserInput | QuizAttemptUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: QuizAttemptCreateManyUserInputEnvelope
    set?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    disconnect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    delete?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    connect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    update?: QuizAttemptUpdateWithWhereUniqueWithoutUserInput | QuizAttemptUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: QuizAttemptUpdateManyWithWhereWithoutUserInput | QuizAttemptUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: QuizAttemptScalarWhereInput | QuizAttemptScalarWhereInput[]
  }

  export type KnowledgeNodeUpdateManyWithoutUserNestedInput = {
    create?: XOR<KnowledgeNodeCreateWithoutUserInput, KnowledgeNodeUncheckedCreateWithoutUserInput> | KnowledgeNodeCreateWithoutUserInput[] | KnowledgeNodeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: KnowledgeNodeCreateOrConnectWithoutUserInput | KnowledgeNodeCreateOrConnectWithoutUserInput[]
    upsert?: KnowledgeNodeUpsertWithWhereUniqueWithoutUserInput | KnowledgeNodeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: KnowledgeNodeCreateManyUserInputEnvelope
    set?: KnowledgeNodeWhereUniqueInput | KnowledgeNodeWhereUniqueInput[]
    disconnect?: KnowledgeNodeWhereUniqueInput | KnowledgeNodeWhereUniqueInput[]
    delete?: KnowledgeNodeWhereUniqueInput | KnowledgeNodeWhereUniqueInput[]
    connect?: KnowledgeNodeWhereUniqueInput | KnowledgeNodeWhereUniqueInput[]
    update?: KnowledgeNodeUpdateWithWhereUniqueWithoutUserInput | KnowledgeNodeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: KnowledgeNodeUpdateManyWithWhereWithoutUserInput | KnowledgeNodeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: KnowledgeNodeScalarWhereInput | KnowledgeNodeScalarWhereInput[]
  }

  export type LeaderboardEntryUpdateManyWithoutUserNestedInput = {
    create?: XOR<LeaderboardEntryCreateWithoutUserInput, LeaderboardEntryUncheckedCreateWithoutUserInput> | LeaderboardEntryCreateWithoutUserInput[] | LeaderboardEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaderboardEntryCreateOrConnectWithoutUserInput | LeaderboardEntryCreateOrConnectWithoutUserInput[]
    upsert?: LeaderboardEntryUpsertWithWhereUniqueWithoutUserInput | LeaderboardEntryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LeaderboardEntryCreateManyUserInputEnvelope
    set?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
    disconnect?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
    delete?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
    connect?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
    update?: LeaderboardEntryUpdateWithWhereUniqueWithoutUserInput | LeaderboardEntryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LeaderboardEntryUpdateManyWithWhereWithoutUserInput | LeaderboardEntryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LeaderboardEntryScalarWhereInput | LeaderboardEntryScalarWhereInput[]
  }

  export type ReviewSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewSessionCreateWithoutUserInput, ReviewSessionUncheckedCreateWithoutUserInput> | ReviewSessionCreateWithoutUserInput[] | ReviewSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewSessionCreateOrConnectWithoutUserInput | ReviewSessionCreateOrConnectWithoutUserInput[]
    upsert?: ReviewSessionUpsertWithWhereUniqueWithoutUserInput | ReviewSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewSessionCreateManyUserInputEnvelope
    set?: ReviewSessionWhereUniqueInput | ReviewSessionWhereUniqueInput[]
    disconnect?: ReviewSessionWhereUniqueInput | ReviewSessionWhereUniqueInput[]
    delete?: ReviewSessionWhereUniqueInput | ReviewSessionWhereUniqueInput[]
    connect?: ReviewSessionWhereUniqueInput | ReviewSessionWhereUniqueInput[]
    update?: ReviewSessionUpdateWithWhereUniqueWithoutUserInput | ReviewSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewSessionUpdateManyWithWhereWithoutUserInput | ReviewSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewSessionScalarWhereInput | ReviewSessionScalarWhereInput[]
  }

  export type WorkspaceMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<WorkspaceMemberCreateWithoutUserInput, WorkspaceMemberUncheckedCreateWithoutUserInput> | WorkspaceMemberCreateWithoutUserInput[] | WorkspaceMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkspaceMemberCreateOrConnectWithoutUserInput | WorkspaceMemberCreateOrConnectWithoutUserInput[]
    upsert?: WorkspaceMemberUpsertWithWhereUniqueWithoutUserInput | WorkspaceMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WorkspaceMemberCreateManyUserInputEnvelope
    set?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
    disconnect?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
    delete?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
    connect?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
    update?: WorkspaceMemberUpdateWithWhereUniqueWithoutUserInput | WorkspaceMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WorkspaceMemberUpdateManyWithWhereWithoutUserInput | WorkspaceMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WorkspaceMemberScalarWhereInput | WorkspaceMemberScalarWhereInput[]
  }

  export type ChatMessageUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChatMessageCreateWithoutUserInput, ChatMessageUncheckedCreateWithoutUserInput> | ChatMessageCreateWithoutUserInput[] | ChatMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutUserInput | ChatMessageCreateOrConnectWithoutUserInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutUserInput | ChatMessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChatMessageCreateManyUserInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutUserInput | ChatMessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutUserInput | ChatMessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type WorkspaceUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<WorkspaceCreateWithoutOwnerInput, WorkspaceUncheckedCreateWithoutOwnerInput> | WorkspaceCreateWithoutOwnerInput[] | WorkspaceUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: WorkspaceCreateOrConnectWithoutOwnerInput | WorkspaceCreateOrConnectWithoutOwnerInput[]
    upsert?: WorkspaceUpsertWithWhereUniqueWithoutOwnerInput | WorkspaceUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: WorkspaceCreateManyOwnerInputEnvelope
    set?: WorkspaceWhereUniqueInput | WorkspaceWhereUniqueInput[]
    disconnect?: WorkspaceWhereUniqueInput | WorkspaceWhereUniqueInput[]
    delete?: WorkspaceWhereUniqueInput | WorkspaceWhereUniqueInput[]
    connect?: WorkspaceWhereUniqueInput | WorkspaceWhereUniqueInput[]
    update?: WorkspaceUpdateWithWhereUniqueWithoutOwnerInput | WorkspaceUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: WorkspaceUpdateManyWithWhereWithoutOwnerInput | WorkspaceUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: WorkspaceScalarWhereInput | WorkspaceScalarWhereInput[]
  }

  export type UserSettingsUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    upsert?: UserSettingsUpsertWithoutUserInput
    disconnect?: UserSettingsWhereInput | boolean
    delete?: UserSettingsWhereInput | boolean
    connect?: UserSettingsWhereUniqueInput
    update?: XOR<XOR<UserSettingsUpdateToOneWithWhereWithoutUserInput, UserSettingsUpdateWithoutUserInput>, UserSettingsUncheckedUpdateWithoutUserInput>
  }

  export type AnalyticsEntryUpdateManyWithoutUserNestedInput = {
    create?: XOR<AnalyticsEntryCreateWithoutUserInput, AnalyticsEntryUncheckedCreateWithoutUserInput> | AnalyticsEntryCreateWithoutUserInput[] | AnalyticsEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AnalyticsEntryCreateOrConnectWithoutUserInput | AnalyticsEntryCreateOrConnectWithoutUserInput[]
    upsert?: AnalyticsEntryUpsertWithWhereUniqueWithoutUserInput | AnalyticsEntryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AnalyticsEntryCreateManyUserInputEnvelope
    set?: AnalyticsEntryWhereUniqueInput | AnalyticsEntryWhereUniqueInput[]
    disconnect?: AnalyticsEntryWhereUniqueInput | AnalyticsEntryWhereUniqueInput[]
    delete?: AnalyticsEntryWhereUniqueInput | AnalyticsEntryWhereUniqueInput[]
    connect?: AnalyticsEntryWhereUniqueInput | AnalyticsEntryWhereUniqueInput[]
    update?: AnalyticsEntryUpdateWithWhereUniqueWithoutUserInput | AnalyticsEntryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AnalyticsEntryUpdateManyWithWhereWithoutUserInput | AnalyticsEntryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AnalyticsEntryScalarWhereInput | AnalyticsEntryScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type PasswordlessTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasswordlessTokenCreateWithoutUserInput, PasswordlessTokenUncheckedCreateWithoutUserInput> | PasswordlessTokenCreateWithoutUserInput[] | PasswordlessTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordlessTokenCreateOrConnectWithoutUserInput | PasswordlessTokenCreateOrConnectWithoutUserInput[]
    upsert?: PasswordlessTokenUpsertWithWhereUniqueWithoutUserInput | PasswordlessTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasswordlessTokenCreateManyUserInputEnvelope
    set?: PasswordlessTokenWhereUniqueInput | PasswordlessTokenWhereUniqueInput[]
    disconnect?: PasswordlessTokenWhereUniqueInput | PasswordlessTokenWhereUniqueInput[]
    delete?: PasswordlessTokenWhereUniqueInput | PasswordlessTokenWhereUniqueInput[]
    connect?: PasswordlessTokenWhereUniqueInput | PasswordlessTokenWhereUniqueInput[]
    update?: PasswordlessTokenUpdateWithWhereUniqueWithoutUserInput | PasswordlessTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasswordlessTokenUpdateManyWithWhereWithoutUserInput | PasswordlessTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasswordlessTokenScalarWhereInput | PasswordlessTokenScalarWhereInput[]
  }

  export type DailyChallengeUpdateManyWithoutUserNestedInput = {
    create?: XOR<DailyChallengeCreateWithoutUserInput, DailyChallengeUncheckedCreateWithoutUserInput> | DailyChallengeCreateWithoutUserInput[] | DailyChallengeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DailyChallengeCreateOrConnectWithoutUserInput | DailyChallengeCreateOrConnectWithoutUserInput[]
    upsert?: DailyChallengeUpsertWithWhereUniqueWithoutUserInput | DailyChallengeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DailyChallengeCreateManyUserInputEnvelope
    set?: DailyChallengeWhereUniqueInput | DailyChallengeWhereUniqueInput[]
    disconnect?: DailyChallengeWhereUniqueInput | DailyChallengeWhereUniqueInput[]
    delete?: DailyChallengeWhereUniqueInput | DailyChallengeWhereUniqueInput[]
    connect?: DailyChallengeWhereUniqueInput | DailyChallengeWhereUniqueInput[]
    update?: DailyChallengeUpdateWithWhereUniqueWithoutUserInput | DailyChallengeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DailyChallengeUpdateManyWithWhereWithoutUserInput | DailyChallengeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DailyChallengeScalarWhereInput | DailyChallengeScalarWhereInput[]
  }

  export type ExternalGoalUpdateManyWithoutUserNestedInput = {
    create?: XOR<ExternalGoalCreateWithoutUserInput, ExternalGoalUncheckedCreateWithoutUserInput> | ExternalGoalCreateWithoutUserInput[] | ExternalGoalUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExternalGoalCreateOrConnectWithoutUserInput | ExternalGoalCreateOrConnectWithoutUserInput[]
    upsert?: ExternalGoalUpsertWithWhereUniqueWithoutUserInput | ExternalGoalUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ExternalGoalCreateManyUserInputEnvelope
    set?: ExternalGoalWhereUniqueInput | ExternalGoalWhereUniqueInput[]
    disconnect?: ExternalGoalWhereUniqueInput | ExternalGoalWhereUniqueInput[]
    delete?: ExternalGoalWhereUniqueInput | ExternalGoalWhereUniqueInput[]
    connect?: ExternalGoalWhereUniqueInput | ExternalGoalWhereUniqueInput[]
    update?: ExternalGoalUpdateWithWhereUniqueWithoutUserInput | ExternalGoalUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ExternalGoalUpdateManyWithWhereWithoutUserInput | ExternalGoalUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ExternalGoalScalarWhereInput | ExternalGoalScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserInput | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserInput | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserInput | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ContentRatingUpdateManyWithoutUserNestedInput = {
    create?: XOR<ContentRatingCreateWithoutUserInput, ContentRatingUncheckedCreateWithoutUserInput> | ContentRatingCreateWithoutUserInput[] | ContentRatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContentRatingCreateOrConnectWithoutUserInput | ContentRatingCreateOrConnectWithoutUserInput[]
    upsert?: ContentRatingUpsertWithWhereUniqueWithoutUserInput | ContentRatingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ContentRatingCreateManyUserInputEnvelope
    set?: ContentRatingWhereUniqueInput | ContentRatingWhereUniqueInput[]
    disconnect?: ContentRatingWhereUniqueInput | ContentRatingWhereUniqueInput[]
    delete?: ContentRatingWhereUniqueInput | ContentRatingWhereUniqueInput[]
    connect?: ContentRatingWhereUniqueInput | ContentRatingWhereUniqueInput[]
    update?: ContentRatingUpdateWithWhereUniqueWithoutUserInput | ContentRatingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ContentRatingUpdateManyWithWhereWithoutUserInput | ContentRatingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ContentRatingScalarWhereInput | ContentRatingScalarWhereInput[]
  }

  export type ChallengeScoreUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChallengeScoreCreateWithoutUserInput, ChallengeScoreUncheckedCreateWithoutUserInput> | ChallengeScoreCreateWithoutUserInput[] | ChallengeScoreUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChallengeScoreCreateOrConnectWithoutUserInput | ChallengeScoreCreateOrConnectWithoutUserInput[]
    upsert?: ChallengeScoreUpsertWithWhereUniqueWithoutUserInput | ChallengeScoreUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChallengeScoreCreateManyUserInputEnvelope
    set?: ChallengeScoreWhereUniqueInput | ChallengeScoreWhereUniqueInput[]
    disconnect?: ChallengeScoreWhereUniqueInput | ChallengeScoreWhereUniqueInput[]
    delete?: ChallengeScoreWhereUniqueInput | ChallengeScoreWhereUniqueInput[]
    connect?: ChallengeScoreWhereUniqueInput | ChallengeScoreWhereUniqueInput[]
    update?: ChallengeScoreUpdateWithWhereUniqueWithoutUserInput | ChallengeScoreUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChallengeScoreUpdateManyWithWhereWithoutUserInput | ChallengeScoreUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChallengeScoreScalarWhereInput | ChallengeScoreScalarWhereInput[]
  }

  export type PollVoteUpdateManyWithoutUserNestedInput = {
    create?: XOR<PollVoteCreateWithoutUserInput, PollVoteUncheckedCreateWithoutUserInput> | PollVoteCreateWithoutUserInput[] | PollVoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PollVoteCreateOrConnectWithoutUserInput | PollVoteCreateOrConnectWithoutUserInput[]
    upsert?: PollVoteUpsertWithWhereUniqueWithoutUserInput | PollVoteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PollVoteCreateManyUserInputEnvelope
    set?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[]
    disconnect?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[]
    delete?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[]
    connect?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[]
    update?: PollVoteUpdateWithWhereUniqueWithoutUserInput | PollVoteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PollVoteUpdateManyWithWhereWithoutUserInput | PollVoteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PollVoteScalarWhereInput | PollVoteScalarWhereInput[]
  }

  export type AIRecommendationUpdateManyWithoutUserNestedInput = {
    create?: XOR<AIRecommendationCreateWithoutUserInput, AIRecommendationUncheckedCreateWithoutUserInput> | AIRecommendationCreateWithoutUserInput[] | AIRecommendationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AIRecommendationCreateOrConnectWithoutUserInput | AIRecommendationCreateOrConnectWithoutUserInput[]
    upsert?: AIRecommendationUpsertWithWhereUniqueWithoutUserInput | AIRecommendationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AIRecommendationCreateManyUserInputEnvelope
    set?: AIRecommendationWhereUniqueInput | AIRecommendationWhereUniqueInput[]
    disconnect?: AIRecommendationWhereUniqueInput | AIRecommendationWhereUniqueInput[]
    delete?: AIRecommendationWhereUniqueInput | AIRecommendationWhereUniqueInput[]
    connect?: AIRecommendationWhereUniqueInput | AIRecommendationWhereUniqueInput[]
    update?: AIRecommendationUpdateWithWhereUniqueWithoutUserInput | AIRecommendationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AIRecommendationUpdateManyWithWhereWithoutUserInput | AIRecommendationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AIRecommendationScalarWhereInput | AIRecommendationScalarWhereInput[]
  }

  export type AIModuleUpdateManyWithoutUserNestedInput = {
    create?: XOR<AIModuleCreateWithoutUserInput, AIModuleUncheckedCreateWithoutUserInput> | AIModuleCreateWithoutUserInput[] | AIModuleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AIModuleCreateOrConnectWithoutUserInput | AIModuleCreateOrConnectWithoutUserInput[]
    upsert?: AIModuleUpsertWithWhereUniqueWithoutUserInput | AIModuleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AIModuleCreateManyUserInputEnvelope
    set?: AIModuleWhereUniqueInput | AIModuleWhereUniqueInput[]
    disconnect?: AIModuleWhereUniqueInput | AIModuleWhereUniqueInput[]
    delete?: AIModuleWhereUniqueInput | AIModuleWhereUniqueInput[]
    connect?: AIModuleWhereUniqueInput | AIModuleWhereUniqueInput[]
    update?: AIModuleUpdateWithWhereUniqueWithoutUserInput | AIModuleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AIModuleUpdateManyWithWhereWithoutUserInput | AIModuleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AIModuleScalarWhereInput | AIModuleScalarWhereInput[]
  }

  export type AIModuleQuizAttemptUpdateManyWithoutUserNestedInput = {
    create?: XOR<AIModuleQuizAttemptCreateWithoutUserInput, AIModuleQuizAttemptUncheckedCreateWithoutUserInput> | AIModuleQuizAttemptCreateWithoutUserInput[] | AIModuleQuizAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AIModuleQuizAttemptCreateOrConnectWithoutUserInput | AIModuleQuizAttemptCreateOrConnectWithoutUserInput[]
    upsert?: AIModuleQuizAttemptUpsertWithWhereUniqueWithoutUserInput | AIModuleQuizAttemptUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AIModuleQuizAttemptCreateManyUserInputEnvelope
    set?: AIModuleQuizAttemptWhereUniqueInput | AIModuleQuizAttemptWhereUniqueInput[]
    disconnect?: AIModuleQuizAttemptWhereUniqueInput | AIModuleQuizAttemptWhereUniqueInput[]
    delete?: AIModuleQuizAttemptWhereUniqueInput | AIModuleQuizAttemptWhereUniqueInput[]
    connect?: AIModuleQuizAttemptWhereUniqueInput | AIModuleQuizAttemptWhereUniqueInput[]
    update?: AIModuleQuizAttemptUpdateWithWhereUniqueWithoutUserInput | AIModuleQuizAttemptUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AIModuleQuizAttemptUpdateManyWithWhereWithoutUserInput | AIModuleQuizAttemptUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AIModuleQuizAttemptScalarWhereInput | AIModuleQuizAttemptScalarWhereInput[]
  }

  export type AIModuleRatingUpdateManyWithoutUserNestedInput = {
    create?: XOR<AIModuleRatingCreateWithoutUserInput, AIModuleRatingUncheckedCreateWithoutUserInput> | AIModuleRatingCreateWithoutUserInput[] | AIModuleRatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AIModuleRatingCreateOrConnectWithoutUserInput | AIModuleRatingCreateOrConnectWithoutUserInput[]
    upsert?: AIModuleRatingUpsertWithWhereUniqueWithoutUserInput | AIModuleRatingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AIModuleRatingCreateManyUserInputEnvelope
    set?: AIModuleRatingWhereUniqueInput | AIModuleRatingWhereUniqueInput[]
    disconnect?: AIModuleRatingWhereUniqueInput | AIModuleRatingWhereUniqueInput[]
    delete?: AIModuleRatingWhereUniqueInput | AIModuleRatingWhereUniqueInput[]
    connect?: AIModuleRatingWhereUniqueInput | AIModuleRatingWhereUniqueInput[]
    update?: AIModuleRatingUpdateWithWhereUniqueWithoutUserInput | AIModuleRatingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AIModuleRatingUpdateManyWithWhereWithoutUserInput | AIModuleRatingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AIModuleRatingScalarWhereInput | AIModuleRatingScalarWhereInput[]
  }

  export type UserProgressUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserProgressCreateWithoutUserInput, UserProgressUncheckedCreateWithoutUserInput> | UserProgressCreateWithoutUserInput[] | UserProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserProgressCreateOrConnectWithoutUserInput | UserProgressCreateOrConnectWithoutUserInput[]
    upsert?: UserProgressUpsertWithWhereUniqueWithoutUserInput | UserProgressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserProgressCreateManyUserInputEnvelope
    set?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    disconnect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    delete?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    connect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    update?: UserProgressUpdateWithWhereUniqueWithoutUserInput | UserProgressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserProgressUpdateManyWithWhereWithoutUserInput | UserProgressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserProgressScalarWhereInput | UserProgressScalarWhereInput[]
  }

  export type AIChatUpdateManyWithoutUserNestedInput = {
    create?: XOR<AIChatCreateWithoutUserInput, AIChatUncheckedCreateWithoutUserInput> | AIChatCreateWithoutUserInput[] | AIChatUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AIChatCreateOrConnectWithoutUserInput | AIChatCreateOrConnectWithoutUserInput[]
    upsert?: AIChatUpsertWithWhereUniqueWithoutUserInput | AIChatUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AIChatCreateManyUserInputEnvelope
    set?: AIChatWhereUniqueInput | AIChatWhereUniqueInput[]
    disconnect?: AIChatWhereUniqueInput | AIChatWhereUniqueInput[]
    delete?: AIChatWhereUniqueInput | AIChatWhereUniqueInput[]
    connect?: AIChatWhereUniqueInput | AIChatWhereUniqueInput[]
    update?: AIChatUpdateWithWhereUniqueWithoutUserInput | AIChatUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AIChatUpdateManyWithWhereWithoutUserInput | AIChatUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AIChatScalarWhereInput | AIChatScalarWhereInput[]
  }

  export type PracticeAttemptUpdateManyWithoutUserNestedInput = {
    create?: XOR<PracticeAttemptCreateWithoutUserInput, PracticeAttemptUncheckedCreateWithoutUserInput> | PracticeAttemptCreateWithoutUserInput[] | PracticeAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PracticeAttemptCreateOrConnectWithoutUserInput | PracticeAttemptCreateOrConnectWithoutUserInput[]
    upsert?: PracticeAttemptUpsertWithWhereUniqueWithoutUserInput | PracticeAttemptUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PracticeAttemptCreateManyUserInputEnvelope
    set?: PracticeAttemptWhereUniqueInput | PracticeAttemptWhereUniqueInput[]
    disconnect?: PracticeAttemptWhereUniqueInput | PracticeAttemptWhereUniqueInput[]
    delete?: PracticeAttemptWhereUniqueInput | PracticeAttemptWhereUniqueInput[]
    connect?: PracticeAttemptWhereUniqueInput | PracticeAttemptWhereUniqueInput[]
    update?: PracticeAttemptUpdateWithWhereUniqueWithoutUserInput | PracticeAttemptUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PracticeAttemptUpdateManyWithWhereWithoutUserInput | PracticeAttemptUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PracticeAttemptScalarWhereInput | PracticeAttemptScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type ActivityUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput> | ActivityCreateWithoutUserInput[] | ActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutUserInput | ActivityCreateOrConnectWithoutUserInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutUserInput | ActivityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ActivityCreateManyUserInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutUserInput | ActivityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutUserInput | ActivityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type LearningPreferencesUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<LearningPreferencesCreateWithoutUserInput, LearningPreferencesUncheckedCreateWithoutUserInput>
    connectOrCreate?: LearningPreferencesCreateOrConnectWithoutUserInput
    upsert?: LearningPreferencesUpsertWithoutUserInput
    disconnect?: LearningPreferencesWhereInput | boolean
    delete?: LearningPreferencesWhereInput | boolean
    connect?: LearningPreferencesWhereUniqueInput
    update?: XOR<XOR<LearningPreferencesUpdateToOneWithWhereWithoutUserInput, LearningPreferencesUpdateWithoutUserInput>, LearningPreferencesUncheckedUpdateWithoutUserInput>
  }

  export type TopicUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TopicCreateWithoutUserInput, TopicUncheckedCreateWithoutUserInput> | TopicCreateWithoutUserInput[] | TopicUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutUserInput | TopicCreateOrConnectWithoutUserInput[]
    upsert?: TopicUpsertWithWhereUniqueWithoutUserInput | TopicUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TopicCreateManyUserInputEnvelope
    set?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    disconnect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    delete?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    update?: TopicUpdateWithWhereUniqueWithoutUserInput | TopicUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TopicUpdateManyWithWhereWithoutUserInput | TopicUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TopicScalarWhereInput | TopicScalarWhereInput[]
  }

  export type ProgressUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProgressCreateWithoutUserInput, ProgressUncheckedCreateWithoutUserInput> | ProgressCreateWithoutUserInput[] | ProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProgressCreateOrConnectWithoutUserInput | ProgressCreateOrConnectWithoutUserInput[]
    upsert?: ProgressUpsertWithWhereUniqueWithoutUserInput | ProgressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProgressCreateManyUserInputEnvelope
    set?: ProgressWhereUniqueInput | ProgressWhereUniqueInput[]
    disconnect?: ProgressWhereUniqueInput | ProgressWhereUniqueInput[]
    delete?: ProgressWhereUniqueInput | ProgressWhereUniqueInput[]
    connect?: ProgressWhereUniqueInput | ProgressWhereUniqueInput[]
    update?: ProgressUpdateWithWhereUniqueWithoutUserInput | ProgressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProgressUpdateManyWithWhereWithoutUserInput | ProgressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProgressScalarWhereInput | ProgressScalarWhereInput[]
  }

  export type BadgeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BadgeCreateWithoutUserInput, BadgeUncheckedCreateWithoutUserInput> | BadgeCreateWithoutUserInput[] | BadgeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BadgeCreateOrConnectWithoutUserInput | BadgeCreateOrConnectWithoutUserInput[]
    upsert?: BadgeUpsertWithWhereUniqueWithoutUserInput | BadgeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BadgeCreateManyUserInputEnvelope
    set?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    disconnect?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    delete?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    connect?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    update?: BadgeUpdateWithWhereUniqueWithoutUserInput | BadgeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BadgeUpdateManyWithWhereWithoutUserInput | BadgeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BadgeScalarWhereInput | BadgeScalarWhereInput[]
  }

  export type UpcomingReviewUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UpcomingReviewCreateWithoutUserInput, UpcomingReviewUncheckedCreateWithoutUserInput> | UpcomingReviewCreateWithoutUserInput[] | UpcomingReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UpcomingReviewCreateOrConnectWithoutUserInput | UpcomingReviewCreateOrConnectWithoutUserInput[]
    upsert?: UpcomingReviewUpsertWithWhereUniqueWithoutUserInput | UpcomingReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UpcomingReviewCreateManyUserInputEnvelope
    set?: UpcomingReviewWhereUniqueInput | UpcomingReviewWhereUniqueInput[]
    disconnect?: UpcomingReviewWhereUniqueInput | UpcomingReviewWhereUniqueInput[]
    delete?: UpcomingReviewWhereUniqueInput | UpcomingReviewWhereUniqueInput[]
    connect?: UpcomingReviewWhereUniqueInput | UpcomingReviewWhereUniqueInput[]
    update?: UpcomingReviewUpdateWithWhereUniqueWithoutUserInput | UpcomingReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UpcomingReviewUpdateManyWithWhereWithoutUserInput | UpcomingReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UpcomingReviewScalarWhereInput | UpcomingReviewScalarWhereInput[]
  }

  export type LearningPathUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LearningPathCreateWithoutUserInput, LearningPathUncheckedCreateWithoutUserInput> | LearningPathCreateWithoutUserInput[] | LearningPathUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LearningPathCreateOrConnectWithoutUserInput | LearningPathCreateOrConnectWithoutUserInput[]
    upsert?: LearningPathUpsertWithWhereUniqueWithoutUserInput | LearningPathUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LearningPathCreateManyUserInputEnvelope
    set?: LearningPathWhereUniqueInput | LearningPathWhereUniqueInput[]
    disconnect?: LearningPathWhereUniqueInput | LearningPathWhereUniqueInput[]
    delete?: LearningPathWhereUniqueInput | LearningPathWhereUniqueInput[]
    connect?: LearningPathWhereUniqueInput | LearningPathWhereUniqueInput[]
    update?: LearningPathUpdateWithWhereUniqueWithoutUserInput | LearningPathUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LearningPathUpdateManyWithWhereWithoutUserInput | LearningPathUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LearningPathScalarWhereInput | LearningPathScalarWhereInput[]
  }

  export type BookmarkUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BookmarkCreateWithoutUserInput, BookmarkUncheckedCreateWithoutUserInput> | BookmarkCreateWithoutUserInput[] | BookmarkUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookmarkCreateOrConnectWithoutUserInput | BookmarkCreateOrConnectWithoutUserInput[]
    upsert?: BookmarkUpsertWithWhereUniqueWithoutUserInput | BookmarkUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BookmarkCreateManyUserInputEnvelope
    set?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    disconnect?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    delete?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    connect?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    update?: BookmarkUpdateWithWhereUniqueWithoutUserInput | BookmarkUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BookmarkUpdateManyWithWhereWithoutUserInput | BookmarkUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BookmarkScalarWhereInput | BookmarkScalarWhereInput[]
  }

  export type QuizAttemptUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<QuizAttemptCreateWithoutUserInput, QuizAttemptUncheckedCreateWithoutUserInput> | QuizAttemptCreateWithoutUserInput[] | QuizAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutUserInput | QuizAttemptCreateOrConnectWithoutUserInput[]
    upsert?: QuizAttemptUpsertWithWhereUniqueWithoutUserInput | QuizAttemptUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: QuizAttemptCreateManyUserInputEnvelope
    set?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    disconnect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    delete?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    connect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    update?: QuizAttemptUpdateWithWhereUniqueWithoutUserInput | QuizAttemptUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: QuizAttemptUpdateManyWithWhereWithoutUserInput | QuizAttemptUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: QuizAttemptScalarWhereInput | QuizAttemptScalarWhereInput[]
  }

  export type KnowledgeNodeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<KnowledgeNodeCreateWithoutUserInput, KnowledgeNodeUncheckedCreateWithoutUserInput> | KnowledgeNodeCreateWithoutUserInput[] | KnowledgeNodeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: KnowledgeNodeCreateOrConnectWithoutUserInput | KnowledgeNodeCreateOrConnectWithoutUserInput[]
    upsert?: KnowledgeNodeUpsertWithWhereUniqueWithoutUserInput | KnowledgeNodeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: KnowledgeNodeCreateManyUserInputEnvelope
    set?: KnowledgeNodeWhereUniqueInput | KnowledgeNodeWhereUniqueInput[]
    disconnect?: KnowledgeNodeWhereUniqueInput | KnowledgeNodeWhereUniqueInput[]
    delete?: KnowledgeNodeWhereUniqueInput | KnowledgeNodeWhereUniqueInput[]
    connect?: KnowledgeNodeWhereUniqueInput | KnowledgeNodeWhereUniqueInput[]
    update?: KnowledgeNodeUpdateWithWhereUniqueWithoutUserInput | KnowledgeNodeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: KnowledgeNodeUpdateManyWithWhereWithoutUserInput | KnowledgeNodeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: KnowledgeNodeScalarWhereInput | KnowledgeNodeScalarWhereInput[]
  }

  export type LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LeaderboardEntryCreateWithoutUserInput, LeaderboardEntryUncheckedCreateWithoutUserInput> | LeaderboardEntryCreateWithoutUserInput[] | LeaderboardEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaderboardEntryCreateOrConnectWithoutUserInput | LeaderboardEntryCreateOrConnectWithoutUserInput[]
    upsert?: LeaderboardEntryUpsertWithWhereUniqueWithoutUserInput | LeaderboardEntryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LeaderboardEntryCreateManyUserInputEnvelope
    set?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
    disconnect?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
    delete?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
    connect?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
    update?: LeaderboardEntryUpdateWithWhereUniqueWithoutUserInput | LeaderboardEntryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LeaderboardEntryUpdateManyWithWhereWithoutUserInput | LeaderboardEntryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LeaderboardEntryScalarWhereInput | LeaderboardEntryScalarWhereInput[]
  }

  export type ReviewSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewSessionCreateWithoutUserInput, ReviewSessionUncheckedCreateWithoutUserInput> | ReviewSessionCreateWithoutUserInput[] | ReviewSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewSessionCreateOrConnectWithoutUserInput | ReviewSessionCreateOrConnectWithoutUserInput[]
    upsert?: ReviewSessionUpsertWithWhereUniqueWithoutUserInput | ReviewSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewSessionCreateManyUserInputEnvelope
    set?: ReviewSessionWhereUniqueInput | ReviewSessionWhereUniqueInput[]
    disconnect?: ReviewSessionWhereUniqueInput | ReviewSessionWhereUniqueInput[]
    delete?: ReviewSessionWhereUniqueInput | ReviewSessionWhereUniqueInput[]
    connect?: ReviewSessionWhereUniqueInput | ReviewSessionWhereUniqueInput[]
    update?: ReviewSessionUpdateWithWhereUniqueWithoutUserInput | ReviewSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewSessionUpdateManyWithWhereWithoutUserInput | ReviewSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewSessionScalarWhereInput | ReviewSessionScalarWhereInput[]
  }

  export type WorkspaceMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WorkspaceMemberCreateWithoutUserInput, WorkspaceMemberUncheckedCreateWithoutUserInput> | WorkspaceMemberCreateWithoutUserInput[] | WorkspaceMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkspaceMemberCreateOrConnectWithoutUserInput | WorkspaceMemberCreateOrConnectWithoutUserInput[]
    upsert?: WorkspaceMemberUpsertWithWhereUniqueWithoutUserInput | WorkspaceMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WorkspaceMemberCreateManyUserInputEnvelope
    set?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
    disconnect?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
    delete?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
    connect?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
    update?: WorkspaceMemberUpdateWithWhereUniqueWithoutUserInput | WorkspaceMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WorkspaceMemberUpdateManyWithWhereWithoutUserInput | WorkspaceMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WorkspaceMemberScalarWhereInput | WorkspaceMemberScalarWhereInput[]
  }

  export type ChatMessageUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChatMessageCreateWithoutUserInput, ChatMessageUncheckedCreateWithoutUserInput> | ChatMessageCreateWithoutUserInput[] | ChatMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutUserInput | ChatMessageCreateOrConnectWithoutUserInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutUserInput | ChatMessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChatMessageCreateManyUserInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutUserInput | ChatMessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutUserInput | ChatMessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type WorkspaceUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<WorkspaceCreateWithoutOwnerInput, WorkspaceUncheckedCreateWithoutOwnerInput> | WorkspaceCreateWithoutOwnerInput[] | WorkspaceUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: WorkspaceCreateOrConnectWithoutOwnerInput | WorkspaceCreateOrConnectWithoutOwnerInput[]
    upsert?: WorkspaceUpsertWithWhereUniqueWithoutOwnerInput | WorkspaceUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: WorkspaceCreateManyOwnerInputEnvelope
    set?: WorkspaceWhereUniqueInput | WorkspaceWhereUniqueInput[]
    disconnect?: WorkspaceWhereUniqueInput | WorkspaceWhereUniqueInput[]
    delete?: WorkspaceWhereUniqueInput | WorkspaceWhereUniqueInput[]
    connect?: WorkspaceWhereUniqueInput | WorkspaceWhereUniqueInput[]
    update?: WorkspaceUpdateWithWhereUniqueWithoutOwnerInput | WorkspaceUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: WorkspaceUpdateManyWithWhereWithoutOwnerInput | WorkspaceUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: WorkspaceScalarWhereInput | WorkspaceScalarWhereInput[]
  }

  export type UserSettingsUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    upsert?: UserSettingsUpsertWithoutUserInput
    disconnect?: UserSettingsWhereInput | boolean
    delete?: UserSettingsWhereInput | boolean
    connect?: UserSettingsWhereUniqueInput
    update?: XOR<XOR<UserSettingsUpdateToOneWithWhereWithoutUserInput, UserSettingsUpdateWithoutUserInput>, UserSettingsUncheckedUpdateWithoutUserInput>
  }

  export type AnalyticsEntryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AnalyticsEntryCreateWithoutUserInput, AnalyticsEntryUncheckedCreateWithoutUserInput> | AnalyticsEntryCreateWithoutUserInput[] | AnalyticsEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AnalyticsEntryCreateOrConnectWithoutUserInput | AnalyticsEntryCreateOrConnectWithoutUserInput[]
    upsert?: AnalyticsEntryUpsertWithWhereUniqueWithoutUserInput | AnalyticsEntryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AnalyticsEntryCreateManyUserInputEnvelope
    set?: AnalyticsEntryWhereUniqueInput | AnalyticsEntryWhereUniqueInput[]
    disconnect?: AnalyticsEntryWhereUniqueInput | AnalyticsEntryWhereUniqueInput[]
    delete?: AnalyticsEntryWhereUniqueInput | AnalyticsEntryWhereUniqueInput[]
    connect?: AnalyticsEntryWhereUniqueInput | AnalyticsEntryWhereUniqueInput[]
    update?: AnalyticsEntryUpdateWithWhereUniqueWithoutUserInput | AnalyticsEntryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AnalyticsEntryUpdateManyWithWhereWithoutUserInput | AnalyticsEntryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AnalyticsEntryScalarWhereInput | AnalyticsEntryScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type PasswordlessTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasswordlessTokenCreateWithoutUserInput, PasswordlessTokenUncheckedCreateWithoutUserInput> | PasswordlessTokenCreateWithoutUserInput[] | PasswordlessTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordlessTokenCreateOrConnectWithoutUserInput | PasswordlessTokenCreateOrConnectWithoutUserInput[]
    upsert?: PasswordlessTokenUpsertWithWhereUniqueWithoutUserInput | PasswordlessTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasswordlessTokenCreateManyUserInputEnvelope
    set?: PasswordlessTokenWhereUniqueInput | PasswordlessTokenWhereUniqueInput[]
    disconnect?: PasswordlessTokenWhereUniqueInput | PasswordlessTokenWhereUniqueInput[]
    delete?: PasswordlessTokenWhereUniqueInput | PasswordlessTokenWhereUniqueInput[]
    connect?: PasswordlessTokenWhereUniqueInput | PasswordlessTokenWhereUniqueInput[]
    update?: PasswordlessTokenUpdateWithWhereUniqueWithoutUserInput | PasswordlessTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasswordlessTokenUpdateManyWithWhereWithoutUserInput | PasswordlessTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasswordlessTokenScalarWhereInput | PasswordlessTokenScalarWhereInput[]
  }

  export type DailyChallengeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DailyChallengeCreateWithoutUserInput, DailyChallengeUncheckedCreateWithoutUserInput> | DailyChallengeCreateWithoutUserInput[] | DailyChallengeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DailyChallengeCreateOrConnectWithoutUserInput | DailyChallengeCreateOrConnectWithoutUserInput[]
    upsert?: DailyChallengeUpsertWithWhereUniqueWithoutUserInput | DailyChallengeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DailyChallengeCreateManyUserInputEnvelope
    set?: DailyChallengeWhereUniqueInput | DailyChallengeWhereUniqueInput[]
    disconnect?: DailyChallengeWhereUniqueInput | DailyChallengeWhereUniqueInput[]
    delete?: DailyChallengeWhereUniqueInput | DailyChallengeWhereUniqueInput[]
    connect?: DailyChallengeWhereUniqueInput | DailyChallengeWhereUniqueInput[]
    update?: DailyChallengeUpdateWithWhereUniqueWithoutUserInput | DailyChallengeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DailyChallengeUpdateManyWithWhereWithoutUserInput | DailyChallengeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DailyChallengeScalarWhereInput | DailyChallengeScalarWhereInput[]
  }

  export type ExternalGoalUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ExternalGoalCreateWithoutUserInput, ExternalGoalUncheckedCreateWithoutUserInput> | ExternalGoalCreateWithoutUserInput[] | ExternalGoalUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExternalGoalCreateOrConnectWithoutUserInput | ExternalGoalCreateOrConnectWithoutUserInput[]
    upsert?: ExternalGoalUpsertWithWhereUniqueWithoutUserInput | ExternalGoalUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ExternalGoalCreateManyUserInputEnvelope
    set?: ExternalGoalWhereUniqueInput | ExternalGoalWhereUniqueInput[]
    disconnect?: ExternalGoalWhereUniqueInput | ExternalGoalWhereUniqueInput[]
    delete?: ExternalGoalWhereUniqueInput | ExternalGoalWhereUniqueInput[]
    connect?: ExternalGoalWhereUniqueInput | ExternalGoalWhereUniqueInput[]
    update?: ExternalGoalUpdateWithWhereUniqueWithoutUserInput | ExternalGoalUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ExternalGoalUpdateManyWithWhereWithoutUserInput | ExternalGoalUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ExternalGoalScalarWhereInput | ExternalGoalScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserInput | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserInput | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserInput | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ContentRatingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ContentRatingCreateWithoutUserInput, ContentRatingUncheckedCreateWithoutUserInput> | ContentRatingCreateWithoutUserInput[] | ContentRatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContentRatingCreateOrConnectWithoutUserInput | ContentRatingCreateOrConnectWithoutUserInput[]
    upsert?: ContentRatingUpsertWithWhereUniqueWithoutUserInput | ContentRatingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ContentRatingCreateManyUserInputEnvelope
    set?: ContentRatingWhereUniqueInput | ContentRatingWhereUniqueInput[]
    disconnect?: ContentRatingWhereUniqueInput | ContentRatingWhereUniqueInput[]
    delete?: ContentRatingWhereUniqueInput | ContentRatingWhereUniqueInput[]
    connect?: ContentRatingWhereUniqueInput | ContentRatingWhereUniqueInput[]
    update?: ContentRatingUpdateWithWhereUniqueWithoutUserInput | ContentRatingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ContentRatingUpdateManyWithWhereWithoutUserInput | ContentRatingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ContentRatingScalarWhereInput | ContentRatingScalarWhereInput[]
  }

  export type ChallengeScoreUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChallengeScoreCreateWithoutUserInput, ChallengeScoreUncheckedCreateWithoutUserInput> | ChallengeScoreCreateWithoutUserInput[] | ChallengeScoreUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChallengeScoreCreateOrConnectWithoutUserInput | ChallengeScoreCreateOrConnectWithoutUserInput[]
    upsert?: ChallengeScoreUpsertWithWhereUniqueWithoutUserInput | ChallengeScoreUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChallengeScoreCreateManyUserInputEnvelope
    set?: ChallengeScoreWhereUniqueInput | ChallengeScoreWhereUniqueInput[]
    disconnect?: ChallengeScoreWhereUniqueInput | ChallengeScoreWhereUniqueInput[]
    delete?: ChallengeScoreWhereUniqueInput | ChallengeScoreWhereUniqueInput[]
    connect?: ChallengeScoreWhereUniqueInput | ChallengeScoreWhereUniqueInput[]
    update?: ChallengeScoreUpdateWithWhereUniqueWithoutUserInput | ChallengeScoreUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChallengeScoreUpdateManyWithWhereWithoutUserInput | ChallengeScoreUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChallengeScoreScalarWhereInput | ChallengeScoreScalarWhereInput[]
  }

  export type PollVoteUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PollVoteCreateWithoutUserInput, PollVoteUncheckedCreateWithoutUserInput> | PollVoteCreateWithoutUserInput[] | PollVoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PollVoteCreateOrConnectWithoutUserInput | PollVoteCreateOrConnectWithoutUserInput[]
    upsert?: PollVoteUpsertWithWhereUniqueWithoutUserInput | PollVoteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PollVoteCreateManyUserInputEnvelope
    set?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[]
    disconnect?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[]
    delete?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[]
    connect?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[]
    update?: PollVoteUpdateWithWhereUniqueWithoutUserInput | PollVoteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PollVoteUpdateManyWithWhereWithoutUserInput | PollVoteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PollVoteScalarWhereInput | PollVoteScalarWhereInput[]
  }

  export type AIRecommendationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AIRecommendationCreateWithoutUserInput, AIRecommendationUncheckedCreateWithoutUserInput> | AIRecommendationCreateWithoutUserInput[] | AIRecommendationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AIRecommendationCreateOrConnectWithoutUserInput | AIRecommendationCreateOrConnectWithoutUserInput[]
    upsert?: AIRecommendationUpsertWithWhereUniqueWithoutUserInput | AIRecommendationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AIRecommendationCreateManyUserInputEnvelope
    set?: AIRecommendationWhereUniqueInput | AIRecommendationWhereUniqueInput[]
    disconnect?: AIRecommendationWhereUniqueInput | AIRecommendationWhereUniqueInput[]
    delete?: AIRecommendationWhereUniqueInput | AIRecommendationWhereUniqueInput[]
    connect?: AIRecommendationWhereUniqueInput | AIRecommendationWhereUniqueInput[]
    update?: AIRecommendationUpdateWithWhereUniqueWithoutUserInput | AIRecommendationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AIRecommendationUpdateManyWithWhereWithoutUserInput | AIRecommendationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AIRecommendationScalarWhereInput | AIRecommendationScalarWhereInput[]
  }

  export type AIModuleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AIModuleCreateWithoutUserInput, AIModuleUncheckedCreateWithoutUserInput> | AIModuleCreateWithoutUserInput[] | AIModuleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AIModuleCreateOrConnectWithoutUserInput | AIModuleCreateOrConnectWithoutUserInput[]
    upsert?: AIModuleUpsertWithWhereUniqueWithoutUserInput | AIModuleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AIModuleCreateManyUserInputEnvelope
    set?: AIModuleWhereUniqueInput | AIModuleWhereUniqueInput[]
    disconnect?: AIModuleWhereUniqueInput | AIModuleWhereUniqueInput[]
    delete?: AIModuleWhereUniqueInput | AIModuleWhereUniqueInput[]
    connect?: AIModuleWhereUniqueInput | AIModuleWhereUniqueInput[]
    update?: AIModuleUpdateWithWhereUniqueWithoutUserInput | AIModuleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AIModuleUpdateManyWithWhereWithoutUserInput | AIModuleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AIModuleScalarWhereInput | AIModuleScalarWhereInput[]
  }

  export type AIModuleQuizAttemptUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AIModuleQuizAttemptCreateWithoutUserInput, AIModuleQuizAttemptUncheckedCreateWithoutUserInput> | AIModuleQuizAttemptCreateWithoutUserInput[] | AIModuleQuizAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AIModuleQuizAttemptCreateOrConnectWithoutUserInput | AIModuleQuizAttemptCreateOrConnectWithoutUserInput[]
    upsert?: AIModuleQuizAttemptUpsertWithWhereUniqueWithoutUserInput | AIModuleQuizAttemptUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AIModuleQuizAttemptCreateManyUserInputEnvelope
    set?: AIModuleQuizAttemptWhereUniqueInput | AIModuleQuizAttemptWhereUniqueInput[]
    disconnect?: AIModuleQuizAttemptWhereUniqueInput | AIModuleQuizAttemptWhereUniqueInput[]
    delete?: AIModuleQuizAttemptWhereUniqueInput | AIModuleQuizAttemptWhereUniqueInput[]
    connect?: AIModuleQuizAttemptWhereUniqueInput | AIModuleQuizAttemptWhereUniqueInput[]
    update?: AIModuleQuizAttemptUpdateWithWhereUniqueWithoutUserInput | AIModuleQuizAttemptUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AIModuleQuizAttemptUpdateManyWithWhereWithoutUserInput | AIModuleQuizAttemptUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AIModuleQuizAttemptScalarWhereInput | AIModuleQuizAttemptScalarWhereInput[]
  }

  export type AIModuleRatingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AIModuleRatingCreateWithoutUserInput, AIModuleRatingUncheckedCreateWithoutUserInput> | AIModuleRatingCreateWithoutUserInput[] | AIModuleRatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AIModuleRatingCreateOrConnectWithoutUserInput | AIModuleRatingCreateOrConnectWithoutUserInput[]
    upsert?: AIModuleRatingUpsertWithWhereUniqueWithoutUserInput | AIModuleRatingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AIModuleRatingCreateManyUserInputEnvelope
    set?: AIModuleRatingWhereUniqueInput | AIModuleRatingWhereUniqueInput[]
    disconnect?: AIModuleRatingWhereUniqueInput | AIModuleRatingWhereUniqueInput[]
    delete?: AIModuleRatingWhereUniqueInput | AIModuleRatingWhereUniqueInput[]
    connect?: AIModuleRatingWhereUniqueInput | AIModuleRatingWhereUniqueInput[]
    update?: AIModuleRatingUpdateWithWhereUniqueWithoutUserInput | AIModuleRatingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AIModuleRatingUpdateManyWithWhereWithoutUserInput | AIModuleRatingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AIModuleRatingScalarWhereInput | AIModuleRatingScalarWhereInput[]
  }

  export type UserProgressUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserProgressCreateWithoutUserInput, UserProgressUncheckedCreateWithoutUserInput> | UserProgressCreateWithoutUserInput[] | UserProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserProgressCreateOrConnectWithoutUserInput | UserProgressCreateOrConnectWithoutUserInput[]
    upsert?: UserProgressUpsertWithWhereUniqueWithoutUserInput | UserProgressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserProgressCreateManyUserInputEnvelope
    set?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    disconnect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    delete?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    connect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    update?: UserProgressUpdateWithWhereUniqueWithoutUserInput | UserProgressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserProgressUpdateManyWithWhereWithoutUserInput | UserProgressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserProgressScalarWhereInput | UserProgressScalarWhereInput[]
  }

  export type AIChatUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AIChatCreateWithoutUserInput, AIChatUncheckedCreateWithoutUserInput> | AIChatCreateWithoutUserInput[] | AIChatUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AIChatCreateOrConnectWithoutUserInput | AIChatCreateOrConnectWithoutUserInput[]
    upsert?: AIChatUpsertWithWhereUniqueWithoutUserInput | AIChatUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AIChatCreateManyUserInputEnvelope
    set?: AIChatWhereUniqueInput | AIChatWhereUniqueInput[]
    disconnect?: AIChatWhereUniqueInput | AIChatWhereUniqueInput[]
    delete?: AIChatWhereUniqueInput | AIChatWhereUniqueInput[]
    connect?: AIChatWhereUniqueInput | AIChatWhereUniqueInput[]
    update?: AIChatUpdateWithWhereUniqueWithoutUserInput | AIChatUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AIChatUpdateManyWithWhereWithoutUserInput | AIChatUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AIChatScalarWhereInput | AIChatScalarWhereInput[]
  }

  export type PracticeAttemptUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PracticeAttemptCreateWithoutUserInput, PracticeAttemptUncheckedCreateWithoutUserInput> | PracticeAttemptCreateWithoutUserInput[] | PracticeAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PracticeAttemptCreateOrConnectWithoutUserInput | PracticeAttemptCreateOrConnectWithoutUserInput[]
    upsert?: PracticeAttemptUpsertWithWhereUniqueWithoutUserInput | PracticeAttemptUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PracticeAttemptCreateManyUserInputEnvelope
    set?: PracticeAttemptWhereUniqueInput | PracticeAttemptWhereUniqueInput[]
    disconnect?: PracticeAttemptWhereUniqueInput | PracticeAttemptWhereUniqueInput[]
    delete?: PracticeAttemptWhereUniqueInput | PracticeAttemptWhereUniqueInput[]
    connect?: PracticeAttemptWhereUniqueInput | PracticeAttemptWhereUniqueInput[]
    update?: PracticeAttemptUpdateWithWhereUniqueWithoutUserInput | PracticeAttemptUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PracticeAttemptUpdateManyWithWhereWithoutUserInput | PracticeAttemptUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PracticeAttemptScalarWhereInput | PracticeAttemptScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivitiesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutActivitiesNestedInput = {
    create?: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivitiesInput
    upsert?: UserUpsertWithoutActivitiesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutActivitiesInput, UserUpdateWithoutActivitiesInput>, UserUncheckedUpdateWithoutActivitiesInput>
  }

  export type UserCreateNestedOneWithoutLearningPreferencesInput = {
    create?: XOR<UserCreateWithoutLearningPreferencesInput, UserUncheckedCreateWithoutLearningPreferencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLearningPreferencesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLearningPreferencesNestedInput = {
    create?: XOR<UserCreateWithoutLearningPreferencesInput, UserUncheckedCreateWithoutLearningPreferencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLearningPreferencesInput
    upsert?: UserUpsertWithoutLearningPreferencesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLearningPreferencesInput, UserUpdateWithoutLearningPreferencesInput>, UserUncheckedUpdateWithoutLearningPreferencesInput>
  }

  export type UserCreateNestedOneWithoutTopicsInput = {
    create?: XOR<UserCreateWithoutTopicsInput, UserUncheckedCreateWithoutTopicsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTopicsInput
    connect?: UserWhereUniqueInput
  }

  export type ProgressCreateNestedManyWithoutTopicInput = {
    create?: XOR<ProgressCreateWithoutTopicInput, ProgressUncheckedCreateWithoutTopicInput> | ProgressCreateWithoutTopicInput[] | ProgressUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: ProgressCreateOrConnectWithoutTopicInput | ProgressCreateOrConnectWithoutTopicInput[]
    createMany?: ProgressCreateManyTopicInputEnvelope
    connect?: ProgressWhereUniqueInput | ProgressWhereUniqueInput[]
  }

  export type LearningPathItemCreateNestedManyWithoutTopicInput = {
    create?: XOR<LearningPathItemCreateWithoutTopicInput, LearningPathItemUncheckedCreateWithoutTopicInput> | LearningPathItemCreateWithoutTopicInput[] | LearningPathItemUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: LearningPathItemCreateOrConnectWithoutTopicInput | LearningPathItemCreateOrConnectWithoutTopicInput[]
    createMany?: LearningPathItemCreateManyTopicInputEnvelope
    connect?: LearningPathItemWhereUniqueInput | LearningPathItemWhereUniqueInput[]
  }

  export type ContentItemCreateNestedManyWithoutTopicInput = {
    create?: XOR<ContentItemCreateWithoutTopicInput, ContentItemUncheckedCreateWithoutTopicInput> | ContentItemCreateWithoutTopicInput[] | ContentItemUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: ContentItemCreateOrConnectWithoutTopicInput | ContentItemCreateOrConnectWithoutTopicInput[]
    createMany?: ContentItemCreateManyTopicInputEnvelope
    connect?: ContentItemWhereUniqueInput | ContentItemWhereUniqueInput[]
  }

  export type AnalyticsEntryCreateNestedManyWithoutTopicInput = {
    create?: XOR<AnalyticsEntryCreateWithoutTopicInput, AnalyticsEntryUncheckedCreateWithoutTopicInput> | AnalyticsEntryCreateWithoutTopicInput[] | AnalyticsEntryUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: AnalyticsEntryCreateOrConnectWithoutTopicInput | AnalyticsEntryCreateOrConnectWithoutTopicInput[]
    createMany?: AnalyticsEntryCreateManyTopicInputEnvelope
    connect?: AnalyticsEntryWhereUniqueInput | AnalyticsEntryWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutTopicInput = {
    create?: XOR<CommentCreateWithoutTopicInput, CommentUncheckedCreateWithoutTopicInput> | CommentCreateWithoutTopicInput[] | CommentUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutTopicInput | CommentCreateOrConnectWithoutTopicInput[]
    createMany?: CommentCreateManyTopicInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type PrerequisiteCreateNestedManyWithoutTopicInput = {
    create?: XOR<PrerequisiteCreateWithoutTopicInput, PrerequisiteUncheckedCreateWithoutTopicInput> | PrerequisiteCreateWithoutTopicInput[] | PrerequisiteUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: PrerequisiteCreateOrConnectWithoutTopicInput | PrerequisiteCreateOrConnectWithoutTopicInput[]
    createMany?: PrerequisiteCreateManyTopicInputEnvelope
    connect?: PrerequisiteWhereUniqueInput | PrerequisiteWhereUniqueInput[]
  }

  export type AIModuleCreateNestedManyWithoutTopicInput = {
    create?: XOR<AIModuleCreateWithoutTopicInput, AIModuleUncheckedCreateWithoutTopicInput> | AIModuleCreateWithoutTopicInput[] | AIModuleUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: AIModuleCreateOrConnectWithoutTopicInput | AIModuleCreateOrConnectWithoutTopicInput[]
    createMany?: AIModuleCreateManyTopicInputEnvelope
    connect?: AIModuleWhereUniqueInput | AIModuleWhereUniqueInput[]
  }

  export type AIModuleQuizAttemptCreateNestedManyWithoutTopicInput = {
    create?: XOR<AIModuleQuizAttemptCreateWithoutTopicInput, AIModuleQuizAttemptUncheckedCreateWithoutTopicInput> | AIModuleQuizAttemptCreateWithoutTopicInput[] | AIModuleQuizAttemptUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: AIModuleQuizAttemptCreateOrConnectWithoutTopicInput | AIModuleQuizAttemptCreateOrConnectWithoutTopicInput[]
    createMany?: AIModuleQuizAttemptCreateManyTopicInputEnvelope
    connect?: AIModuleQuizAttemptWhereUniqueInput | AIModuleQuizAttemptWhereUniqueInput[]
  }

  export type AIModuleRatingCreateNestedManyWithoutTopicInput = {
    create?: XOR<AIModuleRatingCreateWithoutTopicInput, AIModuleRatingUncheckedCreateWithoutTopicInput> | AIModuleRatingCreateWithoutTopicInput[] | AIModuleRatingUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: AIModuleRatingCreateOrConnectWithoutTopicInput | AIModuleRatingCreateOrConnectWithoutTopicInput[]
    createMany?: AIModuleRatingCreateManyTopicInputEnvelope
    connect?: AIModuleRatingWhereUniqueInput | AIModuleRatingWhereUniqueInput[]
  }

  export type ProgressUncheckedCreateNestedManyWithoutTopicInput = {
    create?: XOR<ProgressCreateWithoutTopicInput, ProgressUncheckedCreateWithoutTopicInput> | ProgressCreateWithoutTopicInput[] | ProgressUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: ProgressCreateOrConnectWithoutTopicInput | ProgressCreateOrConnectWithoutTopicInput[]
    createMany?: ProgressCreateManyTopicInputEnvelope
    connect?: ProgressWhereUniqueInput | ProgressWhereUniqueInput[]
  }

  export type LearningPathItemUncheckedCreateNestedManyWithoutTopicInput = {
    create?: XOR<LearningPathItemCreateWithoutTopicInput, LearningPathItemUncheckedCreateWithoutTopicInput> | LearningPathItemCreateWithoutTopicInput[] | LearningPathItemUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: LearningPathItemCreateOrConnectWithoutTopicInput | LearningPathItemCreateOrConnectWithoutTopicInput[]
    createMany?: LearningPathItemCreateManyTopicInputEnvelope
    connect?: LearningPathItemWhereUniqueInput | LearningPathItemWhereUniqueInput[]
  }

  export type ContentItemUncheckedCreateNestedManyWithoutTopicInput = {
    create?: XOR<ContentItemCreateWithoutTopicInput, ContentItemUncheckedCreateWithoutTopicInput> | ContentItemCreateWithoutTopicInput[] | ContentItemUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: ContentItemCreateOrConnectWithoutTopicInput | ContentItemCreateOrConnectWithoutTopicInput[]
    createMany?: ContentItemCreateManyTopicInputEnvelope
    connect?: ContentItemWhereUniqueInput | ContentItemWhereUniqueInput[]
  }

  export type AnalyticsEntryUncheckedCreateNestedManyWithoutTopicInput = {
    create?: XOR<AnalyticsEntryCreateWithoutTopicInput, AnalyticsEntryUncheckedCreateWithoutTopicInput> | AnalyticsEntryCreateWithoutTopicInput[] | AnalyticsEntryUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: AnalyticsEntryCreateOrConnectWithoutTopicInput | AnalyticsEntryCreateOrConnectWithoutTopicInput[]
    createMany?: AnalyticsEntryCreateManyTopicInputEnvelope
    connect?: AnalyticsEntryWhereUniqueInput | AnalyticsEntryWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutTopicInput = {
    create?: XOR<CommentCreateWithoutTopicInput, CommentUncheckedCreateWithoutTopicInput> | CommentCreateWithoutTopicInput[] | CommentUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutTopicInput | CommentCreateOrConnectWithoutTopicInput[]
    createMany?: CommentCreateManyTopicInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type PrerequisiteUncheckedCreateNestedManyWithoutTopicInput = {
    create?: XOR<PrerequisiteCreateWithoutTopicInput, PrerequisiteUncheckedCreateWithoutTopicInput> | PrerequisiteCreateWithoutTopicInput[] | PrerequisiteUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: PrerequisiteCreateOrConnectWithoutTopicInput | PrerequisiteCreateOrConnectWithoutTopicInput[]
    createMany?: PrerequisiteCreateManyTopicInputEnvelope
    connect?: PrerequisiteWhereUniqueInput | PrerequisiteWhereUniqueInput[]
  }

  export type AIModuleUncheckedCreateNestedManyWithoutTopicInput = {
    create?: XOR<AIModuleCreateWithoutTopicInput, AIModuleUncheckedCreateWithoutTopicInput> | AIModuleCreateWithoutTopicInput[] | AIModuleUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: AIModuleCreateOrConnectWithoutTopicInput | AIModuleCreateOrConnectWithoutTopicInput[]
    createMany?: AIModuleCreateManyTopicInputEnvelope
    connect?: AIModuleWhereUniqueInput | AIModuleWhereUniqueInput[]
  }

  export type AIModuleQuizAttemptUncheckedCreateNestedManyWithoutTopicInput = {
    create?: XOR<AIModuleQuizAttemptCreateWithoutTopicInput, AIModuleQuizAttemptUncheckedCreateWithoutTopicInput> | AIModuleQuizAttemptCreateWithoutTopicInput[] | AIModuleQuizAttemptUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: AIModuleQuizAttemptCreateOrConnectWithoutTopicInput | AIModuleQuizAttemptCreateOrConnectWithoutTopicInput[]
    createMany?: AIModuleQuizAttemptCreateManyTopicInputEnvelope
    connect?: AIModuleQuizAttemptWhereUniqueInput | AIModuleQuizAttemptWhereUniqueInput[]
  }

  export type AIModuleRatingUncheckedCreateNestedManyWithoutTopicInput = {
    create?: XOR<AIModuleRatingCreateWithoutTopicInput, AIModuleRatingUncheckedCreateWithoutTopicInput> | AIModuleRatingCreateWithoutTopicInput[] | AIModuleRatingUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: AIModuleRatingCreateOrConnectWithoutTopicInput | AIModuleRatingCreateOrConnectWithoutTopicInput[]
    createMany?: AIModuleRatingCreateManyTopicInputEnvelope
    connect?: AIModuleRatingWhereUniqueInput | AIModuleRatingWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutTopicsNestedInput = {
    create?: XOR<UserCreateWithoutTopicsInput, UserUncheckedCreateWithoutTopicsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTopicsInput
    upsert?: UserUpsertWithoutTopicsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTopicsInput, UserUpdateWithoutTopicsInput>, UserUncheckedUpdateWithoutTopicsInput>
  }

  export type ProgressUpdateManyWithoutTopicNestedInput = {
    create?: XOR<ProgressCreateWithoutTopicInput, ProgressUncheckedCreateWithoutTopicInput> | ProgressCreateWithoutTopicInput[] | ProgressUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: ProgressCreateOrConnectWithoutTopicInput | ProgressCreateOrConnectWithoutTopicInput[]
    upsert?: ProgressUpsertWithWhereUniqueWithoutTopicInput | ProgressUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: ProgressCreateManyTopicInputEnvelope
    set?: ProgressWhereUniqueInput | ProgressWhereUniqueInput[]
    disconnect?: ProgressWhereUniqueInput | ProgressWhereUniqueInput[]
    delete?: ProgressWhereUniqueInput | ProgressWhereUniqueInput[]
    connect?: ProgressWhereUniqueInput | ProgressWhereUniqueInput[]
    update?: ProgressUpdateWithWhereUniqueWithoutTopicInput | ProgressUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: ProgressUpdateManyWithWhereWithoutTopicInput | ProgressUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: ProgressScalarWhereInput | ProgressScalarWhereInput[]
  }

  export type LearningPathItemUpdateManyWithoutTopicNestedInput = {
    create?: XOR<LearningPathItemCreateWithoutTopicInput, LearningPathItemUncheckedCreateWithoutTopicInput> | LearningPathItemCreateWithoutTopicInput[] | LearningPathItemUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: LearningPathItemCreateOrConnectWithoutTopicInput | LearningPathItemCreateOrConnectWithoutTopicInput[]
    upsert?: LearningPathItemUpsertWithWhereUniqueWithoutTopicInput | LearningPathItemUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: LearningPathItemCreateManyTopicInputEnvelope
    set?: LearningPathItemWhereUniqueInput | LearningPathItemWhereUniqueInput[]
    disconnect?: LearningPathItemWhereUniqueInput | LearningPathItemWhereUniqueInput[]
    delete?: LearningPathItemWhereUniqueInput | LearningPathItemWhereUniqueInput[]
    connect?: LearningPathItemWhereUniqueInput | LearningPathItemWhereUniqueInput[]
    update?: LearningPathItemUpdateWithWhereUniqueWithoutTopicInput | LearningPathItemUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: LearningPathItemUpdateManyWithWhereWithoutTopicInput | LearningPathItemUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: LearningPathItemScalarWhereInput | LearningPathItemScalarWhereInput[]
  }

  export type ContentItemUpdateManyWithoutTopicNestedInput = {
    create?: XOR<ContentItemCreateWithoutTopicInput, ContentItemUncheckedCreateWithoutTopicInput> | ContentItemCreateWithoutTopicInput[] | ContentItemUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: ContentItemCreateOrConnectWithoutTopicInput | ContentItemCreateOrConnectWithoutTopicInput[]
    upsert?: ContentItemUpsertWithWhereUniqueWithoutTopicInput | ContentItemUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: ContentItemCreateManyTopicInputEnvelope
    set?: ContentItemWhereUniqueInput | ContentItemWhereUniqueInput[]
    disconnect?: ContentItemWhereUniqueInput | ContentItemWhereUniqueInput[]
    delete?: ContentItemWhereUniqueInput | ContentItemWhereUniqueInput[]
    connect?: ContentItemWhereUniqueInput | ContentItemWhereUniqueInput[]
    update?: ContentItemUpdateWithWhereUniqueWithoutTopicInput | ContentItemUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: ContentItemUpdateManyWithWhereWithoutTopicInput | ContentItemUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: ContentItemScalarWhereInput | ContentItemScalarWhereInput[]
  }

  export type AnalyticsEntryUpdateManyWithoutTopicNestedInput = {
    create?: XOR<AnalyticsEntryCreateWithoutTopicInput, AnalyticsEntryUncheckedCreateWithoutTopicInput> | AnalyticsEntryCreateWithoutTopicInput[] | AnalyticsEntryUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: AnalyticsEntryCreateOrConnectWithoutTopicInput | AnalyticsEntryCreateOrConnectWithoutTopicInput[]
    upsert?: AnalyticsEntryUpsertWithWhereUniqueWithoutTopicInput | AnalyticsEntryUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: AnalyticsEntryCreateManyTopicInputEnvelope
    set?: AnalyticsEntryWhereUniqueInput | AnalyticsEntryWhereUniqueInput[]
    disconnect?: AnalyticsEntryWhereUniqueInput | AnalyticsEntryWhereUniqueInput[]
    delete?: AnalyticsEntryWhereUniqueInput | AnalyticsEntryWhereUniqueInput[]
    connect?: AnalyticsEntryWhereUniqueInput | AnalyticsEntryWhereUniqueInput[]
    update?: AnalyticsEntryUpdateWithWhereUniqueWithoutTopicInput | AnalyticsEntryUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: AnalyticsEntryUpdateManyWithWhereWithoutTopicInput | AnalyticsEntryUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: AnalyticsEntryScalarWhereInput | AnalyticsEntryScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutTopicNestedInput = {
    create?: XOR<CommentCreateWithoutTopicInput, CommentUncheckedCreateWithoutTopicInput> | CommentCreateWithoutTopicInput[] | CommentUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutTopicInput | CommentCreateOrConnectWithoutTopicInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutTopicInput | CommentUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: CommentCreateManyTopicInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutTopicInput | CommentUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutTopicInput | CommentUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type PrerequisiteUpdateManyWithoutTopicNestedInput = {
    create?: XOR<PrerequisiteCreateWithoutTopicInput, PrerequisiteUncheckedCreateWithoutTopicInput> | PrerequisiteCreateWithoutTopicInput[] | PrerequisiteUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: PrerequisiteCreateOrConnectWithoutTopicInput | PrerequisiteCreateOrConnectWithoutTopicInput[]
    upsert?: PrerequisiteUpsertWithWhereUniqueWithoutTopicInput | PrerequisiteUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: PrerequisiteCreateManyTopicInputEnvelope
    set?: PrerequisiteWhereUniqueInput | PrerequisiteWhereUniqueInput[]
    disconnect?: PrerequisiteWhereUniqueInput | PrerequisiteWhereUniqueInput[]
    delete?: PrerequisiteWhereUniqueInput | PrerequisiteWhereUniqueInput[]
    connect?: PrerequisiteWhereUniqueInput | PrerequisiteWhereUniqueInput[]
    update?: PrerequisiteUpdateWithWhereUniqueWithoutTopicInput | PrerequisiteUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: PrerequisiteUpdateManyWithWhereWithoutTopicInput | PrerequisiteUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: PrerequisiteScalarWhereInput | PrerequisiteScalarWhereInput[]
  }

  export type AIModuleUpdateManyWithoutTopicNestedInput = {
    create?: XOR<AIModuleCreateWithoutTopicInput, AIModuleUncheckedCreateWithoutTopicInput> | AIModuleCreateWithoutTopicInput[] | AIModuleUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: AIModuleCreateOrConnectWithoutTopicInput | AIModuleCreateOrConnectWithoutTopicInput[]
    upsert?: AIModuleUpsertWithWhereUniqueWithoutTopicInput | AIModuleUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: AIModuleCreateManyTopicInputEnvelope
    set?: AIModuleWhereUniqueInput | AIModuleWhereUniqueInput[]
    disconnect?: AIModuleWhereUniqueInput | AIModuleWhereUniqueInput[]
    delete?: AIModuleWhereUniqueInput | AIModuleWhereUniqueInput[]
    connect?: AIModuleWhereUniqueInput | AIModuleWhereUniqueInput[]
    update?: AIModuleUpdateWithWhereUniqueWithoutTopicInput | AIModuleUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: AIModuleUpdateManyWithWhereWithoutTopicInput | AIModuleUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: AIModuleScalarWhereInput | AIModuleScalarWhereInput[]
  }

  export type AIModuleQuizAttemptUpdateManyWithoutTopicNestedInput = {
    create?: XOR<AIModuleQuizAttemptCreateWithoutTopicInput, AIModuleQuizAttemptUncheckedCreateWithoutTopicInput> | AIModuleQuizAttemptCreateWithoutTopicInput[] | AIModuleQuizAttemptUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: AIModuleQuizAttemptCreateOrConnectWithoutTopicInput | AIModuleQuizAttemptCreateOrConnectWithoutTopicInput[]
    upsert?: AIModuleQuizAttemptUpsertWithWhereUniqueWithoutTopicInput | AIModuleQuizAttemptUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: AIModuleQuizAttemptCreateManyTopicInputEnvelope
    set?: AIModuleQuizAttemptWhereUniqueInput | AIModuleQuizAttemptWhereUniqueInput[]
    disconnect?: AIModuleQuizAttemptWhereUniqueInput | AIModuleQuizAttemptWhereUniqueInput[]
    delete?: AIModuleQuizAttemptWhereUniqueInput | AIModuleQuizAttemptWhereUniqueInput[]
    connect?: AIModuleQuizAttemptWhereUniqueInput | AIModuleQuizAttemptWhereUniqueInput[]
    update?: AIModuleQuizAttemptUpdateWithWhereUniqueWithoutTopicInput | AIModuleQuizAttemptUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: AIModuleQuizAttemptUpdateManyWithWhereWithoutTopicInput | AIModuleQuizAttemptUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: AIModuleQuizAttemptScalarWhereInput | AIModuleQuizAttemptScalarWhereInput[]
  }

  export type AIModuleRatingUpdateManyWithoutTopicNestedInput = {
    create?: XOR<AIModuleRatingCreateWithoutTopicInput, AIModuleRatingUncheckedCreateWithoutTopicInput> | AIModuleRatingCreateWithoutTopicInput[] | AIModuleRatingUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: AIModuleRatingCreateOrConnectWithoutTopicInput | AIModuleRatingCreateOrConnectWithoutTopicInput[]
    upsert?: AIModuleRatingUpsertWithWhereUniqueWithoutTopicInput | AIModuleRatingUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: AIModuleRatingCreateManyTopicInputEnvelope
    set?: AIModuleRatingWhereUniqueInput | AIModuleRatingWhereUniqueInput[]
    disconnect?: AIModuleRatingWhereUniqueInput | AIModuleRatingWhereUniqueInput[]
    delete?: AIModuleRatingWhereUniqueInput | AIModuleRatingWhereUniqueInput[]
    connect?: AIModuleRatingWhereUniqueInput | AIModuleRatingWhereUniqueInput[]
    update?: AIModuleRatingUpdateWithWhereUniqueWithoutTopicInput | AIModuleRatingUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: AIModuleRatingUpdateManyWithWhereWithoutTopicInput | AIModuleRatingUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: AIModuleRatingScalarWhereInput | AIModuleRatingScalarWhereInput[]
  }

  export type ProgressUncheckedUpdateManyWithoutTopicNestedInput = {
    create?: XOR<ProgressCreateWithoutTopicInput, ProgressUncheckedCreateWithoutTopicInput> | ProgressCreateWithoutTopicInput[] | ProgressUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: ProgressCreateOrConnectWithoutTopicInput | ProgressCreateOrConnectWithoutTopicInput[]
    upsert?: ProgressUpsertWithWhereUniqueWithoutTopicInput | ProgressUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: ProgressCreateManyTopicInputEnvelope
    set?: ProgressWhereUniqueInput | ProgressWhereUniqueInput[]
    disconnect?: ProgressWhereUniqueInput | ProgressWhereUniqueInput[]
    delete?: ProgressWhereUniqueInput | ProgressWhereUniqueInput[]
    connect?: ProgressWhereUniqueInput | ProgressWhereUniqueInput[]
    update?: ProgressUpdateWithWhereUniqueWithoutTopicInput | ProgressUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: ProgressUpdateManyWithWhereWithoutTopicInput | ProgressUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: ProgressScalarWhereInput | ProgressScalarWhereInput[]
  }

  export type LearningPathItemUncheckedUpdateManyWithoutTopicNestedInput = {
    create?: XOR<LearningPathItemCreateWithoutTopicInput, LearningPathItemUncheckedCreateWithoutTopicInput> | LearningPathItemCreateWithoutTopicInput[] | LearningPathItemUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: LearningPathItemCreateOrConnectWithoutTopicInput | LearningPathItemCreateOrConnectWithoutTopicInput[]
    upsert?: LearningPathItemUpsertWithWhereUniqueWithoutTopicInput | LearningPathItemUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: LearningPathItemCreateManyTopicInputEnvelope
    set?: LearningPathItemWhereUniqueInput | LearningPathItemWhereUniqueInput[]
    disconnect?: LearningPathItemWhereUniqueInput | LearningPathItemWhereUniqueInput[]
    delete?: LearningPathItemWhereUniqueInput | LearningPathItemWhereUniqueInput[]
    connect?: LearningPathItemWhereUniqueInput | LearningPathItemWhereUniqueInput[]
    update?: LearningPathItemUpdateWithWhereUniqueWithoutTopicInput | LearningPathItemUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: LearningPathItemUpdateManyWithWhereWithoutTopicInput | LearningPathItemUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: LearningPathItemScalarWhereInput | LearningPathItemScalarWhereInput[]
  }

  export type ContentItemUncheckedUpdateManyWithoutTopicNestedInput = {
    create?: XOR<ContentItemCreateWithoutTopicInput, ContentItemUncheckedCreateWithoutTopicInput> | ContentItemCreateWithoutTopicInput[] | ContentItemUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: ContentItemCreateOrConnectWithoutTopicInput | ContentItemCreateOrConnectWithoutTopicInput[]
    upsert?: ContentItemUpsertWithWhereUniqueWithoutTopicInput | ContentItemUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: ContentItemCreateManyTopicInputEnvelope
    set?: ContentItemWhereUniqueInput | ContentItemWhereUniqueInput[]
    disconnect?: ContentItemWhereUniqueInput | ContentItemWhereUniqueInput[]
    delete?: ContentItemWhereUniqueInput | ContentItemWhereUniqueInput[]
    connect?: ContentItemWhereUniqueInput | ContentItemWhereUniqueInput[]
    update?: ContentItemUpdateWithWhereUniqueWithoutTopicInput | ContentItemUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: ContentItemUpdateManyWithWhereWithoutTopicInput | ContentItemUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: ContentItemScalarWhereInput | ContentItemScalarWhereInput[]
  }

  export type AnalyticsEntryUncheckedUpdateManyWithoutTopicNestedInput = {
    create?: XOR<AnalyticsEntryCreateWithoutTopicInput, AnalyticsEntryUncheckedCreateWithoutTopicInput> | AnalyticsEntryCreateWithoutTopicInput[] | AnalyticsEntryUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: AnalyticsEntryCreateOrConnectWithoutTopicInput | AnalyticsEntryCreateOrConnectWithoutTopicInput[]
    upsert?: AnalyticsEntryUpsertWithWhereUniqueWithoutTopicInput | AnalyticsEntryUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: AnalyticsEntryCreateManyTopicInputEnvelope
    set?: AnalyticsEntryWhereUniqueInput | AnalyticsEntryWhereUniqueInput[]
    disconnect?: AnalyticsEntryWhereUniqueInput | AnalyticsEntryWhereUniqueInput[]
    delete?: AnalyticsEntryWhereUniqueInput | AnalyticsEntryWhereUniqueInput[]
    connect?: AnalyticsEntryWhereUniqueInput | AnalyticsEntryWhereUniqueInput[]
    update?: AnalyticsEntryUpdateWithWhereUniqueWithoutTopicInput | AnalyticsEntryUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: AnalyticsEntryUpdateManyWithWhereWithoutTopicInput | AnalyticsEntryUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: AnalyticsEntryScalarWhereInput | AnalyticsEntryScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutTopicNestedInput = {
    create?: XOR<CommentCreateWithoutTopicInput, CommentUncheckedCreateWithoutTopicInput> | CommentCreateWithoutTopicInput[] | CommentUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutTopicInput | CommentCreateOrConnectWithoutTopicInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutTopicInput | CommentUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: CommentCreateManyTopicInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutTopicInput | CommentUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutTopicInput | CommentUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type PrerequisiteUncheckedUpdateManyWithoutTopicNestedInput = {
    create?: XOR<PrerequisiteCreateWithoutTopicInput, PrerequisiteUncheckedCreateWithoutTopicInput> | PrerequisiteCreateWithoutTopicInput[] | PrerequisiteUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: PrerequisiteCreateOrConnectWithoutTopicInput | PrerequisiteCreateOrConnectWithoutTopicInput[]
    upsert?: PrerequisiteUpsertWithWhereUniqueWithoutTopicInput | PrerequisiteUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: PrerequisiteCreateManyTopicInputEnvelope
    set?: PrerequisiteWhereUniqueInput | PrerequisiteWhereUniqueInput[]
    disconnect?: PrerequisiteWhereUniqueInput | PrerequisiteWhereUniqueInput[]
    delete?: PrerequisiteWhereUniqueInput | PrerequisiteWhereUniqueInput[]
    connect?: PrerequisiteWhereUniqueInput | PrerequisiteWhereUniqueInput[]
    update?: PrerequisiteUpdateWithWhereUniqueWithoutTopicInput | PrerequisiteUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: PrerequisiteUpdateManyWithWhereWithoutTopicInput | PrerequisiteUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: PrerequisiteScalarWhereInput | PrerequisiteScalarWhereInput[]
  }

  export type AIModuleUncheckedUpdateManyWithoutTopicNestedInput = {
    create?: XOR<AIModuleCreateWithoutTopicInput, AIModuleUncheckedCreateWithoutTopicInput> | AIModuleCreateWithoutTopicInput[] | AIModuleUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: AIModuleCreateOrConnectWithoutTopicInput | AIModuleCreateOrConnectWithoutTopicInput[]
    upsert?: AIModuleUpsertWithWhereUniqueWithoutTopicInput | AIModuleUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: AIModuleCreateManyTopicInputEnvelope
    set?: AIModuleWhereUniqueInput | AIModuleWhereUniqueInput[]
    disconnect?: AIModuleWhereUniqueInput | AIModuleWhereUniqueInput[]
    delete?: AIModuleWhereUniqueInput | AIModuleWhereUniqueInput[]
    connect?: AIModuleWhereUniqueInput | AIModuleWhereUniqueInput[]
    update?: AIModuleUpdateWithWhereUniqueWithoutTopicInput | AIModuleUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: AIModuleUpdateManyWithWhereWithoutTopicInput | AIModuleUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: AIModuleScalarWhereInput | AIModuleScalarWhereInput[]
  }

  export type AIModuleQuizAttemptUncheckedUpdateManyWithoutTopicNestedInput = {
    create?: XOR<AIModuleQuizAttemptCreateWithoutTopicInput, AIModuleQuizAttemptUncheckedCreateWithoutTopicInput> | AIModuleQuizAttemptCreateWithoutTopicInput[] | AIModuleQuizAttemptUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: AIModuleQuizAttemptCreateOrConnectWithoutTopicInput | AIModuleQuizAttemptCreateOrConnectWithoutTopicInput[]
    upsert?: AIModuleQuizAttemptUpsertWithWhereUniqueWithoutTopicInput | AIModuleQuizAttemptUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: AIModuleQuizAttemptCreateManyTopicInputEnvelope
    set?: AIModuleQuizAttemptWhereUniqueInput | AIModuleQuizAttemptWhereUniqueInput[]
    disconnect?: AIModuleQuizAttemptWhereUniqueInput | AIModuleQuizAttemptWhereUniqueInput[]
    delete?: AIModuleQuizAttemptWhereUniqueInput | AIModuleQuizAttemptWhereUniqueInput[]
    connect?: AIModuleQuizAttemptWhereUniqueInput | AIModuleQuizAttemptWhereUniqueInput[]
    update?: AIModuleQuizAttemptUpdateWithWhereUniqueWithoutTopicInput | AIModuleQuizAttemptUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: AIModuleQuizAttemptUpdateManyWithWhereWithoutTopicInput | AIModuleQuizAttemptUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: AIModuleQuizAttemptScalarWhereInput | AIModuleQuizAttemptScalarWhereInput[]
  }

  export type AIModuleRatingUncheckedUpdateManyWithoutTopicNestedInput = {
    create?: XOR<AIModuleRatingCreateWithoutTopicInput, AIModuleRatingUncheckedCreateWithoutTopicInput> | AIModuleRatingCreateWithoutTopicInput[] | AIModuleRatingUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: AIModuleRatingCreateOrConnectWithoutTopicInput | AIModuleRatingCreateOrConnectWithoutTopicInput[]
    upsert?: AIModuleRatingUpsertWithWhereUniqueWithoutTopicInput | AIModuleRatingUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: AIModuleRatingCreateManyTopicInputEnvelope
    set?: AIModuleRatingWhereUniqueInput | AIModuleRatingWhereUniqueInput[]
    disconnect?: AIModuleRatingWhereUniqueInput | AIModuleRatingWhereUniqueInput[]
    delete?: AIModuleRatingWhereUniqueInput | AIModuleRatingWhereUniqueInput[]
    connect?: AIModuleRatingWhereUniqueInput | AIModuleRatingWhereUniqueInput[]
    update?: AIModuleRatingUpdateWithWhereUniqueWithoutTopicInput | AIModuleRatingUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: AIModuleRatingUpdateManyWithWhereWithoutTopicInput | AIModuleRatingUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: AIModuleRatingScalarWhereInput | AIModuleRatingScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutProgressInput = {
    create?: XOR<UserCreateWithoutProgressInput, UserUncheckedCreateWithoutProgressInput>
    connectOrCreate?: UserCreateOrConnectWithoutProgressInput
    connect?: UserWhereUniqueInput
  }

  export type TopicCreateNestedOneWithoutProgressInput = {
    create?: XOR<TopicCreateWithoutProgressInput, TopicUncheckedCreateWithoutProgressInput>
    connectOrCreate?: TopicCreateOrConnectWithoutProgressInput
    connect?: TopicWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutProgressNestedInput = {
    create?: XOR<UserCreateWithoutProgressInput, UserUncheckedCreateWithoutProgressInput>
    connectOrCreate?: UserCreateOrConnectWithoutProgressInput
    upsert?: UserUpsertWithoutProgressInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProgressInput, UserUpdateWithoutProgressInput>, UserUncheckedUpdateWithoutProgressInput>
  }

  export type TopicUpdateOneRequiredWithoutProgressNestedInput = {
    create?: XOR<TopicCreateWithoutProgressInput, TopicUncheckedCreateWithoutProgressInput>
    connectOrCreate?: TopicCreateOrConnectWithoutProgressInput
    upsert?: TopicUpsertWithoutProgressInput
    connect?: TopicWhereUniqueInput
    update?: XOR<XOR<TopicUpdateToOneWithWhereWithoutProgressInput, TopicUpdateWithoutProgressInput>, TopicUncheckedUpdateWithoutProgressInput>
  }

  export type UserCreateNestedOneWithoutBadgesInput = {
    create?: XOR<UserCreateWithoutBadgesInput, UserUncheckedCreateWithoutBadgesInput>
    connectOrCreate?: UserCreateOrConnectWithoutBadgesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutBadgesNestedInput = {
    create?: XOR<UserCreateWithoutBadgesInput, UserUncheckedCreateWithoutBadgesInput>
    connectOrCreate?: UserCreateOrConnectWithoutBadgesInput
    upsert?: UserUpsertWithoutBadgesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBadgesInput, UserUpdateWithoutBadgesInput>, UserUncheckedUpdateWithoutBadgesInput>
  }

  export type UserCreateNestedOneWithoutUpcomingReviewsInput = {
    create?: XOR<UserCreateWithoutUpcomingReviewsInput, UserUncheckedCreateWithoutUpcomingReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpcomingReviewsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUpcomingReviewsNestedInput = {
    create?: XOR<UserCreateWithoutUpcomingReviewsInput, UserUncheckedCreateWithoutUpcomingReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpcomingReviewsInput
    upsert?: UserUpsertWithoutUpcomingReviewsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUpcomingReviewsInput, UserUpdateWithoutUpcomingReviewsInput>, UserUncheckedUpdateWithoutUpcomingReviewsInput>
  }

  export type UserCreateNestedOneWithoutLearningPathsInput = {
    create?: XOR<UserCreateWithoutLearningPathsInput, UserUncheckedCreateWithoutLearningPathsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLearningPathsInput
    connect?: UserWhereUniqueInput
  }

  export type LearningPathItemCreateNestedManyWithoutLearningPathInput = {
    create?: XOR<LearningPathItemCreateWithoutLearningPathInput, LearningPathItemUncheckedCreateWithoutLearningPathInput> | LearningPathItemCreateWithoutLearningPathInput[] | LearningPathItemUncheckedCreateWithoutLearningPathInput[]
    connectOrCreate?: LearningPathItemCreateOrConnectWithoutLearningPathInput | LearningPathItemCreateOrConnectWithoutLearningPathInput[]
    createMany?: LearningPathItemCreateManyLearningPathInputEnvelope
    connect?: LearningPathItemWhereUniqueInput | LearningPathItemWhereUniqueInput[]
  }

  export type PrerequisiteCreateNestedManyWithoutLearningPathInput = {
    create?: XOR<PrerequisiteCreateWithoutLearningPathInput, PrerequisiteUncheckedCreateWithoutLearningPathInput> | PrerequisiteCreateWithoutLearningPathInput[] | PrerequisiteUncheckedCreateWithoutLearningPathInput[]
    connectOrCreate?: PrerequisiteCreateOrConnectWithoutLearningPathInput | PrerequisiteCreateOrConnectWithoutLearningPathInput[]
    createMany?: PrerequisiteCreateManyLearningPathInputEnvelope
    connect?: PrerequisiteWhereUniqueInput | PrerequisiteWhereUniqueInput[]
  }

  export type AIModuleLearningPathItemCreateNestedManyWithoutLearningPathInput = {
    create?: XOR<AIModuleLearningPathItemCreateWithoutLearningPathInput, AIModuleLearningPathItemUncheckedCreateWithoutLearningPathInput> | AIModuleLearningPathItemCreateWithoutLearningPathInput[] | AIModuleLearningPathItemUncheckedCreateWithoutLearningPathInput[]
    connectOrCreate?: AIModuleLearningPathItemCreateOrConnectWithoutLearningPathInput | AIModuleLearningPathItemCreateOrConnectWithoutLearningPathInput[]
    createMany?: AIModuleLearningPathItemCreateManyLearningPathInputEnvelope
    connect?: AIModuleLearningPathItemWhereUniqueInput | AIModuleLearningPathItemWhereUniqueInput[]
  }

  export type UserProgressCreateNestedManyWithoutLearningPathInput = {
    create?: XOR<UserProgressCreateWithoutLearningPathInput, UserProgressUncheckedCreateWithoutLearningPathInput> | UserProgressCreateWithoutLearningPathInput[] | UserProgressUncheckedCreateWithoutLearningPathInput[]
    connectOrCreate?: UserProgressCreateOrConnectWithoutLearningPathInput | UserProgressCreateOrConnectWithoutLearningPathInput[]
    createMany?: UserProgressCreateManyLearningPathInputEnvelope
    connect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
  }

  export type LearningPathItemUncheckedCreateNestedManyWithoutLearningPathInput = {
    create?: XOR<LearningPathItemCreateWithoutLearningPathInput, LearningPathItemUncheckedCreateWithoutLearningPathInput> | LearningPathItemCreateWithoutLearningPathInput[] | LearningPathItemUncheckedCreateWithoutLearningPathInput[]
    connectOrCreate?: LearningPathItemCreateOrConnectWithoutLearningPathInput | LearningPathItemCreateOrConnectWithoutLearningPathInput[]
    createMany?: LearningPathItemCreateManyLearningPathInputEnvelope
    connect?: LearningPathItemWhereUniqueInput | LearningPathItemWhereUniqueInput[]
  }

  export type PrerequisiteUncheckedCreateNestedManyWithoutLearningPathInput = {
    create?: XOR<PrerequisiteCreateWithoutLearningPathInput, PrerequisiteUncheckedCreateWithoutLearningPathInput> | PrerequisiteCreateWithoutLearningPathInput[] | PrerequisiteUncheckedCreateWithoutLearningPathInput[]
    connectOrCreate?: PrerequisiteCreateOrConnectWithoutLearningPathInput | PrerequisiteCreateOrConnectWithoutLearningPathInput[]
    createMany?: PrerequisiteCreateManyLearningPathInputEnvelope
    connect?: PrerequisiteWhereUniqueInput | PrerequisiteWhereUniqueInput[]
  }

  export type AIModuleLearningPathItemUncheckedCreateNestedManyWithoutLearningPathInput = {
    create?: XOR<AIModuleLearningPathItemCreateWithoutLearningPathInput, AIModuleLearningPathItemUncheckedCreateWithoutLearningPathInput> | AIModuleLearningPathItemCreateWithoutLearningPathInput[] | AIModuleLearningPathItemUncheckedCreateWithoutLearningPathInput[]
    connectOrCreate?: AIModuleLearningPathItemCreateOrConnectWithoutLearningPathInput | AIModuleLearningPathItemCreateOrConnectWithoutLearningPathInput[]
    createMany?: AIModuleLearningPathItemCreateManyLearningPathInputEnvelope
    connect?: AIModuleLearningPathItemWhereUniqueInput | AIModuleLearningPathItemWhereUniqueInput[]
  }

  export type UserProgressUncheckedCreateNestedManyWithoutLearningPathInput = {
    create?: XOR<UserProgressCreateWithoutLearningPathInput, UserProgressUncheckedCreateWithoutLearningPathInput> | UserProgressCreateWithoutLearningPathInput[] | UserProgressUncheckedCreateWithoutLearningPathInput[]
    connectOrCreate?: UserProgressCreateOrConnectWithoutLearningPathInput | UserProgressCreateOrConnectWithoutLearningPathInput[]
    createMany?: UserProgressCreateManyLearningPathInputEnvelope
    connect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutLearningPathsNestedInput = {
    create?: XOR<UserCreateWithoutLearningPathsInput, UserUncheckedCreateWithoutLearningPathsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLearningPathsInput
    upsert?: UserUpsertWithoutLearningPathsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLearningPathsInput, UserUpdateWithoutLearningPathsInput>, UserUncheckedUpdateWithoutLearningPathsInput>
  }

  export type LearningPathItemUpdateManyWithoutLearningPathNestedInput = {
    create?: XOR<LearningPathItemCreateWithoutLearningPathInput, LearningPathItemUncheckedCreateWithoutLearningPathInput> | LearningPathItemCreateWithoutLearningPathInput[] | LearningPathItemUncheckedCreateWithoutLearningPathInput[]
    connectOrCreate?: LearningPathItemCreateOrConnectWithoutLearningPathInput | LearningPathItemCreateOrConnectWithoutLearningPathInput[]
    upsert?: LearningPathItemUpsertWithWhereUniqueWithoutLearningPathInput | LearningPathItemUpsertWithWhereUniqueWithoutLearningPathInput[]
    createMany?: LearningPathItemCreateManyLearningPathInputEnvelope
    set?: LearningPathItemWhereUniqueInput | LearningPathItemWhereUniqueInput[]
    disconnect?: LearningPathItemWhereUniqueInput | LearningPathItemWhereUniqueInput[]
    delete?: LearningPathItemWhereUniqueInput | LearningPathItemWhereUniqueInput[]
    connect?: LearningPathItemWhereUniqueInput | LearningPathItemWhereUniqueInput[]
    update?: LearningPathItemUpdateWithWhereUniqueWithoutLearningPathInput | LearningPathItemUpdateWithWhereUniqueWithoutLearningPathInput[]
    updateMany?: LearningPathItemUpdateManyWithWhereWithoutLearningPathInput | LearningPathItemUpdateManyWithWhereWithoutLearningPathInput[]
    deleteMany?: LearningPathItemScalarWhereInput | LearningPathItemScalarWhereInput[]
  }

  export type PrerequisiteUpdateManyWithoutLearningPathNestedInput = {
    create?: XOR<PrerequisiteCreateWithoutLearningPathInput, PrerequisiteUncheckedCreateWithoutLearningPathInput> | PrerequisiteCreateWithoutLearningPathInput[] | PrerequisiteUncheckedCreateWithoutLearningPathInput[]
    connectOrCreate?: PrerequisiteCreateOrConnectWithoutLearningPathInput | PrerequisiteCreateOrConnectWithoutLearningPathInput[]
    upsert?: PrerequisiteUpsertWithWhereUniqueWithoutLearningPathInput | PrerequisiteUpsertWithWhereUniqueWithoutLearningPathInput[]
    createMany?: PrerequisiteCreateManyLearningPathInputEnvelope
    set?: PrerequisiteWhereUniqueInput | PrerequisiteWhereUniqueInput[]
    disconnect?: PrerequisiteWhereUniqueInput | PrerequisiteWhereUniqueInput[]
    delete?: PrerequisiteWhereUniqueInput | PrerequisiteWhereUniqueInput[]
    connect?: PrerequisiteWhereUniqueInput | PrerequisiteWhereUniqueInput[]
    update?: PrerequisiteUpdateWithWhereUniqueWithoutLearningPathInput | PrerequisiteUpdateWithWhereUniqueWithoutLearningPathInput[]
    updateMany?: PrerequisiteUpdateManyWithWhereWithoutLearningPathInput | PrerequisiteUpdateManyWithWhereWithoutLearningPathInput[]
    deleteMany?: PrerequisiteScalarWhereInput | PrerequisiteScalarWhereInput[]
  }

  export type AIModuleLearningPathItemUpdateManyWithoutLearningPathNestedInput = {
    create?: XOR<AIModuleLearningPathItemCreateWithoutLearningPathInput, AIModuleLearningPathItemUncheckedCreateWithoutLearningPathInput> | AIModuleLearningPathItemCreateWithoutLearningPathInput[] | AIModuleLearningPathItemUncheckedCreateWithoutLearningPathInput[]
    connectOrCreate?: AIModuleLearningPathItemCreateOrConnectWithoutLearningPathInput | AIModuleLearningPathItemCreateOrConnectWithoutLearningPathInput[]
    upsert?: AIModuleLearningPathItemUpsertWithWhereUniqueWithoutLearningPathInput | AIModuleLearningPathItemUpsertWithWhereUniqueWithoutLearningPathInput[]
    createMany?: AIModuleLearningPathItemCreateManyLearningPathInputEnvelope
    set?: AIModuleLearningPathItemWhereUniqueInput | AIModuleLearningPathItemWhereUniqueInput[]
    disconnect?: AIModuleLearningPathItemWhereUniqueInput | AIModuleLearningPathItemWhereUniqueInput[]
    delete?: AIModuleLearningPathItemWhereUniqueInput | AIModuleLearningPathItemWhereUniqueInput[]
    connect?: AIModuleLearningPathItemWhereUniqueInput | AIModuleLearningPathItemWhereUniqueInput[]
    update?: AIModuleLearningPathItemUpdateWithWhereUniqueWithoutLearningPathInput | AIModuleLearningPathItemUpdateWithWhereUniqueWithoutLearningPathInput[]
    updateMany?: AIModuleLearningPathItemUpdateManyWithWhereWithoutLearningPathInput | AIModuleLearningPathItemUpdateManyWithWhereWithoutLearningPathInput[]
    deleteMany?: AIModuleLearningPathItemScalarWhereInput | AIModuleLearningPathItemScalarWhereInput[]
  }

  export type UserProgressUpdateManyWithoutLearningPathNestedInput = {
    create?: XOR<UserProgressCreateWithoutLearningPathInput, UserProgressUncheckedCreateWithoutLearningPathInput> | UserProgressCreateWithoutLearningPathInput[] | UserProgressUncheckedCreateWithoutLearningPathInput[]
    connectOrCreate?: UserProgressCreateOrConnectWithoutLearningPathInput | UserProgressCreateOrConnectWithoutLearningPathInput[]
    upsert?: UserProgressUpsertWithWhereUniqueWithoutLearningPathInput | UserProgressUpsertWithWhereUniqueWithoutLearningPathInput[]
    createMany?: UserProgressCreateManyLearningPathInputEnvelope
    set?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    disconnect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    delete?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    connect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    update?: UserProgressUpdateWithWhereUniqueWithoutLearningPathInput | UserProgressUpdateWithWhereUniqueWithoutLearningPathInput[]
    updateMany?: UserProgressUpdateManyWithWhereWithoutLearningPathInput | UserProgressUpdateManyWithWhereWithoutLearningPathInput[]
    deleteMany?: UserProgressScalarWhereInput | UserProgressScalarWhereInput[]
  }

  export type LearningPathItemUncheckedUpdateManyWithoutLearningPathNestedInput = {
    create?: XOR<LearningPathItemCreateWithoutLearningPathInput, LearningPathItemUncheckedCreateWithoutLearningPathInput> | LearningPathItemCreateWithoutLearningPathInput[] | LearningPathItemUncheckedCreateWithoutLearningPathInput[]
    connectOrCreate?: LearningPathItemCreateOrConnectWithoutLearningPathInput | LearningPathItemCreateOrConnectWithoutLearningPathInput[]
    upsert?: LearningPathItemUpsertWithWhereUniqueWithoutLearningPathInput | LearningPathItemUpsertWithWhereUniqueWithoutLearningPathInput[]
    createMany?: LearningPathItemCreateManyLearningPathInputEnvelope
    set?: LearningPathItemWhereUniqueInput | LearningPathItemWhereUniqueInput[]
    disconnect?: LearningPathItemWhereUniqueInput | LearningPathItemWhereUniqueInput[]
    delete?: LearningPathItemWhereUniqueInput | LearningPathItemWhereUniqueInput[]
    connect?: LearningPathItemWhereUniqueInput | LearningPathItemWhereUniqueInput[]
    update?: LearningPathItemUpdateWithWhereUniqueWithoutLearningPathInput | LearningPathItemUpdateWithWhereUniqueWithoutLearningPathInput[]
    updateMany?: LearningPathItemUpdateManyWithWhereWithoutLearningPathInput | LearningPathItemUpdateManyWithWhereWithoutLearningPathInput[]
    deleteMany?: LearningPathItemScalarWhereInput | LearningPathItemScalarWhereInput[]
  }

  export type PrerequisiteUncheckedUpdateManyWithoutLearningPathNestedInput = {
    create?: XOR<PrerequisiteCreateWithoutLearningPathInput, PrerequisiteUncheckedCreateWithoutLearningPathInput> | PrerequisiteCreateWithoutLearningPathInput[] | PrerequisiteUncheckedCreateWithoutLearningPathInput[]
    connectOrCreate?: PrerequisiteCreateOrConnectWithoutLearningPathInput | PrerequisiteCreateOrConnectWithoutLearningPathInput[]
    upsert?: PrerequisiteUpsertWithWhereUniqueWithoutLearningPathInput | PrerequisiteUpsertWithWhereUniqueWithoutLearningPathInput[]
    createMany?: PrerequisiteCreateManyLearningPathInputEnvelope
    set?: PrerequisiteWhereUniqueInput | PrerequisiteWhereUniqueInput[]
    disconnect?: PrerequisiteWhereUniqueInput | PrerequisiteWhereUniqueInput[]
    delete?: PrerequisiteWhereUniqueInput | PrerequisiteWhereUniqueInput[]
    connect?: PrerequisiteWhereUniqueInput | PrerequisiteWhereUniqueInput[]
    update?: PrerequisiteUpdateWithWhereUniqueWithoutLearningPathInput | PrerequisiteUpdateWithWhereUniqueWithoutLearningPathInput[]
    updateMany?: PrerequisiteUpdateManyWithWhereWithoutLearningPathInput | PrerequisiteUpdateManyWithWhereWithoutLearningPathInput[]
    deleteMany?: PrerequisiteScalarWhereInput | PrerequisiteScalarWhereInput[]
  }

  export type AIModuleLearningPathItemUncheckedUpdateManyWithoutLearningPathNestedInput = {
    create?: XOR<AIModuleLearningPathItemCreateWithoutLearningPathInput, AIModuleLearningPathItemUncheckedCreateWithoutLearningPathInput> | AIModuleLearningPathItemCreateWithoutLearningPathInput[] | AIModuleLearningPathItemUncheckedCreateWithoutLearningPathInput[]
    connectOrCreate?: AIModuleLearningPathItemCreateOrConnectWithoutLearningPathInput | AIModuleLearningPathItemCreateOrConnectWithoutLearningPathInput[]
    upsert?: AIModuleLearningPathItemUpsertWithWhereUniqueWithoutLearningPathInput | AIModuleLearningPathItemUpsertWithWhereUniqueWithoutLearningPathInput[]
    createMany?: AIModuleLearningPathItemCreateManyLearningPathInputEnvelope
    set?: AIModuleLearningPathItemWhereUniqueInput | AIModuleLearningPathItemWhereUniqueInput[]
    disconnect?: AIModuleLearningPathItemWhereUniqueInput | AIModuleLearningPathItemWhereUniqueInput[]
    delete?: AIModuleLearningPathItemWhereUniqueInput | AIModuleLearningPathItemWhereUniqueInput[]
    connect?: AIModuleLearningPathItemWhereUniqueInput | AIModuleLearningPathItemWhereUniqueInput[]
    update?: AIModuleLearningPathItemUpdateWithWhereUniqueWithoutLearningPathInput | AIModuleLearningPathItemUpdateWithWhereUniqueWithoutLearningPathInput[]
    updateMany?: AIModuleLearningPathItemUpdateManyWithWhereWithoutLearningPathInput | AIModuleLearningPathItemUpdateManyWithWhereWithoutLearningPathInput[]
    deleteMany?: AIModuleLearningPathItemScalarWhereInput | AIModuleLearningPathItemScalarWhereInput[]
  }

  export type UserProgressUncheckedUpdateManyWithoutLearningPathNestedInput = {
    create?: XOR<UserProgressCreateWithoutLearningPathInput, UserProgressUncheckedCreateWithoutLearningPathInput> | UserProgressCreateWithoutLearningPathInput[] | UserProgressUncheckedCreateWithoutLearningPathInput[]
    connectOrCreate?: UserProgressCreateOrConnectWithoutLearningPathInput | UserProgressCreateOrConnectWithoutLearningPathInput[]
    upsert?: UserProgressUpsertWithWhereUniqueWithoutLearningPathInput | UserProgressUpsertWithWhereUniqueWithoutLearningPathInput[]
    createMany?: UserProgressCreateManyLearningPathInputEnvelope
    set?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    disconnect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    delete?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    connect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    update?: UserProgressUpdateWithWhereUniqueWithoutLearningPathInput | UserProgressUpdateWithWhereUniqueWithoutLearningPathInput[]
    updateMany?: UserProgressUpdateManyWithWhereWithoutLearningPathInput | UserProgressUpdateManyWithWhereWithoutLearningPathInput[]
    deleteMany?: UserProgressScalarWhereInput | UserProgressScalarWhereInput[]
  }

  export type LearningPathCreateNestedOneWithoutItemsInput = {
    create?: XOR<LearningPathCreateWithoutItemsInput, LearningPathUncheckedCreateWithoutItemsInput>
    connectOrCreate?: LearningPathCreateOrConnectWithoutItemsInput
    connect?: LearningPathWhereUniqueInput
  }

  export type TopicCreateNestedOneWithoutLearningPathItemsInput = {
    create?: XOR<TopicCreateWithoutLearningPathItemsInput, TopicUncheckedCreateWithoutLearningPathItemsInput>
    connectOrCreate?: TopicCreateOrConnectWithoutLearningPathItemsInput
    connect?: TopicWhereUniqueInput
  }

  export type UserProgressCreateNestedManyWithoutModuleInput = {
    create?: XOR<UserProgressCreateWithoutModuleInput, UserProgressUncheckedCreateWithoutModuleInput> | UserProgressCreateWithoutModuleInput[] | UserProgressUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: UserProgressCreateOrConnectWithoutModuleInput | UserProgressCreateOrConnectWithoutModuleInput[]
    createMany?: UserProgressCreateManyModuleInputEnvelope
    connect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
  }

  export type UserProgressUncheckedCreateNestedManyWithoutModuleInput = {
    create?: XOR<UserProgressCreateWithoutModuleInput, UserProgressUncheckedCreateWithoutModuleInput> | UserProgressCreateWithoutModuleInput[] | UserProgressUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: UserProgressCreateOrConnectWithoutModuleInput | UserProgressCreateOrConnectWithoutModuleInput[]
    createMany?: UserProgressCreateManyModuleInputEnvelope
    connect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
  }

  export type LearningPathUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<LearningPathCreateWithoutItemsInput, LearningPathUncheckedCreateWithoutItemsInput>
    connectOrCreate?: LearningPathCreateOrConnectWithoutItemsInput
    upsert?: LearningPathUpsertWithoutItemsInput
    connect?: LearningPathWhereUniqueInput
    update?: XOR<XOR<LearningPathUpdateToOneWithWhereWithoutItemsInput, LearningPathUpdateWithoutItemsInput>, LearningPathUncheckedUpdateWithoutItemsInput>
  }

  export type TopicUpdateOneRequiredWithoutLearningPathItemsNestedInput = {
    create?: XOR<TopicCreateWithoutLearningPathItemsInput, TopicUncheckedCreateWithoutLearningPathItemsInput>
    connectOrCreate?: TopicCreateOrConnectWithoutLearningPathItemsInput
    upsert?: TopicUpsertWithoutLearningPathItemsInput
    connect?: TopicWhereUniqueInput
    update?: XOR<XOR<TopicUpdateToOneWithWhereWithoutLearningPathItemsInput, TopicUpdateWithoutLearningPathItemsInput>, TopicUncheckedUpdateWithoutLearningPathItemsInput>
  }

  export type UserProgressUpdateManyWithoutModuleNestedInput = {
    create?: XOR<UserProgressCreateWithoutModuleInput, UserProgressUncheckedCreateWithoutModuleInput> | UserProgressCreateWithoutModuleInput[] | UserProgressUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: UserProgressCreateOrConnectWithoutModuleInput | UserProgressCreateOrConnectWithoutModuleInput[]
    upsert?: UserProgressUpsertWithWhereUniqueWithoutModuleInput | UserProgressUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: UserProgressCreateManyModuleInputEnvelope
    set?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    disconnect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    delete?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    connect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    update?: UserProgressUpdateWithWhereUniqueWithoutModuleInput | UserProgressUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: UserProgressUpdateManyWithWhereWithoutModuleInput | UserProgressUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: UserProgressScalarWhereInput | UserProgressScalarWhereInput[]
  }

  export type UserProgressUncheckedUpdateManyWithoutModuleNestedInput = {
    create?: XOR<UserProgressCreateWithoutModuleInput, UserProgressUncheckedCreateWithoutModuleInput> | UserProgressCreateWithoutModuleInput[] | UserProgressUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: UserProgressCreateOrConnectWithoutModuleInput | UserProgressCreateOrConnectWithoutModuleInput[]
    upsert?: UserProgressUpsertWithWhereUniqueWithoutModuleInput | UserProgressUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: UserProgressCreateManyModuleInputEnvelope
    set?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    disconnect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    delete?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    connect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    update?: UserProgressUpdateWithWhereUniqueWithoutModuleInput | UserProgressUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: UserProgressUpdateManyWithWhereWithoutModuleInput | UserProgressUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: UserProgressScalarWhereInput | UserProgressScalarWhereInput[]
  }

  export type TopicCreateNestedOneWithoutContentItemsInput = {
    create?: XOR<TopicCreateWithoutContentItemsInput, TopicUncheckedCreateWithoutContentItemsInput>
    connectOrCreate?: TopicCreateOrConnectWithoutContentItemsInput
    connect?: TopicWhereUniqueInput
  }

  export type BookmarkCreateNestedManyWithoutContentItemInput = {
    create?: XOR<BookmarkCreateWithoutContentItemInput, BookmarkUncheckedCreateWithoutContentItemInput> | BookmarkCreateWithoutContentItemInput[] | BookmarkUncheckedCreateWithoutContentItemInput[]
    connectOrCreate?: BookmarkCreateOrConnectWithoutContentItemInput | BookmarkCreateOrConnectWithoutContentItemInput[]
    createMany?: BookmarkCreateManyContentItemInputEnvelope
    connect?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
  }

  export type QuizAttemptCreateNestedManyWithoutContentItemInput = {
    create?: XOR<QuizAttemptCreateWithoutContentItemInput, QuizAttemptUncheckedCreateWithoutContentItemInput> | QuizAttemptCreateWithoutContentItemInput[] | QuizAttemptUncheckedCreateWithoutContentItemInput[]
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutContentItemInput | QuizAttemptCreateOrConnectWithoutContentItemInput[]
    createMany?: QuizAttemptCreateManyContentItemInputEnvelope
    connect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
  }

  export type ReviewItemCreateNestedManyWithoutContentItemInput = {
    create?: XOR<ReviewItemCreateWithoutContentItemInput, ReviewItemUncheckedCreateWithoutContentItemInput> | ReviewItemCreateWithoutContentItemInput[] | ReviewItemUncheckedCreateWithoutContentItemInput[]
    connectOrCreate?: ReviewItemCreateOrConnectWithoutContentItemInput | ReviewItemCreateOrConnectWithoutContentItemInput[]
    createMany?: ReviewItemCreateManyContentItemInputEnvelope
    connect?: ReviewItemWhereUniqueInput | ReviewItemWhereUniqueInput[]
  }

  export type ContentRatingCreateNestedManyWithoutContentItemInput = {
    create?: XOR<ContentRatingCreateWithoutContentItemInput, ContentRatingUncheckedCreateWithoutContentItemInput> | ContentRatingCreateWithoutContentItemInput[] | ContentRatingUncheckedCreateWithoutContentItemInput[]
    connectOrCreate?: ContentRatingCreateOrConnectWithoutContentItemInput | ContentRatingCreateOrConnectWithoutContentItemInput[]
    createMany?: ContentRatingCreateManyContentItemInputEnvelope
    connect?: ContentRatingWhereUniqueInput | ContentRatingWhereUniqueInput[]
  }

  export type AIPlaylistItemCreateNestedManyWithoutContentItemInput = {
    create?: XOR<AIPlaylistItemCreateWithoutContentItemInput, AIPlaylistItemUncheckedCreateWithoutContentItemInput> | AIPlaylistItemCreateWithoutContentItemInput[] | AIPlaylistItemUncheckedCreateWithoutContentItemInput[]
    connectOrCreate?: AIPlaylistItemCreateOrConnectWithoutContentItemInput | AIPlaylistItemCreateOrConnectWithoutContentItemInput[]
    createMany?: AIPlaylistItemCreateManyContentItemInputEnvelope
    connect?: AIPlaylistItemWhereUniqueInput | AIPlaylistItemWhereUniqueInput[]
  }

  export type BookmarkUncheckedCreateNestedManyWithoutContentItemInput = {
    create?: XOR<BookmarkCreateWithoutContentItemInput, BookmarkUncheckedCreateWithoutContentItemInput> | BookmarkCreateWithoutContentItemInput[] | BookmarkUncheckedCreateWithoutContentItemInput[]
    connectOrCreate?: BookmarkCreateOrConnectWithoutContentItemInput | BookmarkCreateOrConnectWithoutContentItemInput[]
    createMany?: BookmarkCreateManyContentItemInputEnvelope
    connect?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
  }

  export type QuizAttemptUncheckedCreateNestedManyWithoutContentItemInput = {
    create?: XOR<QuizAttemptCreateWithoutContentItemInput, QuizAttemptUncheckedCreateWithoutContentItemInput> | QuizAttemptCreateWithoutContentItemInput[] | QuizAttemptUncheckedCreateWithoutContentItemInput[]
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutContentItemInput | QuizAttemptCreateOrConnectWithoutContentItemInput[]
    createMany?: QuizAttemptCreateManyContentItemInputEnvelope
    connect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
  }

  export type ReviewItemUncheckedCreateNestedManyWithoutContentItemInput = {
    create?: XOR<ReviewItemCreateWithoutContentItemInput, ReviewItemUncheckedCreateWithoutContentItemInput> | ReviewItemCreateWithoutContentItemInput[] | ReviewItemUncheckedCreateWithoutContentItemInput[]
    connectOrCreate?: ReviewItemCreateOrConnectWithoutContentItemInput | ReviewItemCreateOrConnectWithoutContentItemInput[]
    createMany?: ReviewItemCreateManyContentItemInputEnvelope
    connect?: ReviewItemWhereUniqueInput | ReviewItemWhereUniqueInput[]
  }

  export type ContentRatingUncheckedCreateNestedManyWithoutContentItemInput = {
    create?: XOR<ContentRatingCreateWithoutContentItemInput, ContentRatingUncheckedCreateWithoutContentItemInput> | ContentRatingCreateWithoutContentItemInput[] | ContentRatingUncheckedCreateWithoutContentItemInput[]
    connectOrCreate?: ContentRatingCreateOrConnectWithoutContentItemInput | ContentRatingCreateOrConnectWithoutContentItemInput[]
    createMany?: ContentRatingCreateManyContentItemInputEnvelope
    connect?: ContentRatingWhereUniqueInput | ContentRatingWhereUniqueInput[]
  }

  export type AIPlaylistItemUncheckedCreateNestedManyWithoutContentItemInput = {
    create?: XOR<AIPlaylistItemCreateWithoutContentItemInput, AIPlaylistItemUncheckedCreateWithoutContentItemInput> | AIPlaylistItemCreateWithoutContentItemInput[] | AIPlaylistItemUncheckedCreateWithoutContentItemInput[]
    connectOrCreate?: AIPlaylistItemCreateOrConnectWithoutContentItemInput | AIPlaylistItemCreateOrConnectWithoutContentItemInput[]
    createMany?: AIPlaylistItemCreateManyContentItemInputEnvelope
    connect?: AIPlaylistItemWhereUniqueInput | AIPlaylistItemWhereUniqueInput[]
  }

  export type TopicUpdateOneRequiredWithoutContentItemsNestedInput = {
    create?: XOR<TopicCreateWithoutContentItemsInput, TopicUncheckedCreateWithoutContentItemsInput>
    connectOrCreate?: TopicCreateOrConnectWithoutContentItemsInput
    upsert?: TopicUpsertWithoutContentItemsInput
    connect?: TopicWhereUniqueInput
    update?: XOR<XOR<TopicUpdateToOneWithWhereWithoutContentItemsInput, TopicUpdateWithoutContentItemsInput>, TopicUncheckedUpdateWithoutContentItemsInput>
  }

  export type BookmarkUpdateManyWithoutContentItemNestedInput = {
    create?: XOR<BookmarkCreateWithoutContentItemInput, BookmarkUncheckedCreateWithoutContentItemInput> | BookmarkCreateWithoutContentItemInput[] | BookmarkUncheckedCreateWithoutContentItemInput[]
    connectOrCreate?: BookmarkCreateOrConnectWithoutContentItemInput | BookmarkCreateOrConnectWithoutContentItemInput[]
    upsert?: BookmarkUpsertWithWhereUniqueWithoutContentItemInput | BookmarkUpsertWithWhereUniqueWithoutContentItemInput[]
    createMany?: BookmarkCreateManyContentItemInputEnvelope
    set?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    disconnect?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    delete?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    connect?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    update?: BookmarkUpdateWithWhereUniqueWithoutContentItemInput | BookmarkUpdateWithWhereUniqueWithoutContentItemInput[]
    updateMany?: BookmarkUpdateManyWithWhereWithoutContentItemInput | BookmarkUpdateManyWithWhereWithoutContentItemInput[]
    deleteMany?: BookmarkScalarWhereInput | BookmarkScalarWhereInput[]
  }

  export type QuizAttemptUpdateManyWithoutContentItemNestedInput = {
    create?: XOR<QuizAttemptCreateWithoutContentItemInput, QuizAttemptUncheckedCreateWithoutContentItemInput> | QuizAttemptCreateWithoutContentItemInput[] | QuizAttemptUncheckedCreateWithoutContentItemInput[]
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutContentItemInput | QuizAttemptCreateOrConnectWithoutContentItemInput[]
    upsert?: QuizAttemptUpsertWithWhereUniqueWithoutContentItemInput | QuizAttemptUpsertWithWhereUniqueWithoutContentItemInput[]
    createMany?: QuizAttemptCreateManyContentItemInputEnvelope
    set?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    disconnect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    delete?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    connect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    update?: QuizAttemptUpdateWithWhereUniqueWithoutContentItemInput | QuizAttemptUpdateWithWhereUniqueWithoutContentItemInput[]
    updateMany?: QuizAttemptUpdateManyWithWhereWithoutContentItemInput | QuizAttemptUpdateManyWithWhereWithoutContentItemInput[]
    deleteMany?: QuizAttemptScalarWhereInput | QuizAttemptScalarWhereInput[]
  }

  export type ReviewItemUpdateManyWithoutContentItemNestedInput = {
    create?: XOR<ReviewItemCreateWithoutContentItemInput, ReviewItemUncheckedCreateWithoutContentItemInput> | ReviewItemCreateWithoutContentItemInput[] | ReviewItemUncheckedCreateWithoutContentItemInput[]
    connectOrCreate?: ReviewItemCreateOrConnectWithoutContentItemInput | ReviewItemCreateOrConnectWithoutContentItemInput[]
    upsert?: ReviewItemUpsertWithWhereUniqueWithoutContentItemInput | ReviewItemUpsertWithWhereUniqueWithoutContentItemInput[]
    createMany?: ReviewItemCreateManyContentItemInputEnvelope
    set?: ReviewItemWhereUniqueInput | ReviewItemWhereUniqueInput[]
    disconnect?: ReviewItemWhereUniqueInput | ReviewItemWhereUniqueInput[]
    delete?: ReviewItemWhereUniqueInput | ReviewItemWhereUniqueInput[]
    connect?: ReviewItemWhereUniqueInput | ReviewItemWhereUniqueInput[]
    update?: ReviewItemUpdateWithWhereUniqueWithoutContentItemInput | ReviewItemUpdateWithWhereUniqueWithoutContentItemInput[]
    updateMany?: ReviewItemUpdateManyWithWhereWithoutContentItemInput | ReviewItemUpdateManyWithWhereWithoutContentItemInput[]
    deleteMany?: ReviewItemScalarWhereInput | ReviewItemScalarWhereInput[]
  }

  export type ContentRatingUpdateManyWithoutContentItemNestedInput = {
    create?: XOR<ContentRatingCreateWithoutContentItemInput, ContentRatingUncheckedCreateWithoutContentItemInput> | ContentRatingCreateWithoutContentItemInput[] | ContentRatingUncheckedCreateWithoutContentItemInput[]
    connectOrCreate?: ContentRatingCreateOrConnectWithoutContentItemInput | ContentRatingCreateOrConnectWithoutContentItemInput[]
    upsert?: ContentRatingUpsertWithWhereUniqueWithoutContentItemInput | ContentRatingUpsertWithWhereUniqueWithoutContentItemInput[]
    createMany?: ContentRatingCreateManyContentItemInputEnvelope
    set?: ContentRatingWhereUniqueInput | ContentRatingWhereUniqueInput[]
    disconnect?: ContentRatingWhereUniqueInput | ContentRatingWhereUniqueInput[]
    delete?: ContentRatingWhereUniqueInput | ContentRatingWhereUniqueInput[]
    connect?: ContentRatingWhereUniqueInput | ContentRatingWhereUniqueInput[]
    update?: ContentRatingUpdateWithWhereUniqueWithoutContentItemInput | ContentRatingUpdateWithWhereUniqueWithoutContentItemInput[]
    updateMany?: ContentRatingUpdateManyWithWhereWithoutContentItemInput | ContentRatingUpdateManyWithWhereWithoutContentItemInput[]
    deleteMany?: ContentRatingScalarWhereInput | ContentRatingScalarWhereInput[]
  }

  export type AIPlaylistItemUpdateManyWithoutContentItemNestedInput = {
    create?: XOR<AIPlaylistItemCreateWithoutContentItemInput, AIPlaylistItemUncheckedCreateWithoutContentItemInput> | AIPlaylistItemCreateWithoutContentItemInput[] | AIPlaylistItemUncheckedCreateWithoutContentItemInput[]
    connectOrCreate?: AIPlaylistItemCreateOrConnectWithoutContentItemInput | AIPlaylistItemCreateOrConnectWithoutContentItemInput[]
    upsert?: AIPlaylistItemUpsertWithWhereUniqueWithoutContentItemInput | AIPlaylistItemUpsertWithWhereUniqueWithoutContentItemInput[]
    createMany?: AIPlaylistItemCreateManyContentItemInputEnvelope
    set?: AIPlaylistItemWhereUniqueInput | AIPlaylistItemWhereUniqueInput[]
    disconnect?: AIPlaylistItemWhereUniqueInput | AIPlaylistItemWhereUniqueInput[]
    delete?: AIPlaylistItemWhereUniqueInput | AIPlaylistItemWhereUniqueInput[]
    connect?: AIPlaylistItemWhereUniqueInput | AIPlaylistItemWhereUniqueInput[]
    update?: AIPlaylistItemUpdateWithWhereUniqueWithoutContentItemInput | AIPlaylistItemUpdateWithWhereUniqueWithoutContentItemInput[]
    updateMany?: AIPlaylistItemUpdateManyWithWhereWithoutContentItemInput | AIPlaylistItemUpdateManyWithWhereWithoutContentItemInput[]
    deleteMany?: AIPlaylistItemScalarWhereInput | AIPlaylistItemScalarWhereInput[]
  }

  export type BookmarkUncheckedUpdateManyWithoutContentItemNestedInput = {
    create?: XOR<BookmarkCreateWithoutContentItemInput, BookmarkUncheckedCreateWithoutContentItemInput> | BookmarkCreateWithoutContentItemInput[] | BookmarkUncheckedCreateWithoutContentItemInput[]
    connectOrCreate?: BookmarkCreateOrConnectWithoutContentItemInput | BookmarkCreateOrConnectWithoutContentItemInput[]
    upsert?: BookmarkUpsertWithWhereUniqueWithoutContentItemInput | BookmarkUpsertWithWhereUniqueWithoutContentItemInput[]
    createMany?: BookmarkCreateManyContentItemInputEnvelope
    set?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    disconnect?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    delete?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    connect?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    update?: BookmarkUpdateWithWhereUniqueWithoutContentItemInput | BookmarkUpdateWithWhereUniqueWithoutContentItemInput[]
    updateMany?: BookmarkUpdateManyWithWhereWithoutContentItemInput | BookmarkUpdateManyWithWhereWithoutContentItemInput[]
    deleteMany?: BookmarkScalarWhereInput | BookmarkScalarWhereInput[]
  }

  export type QuizAttemptUncheckedUpdateManyWithoutContentItemNestedInput = {
    create?: XOR<QuizAttemptCreateWithoutContentItemInput, QuizAttemptUncheckedCreateWithoutContentItemInput> | QuizAttemptCreateWithoutContentItemInput[] | QuizAttemptUncheckedCreateWithoutContentItemInput[]
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutContentItemInput | QuizAttemptCreateOrConnectWithoutContentItemInput[]
    upsert?: QuizAttemptUpsertWithWhereUniqueWithoutContentItemInput | QuizAttemptUpsertWithWhereUniqueWithoutContentItemInput[]
    createMany?: QuizAttemptCreateManyContentItemInputEnvelope
    set?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    disconnect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    delete?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    connect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    update?: QuizAttemptUpdateWithWhereUniqueWithoutContentItemInput | QuizAttemptUpdateWithWhereUniqueWithoutContentItemInput[]
    updateMany?: QuizAttemptUpdateManyWithWhereWithoutContentItemInput | QuizAttemptUpdateManyWithWhereWithoutContentItemInput[]
    deleteMany?: QuizAttemptScalarWhereInput | QuizAttemptScalarWhereInput[]
  }

  export type ReviewItemUncheckedUpdateManyWithoutContentItemNestedInput = {
    create?: XOR<ReviewItemCreateWithoutContentItemInput, ReviewItemUncheckedCreateWithoutContentItemInput> | ReviewItemCreateWithoutContentItemInput[] | ReviewItemUncheckedCreateWithoutContentItemInput[]
    connectOrCreate?: ReviewItemCreateOrConnectWithoutContentItemInput | ReviewItemCreateOrConnectWithoutContentItemInput[]
    upsert?: ReviewItemUpsertWithWhereUniqueWithoutContentItemInput | ReviewItemUpsertWithWhereUniqueWithoutContentItemInput[]
    createMany?: ReviewItemCreateManyContentItemInputEnvelope
    set?: ReviewItemWhereUniqueInput | ReviewItemWhereUniqueInput[]
    disconnect?: ReviewItemWhereUniqueInput | ReviewItemWhereUniqueInput[]
    delete?: ReviewItemWhereUniqueInput | ReviewItemWhereUniqueInput[]
    connect?: ReviewItemWhereUniqueInput | ReviewItemWhereUniqueInput[]
    update?: ReviewItemUpdateWithWhereUniqueWithoutContentItemInput | ReviewItemUpdateWithWhereUniqueWithoutContentItemInput[]
    updateMany?: ReviewItemUpdateManyWithWhereWithoutContentItemInput | ReviewItemUpdateManyWithWhereWithoutContentItemInput[]
    deleteMany?: ReviewItemScalarWhereInput | ReviewItemScalarWhereInput[]
  }

  export type ContentRatingUncheckedUpdateManyWithoutContentItemNestedInput = {
    create?: XOR<ContentRatingCreateWithoutContentItemInput, ContentRatingUncheckedCreateWithoutContentItemInput> | ContentRatingCreateWithoutContentItemInput[] | ContentRatingUncheckedCreateWithoutContentItemInput[]
    connectOrCreate?: ContentRatingCreateOrConnectWithoutContentItemInput | ContentRatingCreateOrConnectWithoutContentItemInput[]
    upsert?: ContentRatingUpsertWithWhereUniqueWithoutContentItemInput | ContentRatingUpsertWithWhereUniqueWithoutContentItemInput[]
    createMany?: ContentRatingCreateManyContentItemInputEnvelope
    set?: ContentRatingWhereUniqueInput | ContentRatingWhereUniqueInput[]
    disconnect?: ContentRatingWhereUniqueInput | ContentRatingWhereUniqueInput[]
    delete?: ContentRatingWhereUniqueInput | ContentRatingWhereUniqueInput[]
    connect?: ContentRatingWhereUniqueInput | ContentRatingWhereUniqueInput[]
    update?: ContentRatingUpdateWithWhereUniqueWithoutContentItemInput | ContentRatingUpdateWithWhereUniqueWithoutContentItemInput[]
    updateMany?: ContentRatingUpdateManyWithWhereWithoutContentItemInput | ContentRatingUpdateManyWithWhereWithoutContentItemInput[]
    deleteMany?: ContentRatingScalarWhereInput | ContentRatingScalarWhereInput[]
  }

  export type AIPlaylistItemUncheckedUpdateManyWithoutContentItemNestedInput = {
    create?: XOR<AIPlaylistItemCreateWithoutContentItemInput, AIPlaylistItemUncheckedCreateWithoutContentItemInput> | AIPlaylistItemCreateWithoutContentItemInput[] | AIPlaylistItemUncheckedCreateWithoutContentItemInput[]
    connectOrCreate?: AIPlaylistItemCreateOrConnectWithoutContentItemInput | AIPlaylistItemCreateOrConnectWithoutContentItemInput[]
    upsert?: AIPlaylistItemUpsertWithWhereUniqueWithoutContentItemInput | AIPlaylistItemUpsertWithWhereUniqueWithoutContentItemInput[]
    createMany?: AIPlaylistItemCreateManyContentItemInputEnvelope
    set?: AIPlaylistItemWhereUniqueInput | AIPlaylistItemWhereUniqueInput[]
    disconnect?: AIPlaylistItemWhereUniqueInput | AIPlaylistItemWhereUniqueInput[]
    delete?: AIPlaylistItemWhereUniqueInput | AIPlaylistItemWhereUniqueInput[]
    connect?: AIPlaylistItemWhereUniqueInput | AIPlaylistItemWhereUniqueInput[]
    update?: AIPlaylistItemUpdateWithWhereUniqueWithoutContentItemInput | AIPlaylistItemUpdateWithWhereUniqueWithoutContentItemInput[]
    updateMany?: AIPlaylistItemUpdateManyWithWhereWithoutContentItemInput | AIPlaylistItemUpdateManyWithWhereWithoutContentItemInput[]
    deleteMany?: AIPlaylistItemScalarWhereInput | AIPlaylistItemScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutContentRatingsInput = {
    create?: XOR<UserCreateWithoutContentRatingsInput, UserUncheckedCreateWithoutContentRatingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutContentRatingsInput
    connect?: UserWhereUniqueInput
  }

  export type ContentItemCreateNestedOneWithoutRatingsInput = {
    create?: XOR<ContentItemCreateWithoutRatingsInput, ContentItemUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: ContentItemCreateOrConnectWithoutRatingsInput
    connect?: ContentItemWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutContentRatingsNestedInput = {
    create?: XOR<UserCreateWithoutContentRatingsInput, UserUncheckedCreateWithoutContentRatingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutContentRatingsInput
    upsert?: UserUpsertWithoutContentRatingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutContentRatingsInput, UserUpdateWithoutContentRatingsInput>, UserUncheckedUpdateWithoutContentRatingsInput>
  }

  export type ContentItemUpdateOneRequiredWithoutRatingsNestedInput = {
    create?: XOR<ContentItemCreateWithoutRatingsInput, ContentItemUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: ContentItemCreateOrConnectWithoutRatingsInput
    upsert?: ContentItemUpsertWithoutRatingsInput
    connect?: ContentItemWhereUniqueInput
    update?: XOR<XOR<ContentItemUpdateToOneWithWhereWithoutRatingsInput, ContentItemUpdateWithoutRatingsInput>, ContentItemUncheckedUpdateWithoutRatingsInput>
  }

  export type UserCreateNestedOneWithoutBookmarksInput = {
    create?: XOR<UserCreateWithoutBookmarksInput, UserUncheckedCreateWithoutBookmarksInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookmarksInput
    connect?: UserWhereUniqueInput
  }

  export type ContentItemCreateNestedOneWithoutBookmarksInput = {
    create?: XOR<ContentItemCreateWithoutBookmarksInput, ContentItemUncheckedCreateWithoutBookmarksInput>
    connectOrCreate?: ContentItemCreateOrConnectWithoutBookmarksInput
    connect?: ContentItemWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutBookmarksNestedInput = {
    create?: XOR<UserCreateWithoutBookmarksInput, UserUncheckedCreateWithoutBookmarksInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookmarksInput
    upsert?: UserUpsertWithoutBookmarksInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBookmarksInput, UserUpdateWithoutBookmarksInput>, UserUncheckedUpdateWithoutBookmarksInput>
  }

  export type ContentItemUpdateOneRequiredWithoutBookmarksNestedInput = {
    create?: XOR<ContentItemCreateWithoutBookmarksInput, ContentItemUncheckedCreateWithoutBookmarksInput>
    connectOrCreate?: ContentItemCreateOrConnectWithoutBookmarksInput
    upsert?: ContentItemUpsertWithoutBookmarksInput
    connect?: ContentItemWhereUniqueInput
    update?: XOR<XOR<ContentItemUpdateToOneWithWhereWithoutBookmarksInput, ContentItemUpdateWithoutBookmarksInput>, ContentItemUncheckedUpdateWithoutBookmarksInput>
  }

  export type UserCreateNestedOneWithoutQuizAttemptsInput = {
    create?: XOR<UserCreateWithoutQuizAttemptsInput, UserUncheckedCreateWithoutQuizAttemptsInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuizAttemptsInput
    connect?: UserWhereUniqueInput
  }

  export type ContentItemCreateNestedOneWithoutQuizAttemptsInput = {
    create?: XOR<ContentItemCreateWithoutQuizAttemptsInput, ContentItemUncheckedCreateWithoutQuizAttemptsInput>
    connectOrCreate?: ContentItemCreateOrConnectWithoutQuizAttemptsInput
    connect?: ContentItemWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutQuizAttemptsNestedInput = {
    create?: XOR<UserCreateWithoutQuizAttemptsInput, UserUncheckedCreateWithoutQuizAttemptsInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuizAttemptsInput
    upsert?: UserUpsertWithoutQuizAttemptsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutQuizAttemptsInput, UserUpdateWithoutQuizAttemptsInput>, UserUncheckedUpdateWithoutQuizAttemptsInput>
  }

  export type ContentItemUpdateOneRequiredWithoutQuizAttemptsNestedInput = {
    create?: XOR<ContentItemCreateWithoutQuizAttemptsInput, ContentItemUncheckedCreateWithoutQuizAttemptsInput>
    connectOrCreate?: ContentItemCreateOrConnectWithoutQuizAttemptsInput
    upsert?: ContentItemUpsertWithoutQuizAttemptsInput
    connect?: ContentItemWhereUniqueInput
    update?: XOR<XOR<ContentItemUpdateToOneWithWhereWithoutQuizAttemptsInput, ContentItemUpdateWithoutQuizAttemptsInput>, ContentItemUncheckedUpdateWithoutQuizAttemptsInput>
  }

  export type UserCreateNestedOneWithoutKnowledgeNodesInput = {
    create?: XOR<UserCreateWithoutKnowledgeNodesInput, UserUncheckedCreateWithoutKnowledgeNodesInput>
    connectOrCreate?: UserCreateOrConnectWithoutKnowledgeNodesInput
    connect?: UserWhereUniqueInput
  }

  export type KnowledgeNodeCreateNestedOneWithoutChildrenInput = {
    create?: XOR<KnowledgeNodeCreateWithoutChildrenInput, KnowledgeNodeUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: KnowledgeNodeCreateOrConnectWithoutChildrenInput
    connect?: KnowledgeNodeWhereUniqueInput
  }

  export type KnowledgeNodeCreateNestedManyWithoutParentInput = {
    create?: XOR<KnowledgeNodeCreateWithoutParentInput, KnowledgeNodeUncheckedCreateWithoutParentInput> | KnowledgeNodeCreateWithoutParentInput[] | KnowledgeNodeUncheckedCreateWithoutParentInput[]
    connectOrCreate?: KnowledgeNodeCreateOrConnectWithoutParentInput | KnowledgeNodeCreateOrConnectWithoutParentInput[]
    createMany?: KnowledgeNodeCreateManyParentInputEnvelope
    connect?: KnowledgeNodeWhereUniqueInput | KnowledgeNodeWhereUniqueInput[]
  }

  export type KnowledgeNodeUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<KnowledgeNodeCreateWithoutParentInput, KnowledgeNodeUncheckedCreateWithoutParentInput> | KnowledgeNodeCreateWithoutParentInput[] | KnowledgeNodeUncheckedCreateWithoutParentInput[]
    connectOrCreate?: KnowledgeNodeCreateOrConnectWithoutParentInput | KnowledgeNodeCreateOrConnectWithoutParentInput[]
    createMany?: KnowledgeNodeCreateManyParentInputEnvelope
    connect?: KnowledgeNodeWhereUniqueInput | KnowledgeNodeWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutKnowledgeNodesNestedInput = {
    create?: XOR<UserCreateWithoutKnowledgeNodesInput, UserUncheckedCreateWithoutKnowledgeNodesInput>
    connectOrCreate?: UserCreateOrConnectWithoutKnowledgeNodesInput
    upsert?: UserUpsertWithoutKnowledgeNodesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutKnowledgeNodesInput, UserUpdateWithoutKnowledgeNodesInput>, UserUncheckedUpdateWithoutKnowledgeNodesInput>
  }

  export type KnowledgeNodeUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<KnowledgeNodeCreateWithoutChildrenInput, KnowledgeNodeUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: KnowledgeNodeCreateOrConnectWithoutChildrenInput
    upsert?: KnowledgeNodeUpsertWithoutChildrenInput
    disconnect?: KnowledgeNodeWhereInput | boolean
    delete?: KnowledgeNodeWhereInput | boolean
    connect?: KnowledgeNodeWhereUniqueInput
    update?: XOR<XOR<KnowledgeNodeUpdateToOneWithWhereWithoutChildrenInput, KnowledgeNodeUpdateWithoutChildrenInput>, KnowledgeNodeUncheckedUpdateWithoutChildrenInput>
  }

  export type KnowledgeNodeUpdateManyWithoutParentNestedInput = {
    create?: XOR<KnowledgeNodeCreateWithoutParentInput, KnowledgeNodeUncheckedCreateWithoutParentInput> | KnowledgeNodeCreateWithoutParentInput[] | KnowledgeNodeUncheckedCreateWithoutParentInput[]
    connectOrCreate?: KnowledgeNodeCreateOrConnectWithoutParentInput | KnowledgeNodeCreateOrConnectWithoutParentInput[]
    upsert?: KnowledgeNodeUpsertWithWhereUniqueWithoutParentInput | KnowledgeNodeUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: KnowledgeNodeCreateManyParentInputEnvelope
    set?: KnowledgeNodeWhereUniqueInput | KnowledgeNodeWhereUniqueInput[]
    disconnect?: KnowledgeNodeWhereUniqueInput | KnowledgeNodeWhereUniqueInput[]
    delete?: KnowledgeNodeWhereUniqueInput | KnowledgeNodeWhereUniqueInput[]
    connect?: KnowledgeNodeWhereUniqueInput | KnowledgeNodeWhereUniqueInput[]
    update?: KnowledgeNodeUpdateWithWhereUniqueWithoutParentInput | KnowledgeNodeUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: KnowledgeNodeUpdateManyWithWhereWithoutParentInput | KnowledgeNodeUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: KnowledgeNodeScalarWhereInput | KnowledgeNodeScalarWhereInput[]
  }

  export type KnowledgeNodeUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<KnowledgeNodeCreateWithoutParentInput, KnowledgeNodeUncheckedCreateWithoutParentInput> | KnowledgeNodeCreateWithoutParentInput[] | KnowledgeNodeUncheckedCreateWithoutParentInput[]
    connectOrCreate?: KnowledgeNodeCreateOrConnectWithoutParentInput | KnowledgeNodeCreateOrConnectWithoutParentInput[]
    upsert?: KnowledgeNodeUpsertWithWhereUniqueWithoutParentInput | KnowledgeNodeUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: KnowledgeNodeCreateManyParentInputEnvelope
    set?: KnowledgeNodeWhereUniqueInput | KnowledgeNodeWhereUniqueInput[]
    disconnect?: KnowledgeNodeWhereUniqueInput | KnowledgeNodeWhereUniqueInput[]
    delete?: KnowledgeNodeWhereUniqueInput | KnowledgeNodeWhereUniqueInput[]
    connect?: KnowledgeNodeWhereUniqueInput | KnowledgeNodeWhereUniqueInput[]
    update?: KnowledgeNodeUpdateWithWhereUniqueWithoutParentInput | KnowledgeNodeUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: KnowledgeNodeUpdateManyWithWhereWithoutParentInput | KnowledgeNodeUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: KnowledgeNodeScalarWhereInput | KnowledgeNodeScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutLeaderboardEntriesInput = {
    create?: XOR<UserCreateWithoutLeaderboardEntriesInput, UserUncheckedCreateWithoutLeaderboardEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeaderboardEntriesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLeaderboardEntriesNestedInput = {
    create?: XOR<UserCreateWithoutLeaderboardEntriesInput, UserUncheckedCreateWithoutLeaderboardEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeaderboardEntriesInput
    upsert?: UserUpsertWithoutLeaderboardEntriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLeaderboardEntriesInput, UserUpdateWithoutLeaderboardEntriesInput>, UserUncheckedUpdateWithoutLeaderboardEntriesInput>
  }

  export type UserCreateNestedOneWithoutReviewSessionsInput = {
    create?: XOR<UserCreateWithoutReviewSessionsInput, UserUncheckedCreateWithoutReviewSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type ReviewItemCreateNestedManyWithoutReviewSessionInput = {
    create?: XOR<ReviewItemCreateWithoutReviewSessionInput, ReviewItemUncheckedCreateWithoutReviewSessionInput> | ReviewItemCreateWithoutReviewSessionInput[] | ReviewItemUncheckedCreateWithoutReviewSessionInput[]
    connectOrCreate?: ReviewItemCreateOrConnectWithoutReviewSessionInput | ReviewItemCreateOrConnectWithoutReviewSessionInput[]
    createMany?: ReviewItemCreateManyReviewSessionInputEnvelope
    connect?: ReviewItemWhereUniqueInput | ReviewItemWhereUniqueInput[]
  }

  export type ReviewItemUncheckedCreateNestedManyWithoutReviewSessionInput = {
    create?: XOR<ReviewItemCreateWithoutReviewSessionInput, ReviewItemUncheckedCreateWithoutReviewSessionInput> | ReviewItemCreateWithoutReviewSessionInput[] | ReviewItemUncheckedCreateWithoutReviewSessionInput[]
    connectOrCreate?: ReviewItemCreateOrConnectWithoutReviewSessionInput | ReviewItemCreateOrConnectWithoutReviewSessionInput[]
    createMany?: ReviewItemCreateManyReviewSessionInputEnvelope
    connect?: ReviewItemWhereUniqueInput | ReviewItemWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutReviewSessionsNestedInput = {
    create?: XOR<UserCreateWithoutReviewSessionsInput, UserUncheckedCreateWithoutReviewSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewSessionsInput
    upsert?: UserUpsertWithoutReviewSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewSessionsInput, UserUpdateWithoutReviewSessionsInput>, UserUncheckedUpdateWithoutReviewSessionsInput>
  }

  export type ReviewItemUpdateManyWithoutReviewSessionNestedInput = {
    create?: XOR<ReviewItemCreateWithoutReviewSessionInput, ReviewItemUncheckedCreateWithoutReviewSessionInput> | ReviewItemCreateWithoutReviewSessionInput[] | ReviewItemUncheckedCreateWithoutReviewSessionInput[]
    connectOrCreate?: ReviewItemCreateOrConnectWithoutReviewSessionInput | ReviewItemCreateOrConnectWithoutReviewSessionInput[]
    upsert?: ReviewItemUpsertWithWhereUniqueWithoutReviewSessionInput | ReviewItemUpsertWithWhereUniqueWithoutReviewSessionInput[]
    createMany?: ReviewItemCreateManyReviewSessionInputEnvelope
    set?: ReviewItemWhereUniqueInput | ReviewItemWhereUniqueInput[]
    disconnect?: ReviewItemWhereUniqueInput | ReviewItemWhereUniqueInput[]
    delete?: ReviewItemWhereUniqueInput | ReviewItemWhereUniqueInput[]
    connect?: ReviewItemWhereUniqueInput | ReviewItemWhereUniqueInput[]
    update?: ReviewItemUpdateWithWhereUniqueWithoutReviewSessionInput | ReviewItemUpdateWithWhereUniqueWithoutReviewSessionInput[]
    updateMany?: ReviewItemUpdateManyWithWhereWithoutReviewSessionInput | ReviewItemUpdateManyWithWhereWithoutReviewSessionInput[]
    deleteMany?: ReviewItemScalarWhereInput | ReviewItemScalarWhereInput[]
  }

  export type ReviewItemUncheckedUpdateManyWithoutReviewSessionNestedInput = {
    create?: XOR<ReviewItemCreateWithoutReviewSessionInput, ReviewItemUncheckedCreateWithoutReviewSessionInput> | ReviewItemCreateWithoutReviewSessionInput[] | ReviewItemUncheckedCreateWithoutReviewSessionInput[]
    connectOrCreate?: ReviewItemCreateOrConnectWithoutReviewSessionInput | ReviewItemCreateOrConnectWithoutReviewSessionInput[]
    upsert?: ReviewItemUpsertWithWhereUniqueWithoutReviewSessionInput | ReviewItemUpsertWithWhereUniqueWithoutReviewSessionInput[]
    createMany?: ReviewItemCreateManyReviewSessionInputEnvelope
    set?: ReviewItemWhereUniqueInput | ReviewItemWhereUniqueInput[]
    disconnect?: ReviewItemWhereUniqueInput | ReviewItemWhereUniqueInput[]
    delete?: ReviewItemWhereUniqueInput | ReviewItemWhereUniqueInput[]
    connect?: ReviewItemWhereUniqueInput | ReviewItemWhereUniqueInput[]
    update?: ReviewItemUpdateWithWhereUniqueWithoutReviewSessionInput | ReviewItemUpdateWithWhereUniqueWithoutReviewSessionInput[]
    updateMany?: ReviewItemUpdateManyWithWhereWithoutReviewSessionInput | ReviewItemUpdateManyWithWhereWithoutReviewSessionInput[]
    deleteMany?: ReviewItemScalarWhereInput | ReviewItemScalarWhereInput[]
  }

  export type ReviewSessionCreateNestedOneWithoutItemsInput = {
    create?: XOR<ReviewSessionCreateWithoutItemsInput, ReviewSessionUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ReviewSessionCreateOrConnectWithoutItemsInput
    connect?: ReviewSessionWhereUniqueInput
  }

  export type ContentItemCreateNestedOneWithoutReviewItemsInput = {
    create?: XOR<ContentItemCreateWithoutReviewItemsInput, ContentItemUncheckedCreateWithoutReviewItemsInput>
    connectOrCreate?: ContentItemCreateOrConnectWithoutReviewItemsInput
    connect?: ContentItemWhereUniqueInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type ReviewSessionUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<ReviewSessionCreateWithoutItemsInput, ReviewSessionUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ReviewSessionCreateOrConnectWithoutItemsInput
    upsert?: ReviewSessionUpsertWithoutItemsInput
    connect?: ReviewSessionWhereUniqueInput
    update?: XOR<XOR<ReviewSessionUpdateToOneWithWhereWithoutItemsInput, ReviewSessionUpdateWithoutItemsInput>, ReviewSessionUncheckedUpdateWithoutItemsInput>
  }

  export type ContentItemUpdateOneRequiredWithoutReviewItemsNestedInput = {
    create?: XOR<ContentItemCreateWithoutReviewItemsInput, ContentItemUncheckedCreateWithoutReviewItemsInput>
    connectOrCreate?: ContentItemCreateOrConnectWithoutReviewItemsInput
    upsert?: ContentItemUpsertWithoutReviewItemsInput
    connect?: ContentItemWhereUniqueInput
    update?: XOR<XOR<ContentItemUpdateToOneWithWhereWithoutReviewItemsInput, ContentItemUpdateWithoutReviewItemsInput>, ContentItemUncheckedUpdateWithoutReviewItemsInput>
  }

  export type UserCreateNestedOneWithoutOwnedWorkspacesInput = {
    create?: XOR<UserCreateWithoutOwnedWorkspacesInput, UserUncheckedCreateWithoutOwnedWorkspacesInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedWorkspacesInput
    connect?: UserWhereUniqueInput
  }

  export type WorkspaceMemberCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<WorkspaceMemberCreateWithoutWorkspaceInput, WorkspaceMemberUncheckedCreateWithoutWorkspaceInput> | WorkspaceMemberCreateWithoutWorkspaceInput[] | WorkspaceMemberUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceMemberCreateOrConnectWithoutWorkspaceInput | WorkspaceMemberCreateOrConnectWithoutWorkspaceInput[]
    createMany?: WorkspaceMemberCreateManyWorkspaceInputEnvelope
    connect?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
  }

  export type WhiteboardCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<WhiteboardCreateWithoutWorkspaceInput, WhiteboardUncheckedCreateWithoutWorkspaceInput> | WhiteboardCreateWithoutWorkspaceInput[] | WhiteboardUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WhiteboardCreateOrConnectWithoutWorkspaceInput | WhiteboardCreateOrConnectWithoutWorkspaceInput[]
    createMany?: WhiteboardCreateManyWorkspaceInputEnvelope
    connect?: WhiteboardWhereUniqueInput | WhiteboardWhereUniqueInput[]
  }

  export type ChatCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<ChatCreateWithoutWorkspaceInput, ChatUncheckedCreateWithoutWorkspaceInput> | ChatCreateWithoutWorkspaceInput[] | ChatUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutWorkspaceInput | ChatCreateOrConnectWithoutWorkspaceInput[]
    createMany?: ChatCreateManyWorkspaceInputEnvelope
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
  }

  export type BreakoutRoomCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<BreakoutRoomCreateWithoutWorkspaceInput, BreakoutRoomUncheckedCreateWithoutWorkspaceInput> | BreakoutRoomCreateWithoutWorkspaceInput[] | BreakoutRoomUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: BreakoutRoomCreateOrConnectWithoutWorkspaceInput | BreakoutRoomCreateOrConnectWithoutWorkspaceInput[]
    createMany?: BreakoutRoomCreateManyWorkspaceInputEnvelope
    connect?: BreakoutRoomWhereUniqueInput | BreakoutRoomWhereUniqueInput[]
  }

  export type LivePollCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<LivePollCreateWithoutWorkspaceInput, LivePollUncheckedCreateWithoutWorkspaceInput> | LivePollCreateWithoutWorkspaceInput[] | LivePollUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: LivePollCreateOrConnectWithoutWorkspaceInput | LivePollCreateOrConnectWithoutWorkspaceInput[]
    createMany?: LivePollCreateManyWorkspaceInputEnvelope
    connect?: LivePollWhereUniqueInput | LivePollWhereUniqueInput[]
  }

  export type SessionSummaryCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<SessionSummaryCreateWithoutWorkspaceInput, SessionSummaryUncheckedCreateWithoutWorkspaceInput> | SessionSummaryCreateWithoutWorkspaceInput[] | SessionSummaryUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: SessionSummaryCreateOrConnectWithoutWorkspaceInput | SessionSummaryCreateOrConnectWithoutWorkspaceInput[]
    createMany?: SessionSummaryCreateManyWorkspaceInputEnvelope
    connect?: SessionSummaryWhereUniqueInput | SessionSummaryWhereUniqueInput[]
  }

  export type WorkspaceMemberUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<WorkspaceMemberCreateWithoutWorkspaceInput, WorkspaceMemberUncheckedCreateWithoutWorkspaceInput> | WorkspaceMemberCreateWithoutWorkspaceInput[] | WorkspaceMemberUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceMemberCreateOrConnectWithoutWorkspaceInput | WorkspaceMemberCreateOrConnectWithoutWorkspaceInput[]
    createMany?: WorkspaceMemberCreateManyWorkspaceInputEnvelope
    connect?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
  }

  export type WhiteboardUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<WhiteboardCreateWithoutWorkspaceInput, WhiteboardUncheckedCreateWithoutWorkspaceInput> | WhiteboardCreateWithoutWorkspaceInput[] | WhiteboardUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WhiteboardCreateOrConnectWithoutWorkspaceInput | WhiteboardCreateOrConnectWithoutWorkspaceInput[]
    createMany?: WhiteboardCreateManyWorkspaceInputEnvelope
    connect?: WhiteboardWhereUniqueInput | WhiteboardWhereUniqueInput[]
  }

  export type ChatUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<ChatCreateWithoutWorkspaceInput, ChatUncheckedCreateWithoutWorkspaceInput> | ChatCreateWithoutWorkspaceInput[] | ChatUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutWorkspaceInput | ChatCreateOrConnectWithoutWorkspaceInput[]
    createMany?: ChatCreateManyWorkspaceInputEnvelope
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
  }

  export type BreakoutRoomUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<BreakoutRoomCreateWithoutWorkspaceInput, BreakoutRoomUncheckedCreateWithoutWorkspaceInput> | BreakoutRoomCreateWithoutWorkspaceInput[] | BreakoutRoomUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: BreakoutRoomCreateOrConnectWithoutWorkspaceInput | BreakoutRoomCreateOrConnectWithoutWorkspaceInput[]
    createMany?: BreakoutRoomCreateManyWorkspaceInputEnvelope
    connect?: BreakoutRoomWhereUniqueInput | BreakoutRoomWhereUniqueInput[]
  }

  export type LivePollUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<LivePollCreateWithoutWorkspaceInput, LivePollUncheckedCreateWithoutWorkspaceInput> | LivePollCreateWithoutWorkspaceInput[] | LivePollUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: LivePollCreateOrConnectWithoutWorkspaceInput | LivePollCreateOrConnectWithoutWorkspaceInput[]
    createMany?: LivePollCreateManyWorkspaceInputEnvelope
    connect?: LivePollWhereUniqueInput | LivePollWhereUniqueInput[]
  }

  export type SessionSummaryUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<SessionSummaryCreateWithoutWorkspaceInput, SessionSummaryUncheckedCreateWithoutWorkspaceInput> | SessionSummaryCreateWithoutWorkspaceInput[] | SessionSummaryUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: SessionSummaryCreateOrConnectWithoutWorkspaceInput | SessionSummaryCreateOrConnectWithoutWorkspaceInput[]
    createMany?: SessionSummaryCreateManyWorkspaceInputEnvelope
    connect?: SessionSummaryWhereUniqueInput | SessionSummaryWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutOwnedWorkspacesNestedInput = {
    create?: XOR<UserCreateWithoutOwnedWorkspacesInput, UserUncheckedCreateWithoutOwnedWorkspacesInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedWorkspacesInput
    upsert?: UserUpsertWithoutOwnedWorkspacesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOwnedWorkspacesInput, UserUpdateWithoutOwnedWorkspacesInput>, UserUncheckedUpdateWithoutOwnedWorkspacesInput>
  }

  export type WorkspaceMemberUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<WorkspaceMemberCreateWithoutWorkspaceInput, WorkspaceMemberUncheckedCreateWithoutWorkspaceInput> | WorkspaceMemberCreateWithoutWorkspaceInput[] | WorkspaceMemberUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceMemberCreateOrConnectWithoutWorkspaceInput | WorkspaceMemberCreateOrConnectWithoutWorkspaceInput[]
    upsert?: WorkspaceMemberUpsertWithWhereUniqueWithoutWorkspaceInput | WorkspaceMemberUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: WorkspaceMemberCreateManyWorkspaceInputEnvelope
    set?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
    disconnect?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
    delete?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
    connect?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
    update?: WorkspaceMemberUpdateWithWhereUniqueWithoutWorkspaceInput | WorkspaceMemberUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: WorkspaceMemberUpdateManyWithWhereWithoutWorkspaceInput | WorkspaceMemberUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: WorkspaceMemberScalarWhereInput | WorkspaceMemberScalarWhereInput[]
  }

  export type WhiteboardUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<WhiteboardCreateWithoutWorkspaceInput, WhiteboardUncheckedCreateWithoutWorkspaceInput> | WhiteboardCreateWithoutWorkspaceInput[] | WhiteboardUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WhiteboardCreateOrConnectWithoutWorkspaceInput | WhiteboardCreateOrConnectWithoutWorkspaceInput[]
    upsert?: WhiteboardUpsertWithWhereUniqueWithoutWorkspaceInput | WhiteboardUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: WhiteboardCreateManyWorkspaceInputEnvelope
    set?: WhiteboardWhereUniqueInput | WhiteboardWhereUniqueInput[]
    disconnect?: WhiteboardWhereUniqueInput | WhiteboardWhereUniqueInput[]
    delete?: WhiteboardWhereUniqueInput | WhiteboardWhereUniqueInput[]
    connect?: WhiteboardWhereUniqueInput | WhiteboardWhereUniqueInput[]
    update?: WhiteboardUpdateWithWhereUniqueWithoutWorkspaceInput | WhiteboardUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: WhiteboardUpdateManyWithWhereWithoutWorkspaceInput | WhiteboardUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: WhiteboardScalarWhereInput | WhiteboardScalarWhereInput[]
  }

  export type ChatUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<ChatCreateWithoutWorkspaceInput, ChatUncheckedCreateWithoutWorkspaceInput> | ChatCreateWithoutWorkspaceInput[] | ChatUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutWorkspaceInput | ChatCreateOrConnectWithoutWorkspaceInput[]
    upsert?: ChatUpsertWithWhereUniqueWithoutWorkspaceInput | ChatUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: ChatCreateManyWorkspaceInputEnvelope
    set?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    disconnect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    delete?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    update?: ChatUpdateWithWhereUniqueWithoutWorkspaceInput | ChatUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: ChatUpdateManyWithWhereWithoutWorkspaceInput | ChatUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: ChatScalarWhereInput | ChatScalarWhereInput[]
  }

  export type BreakoutRoomUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<BreakoutRoomCreateWithoutWorkspaceInput, BreakoutRoomUncheckedCreateWithoutWorkspaceInput> | BreakoutRoomCreateWithoutWorkspaceInput[] | BreakoutRoomUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: BreakoutRoomCreateOrConnectWithoutWorkspaceInput | BreakoutRoomCreateOrConnectWithoutWorkspaceInput[]
    upsert?: BreakoutRoomUpsertWithWhereUniqueWithoutWorkspaceInput | BreakoutRoomUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: BreakoutRoomCreateManyWorkspaceInputEnvelope
    set?: BreakoutRoomWhereUniqueInput | BreakoutRoomWhereUniqueInput[]
    disconnect?: BreakoutRoomWhereUniqueInput | BreakoutRoomWhereUniqueInput[]
    delete?: BreakoutRoomWhereUniqueInput | BreakoutRoomWhereUniqueInput[]
    connect?: BreakoutRoomWhereUniqueInput | BreakoutRoomWhereUniqueInput[]
    update?: BreakoutRoomUpdateWithWhereUniqueWithoutWorkspaceInput | BreakoutRoomUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: BreakoutRoomUpdateManyWithWhereWithoutWorkspaceInput | BreakoutRoomUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: BreakoutRoomScalarWhereInput | BreakoutRoomScalarWhereInput[]
  }

  export type LivePollUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<LivePollCreateWithoutWorkspaceInput, LivePollUncheckedCreateWithoutWorkspaceInput> | LivePollCreateWithoutWorkspaceInput[] | LivePollUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: LivePollCreateOrConnectWithoutWorkspaceInput | LivePollCreateOrConnectWithoutWorkspaceInput[]
    upsert?: LivePollUpsertWithWhereUniqueWithoutWorkspaceInput | LivePollUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: LivePollCreateManyWorkspaceInputEnvelope
    set?: LivePollWhereUniqueInput | LivePollWhereUniqueInput[]
    disconnect?: LivePollWhereUniqueInput | LivePollWhereUniqueInput[]
    delete?: LivePollWhereUniqueInput | LivePollWhereUniqueInput[]
    connect?: LivePollWhereUniqueInput | LivePollWhereUniqueInput[]
    update?: LivePollUpdateWithWhereUniqueWithoutWorkspaceInput | LivePollUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: LivePollUpdateManyWithWhereWithoutWorkspaceInput | LivePollUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: LivePollScalarWhereInput | LivePollScalarWhereInput[]
  }

  export type SessionSummaryUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<SessionSummaryCreateWithoutWorkspaceInput, SessionSummaryUncheckedCreateWithoutWorkspaceInput> | SessionSummaryCreateWithoutWorkspaceInput[] | SessionSummaryUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: SessionSummaryCreateOrConnectWithoutWorkspaceInput | SessionSummaryCreateOrConnectWithoutWorkspaceInput[]
    upsert?: SessionSummaryUpsertWithWhereUniqueWithoutWorkspaceInput | SessionSummaryUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: SessionSummaryCreateManyWorkspaceInputEnvelope
    set?: SessionSummaryWhereUniqueInput | SessionSummaryWhereUniqueInput[]
    disconnect?: SessionSummaryWhereUniqueInput | SessionSummaryWhereUniqueInput[]
    delete?: SessionSummaryWhereUniqueInput | SessionSummaryWhereUniqueInput[]
    connect?: SessionSummaryWhereUniqueInput | SessionSummaryWhereUniqueInput[]
    update?: SessionSummaryUpdateWithWhereUniqueWithoutWorkspaceInput | SessionSummaryUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: SessionSummaryUpdateManyWithWhereWithoutWorkspaceInput | SessionSummaryUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: SessionSummaryScalarWhereInput | SessionSummaryScalarWhereInput[]
  }

  export type WorkspaceMemberUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<WorkspaceMemberCreateWithoutWorkspaceInput, WorkspaceMemberUncheckedCreateWithoutWorkspaceInput> | WorkspaceMemberCreateWithoutWorkspaceInput[] | WorkspaceMemberUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceMemberCreateOrConnectWithoutWorkspaceInput | WorkspaceMemberCreateOrConnectWithoutWorkspaceInput[]
    upsert?: WorkspaceMemberUpsertWithWhereUniqueWithoutWorkspaceInput | WorkspaceMemberUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: WorkspaceMemberCreateManyWorkspaceInputEnvelope
    set?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
    disconnect?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
    delete?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
    connect?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
    update?: WorkspaceMemberUpdateWithWhereUniqueWithoutWorkspaceInput | WorkspaceMemberUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: WorkspaceMemberUpdateManyWithWhereWithoutWorkspaceInput | WorkspaceMemberUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: WorkspaceMemberScalarWhereInput | WorkspaceMemberScalarWhereInput[]
  }

  export type WhiteboardUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<WhiteboardCreateWithoutWorkspaceInput, WhiteboardUncheckedCreateWithoutWorkspaceInput> | WhiteboardCreateWithoutWorkspaceInput[] | WhiteboardUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WhiteboardCreateOrConnectWithoutWorkspaceInput | WhiteboardCreateOrConnectWithoutWorkspaceInput[]
    upsert?: WhiteboardUpsertWithWhereUniqueWithoutWorkspaceInput | WhiteboardUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: WhiteboardCreateManyWorkspaceInputEnvelope
    set?: WhiteboardWhereUniqueInput | WhiteboardWhereUniqueInput[]
    disconnect?: WhiteboardWhereUniqueInput | WhiteboardWhereUniqueInput[]
    delete?: WhiteboardWhereUniqueInput | WhiteboardWhereUniqueInput[]
    connect?: WhiteboardWhereUniqueInput | WhiteboardWhereUniqueInput[]
    update?: WhiteboardUpdateWithWhereUniqueWithoutWorkspaceInput | WhiteboardUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: WhiteboardUpdateManyWithWhereWithoutWorkspaceInput | WhiteboardUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: WhiteboardScalarWhereInput | WhiteboardScalarWhereInput[]
  }

  export type ChatUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<ChatCreateWithoutWorkspaceInput, ChatUncheckedCreateWithoutWorkspaceInput> | ChatCreateWithoutWorkspaceInput[] | ChatUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutWorkspaceInput | ChatCreateOrConnectWithoutWorkspaceInput[]
    upsert?: ChatUpsertWithWhereUniqueWithoutWorkspaceInput | ChatUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: ChatCreateManyWorkspaceInputEnvelope
    set?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    disconnect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    delete?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    update?: ChatUpdateWithWhereUniqueWithoutWorkspaceInput | ChatUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: ChatUpdateManyWithWhereWithoutWorkspaceInput | ChatUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: ChatScalarWhereInput | ChatScalarWhereInput[]
  }

  export type BreakoutRoomUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<BreakoutRoomCreateWithoutWorkspaceInput, BreakoutRoomUncheckedCreateWithoutWorkspaceInput> | BreakoutRoomCreateWithoutWorkspaceInput[] | BreakoutRoomUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: BreakoutRoomCreateOrConnectWithoutWorkspaceInput | BreakoutRoomCreateOrConnectWithoutWorkspaceInput[]
    upsert?: BreakoutRoomUpsertWithWhereUniqueWithoutWorkspaceInput | BreakoutRoomUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: BreakoutRoomCreateManyWorkspaceInputEnvelope
    set?: BreakoutRoomWhereUniqueInput | BreakoutRoomWhereUniqueInput[]
    disconnect?: BreakoutRoomWhereUniqueInput | BreakoutRoomWhereUniqueInput[]
    delete?: BreakoutRoomWhereUniqueInput | BreakoutRoomWhereUniqueInput[]
    connect?: BreakoutRoomWhereUniqueInput | BreakoutRoomWhereUniqueInput[]
    update?: BreakoutRoomUpdateWithWhereUniqueWithoutWorkspaceInput | BreakoutRoomUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: BreakoutRoomUpdateManyWithWhereWithoutWorkspaceInput | BreakoutRoomUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: BreakoutRoomScalarWhereInput | BreakoutRoomScalarWhereInput[]
  }

  export type LivePollUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<LivePollCreateWithoutWorkspaceInput, LivePollUncheckedCreateWithoutWorkspaceInput> | LivePollCreateWithoutWorkspaceInput[] | LivePollUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: LivePollCreateOrConnectWithoutWorkspaceInput | LivePollCreateOrConnectWithoutWorkspaceInput[]
    upsert?: LivePollUpsertWithWhereUniqueWithoutWorkspaceInput | LivePollUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: LivePollCreateManyWorkspaceInputEnvelope
    set?: LivePollWhereUniqueInput | LivePollWhereUniqueInput[]
    disconnect?: LivePollWhereUniqueInput | LivePollWhereUniqueInput[]
    delete?: LivePollWhereUniqueInput | LivePollWhereUniqueInput[]
    connect?: LivePollWhereUniqueInput | LivePollWhereUniqueInput[]
    update?: LivePollUpdateWithWhereUniqueWithoutWorkspaceInput | LivePollUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: LivePollUpdateManyWithWhereWithoutWorkspaceInput | LivePollUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: LivePollScalarWhereInput | LivePollScalarWhereInput[]
  }

  export type SessionSummaryUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<SessionSummaryCreateWithoutWorkspaceInput, SessionSummaryUncheckedCreateWithoutWorkspaceInput> | SessionSummaryCreateWithoutWorkspaceInput[] | SessionSummaryUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: SessionSummaryCreateOrConnectWithoutWorkspaceInput | SessionSummaryCreateOrConnectWithoutWorkspaceInput[]
    upsert?: SessionSummaryUpsertWithWhereUniqueWithoutWorkspaceInput | SessionSummaryUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: SessionSummaryCreateManyWorkspaceInputEnvelope
    set?: SessionSummaryWhereUniqueInput | SessionSummaryWhereUniqueInput[]
    disconnect?: SessionSummaryWhereUniqueInput | SessionSummaryWhereUniqueInput[]
    delete?: SessionSummaryWhereUniqueInput | SessionSummaryWhereUniqueInput[]
    connect?: SessionSummaryWhereUniqueInput | SessionSummaryWhereUniqueInput[]
    update?: SessionSummaryUpdateWithWhereUniqueWithoutWorkspaceInput | SessionSummaryUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: SessionSummaryUpdateManyWithWhereWithoutWorkspaceInput | SessionSummaryUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: SessionSummaryScalarWhereInput | SessionSummaryScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutWorkspacesInput = {
    create?: XOR<UserCreateWithoutWorkspacesInput, UserUncheckedCreateWithoutWorkspacesInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkspacesInput
    connect?: UserWhereUniqueInput
  }

  export type WorkspaceCreateNestedOneWithoutMembersInput = {
    create?: XOR<WorkspaceCreateWithoutMembersInput, WorkspaceUncheckedCreateWithoutMembersInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutMembersInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type BreakoutRoomCreateNestedManyWithoutParticipantsInput = {
    create?: XOR<BreakoutRoomCreateWithoutParticipantsInput, BreakoutRoomUncheckedCreateWithoutParticipantsInput> | BreakoutRoomCreateWithoutParticipantsInput[] | BreakoutRoomUncheckedCreateWithoutParticipantsInput[]
    connectOrCreate?: BreakoutRoomCreateOrConnectWithoutParticipantsInput | BreakoutRoomCreateOrConnectWithoutParticipantsInput[]
    connect?: BreakoutRoomWhereUniqueInput | BreakoutRoomWhereUniqueInput[]
  }

  export type BreakoutRoomUncheckedCreateNestedManyWithoutParticipantsInput = {
    create?: XOR<BreakoutRoomCreateWithoutParticipantsInput, BreakoutRoomUncheckedCreateWithoutParticipantsInput> | BreakoutRoomCreateWithoutParticipantsInput[] | BreakoutRoomUncheckedCreateWithoutParticipantsInput[]
    connectOrCreate?: BreakoutRoomCreateOrConnectWithoutParticipantsInput | BreakoutRoomCreateOrConnectWithoutParticipantsInput[]
    connect?: BreakoutRoomWhereUniqueInput | BreakoutRoomWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutWorkspacesNestedInput = {
    create?: XOR<UserCreateWithoutWorkspacesInput, UserUncheckedCreateWithoutWorkspacesInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkspacesInput
    upsert?: UserUpsertWithoutWorkspacesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWorkspacesInput, UserUpdateWithoutWorkspacesInput>, UserUncheckedUpdateWithoutWorkspacesInput>
  }

  export type WorkspaceUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<WorkspaceCreateWithoutMembersInput, WorkspaceUncheckedCreateWithoutMembersInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutMembersInput
    upsert?: WorkspaceUpsertWithoutMembersInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutMembersInput, WorkspaceUpdateWithoutMembersInput>, WorkspaceUncheckedUpdateWithoutMembersInput>
  }

  export type BreakoutRoomUpdateManyWithoutParticipantsNestedInput = {
    create?: XOR<BreakoutRoomCreateWithoutParticipantsInput, BreakoutRoomUncheckedCreateWithoutParticipantsInput> | BreakoutRoomCreateWithoutParticipantsInput[] | BreakoutRoomUncheckedCreateWithoutParticipantsInput[]
    connectOrCreate?: BreakoutRoomCreateOrConnectWithoutParticipantsInput | BreakoutRoomCreateOrConnectWithoutParticipantsInput[]
    upsert?: BreakoutRoomUpsertWithWhereUniqueWithoutParticipantsInput | BreakoutRoomUpsertWithWhereUniqueWithoutParticipantsInput[]
    set?: BreakoutRoomWhereUniqueInput | BreakoutRoomWhereUniqueInput[]
    disconnect?: BreakoutRoomWhereUniqueInput | BreakoutRoomWhereUniqueInput[]
    delete?: BreakoutRoomWhereUniqueInput | BreakoutRoomWhereUniqueInput[]
    connect?: BreakoutRoomWhereUniqueInput | BreakoutRoomWhereUniqueInput[]
    update?: BreakoutRoomUpdateWithWhereUniqueWithoutParticipantsInput | BreakoutRoomUpdateWithWhereUniqueWithoutParticipantsInput[]
    updateMany?: BreakoutRoomUpdateManyWithWhereWithoutParticipantsInput | BreakoutRoomUpdateManyWithWhereWithoutParticipantsInput[]
    deleteMany?: BreakoutRoomScalarWhereInput | BreakoutRoomScalarWhereInput[]
  }

  export type BreakoutRoomUncheckedUpdateManyWithoutParticipantsNestedInput = {
    create?: XOR<BreakoutRoomCreateWithoutParticipantsInput, BreakoutRoomUncheckedCreateWithoutParticipantsInput> | BreakoutRoomCreateWithoutParticipantsInput[] | BreakoutRoomUncheckedCreateWithoutParticipantsInput[]
    connectOrCreate?: BreakoutRoomCreateOrConnectWithoutParticipantsInput | BreakoutRoomCreateOrConnectWithoutParticipantsInput[]
    upsert?: BreakoutRoomUpsertWithWhereUniqueWithoutParticipantsInput | BreakoutRoomUpsertWithWhereUniqueWithoutParticipantsInput[]
    set?: BreakoutRoomWhereUniqueInput | BreakoutRoomWhereUniqueInput[]
    disconnect?: BreakoutRoomWhereUniqueInput | BreakoutRoomWhereUniqueInput[]
    delete?: BreakoutRoomWhereUniqueInput | BreakoutRoomWhereUniqueInput[]
    connect?: BreakoutRoomWhereUniqueInput | BreakoutRoomWhereUniqueInput[]
    update?: BreakoutRoomUpdateWithWhereUniqueWithoutParticipantsInput | BreakoutRoomUpdateWithWhereUniqueWithoutParticipantsInput[]
    updateMany?: BreakoutRoomUpdateManyWithWhereWithoutParticipantsInput | BreakoutRoomUpdateManyWithWhereWithoutParticipantsInput[]
    deleteMany?: BreakoutRoomScalarWhereInput | BreakoutRoomScalarWhereInput[]
  }

  export type WorkspaceCreateNestedOneWithoutWhiteboardsInput = {
    create?: XOR<WorkspaceCreateWithoutWhiteboardsInput, WorkspaceUncheckedCreateWithoutWhiteboardsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutWhiteboardsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type WhiteboardVersionCreateNestedManyWithoutWhiteboardInput = {
    create?: XOR<WhiteboardVersionCreateWithoutWhiteboardInput, WhiteboardVersionUncheckedCreateWithoutWhiteboardInput> | WhiteboardVersionCreateWithoutWhiteboardInput[] | WhiteboardVersionUncheckedCreateWithoutWhiteboardInput[]
    connectOrCreate?: WhiteboardVersionCreateOrConnectWithoutWhiteboardInput | WhiteboardVersionCreateOrConnectWithoutWhiteboardInput[]
    createMany?: WhiteboardVersionCreateManyWhiteboardInputEnvelope
    connect?: WhiteboardVersionWhereUniqueInput | WhiteboardVersionWhereUniqueInput[]
  }

  export type WhiteboardVersionUncheckedCreateNestedManyWithoutWhiteboardInput = {
    create?: XOR<WhiteboardVersionCreateWithoutWhiteboardInput, WhiteboardVersionUncheckedCreateWithoutWhiteboardInput> | WhiteboardVersionCreateWithoutWhiteboardInput[] | WhiteboardVersionUncheckedCreateWithoutWhiteboardInput[]
    connectOrCreate?: WhiteboardVersionCreateOrConnectWithoutWhiteboardInput | WhiteboardVersionCreateOrConnectWithoutWhiteboardInput[]
    createMany?: WhiteboardVersionCreateManyWhiteboardInputEnvelope
    connect?: WhiteboardVersionWhereUniqueInput | WhiteboardVersionWhereUniqueInput[]
  }

  export type WorkspaceUpdateOneRequiredWithoutWhiteboardsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutWhiteboardsInput, WorkspaceUncheckedCreateWithoutWhiteboardsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutWhiteboardsInput
    upsert?: WorkspaceUpsertWithoutWhiteboardsInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutWhiteboardsInput, WorkspaceUpdateWithoutWhiteboardsInput>, WorkspaceUncheckedUpdateWithoutWhiteboardsInput>
  }

  export type WhiteboardVersionUpdateManyWithoutWhiteboardNestedInput = {
    create?: XOR<WhiteboardVersionCreateWithoutWhiteboardInput, WhiteboardVersionUncheckedCreateWithoutWhiteboardInput> | WhiteboardVersionCreateWithoutWhiteboardInput[] | WhiteboardVersionUncheckedCreateWithoutWhiteboardInput[]
    connectOrCreate?: WhiteboardVersionCreateOrConnectWithoutWhiteboardInput | WhiteboardVersionCreateOrConnectWithoutWhiteboardInput[]
    upsert?: WhiteboardVersionUpsertWithWhereUniqueWithoutWhiteboardInput | WhiteboardVersionUpsertWithWhereUniqueWithoutWhiteboardInput[]
    createMany?: WhiteboardVersionCreateManyWhiteboardInputEnvelope
    set?: WhiteboardVersionWhereUniqueInput | WhiteboardVersionWhereUniqueInput[]
    disconnect?: WhiteboardVersionWhereUniqueInput | WhiteboardVersionWhereUniqueInput[]
    delete?: WhiteboardVersionWhereUniqueInput | WhiteboardVersionWhereUniqueInput[]
    connect?: WhiteboardVersionWhereUniqueInput | WhiteboardVersionWhereUniqueInput[]
    update?: WhiteboardVersionUpdateWithWhereUniqueWithoutWhiteboardInput | WhiteboardVersionUpdateWithWhereUniqueWithoutWhiteboardInput[]
    updateMany?: WhiteboardVersionUpdateManyWithWhereWithoutWhiteboardInput | WhiteboardVersionUpdateManyWithWhereWithoutWhiteboardInput[]
    deleteMany?: WhiteboardVersionScalarWhereInput | WhiteboardVersionScalarWhereInput[]
  }

  export type WhiteboardVersionUncheckedUpdateManyWithoutWhiteboardNestedInput = {
    create?: XOR<WhiteboardVersionCreateWithoutWhiteboardInput, WhiteboardVersionUncheckedCreateWithoutWhiteboardInput> | WhiteboardVersionCreateWithoutWhiteboardInput[] | WhiteboardVersionUncheckedCreateWithoutWhiteboardInput[]
    connectOrCreate?: WhiteboardVersionCreateOrConnectWithoutWhiteboardInput | WhiteboardVersionCreateOrConnectWithoutWhiteboardInput[]
    upsert?: WhiteboardVersionUpsertWithWhereUniqueWithoutWhiteboardInput | WhiteboardVersionUpsertWithWhereUniqueWithoutWhiteboardInput[]
    createMany?: WhiteboardVersionCreateManyWhiteboardInputEnvelope
    set?: WhiteboardVersionWhereUniqueInput | WhiteboardVersionWhereUniqueInput[]
    disconnect?: WhiteboardVersionWhereUniqueInput | WhiteboardVersionWhereUniqueInput[]
    delete?: WhiteboardVersionWhereUniqueInput | WhiteboardVersionWhereUniqueInput[]
    connect?: WhiteboardVersionWhereUniqueInput | WhiteboardVersionWhereUniqueInput[]
    update?: WhiteboardVersionUpdateWithWhereUniqueWithoutWhiteboardInput | WhiteboardVersionUpdateWithWhereUniqueWithoutWhiteboardInput[]
    updateMany?: WhiteboardVersionUpdateManyWithWhereWithoutWhiteboardInput | WhiteboardVersionUpdateManyWithWhereWithoutWhiteboardInput[]
    deleteMany?: WhiteboardVersionScalarWhereInput | WhiteboardVersionScalarWhereInput[]
  }

  export type WhiteboardCreateNestedOneWithoutVersionsInput = {
    create?: XOR<WhiteboardCreateWithoutVersionsInput, WhiteboardUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: WhiteboardCreateOrConnectWithoutVersionsInput
    connect?: WhiteboardWhereUniqueInput
  }

  export type WhiteboardUpdateOneRequiredWithoutVersionsNestedInput = {
    create?: XOR<WhiteboardCreateWithoutVersionsInput, WhiteboardUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: WhiteboardCreateOrConnectWithoutVersionsInput
    upsert?: WhiteboardUpsertWithoutVersionsInput
    connect?: WhiteboardWhereUniqueInput
    update?: XOR<XOR<WhiteboardUpdateToOneWithWhereWithoutVersionsInput, WhiteboardUpdateWithoutVersionsInput>, WhiteboardUncheckedUpdateWithoutVersionsInput>
  }

  export type WorkspaceCreateNestedOneWithoutBreakoutRoomsInput = {
    create?: XOR<WorkspaceCreateWithoutBreakoutRoomsInput, WorkspaceUncheckedCreateWithoutBreakoutRoomsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutBreakoutRoomsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type WorkspaceMemberCreateNestedManyWithoutBreakoutRoomsInput = {
    create?: XOR<WorkspaceMemberCreateWithoutBreakoutRoomsInput, WorkspaceMemberUncheckedCreateWithoutBreakoutRoomsInput> | WorkspaceMemberCreateWithoutBreakoutRoomsInput[] | WorkspaceMemberUncheckedCreateWithoutBreakoutRoomsInput[]
    connectOrCreate?: WorkspaceMemberCreateOrConnectWithoutBreakoutRoomsInput | WorkspaceMemberCreateOrConnectWithoutBreakoutRoomsInput[]
    connect?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
  }

  export type WorkspaceMemberUncheckedCreateNestedManyWithoutBreakoutRoomsInput = {
    create?: XOR<WorkspaceMemberCreateWithoutBreakoutRoomsInput, WorkspaceMemberUncheckedCreateWithoutBreakoutRoomsInput> | WorkspaceMemberCreateWithoutBreakoutRoomsInput[] | WorkspaceMemberUncheckedCreateWithoutBreakoutRoomsInput[]
    connectOrCreate?: WorkspaceMemberCreateOrConnectWithoutBreakoutRoomsInput | WorkspaceMemberCreateOrConnectWithoutBreakoutRoomsInput[]
    connect?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
  }

  export type WorkspaceUpdateOneRequiredWithoutBreakoutRoomsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutBreakoutRoomsInput, WorkspaceUncheckedCreateWithoutBreakoutRoomsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutBreakoutRoomsInput
    upsert?: WorkspaceUpsertWithoutBreakoutRoomsInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutBreakoutRoomsInput, WorkspaceUpdateWithoutBreakoutRoomsInput>, WorkspaceUncheckedUpdateWithoutBreakoutRoomsInput>
  }

  export type WorkspaceMemberUpdateManyWithoutBreakoutRoomsNestedInput = {
    create?: XOR<WorkspaceMemberCreateWithoutBreakoutRoomsInput, WorkspaceMemberUncheckedCreateWithoutBreakoutRoomsInput> | WorkspaceMemberCreateWithoutBreakoutRoomsInput[] | WorkspaceMemberUncheckedCreateWithoutBreakoutRoomsInput[]
    connectOrCreate?: WorkspaceMemberCreateOrConnectWithoutBreakoutRoomsInput | WorkspaceMemberCreateOrConnectWithoutBreakoutRoomsInput[]
    upsert?: WorkspaceMemberUpsertWithWhereUniqueWithoutBreakoutRoomsInput | WorkspaceMemberUpsertWithWhereUniqueWithoutBreakoutRoomsInput[]
    set?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
    disconnect?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
    delete?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
    connect?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
    update?: WorkspaceMemberUpdateWithWhereUniqueWithoutBreakoutRoomsInput | WorkspaceMemberUpdateWithWhereUniqueWithoutBreakoutRoomsInput[]
    updateMany?: WorkspaceMemberUpdateManyWithWhereWithoutBreakoutRoomsInput | WorkspaceMemberUpdateManyWithWhereWithoutBreakoutRoomsInput[]
    deleteMany?: WorkspaceMemberScalarWhereInput | WorkspaceMemberScalarWhereInput[]
  }

  export type WorkspaceMemberUncheckedUpdateManyWithoutBreakoutRoomsNestedInput = {
    create?: XOR<WorkspaceMemberCreateWithoutBreakoutRoomsInput, WorkspaceMemberUncheckedCreateWithoutBreakoutRoomsInput> | WorkspaceMemberCreateWithoutBreakoutRoomsInput[] | WorkspaceMemberUncheckedCreateWithoutBreakoutRoomsInput[]
    connectOrCreate?: WorkspaceMemberCreateOrConnectWithoutBreakoutRoomsInput | WorkspaceMemberCreateOrConnectWithoutBreakoutRoomsInput[]
    upsert?: WorkspaceMemberUpsertWithWhereUniqueWithoutBreakoutRoomsInput | WorkspaceMemberUpsertWithWhereUniqueWithoutBreakoutRoomsInput[]
    set?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
    disconnect?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
    delete?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
    connect?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
    update?: WorkspaceMemberUpdateWithWhereUniqueWithoutBreakoutRoomsInput | WorkspaceMemberUpdateWithWhereUniqueWithoutBreakoutRoomsInput[]
    updateMany?: WorkspaceMemberUpdateManyWithWhereWithoutBreakoutRoomsInput | WorkspaceMemberUpdateManyWithWhereWithoutBreakoutRoomsInput[]
    deleteMany?: WorkspaceMemberScalarWhereInput | WorkspaceMemberScalarWhereInput[]
  }

  export type WorkspaceCreateNestedOneWithoutLivePollsInput = {
    create?: XOR<WorkspaceCreateWithoutLivePollsInput, WorkspaceUncheckedCreateWithoutLivePollsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutLivePollsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type PollVoteCreateNestedManyWithoutLivePollInput = {
    create?: XOR<PollVoteCreateWithoutLivePollInput, PollVoteUncheckedCreateWithoutLivePollInput> | PollVoteCreateWithoutLivePollInput[] | PollVoteUncheckedCreateWithoutLivePollInput[]
    connectOrCreate?: PollVoteCreateOrConnectWithoutLivePollInput | PollVoteCreateOrConnectWithoutLivePollInput[]
    createMany?: PollVoteCreateManyLivePollInputEnvelope
    connect?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[]
  }

  export type PollVoteUncheckedCreateNestedManyWithoutLivePollInput = {
    create?: XOR<PollVoteCreateWithoutLivePollInput, PollVoteUncheckedCreateWithoutLivePollInput> | PollVoteCreateWithoutLivePollInput[] | PollVoteUncheckedCreateWithoutLivePollInput[]
    connectOrCreate?: PollVoteCreateOrConnectWithoutLivePollInput | PollVoteCreateOrConnectWithoutLivePollInput[]
    createMany?: PollVoteCreateManyLivePollInputEnvelope
    connect?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[]
  }

  export type WorkspaceUpdateOneRequiredWithoutLivePollsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutLivePollsInput, WorkspaceUncheckedCreateWithoutLivePollsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutLivePollsInput
    upsert?: WorkspaceUpsertWithoutLivePollsInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutLivePollsInput, WorkspaceUpdateWithoutLivePollsInput>, WorkspaceUncheckedUpdateWithoutLivePollsInput>
  }

  export type PollVoteUpdateManyWithoutLivePollNestedInput = {
    create?: XOR<PollVoteCreateWithoutLivePollInput, PollVoteUncheckedCreateWithoutLivePollInput> | PollVoteCreateWithoutLivePollInput[] | PollVoteUncheckedCreateWithoutLivePollInput[]
    connectOrCreate?: PollVoteCreateOrConnectWithoutLivePollInput | PollVoteCreateOrConnectWithoutLivePollInput[]
    upsert?: PollVoteUpsertWithWhereUniqueWithoutLivePollInput | PollVoteUpsertWithWhereUniqueWithoutLivePollInput[]
    createMany?: PollVoteCreateManyLivePollInputEnvelope
    set?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[]
    disconnect?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[]
    delete?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[]
    connect?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[]
    update?: PollVoteUpdateWithWhereUniqueWithoutLivePollInput | PollVoteUpdateWithWhereUniqueWithoutLivePollInput[]
    updateMany?: PollVoteUpdateManyWithWhereWithoutLivePollInput | PollVoteUpdateManyWithWhereWithoutLivePollInput[]
    deleteMany?: PollVoteScalarWhereInput | PollVoteScalarWhereInput[]
  }

  export type PollVoteUncheckedUpdateManyWithoutLivePollNestedInput = {
    create?: XOR<PollVoteCreateWithoutLivePollInput, PollVoteUncheckedCreateWithoutLivePollInput> | PollVoteCreateWithoutLivePollInput[] | PollVoteUncheckedCreateWithoutLivePollInput[]
    connectOrCreate?: PollVoteCreateOrConnectWithoutLivePollInput | PollVoteCreateOrConnectWithoutLivePollInput[]
    upsert?: PollVoteUpsertWithWhereUniqueWithoutLivePollInput | PollVoteUpsertWithWhereUniqueWithoutLivePollInput[]
    createMany?: PollVoteCreateManyLivePollInputEnvelope
    set?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[]
    disconnect?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[]
    delete?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[]
    connect?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[]
    update?: PollVoteUpdateWithWhereUniqueWithoutLivePollInput | PollVoteUpdateWithWhereUniqueWithoutLivePollInput[]
    updateMany?: PollVoteUpdateManyWithWhereWithoutLivePollInput | PollVoteUpdateManyWithWhereWithoutLivePollInput[]
    deleteMany?: PollVoteScalarWhereInput | PollVoteScalarWhereInput[]
  }

  export type LivePollCreateNestedOneWithoutVotesInput = {
    create?: XOR<LivePollCreateWithoutVotesInput, LivePollUncheckedCreateWithoutVotesInput>
    connectOrCreate?: LivePollCreateOrConnectWithoutVotesInput
    connect?: LivePollWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPollVotesInput = {
    create?: XOR<UserCreateWithoutPollVotesInput, UserUncheckedCreateWithoutPollVotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPollVotesInput
    connect?: UserWhereUniqueInput
  }

  export type LivePollUpdateOneRequiredWithoutVotesNestedInput = {
    create?: XOR<LivePollCreateWithoutVotesInput, LivePollUncheckedCreateWithoutVotesInput>
    connectOrCreate?: LivePollCreateOrConnectWithoutVotesInput
    upsert?: LivePollUpsertWithoutVotesInput
    connect?: LivePollWhereUniqueInput
    update?: XOR<XOR<LivePollUpdateToOneWithWhereWithoutVotesInput, LivePollUpdateWithoutVotesInput>, LivePollUncheckedUpdateWithoutVotesInput>
  }

  export type UserUpdateOneRequiredWithoutPollVotesNestedInput = {
    create?: XOR<UserCreateWithoutPollVotesInput, UserUncheckedCreateWithoutPollVotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPollVotesInput
    upsert?: UserUpsertWithoutPollVotesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPollVotesInput, UserUpdateWithoutPollVotesInput>, UserUncheckedUpdateWithoutPollVotesInput>
  }

  export type WorkspaceCreateNestedOneWithoutSessionSummariesInput = {
    create?: XOR<WorkspaceCreateWithoutSessionSummariesInput, WorkspaceUncheckedCreateWithoutSessionSummariesInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutSessionSummariesInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type WorkspaceUpdateOneRequiredWithoutSessionSummariesNestedInput = {
    create?: XOR<WorkspaceCreateWithoutSessionSummariesInput, WorkspaceUncheckedCreateWithoutSessionSummariesInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutSessionSummariesInput
    upsert?: WorkspaceUpsertWithoutSessionSummariesInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutSessionSummariesInput, WorkspaceUpdateWithoutSessionSummariesInput>, WorkspaceUncheckedUpdateWithoutSessionSummariesInput>
  }

  export type WorkspaceCreateNestedOneWithoutChatsInput = {
    create?: XOR<WorkspaceCreateWithoutChatsInput, WorkspaceUncheckedCreateWithoutChatsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutChatsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type ChatMessageCreateNestedManyWithoutChatInput = {
    create?: XOR<ChatMessageCreateWithoutChatInput, ChatMessageUncheckedCreateWithoutChatInput> | ChatMessageCreateWithoutChatInput[] | ChatMessageUncheckedCreateWithoutChatInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutChatInput | ChatMessageCreateOrConnectWithoutChatInput[]
    createMany?: ChatMessageCreateManyChatInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type ChatMessageUncheckedCreateNestedManyWithoutChatInput = {
    create?: XOR<ChatMessageCreateWithoutChatInput, ChatMessageUncheckedCreateWithoutChatInput> | ChatMessageCreateWithoutChatInput[] | ChatMessageUncheckedCreateWithoutChatInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutChatInput | ChatMessageCreateOrConnectWithoutChatInput[]
    createMany?: ChatMessageCreateManyChatInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type WorkspaceUpdateOneRequiredWithoutChatsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutChatsInput, WorkspaceUncheckedCreateWithoutChatsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutChatsInput
    upsert?: WorkspaceUpsertWithoutChatsInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutChatsInput, WorkspaceUpdateWithoutChatsInput>, WorkspaceUncheckedUpdateWithoutChatsInput>
  }

  export type ChatMessageUpdateManyWithoutChatNestedInput = {
    create?: XOR<ChatMessageCreateWithoutChatInput, ChatMessageUncheckedCreateWithoutChatInput> | ChatMessageCreateWithoutChatInput[] | ChatMessageUncheckedCreateWithoutChatInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutChatInput | ChatMessageCreateOrConnectWithoutChatInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutChatInput | ChatMessageUpsertWithWhereUniqueWithoutChatInput[]
    createMany?: ChatMessageCreateManyChatInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutChatInput | ChatMessageUpdateWithWhereUniqueWithoutChatInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutChatInput | ChatMessageUpdateManyWithWhereWithoutChatInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type ChatMessageUncheckedUpdateManyWithoutChatNestedInput = {
    create?: XOR<ChatMessageCreateWithoutChatInput, ChatMessageUncheckedCreateWithoutChatInput> | ChatMessageCreateWithoutChatInput[] | ChatMessageUncheckedCreateWithoutChatInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutChatInput | ChatMessageCreateOrConnectWithoutChatInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutChatInput | ChatMessageUpsertWithWhereUniqueWithoutChatInput[]
    createMany?: ChatMessageCreateManyChatInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutChatInput | ChatMessageUpdateWithWhereUniqueWithoutChatInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutChatInput | ChatMessageUpdateManyWithWhereWithoutChatInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type ChatCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ChatCreateWithoutMessagesInput, ChatUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ChatCreateOrConnectWithoutMessagesInput
    connect?: ChatWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutChatMessagesInput = {
    create?: XOR<UserCreateWithoutChatMessagesInput, UserUncheckedCreateWithoutChatMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutChatMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type ChatUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ChatCreateWithoutMessagesInput, ChatUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ChatCreateOrConnectWithoutMessagesInput
    upsert?: ChatUpsertWithoutMessagesInput
    connect?: ChatWhereUniqueInput
    update?: XOR<XOR<ChatUpdateToOneWithWhereWithoutMessagesInput, ChatUpdateWithoutMessagesInput>, ChatUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutChatMessagesNestedInput = {
    create?: XOR<UserCreateWithoutChatMessagesInput, UserUncheckedCreateWithoutChatMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutChatMessagesInput
    upsert?: UserUpsertWithoutChatMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChatMessagesInput, UserUpdateWithoutChatMessagesInput>, UserUncheckedUpdateWithoutChatMessagesInput>
  }

  export type UserCreateNestedOneWithoutSettingsInput = {
    create?: XOR<UserCreateWithoutSettingsInput, UserUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSettingsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSettingsNestedInput = {
    create?: XOR<UserCreateWithoutSettingsInput, UserUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSettingsInput
    upsert?: UserUpsertWithoutSettingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSettingsInput, UserUpdateWithoutSettingsInput>, UserUncheckedUpdateWithoutSettingsInput>
  }

  export type UserCreateNestedOneWithoutAnalyticsEntriesInput = {
    create?: XOR<UserCreateWithoutAnalyticsEntriesInput, UserUncheckedCreateWithoutAnalyticsEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnalyticsEntriesInput
    connect?: UserWhereUniqueInput
  }

  export type TopicCreateNestedOneWithoutAnalyticsEntriesInput = {
    create?: XOR<TopicCreateWithoutAnalyticsEntriesInput, TopicUncheckedCreateWithoutAnalyticsEntriesInput>
    connectOrCreate?: TopicCreateOrConnectWithoutAnalyticsEntriesInput
    connect?: TopicWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAnalyticsEntriesNestedInput = {
    create?: XOR<UserCreateWithoutAnalyticsEntriesInput, UserUncheckedCreateWithoutAnalyticsEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnalyticsEntriesInput
    upsert?: UserUpsertWithoutAnalyticsEntriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAnalyticsEntriesInput, UserUpdateWithoutAnalyticsEntriesInput>, UserUncheckedUpdateWithoutAnalyticsEntriesInput>
  }

  export type TopicUpdateOneRequiredWithoutAnalyticsEntriesNestedInput = {
    create?: XOR<TopicCreateWithoutAnalyticsEntriesInput, TopicUncheckedCreateWithoutAnalyticsEntriesInput>
    connectOrCreate?: TopicCreateOrConnectWithoutAnalyticsEntriesInput
    upsert?: TopicUpsertWithoutAnalyticsEntriesInput
    connect?: TopicWhereUniqueInput
    update?: XOR<XOR<TopicUpdateToOneWithWhereWithoutAnalyticsEntriesInput, TopicUpdateWithoutAnalyticsEntriesInput>, TopicUncheckedUpdateWithoutAnalyticsEntriesInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutPasswordlessTokensInput = {
    create?: XOR<UserCreateWithoutPasswordlessTokensInput, UserUncheckedCreateWithoutPasswordlessTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordlessTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPasswordlessTokensNestedInput = {
    create?: XOR<UserCreateWithoutPasswordlessTokensInput, UserUncheckedCreateWithoutPasswordlessTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordlessTokensInput
    upsert?: UserUpsertWithoutPasswordlessTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPasswordlessTokensInput, UserUpdateWithoutPasswordlessTokensInput>, UserUncheckedUpdateWithoutPasswordlessTokensInput>
  }

  export type UserCreateNestedOneWithoutDailyChallengesInput = {
    create?: XOR<UserCreateWithoutDailyChallengesInput, UserUncheckedCreateWithoutDailyChallengesInput>
    connectOrCreate?: UserCreateOrConnectWithoutDailyChallengesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutDailyChallengesNestedInput = {
    create?: XOR<UserCreateWithoutDailyChallengesInput, UserUncheckedCreateWithoutDailyChallengesInput>
    connectOrCreate?: UserCreateOrConnectWithoutDailyChallengesInput
    upsert?: UserUpsertWithoutDailyChallengesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDailyChallengesInput, UserUpdateWithoutDailyChallengesInput>, UserUncheckedUpdateWithoutDailyChallengesInput>
  }

  export type UserCreateNestedOneWithoutExternalGoalsInput = {
    create?: XOR<UserCreateWithoutExternalGoalsInput, UserUncheckedCreateWithoutExternalGoalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutExternalGoalsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutExternalGoalsNestedInput = {
    create?: XOR<UserCreateWithoutExternalGoalsInput, UserUncheckedCreateWithoutExternalGoalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutExternalGoalsInput
    upsert?: UserUpsertWithoutExternalGoalsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutExternalGoalsInput, UserUpdateWithoutExternalGoalsInput>, UserUncheckedUpdateWithoutExternalGoalsInput>
  }

  export type LearningPathCreateNestedOneWithoutPrerequisitesInput = {
    create?: XOR<LearningPathCreateWithoutPrerequisitesInput, LearningPathUncheckedCreateWithoutPrerequisitesInput>
    connectOrCreate?: LearningPathCreateOrConnectWithoutPrerequisitesInput
    connect?: LearningPathWhereUniqueInput
  }

  export type TopicCreateNestedOneWithoutPrerequisitesInput = {
    create?: XOR<TopicCreateWithoutPrerequisitesInput, TopicUncheckedCreateWithoutPrerequisitesInput>
    connectOrCreate?: TopicCreateOrConnectWithoutPrerequisitesInput
    connect?: TopicWhereUniqueInput
  }

  export type LearningPathUpdateOneRequiredWithoutPrerequisitesNestedInput = {
    create?: XOR<LearningPathCreateWithoutPrerequisitesInput, LearningPathUncheckedCreateWithoutPrerequisitesInput>
    connectOrCreate?: LearningPathCreateOrConnectWithoutPrerequisitesInput
    upsert?: LearningPathUpsertWithoutPrerequisitesInput
    connect?: LearningPathWhereUniqueInput
    update?: XOR<XOR<LearningPathUpdateToOneWithWhereWithoutPrerequisitesInput, LearningPathUpdateWithoutPrerequisitesInput>, LearningPathUncheckedUpdateWithoutPrerequisitesInput>
  }

  export type TopicUpdateOneRequiredWithoutPrerequisitesNestedInput = {
    create?: XOR<TopicCreateWithoutPrerequisitesInput, TopicUncheckedCreateWithoutPrerequisitesInput>
    connectOrCreate?: TopicCreateOrConnectWithoutPrerequisitesInput
    upsert?: TopicUpsertWithoutPrerequisitesInput
    connect?: TopicWhereUniqueInput
    update?: XOR<XOR<TopicUpdateToOneWithWhereWithoutPrerequisitesInput, TopicUpdateWithoutPrerequisitesInput>, TopicUncheckedUpdateWithoutPrerequisitesInput>
  }

  export type UserCreateNestedOneWithoutCommentsInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type TopicCreateNestedOneWithoutCommentsInput = {
    create?: XOR<TopicCreateWithoutCommentsInput, TopicUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: TopicCreateOrConnectWithoutCommentsInput
    connect?: TopicWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    upsert?: UserUpsertWithoutCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentsInput, UserUpdateWithoutCommentsInput>, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type TopicUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<TopicCreateWithoutCommentsInput, TopicUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: TopicCreateOrConnectWithoutCommentsInput
    upsert?: TopicUpsertWithoutCommentsInput
    connect?: TopicWhereUniqueInput
    update?: XOR<XOR<TopicUpdateToOneWithWhereWithoutCommentsInput, TopicUpdateWithoutCommentsInput>, TopicUncheckedUpdateWithoutCommentsInput>
  }

  export type AIPlaylistItemCreateNestedManyWithoutPlaylistInput = {
    create?: XOR<AIPlaylistItemCreateWithoutPlaylistInput, AIPlaylistItemUncheckedCreateWithoutPlaylistInput> | AIPlaylistItemCreateWithoutPlaylistInput[] | AIPlaylistItemUncheckedCreateWithoutPlaylistInput[]
    connectOrCreate?: AIPlaylistItemCreateOrConnectWithoutPlaylistInput | AIPlaylistItemCreateOrConnectWithoutPlaylistInput[]
    createMany?: AIPlaylistItemCreateManyPlaylistInputEnvelope
    connect?: AIPlaylistItemWhereUniqueInput | AIPlaylistItemWhereUniqueInput[]
  }

  export type AIPlaylistItemUncheckedCreateNestedManyWithoutPlaylistInput = {
    create?: XOR<AIPlaylistItemCreateWithoutPlaylistInput, AIPlaylistItemUncheckedCreateWithoutPlaylistInput> | AIPlaylistItemCreateWithoutPlaylistInput[] | AIPlaylistItemUncheckedCreateWithoutPlaylistInput[]
    connectOrCreate?: AIPlaylistItemCreateOrConnectWithoutPlaylistInput | AIPlaylistItemCreateOrConnectWithoutPlaylistInput[]
    createMany?: AIPlaylistItemCreateManyPlaylistInputEnvelope
    connect?: AIPlaylistItemWhereUniqueInput | AIPlaylistItemWhereUniqueInput[]
  }

  export type AIPlaylistItemUpdateManyWithoutPlaylistNestedInput = {
    create?: XOR<AIPlaylistItemCreateWithoutPlaylistInput, AIPlaylistItemUncheckedCreateWithoutPlaylistInput> | AIPlaylistItemCreateWithoutPlaylistInput[] | AIPlaylistItemUncheckedCreateWithoutPlaylistInput[]
    connectOrCreate?: AIPlaylistItemCreateOrConnectWithoutPlaylistInput | AIPlaylistItemCreateOrConnectWithoutPlaylistInput[]
    upsert?: AIPlaylistItemUpsertWithWhereUniqueWithoutPlaylistInput | AIPlaylistItemUpsertWithWhereUniqueWithoutPlaylistInput[]
    createMany?: AIPlaylistItemCreateManyPlaylistInputEnvelope
    set?: AIPlaylistItemWhereUniqueInput | AIPlaylistItemWhereUniqueInput[]
    disconnect?: AIPlaylistItemWhereUniqueInput | AIPlaylistItemWhereUniqueInput[]
    delete?: AIPlaylistItemWhereUniqueInput | AIPlaylistItemWhereUniqueInput[]
    connect?: AIPlaylistItemWhereUniqueInput | AIPlaylistItemWhereUniqueInput[]
    update?: AIPlaylistItemUpdateWithWhereUniqueWithoutPlaylistInput | AIPlaylistItemUpdateWithWhereUniqueWithoutPlaylistInput[]
    updateMany?: AIPlaylistItemUpdateManyWithWhereWithoutPlaylistInput | AIPlaylistItemUpdateManyWithWhereWithoutPlaylistInput[]
    deleteMany?: AIPlaylistItemScalarWhereInput | AIPlaylistItemScalarWhereInput[]
  }

  export type AIPlaylistItemUncheckedUpdateManyWithoutPlaylistNestedInput = {
    create?: XOR<AIPlaylistItemCreateWithoutPlaylistInput, AIPlaylistItemUncheckedCreateWithoutPlaylistInput> | AIPlaylistItemCreateWithoutPlaylistInput[] | AIPlaylistItemUncheckedCreateWithoutPlaylistInput[]
    connectOrCreate?: AIPlaylistItemCreateOrConnectWithoutPlaylistInput | AIPlaylistItemCreateOrConnectWithoutPlaylistInput[]
    upsert?: AIPlaylistItemUpsertWithWhereUniqueWithoutPlaylistInput | AIPlaylistItemUpsertWithWhereUniqueWithoutPlaylistInput[]
    createMany?: AIPlaylistItemCreateManyPlaylistInputEnvelope
    set?: AIPlaylistItemWhereUniqueInput | AIPlaylistItemWhereUniqueInput[]
    disconnect?: AIPlaylistItemWhereUniqueInput | AIPlaylistItemWhereUniqueInput[]
    delete?: AIPlaylistItemWhereUniqueInput | AIPlaylistItemWhereUniqueInput[]
    connect?: AIPlaylistItemWhereUniqueInput | AIPlaylistItemWhereUniqueInput[]
    update?: AIPlaylistItemUpdateWithWhereUniqueWithoutPlaylistInput | AIPlaylistItemUpdateWithWhereUniqueWithoutPlaylistInput[]
    updateMany?: AIPlaylistItemUpdateManyWithWhereWithoutPlaylistInput | AIPlaylistItemUpdateManyWithWhereWithoutPlaylistInput[]
    deleteMany?: AIPlaylistItemScalarWhereInput | AIPlaylistItemScalarWhereInput[]
  }

  export type AIPlaylistCreateNestedOneWithoutItemsInput = {
    create?: XOR<AIPlaylistCreateWithoutItemsInput, AIPlaylistUncheckedCreateWithoutItemsInput>
    connectOrCreate?: AIPlaylistCreateOrConnectWithoutItemsInput
    connect?: AIPlaylistWhereUniqueInput
  }

  export type ContentItemCreateNestedOneWithoutAiPlaylistItemsInput = {
    create?: XOR<ContentItemCreateWithoutAiPlaylistItemsInput, ContentItemUncheckedCreateWithoutAiPlaylistItemsInput>
    connectOrCreate?: ContentItemCreateOrConnectWithoutAiPlaylistItemsInput
    connect?: ContentItemWhereUniqueInput
  }

  export type AIPlaylistUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<AIPlaylistCreateWithoutItemsInput, AIPlaylistUncheckedCreateWithoutItemsInput>
    connectOrCreate?: AIPlaylistCreateOrConnectWithoutItemsInput
    upsert?: AIPlaylistUpsertWithoutItemsInput
    connect?: AIPlaylistWhereUniqueInput
    update?: XOR<XOR<AIPlaylistUpdateToOneWithWhereWithoutItemsInput, AIPlaylistUpdateWithoutItemsInput>, AIPlaylistUncheckedUpdateWithoutItemsInput>
  }

  export type ContentItemUpdateOneRequiredWithoutAiPlaylistItemsNestedInput = {
    create?: XOR<ContentItemCreateWithoutAiPlaylistItemsInput, ContentItemUncheckedCreateWithoutAiPlaylistItemsInput>
    connectOrCreate?: ContentItemCreateOrConnectWithoutAiPlaylistItemsInput
    upsert?: ContentItemUpsertWithoutAiPlaylistItemsInput
    connect?: ContentItemWhereUniqueInput
    update?: XOR<XOR<ContentItemUpdateToOneWithWhereWithoutAiPlaylistItemsInput, ContentItemUpdateWithoutAiPlaylistItemsInput>, ContentItemUncheckedUpdateWithoutAiPlaylistItemsInput>
  }

  export type UserCreateNestedOneWithoutChallengeScoresInput = {
    create?: XOR<UserCreateWithoutChallengeScoresInput, UserUncheckedCreateWithoutChallengeScoresInput>
    connectOrCreate?: UserCreateOrConnectWithoutChallengeScoresInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutChallengeScoresNestedInput = {
    create?: XOR<UserCreateWithoutChallengeScoresInput, UserUncheckedCreateWithoutChallengeScoresInput>
    connectOrCreate?: UserCreateOrConnectWithoutChallengeScoresInput
    upsert?: UserUpsertWithoutChallengeScoresInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChallengeScoresInput, UserUpdateWithoutChallengeScoresInput>, UserUncheckedUpdateWithoutChallengeScoresInput>
  }

  export type UserCreateNestedOneWithoutAiRecommendationsInput = {
    create?: XOR<UserCreateWithoutAiRecommendationsInput, UserUncheckedCreateWithoutAiRecommendationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAiRecommendationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAiRecommendationsNestedInput = {
    create?: XOR<UserCreateWithoutAiRecommendationsInput, UserUncheckedCreateWithoutAiRecommendationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAiRecommendationsInput
    upsert?: UserUpsertWithoutAiRecommendationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAiRecommendationsInput, UserUpdateWithoutAiRecommendationsInput>, UserUncheckedUpdateWithoutAiRecommendationsInput>
  }

  export type AIModuleCreatetagsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutAiModulesInput = {
    create?: XOR<UserCreateWithoutAiModulesInput, UserUncheckedCreateWithoutAiModulesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAiModulesInput
    connect?: UserWhereUniqueInput
  }

  export type TopicCreateNestedOneWithoutAiModulesInput = {
    create?: XOR<TopicCreateWithoutAiModulesInput, TopicUncheckedCreateWithoutAiModulesInput>
    connectOrCreate?: TopicCreateOrConnectWithoutAiModulesInput
    connect?: TopicWhereUniqueInput
  }

  export type AIModuleLearningPathItemCreateNestedManyWithoutAiModuleInput = {
    create?: XOR<AIModuleLearningPathItemCreateWithoutAiModuleInput, AIModuleLearningPathItemUncheckedCreateWithoutAiModuleInput> | AIModuleLearningPathItemCreateWithoutAiModuleInput[] | AIModuleLearningPathItemUncheckedCreateWithoutAiModuleInput[]
    connectOrCreate?: AIModuleLearningPathItemCreateOrConnectWithoutAiModuleInput | AIModuleLearningPathItemCreateOrConnectWithoutAiModuleInput[]
    createMany?: AIModuleLearningPathItemCreateManyAiModuleInputEnvelope
    connect?: AIModuleLearningPathItemWhereUniqueInput | AIModuleLearningPathItemWhereUniqueInput[]
  }

  export type AIModuleQuizAttemptCreateNestedManyWithoutAiModuleInput = {
    create?: XOR<AIModuleQuizAttemptCreateWithoutAiModuleInput, AIModuleQuizAttemptUncheckedCreateWithoutAiModuleInput> | AIModuleQuizAttemptCreateWithoutAiModuleInput[] | AIModuleQuizAttemptUncheckedCreateWithoutAiModuleInput[]
    connectOrCreate?: AIModuleQuizAttemptCreateOrConnectWithoutAiModuleInput | AIModuleQuizAttemptCreateOrConnectWithoutAiModuleInput[]
    createMany?: AIModuleQuizAttemptCreateManyAiModuleInputEnvelope
    connect?: AIModuleQuizAttemptWhereUniqueInput | AIModuleQuizAttemptWhereUniqueInput[]
  }

  export type AIModuleRatingCreateNestedManyWithoutAiModuleInput = {
    create?: XOR<AIModuleRatingCreateWithoutAiModuleInput, AIModuleRatingUncheckedCreateWithoutAiModuleInput> | AIModuleRatingCreateWithoutAiModuleInput[] | AIModuleRatingUncheckedCreateWithoutAiModuleInput[]
    connectOrCreate?: AIModuleRatingCreateOrConnectWithoutAiModuleInput | AIModuleRatingCreateOrConnectWithoutAiModuleInput[]
    createMany?: AIModuleRatingCreateManyAiModuleInputEnvelope
    connect?: AIModuleRatingWhereUniqueInput | AIModuleRatingWhereUniqueInput[]
  }

  export type PracticeAttemptCreateNestedManyWithoutAiModuleInput = {
    create?: XOR<PracticeAttemptCreateWithoutAiModuleInput, PracticeAttemptUncheckedCreateWithoutAiModuleInput> | PracticeAttemptCreateWithoutAiModuleInput[] | PracticeAttemptUncheckedCreateWithoutAiModuleInput[]
    connectOrCreate?: PracticeAttemptCreateOrConnectWithoutAiModuleInput | PracticeAttemptCreateOrConnectWithoutAiModuleInput[]
    createMany?: PracticeAttemptCreateManyAiModuleInputEnvelope
    connect?: PracticeAttemptWhereUniqueInput | PracticeAttemptWhereUniqueInput[]
  }

  export type AIModuleLearningPathItemUncheckedCreateNestedManyWithoutAiModuleInput = {
    create?: XOR<AIModuleLearningPathItemCreateWithoutAiModuleInput, AIModuleLearningPathItemUncheckedCreateWithoutAiModuleInput> | AIModuleLearningPathItemCreateWithoutAiModuleInput[] | AIModuleLearningPathItemUncheckedCreateWithoutAiModuleInput[]
    connectOrCreate?: AIModuleLearningPathItemCreateOrConnectWithoutAiModuleInput | AIModuleLearningPathItemCreateOrConnectWithoutAiModuleInput[]
    createMany?: AIModuleLearningPathItemCreateManyAiModuleInputEnvelope
    connect?: AIModuleLearningPathItemWhereUniqueInput | AIModuleLearningPathItemWhereUniqueInput[]
  }

  export type AIModuleQuizAttemptUncheckedCreateNestedManyWithoutAiModuleInput = {
    create?: XOR<AIModuleQuizAttemptCreateWithoutAiModuleInput, AIModuleQuizAttemptUncheckedCreateWithoutAiModuleInput> | AIModuleQuizAttemptCreateWithoutAiModuleInput[] | AIModuleQuizAttemptUncheckedCreateWithoutAiModuleInput[]
    connectOrCreate?: AIModuleQuizAttemptCreateOrConnectWithoutAiModuleInput | AIModuleQuizAttemptCreateOrConnectWithoutAiModuleInput[]
    createMany?: AIModuleQuizAttemptCreateManyAiModuleInputEnvelope
    connect?: AIModuleQuizAttemptWhereUniqueInput | AIModuleQuizAttemptWhereUniqueInput[]
  }

  export type AIModuleRatingUncheckedCreateNestedManyWithoutAiModuleInput = {
    create?: XOR<AIModuleRatingCreateWithoutAiModuleInput, AIModuleRatingUncheckedCreateWithoutAiModuleInput> | AIModuleRatingCreateWithoutAiModuleInput[] | AIModuleRatingUncheckedCreateWithoutAiModuleInput[]
    connectOrCreate?: AIModuleRatingCreateOrConnectWithoutAiModuleInput | AIModuleRatingCreateOrConnectWithoutAiModuleInput[]
    createMany?: AIModuleRatingCreateManyAiModuleInputEnvelope
    connect?: AIModuleRatingWhereUniqueInput | AIModuleRatingWhereUniqueInput[]
  }

  export type PracticeAttemptUncheckedCreateNestedManyWithoutAiModuleInput = {
    create?: XOR<PracticeAttemptCreateWithoutAiModuleInput, PracticeAttemptUncheckedCreateWithoutAiModuleInput> | PracticeAttemptCreateWithoutAiModuleInput[] | PracticeAttemptUncheckedCreateWithoutAiModuleInput[]
    connectOrCreate?: PracticeAttemptCreateOrConnectWithoutAiModuleInput | PracticeAttemptCreateOrConnectWithoutAiModuleInput[]
    createMany?: PracticeAttemptCreateManyAiModuleInputEnvelope
    connect?: PracticeAttemptWhereUniqueInput | PracticeAttemptWhereUniqueInput[]
  }

  export type AIModuleUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneWithoutAiModulesNestedInput = {
    create?: XOR<UserCreateWithoutAiModulesInput, UserUncheckedCreateWithoutAiModulesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAiModulesInput
    upsert?: UserUpsertWithoutAiModulesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAiModulesInput, UserUpdateWithoutAiModulesInput>, UserUncheckedUpdateWithoutAiModulesInput>
  }

  export type TopicUpdateOneWithoutAiModulesNestedInput = {
    create?: XOR<TopicCreateWithoutAiModulesInput, TopicUncheckedCreateWithoutAiModulesInput>
    connectOrCreate?: TopicCreateOrConnectWithoutAiModulesInput
    upsert?: TopicUpsertWithoutAiModulesInput
    disconnect?: TopicWhereInput | boolean
    delete?: TopicWhereInput | boolean
    connect?: TopicWhereUniqueInput
    update?: XOR<XOR<TopicUpdateToOneWithWhereWithoutAiModulesInput, TopicUpdateWithoutAiModulesInput>, TopicUncheckedUpdateWithoutAiModulesInput>
  }

  export type AIModuleLearningPathItemUpdateManyWithoutAiModuleNestedInput = {
    create?: XOR<AIModuleLearningPathItemCreateWithoutAiModuleInput, AIModuleLearningPathItemUncheckedCreateWithoutAiModuleInput> | AIModuleLearningPathItemCreateWithoutAiModuleInput[] | AIModuleLearningPathItemUncheckedCreateWithoutAiModuleInput[]
    connectOrCreate?: AIModuleLearningPathItemCreateOrConnectWithoutAiModuleInput | AIModuleLearningPathItemCreateOrConnectWithoutAiModuleInput[]
    upsert?: AIModuleLearningPathItemUpsertWithWhereUniqueWithoutAiModuleInput | AIModuleLearningPathItemUpsertWithWhereUniqueWithoutAiModuleInput[]
    createMany?: AIModuleLearningPathItemCreateManyAiModuleInputEnvelope
    set?: AIModuleLearningPathItemWhereUniqueInput | AIModuleLearningPathItemWhereUniqueInput[]
    disconnect?: AIModuleLearningPathItemWhereUniqueInput | AIModuleLearningPathItemWhereUniqueInput[]
    delete?: AIModuleLearningPathItemWhereUniqueInput | AIModuleLearningPathItemWhereUniqueInput[]
    connect?: AIModuleLearningPathItemWhereUniqueInput | AIModuleLearningPathItemWhereUniqueInput[]
    update?: AIModuleLearningPathItemUpdateWithWhereUniqueWithoutAiModuleInput | AIModuleLearningPathItemUpdateWithWhereUniqueWithoutAiModuleInput[]
    updateMany?: AIModuleLearningPathItemUpdateManyWithWhereWithoutAiModuleInput | AIModuleLearningPathItemUpdateManyWithWhereWithoutAiModuleInput[]
    deleteMany?: AIModuleLearningPathItemScalarWhereInput | AIModuleLearningPathItemScalarWhereInput[]
  }

  export type AIModuleQuizAttemptUpdateManyWithoutAiModuleNestedInput = {
    create?: XOR<AIModuleQuizAttemptCreateWithoutAiModuleInput, AIModuleQuizAttemptUncheckedCreateWithoutAiModuleInput> | AIModuleQuizAttemptCreateWithoutAiModuleInput[] | AIModuleQuizAttemptUncheckedCreateWithoutAiModuleInput[]
    connectOrCreate?: AIModuleQuizAttemptCreateOrConnectWithoutAiModuleInput | AIModuleQuizAttemptCreateOrConnectWithoutAiModuleInput[]
    upsert?: AIModuleQuizAttemptUpsertWithWhereUniqueWithoutAiModuleInput | AIModuleQuizAttemptUpsertWithWhereUniqueWithoutAiModuleInput[]
    createMany?: AIModuleQuizAttemptCreateManyAiModuleInputEnvelope
    set?: AIModuleQuizAttemptWhereUniqueInput | AIModuleQuizAttemptWhereUniqueInput[]
    disconnect?: AIModuleQuizAttemptWhereUniqueInput | AIModuleQuizAttemptWhereUniqueInput[]
    delete?: AIModuleQuizAttemptWhereUniqueInput | AIModuleQuizAttemptWhereUniqueInput[]
    connect?: AIModuleQuizAttemptWhereUniqueInput | AIModuleQuizAttemptWhereUniqueInput[]
    update?: AIModuleQuizAttemptUpdateWithWhereUniqueWithoutAiModuleInput | AIModuleQuizAttemptUpdateWithWhereUniqueWithoutAiModuleInput[]
    updateMany?: AIModuleQuizAttemptUpdateManyWithWhereWithoutAiModuleInput | AIModuleQuizAttemptUpdateManyWithWhereWithoutAiModuleInput[]
    deleteMany?: AIModuleQuizAttemptScalarWhereInput | AIModuleQuizAttemptScalarWhereInput[]
  }

  export type AIModuleRatingUpdateManyWithoutAiModuleNestedInput = {
    create?: XOR<AIModuleRatingCreateWithoutAiModuleInput, AIModuleRatingUncheckedCreateWithoutAiModuleInput> | AIModuleRatingCreateWithoutAiModuleInput[] | AIModuleRatingUncheckedCreateWithoutAiModuleInput[]
    connectOrCreate?: AIModuleRatingCreateOrConnectWithoutAiModuleInput | AIModuleRatingCreateOrConnectWithoutAiModuleInput[]
    upsert?: AIModuleRatingUpsertWithWhereUniqueWithoutAiModuleInput | AIModuleRatingUpsertWithWhereUniqueWithoutAiModuleInput[]
    createMany?: AIModuleRatingCreateManyAiModuleInputEnvelope
    set?: AIModuleRatingWhereUniqueInput | AIModuleRatingWhereUniqueInput[]
    disconnect?: AIModuleRatingWhereUniqueInput | AIModuleRatingWhereUniqueInput[]
    delete?: AIModuleRatingWhereUniqueInput | AIModuleRatingWhereUniqueInput[]
    connect?: AIModuleRatingWhereUniqueInput | AIModuleRatingWhereUniqueInput[]
    update?: AIModuleRatingUpdateWithWhereUniqueWithoutAiModuleInput | AIModuleRatingUpdateWithWhereUniqueWithoutAiModuleInput[]
    updateMany?: AIModuleRatingUpdateManyWithWhereWithoutAiModuleInput | AIModuleRatingUpdateManyWithWhereWithoutAiModuleInput[]
    deleteMany?: AIModuleRatingScalarWhereInput | AIModuleRatingScalarWhereInput[]
  }

  export type PracticeAttemptUpdateManyWithoutAiModuleNestedInput = {
    create?: XOR<PracticeAttemptCreateWithoutAiModuleInput, PracticeAttemptUncheckedCreateWithoutAiModuleInput> | PracticeAttemptCreateWithoutAiModuleInput[] | PracticeAttemptUncheckedCreateWithoutAiModuleInput[]
    connectOrCreate?: PracticeAttemptCreateOrConnectWithoutAiModuleInput | PracticeAttemptCreateOrConnectWithoutAiModuleInput[]
    upsert?: PracticeAttemptUpsertWithWhereUniqueWithoutAiModuleInput | PracticeAttemptUpsertWithWhereUniqueWithoutAiModuleInput[]
    createMany?: PracticeAttemptCreateManyAiModuleInputEnvelope
    set?: PracticeAttemptWhereUniqueInput | PracticeAttemptWhereUniqueInput[]
    disconnect?: PracticeAttemptWhereUniqueInput | PracticeAttemptWhereUniqueInput[]
    delete?: PracticeAttemptWhereUniqueInput | PracticeAttemptWhereUniqueInput[]
    connect?: PracticeAttemptWhereUniqueInput | PracticeAttemptWhereUniqueInput[]
    update?: PracticeAttemptUpdateWithWhereUniqueWithoutAiModuleInput | PracticeAttemptUpdateWithWhereUniqueWithoutAiModuleInput[]
    updateMany?: PracticeAttemptUpdateManyWithWhereWithoutAiModuleInput | PracticeAttemptUpdateManyWithWhereWithoutAiModuleInput[]
    deleteMany?: PracticeAttemptScalarWhereInput | PracticeAttemptScalarWhereInput[]
  }

  export type AIModuleLearningPathItemUncheckedUpdateManyWithoutAiModuleNestedInput = {
    create?: XOR<AIModuleLearningPathItemCreateWithoutAiModuleInput, AIModuleLearningPathItemUncheckedCreateWithoutAiModuleInput> | AIModuleLearningPathItemCreateWithoutAiModuleInput[] | AIModuleLearningPathItemUncheckedCreateWithoutAiModuleInput[]
    connectOrCreate?: AIModuleLearningPathItemCreateOrConnectWithoutAiModuleInput | AIModuleLearningPathItemCreateOrConnectWithoutAiModuleInput[]
    upsert?: AIModuleLearningPathItemUpsertWithWhereUniqueWithoutAiModuleInput | AIModuleLearningPathItemUpsertWithWhereUniqueWithoutAiModuleInput[]
    createMany?: AIModuleLearningPathItemCreateManyAiModuleInputEnvelope
    set?: AIModuleLearningPathItemWhereUniqueInput | AIModuleLearningPathItemWhereUniqueInput[]
    disconnect?: AIModuleLearningPathItemWhereUniqueInput | AIModuleLearningPathItemWhereUniqueInput[]
    delete?: AIModuleLearningPathItemWhereUniqueInput | AIModuleLearningPathItemWhereUniqueInput[]
    connect?: AIModuleLearningPathItemWhereUniqueInput | AIModuleLearningPathItemWhereUniqueInput[]
    update?: AIModuleLearningPathItemUpdateWithWhereUniqueWithoutAiModuleInput | AIModuleLearningPathItemUpdateWithWhereUniqueWithoutAiModuleInput[]
    updateMany?: AIModuleLearningPathItemUpdateManyWithWhereWithoutAiModuleInput | AIModuleLearningPathItemUpdateManyWithWhereWithoutAiModuleInput[]
    deleteMany?: AIModuleLearningPathItemScalarWhereInput | AIModuleLearningPathItemScalarWhereInput[]
  }

  export type AIModuleQuizAttemptUncheckedUpdateManyWithoutAiModuleNestedInput = {
    create?: XOR<AIModuleQuizAttemptCreateWithoutAiModuleInput, AIModuleQuizAttemptUncheckedCreateWithoutAiModuleInput> | AIModuleQuizAttemptCreateWithoutAiModuleInput[] | AIModuleQuizAttemptUncheckedCreateWithoutAiModuleInput[]
    connectOrCreate?: AIModuleQuizAttemptCreateOrConnectWithoutAiModuleInput | AIModuleQuizAttemptCreateOrConnectWithoutAiModuleInput[]
    upsert?: AIModuleQuizAttemptUpsertWithWhereUniqueWithoutAiModuleInput | AIModuleQuizAttemptUpsertWithWhereUniqueWithoutAiModuleInput[]
    createMany?: AIModuleQuizAttemptCreateManyAiModuleInputEnvelope
    set?: AIModuleQuizAttemptWhereUniqueInput | AIModuleQuizAttemptWhereUniqueInput[]
    disconnect?: AIModuleQuizAttemptWhereUniqueInput | AIModuleQuizAttemptWhereUniqueInput[]
    delete?: AIModuleQuizAttemptWhereUniqueInput | AIModuleQuizAttemptWhereUniqueInput[]
    connect?: AIModuleQuizAttemptWhereUniqueInput | AIModuleQuizAttemptWhereUniqueInput[]
    update?: AIModuleQuizAttemptUpdateWithWhereUniqueWithoutAiModuleInput | AIModuleQuizAttemptUpdateWithWhereUniqueWithoutAiModuleInput[]
    updateMany?: AIModuleQuizAttemptUpdateManyWithWhereWithoutAiModuleInput | AIModuleQuizAttemptUpdateManyWithWhereWithoutAiModuleInput[]
    deleteMany?: AIModuleQuizAttemptScalarWhereInput | AIModuleQuizAttemptScalarWhereInput[]
  }

  export type AIModuleRatingUncheckedUpdateManyWithoutAiModuleNestedInput = {
    create?: XOR<AIModuleRatingCreateWithoutAiModuleInput, AIModuleRatingUncheckedCreateWithoutAiModuleInput> | AIModuleRatingCreateWithoutAiModuleInput[] | AIModuleRatingUncheckedCreateWithoutAiModuleInput[]
    connectOrCreate?: AIModuleRatingCreateOrConnectWithoutAiModuleInput | AIModuleRatingCreateOrConnectWithoutAiModuleInput[]
    upsert?: AIModuleRatingUpsertWithWhereUniqueWithoutAiModuleInput | AIModuleRatingUpsertWithWhereUniqueWithoutAiModuleInput[]
    createMany?: AIModuleRatingCreateManyAiModuleInputEnvelope
    set?: AIModuleRatingWhereUniqueInput | AIModuleRatingWhereUniqueInput[]
    disconnect?: AIModuleRatingWhereUniqueInput | AIModuleRatingWhereUniqueInput[]
    delete?: AIModuleRatingWhereUniqueInput | AIModuleRatingWhereUniqueInput[]
    connect?: AIModuleRatingWhereUniqueInput | AIModuleRatingWhereUniqueInput[]
    update?: AIModuleRatingUpdateWithWhereUniqueWithoutAiModuleInput | AIModuleRatingUpdateWithWhereUniqueWithoutAiModuleInput[]
    updateMany?: AIModuleRatingUpdateManyWithWhereWithoutAiModuleInput | AIModuleRatingUpdateManyWithWhereWithoutAiModuleInput[]
    deleteMany?: AIModuleRatingScalarWhereInput | AIModuleRatingScalarWhereInput[]
  }

  export type PracticeAttemptUncheckedUpdateManyWithoutAiModuleNestedInput = {
    create?: XOR<PracticeAttemptCreateWithoutAiModuleInput, PracticeAttemptUncheckedCreateWithoutAiModuleInput> | PracticeAttemptCreateWithoutAiModuleInput[] | PracticeAttemptUncheckedCreateWithoutAiModuleInput[]
    connectOrCreate?: PracticeAttemptCreateOrConnectWithoutAiModuleInput | PracticeAttemptCreateOrConnectWithoutAiModuleInput[]
    upsert?: PracticeAttemptUpsertWithWhereUniqueWithoutAiModuleInput | PracticeAttemptUpsertWithWhereUniqueWithoutAiModuleInput[]
    createMany?: PracticeAttemptCreateManyAiModuleInputEnvelope
    set?: PracticeAttemptWhereUniqueInput | PracticeAttemptWhereUniqueInput[]
    disconnect?: PracticeAttemptWhereUniqueInput | PracticeAttemptWhereUniqueInput[]
    delete?: PracticeAttemptWhereUniqueInput | PracticeAttemptWhereUniqueInput[]
    connect?: PracticeAttemptWhereUniqueInput | PracticeAttemptWhereUniqueInput[]
    update?: PracticeAttemptUpdateWithWhereUniqueWithoutAiModuleInput | PracticeAttemptUpdateWithWhereUniqueWithoutAiModuleInput[]
    updateMany?: PracticeAttemptUpdateManyWithWhereWithoutAiModuleInput | PracticeAttemptUpdateManyWithWhereWithoutAiModuleInput[]
    deleteMany?: PracticeAttemptScalarWhereInput | PracticeAttemptScalarWhereInput[]
  }

  export type LearningPathCreateNestedOneWithoutAiModuleItemsInput = {
    create?: XOR<LearningPathCreateWithoutAiModuleItemsInput, LearningPathUncheckedCreateWithoutAiModuleItemsInput>
    connectOrCreate?: LearningPathCreateOrConnectWithoutAiModuleItemsInput
    connect?: LearningPathWhereUniqueInput
  }

  export type AIModuleCreateNestedOneWithoutLearningPathItemsInput = {
    create?: XOR<AIModuleCreateWithoutLearningPathItemsInput, AIModuleUncheckedCreateWithoutLearningPathItemsInput>
    connectOrCreate?: AIModuleCreateOrConnectWithoutLearningPathItemsInput
    connect?: AIModuleWhereUniqueInput
  }

  export type LearningPathUpdateOneRequiredWithoutAiModuleItemsNestedInput = {
    create?: XOR<LearningPathCreateWithoutAiModuleItemsInput, LearningPathUncheckedCreateWithoutAiModuleItemsInput>
    connectOrCreate?: LearningPathCreateOrConnectWithoutAiModuleItemsInput
    upsert?: LearningPathUpsertWithoutAiModuleItemsInput
    connect?: LearningPathWhereUniqueInput
    update?: XOR<XOR<LearningPathUpdateToOneWithWhereWithoutAiModuleItemsInput, LearningPathUpdateWithoutAiModuleItemsInput>, LearningPathUncheckedUpdateWithoutAiModuleItemsInput>
  }

  export type AIModuleUpdateOneRequiredWithoutLearningPathItemsNestedInput = {
    create?: XOR<AIModuleCreateWithoutLearningPathItemsInput, AIModuleUncheckedCreateWithoutLearningPathItemsInput>
    connectOrCreate?: AIModuleCreateOrConnectWithoutLearningPathItemsInput
    upsert?: AIModuleUpsertWithoutLearningPathItemsInput
    connect?: AIModuleWhereUniqueInput
    update?: XOR<XOR<AIModuleUpdateToOneWithWhereWithoutLearningPathItemsInput, AIModuleUpdateWithoutLearningPathItemsInput>, AIModuleUncheckedUpdateWithoutLearningPathItemsInput>
  }

  export type UserCreateNestedOneWithoutAiModuleQuizAttemptsInput = {
    create?: XOR<UserCreateWithoutAiModuleQuizAttemptsInput, UserUncheckedCreateWithoutAiModuleQuizAttemptsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAiModuleQuizAttemptsInput
    connect?: UserWhereUniqueInput
  }

  export type AIModuleCreateNestedOneWithoutQuizAttemptsInput = {
    create?: XOR<AIModuleCreateWithoutQuizAttemptsInput, AIModuleUncheckedCreateWithoutQuizAttemptsInput>
    connectOrCreate?: AIModuleCreateOrConnectWithoutQuizAttemptsInput
    connect?: AIModuleWhereUniqueInput
  }

  export type TopicCreateNestedOneWithoutAiModuleQuizAttemptsInput = {
    create?: XOR<TopicCreateWithoutAiModuleQuizAttemptsInput, TopicUncheckedCreateWithoutAiModuleQuizAttemptsInput>
    connectOrCreate?: TopicCreateOrConnectWithoutAiModuleQuizAttemptsInput
    connect?: TopicWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAiModuleQuizAttemptsNestedInput = {
    create?: XOR<UserCreateWithoutAiModuleQuizAttemptsInput, UserUncheckedCreateWithoutAiModuleQuizAttemptsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAiModuleQuizAttemptsInput
    upsert?: UserUpsertWithoutAiModuleQuizAttemptsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAiModuleQuizAttemptsInput, UserUpdateWithoutAiModuleQuizAttemptsInput>, UserUncheckedUpdateWithoutAiModuleQuizAttemptsInput>
  }

  export type AIModuleUpdateOneRequiredWithoutQuizAttemptsNestedInput = {
    create?: XOR<AIModuleCreateWithoutQuizAttemptsInput, AIModuleUncheckedCreateWithoutQuizAttemptsInput>
    connectOrCreate?: AIModuleCreateOrConnectWithoutQuizAttemptsInput
    upsert?: AIModuleUpsertWithoutQuizAttemptsInput
    connect?: AIModuleWhereUniqueInput
    update?: XOR<XOR<AIModuleUpdateToOneWithWhereWithoutQuizAttemptsInput, AIModuleUpdateWithoutQuizAttemptsInput>, AIModuleUncheckedUpdateWithoutQuizAttemptsInput>
  }

  export type TopicUpdateOneRequiredWithoutAiModuleQuizAttemptsNestedInput = {
    create?: XOR<TopicCreateWithoutAiModuleQuizAttemptsInput, TopicUncheckedCreateWithoutAiModuleQuizAttemptsInput>
    connectOrCreate?: TopicCreateOrConnectWithoutAiModuleQuizAttemptsInput
    upsert?: TopicUpsertWithoutAiModuleQuizAttemptsInput
    connect?: TopicWhereUniqueInput
    update?: XOR<XOR<TopicUpdateToOneWithWhereWithoutAiModuleQuizAttemptsInput, TopicUpdateWithoutAiModuleQuizAttemptsInput>, TopicUncheckedUpdateWithoutAiModuleQuizAttemptsInput>
  }

  export type UserCreateNestedOneWithoutAiModuleRatingsInput = {
    create?: XOR<UserCreateWithoutAiModuleRatingsInput, UserUncheckedCreateWithoutAiModuleRatingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAiModuleRatingsInput
    connect?: UserWhereUniqueInput
  }

  export type AIModuleCreateNestedOneWithoutRatingsInput = {
    create?: XOR<AIModuleCreateWithoutRatingsInput, AIModuleUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: AIModuleCreateOrConnectWithoutRatingsInput
    connect?: AIModuleWhereUniqueInput
  }

  export type TopicCreateNestedOneWithoutAiModuleRatingsInput = {
    create?: XOR<TopicCreateWithoutAiModuleRatingsInput, TopicUncheckedCreateWithoutAiModuleRatingsInput>
    connectOrCreate?: TopicCreateOrConnectWithoutAiModuleRatingsInput
    connect?: TopicWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAiModuleRatingsNestedInput = {
    create?: XOR<UserCreateWithoutAiModuleRatingsInput, UserUncheckedCreateWithoutAiModuleRatingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAiModuleRatingsInput
    upsert?: UserUpsertWithoutAiModuleRatingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAiModuleRatingsInput, UserUpdateWithoutAiModuleRatingsInput>, UserUncheckedUpdateWithoutAiModuleRatingsInput>
  }

  export type AIModuleUpdateOneRequiredWithoutRatingsNestedInput = {
    create?: XOR<AIModuleCreateWithoutRatingsInput, AIModuleUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: AIModuleCreateOrConnectWithoutRatingsInput
    upsert?: AIModuleUpsertWithoutRatingsInput
    connect?: AIModuleWhereUniqueInput
    update?: XOR<XOR<AIModuleUpdateToOneWithWhereWithoutRatingsInput, AIModuleUpdateWithoutRatingsInput>, AIModuleUncheckedUpdateWithoutRatingsInput>
  }

  export type TopicUpdateOneRequiredWithoutAiModuleRatingsNestedInput = {
    create?: XOR<TopicCreateWithoutAiModuleRatingsInput, TopicUncheckedCreateWithoutAiModuleRatingsInput>
    connectOrCreate?: TopicCreateOrConnectWithoutAiModuleRatingsInput
    upsert?: TopicUpsertWithoutAiModuleRatingsInput
    connect?: TopicWhereUniqueInput
    update?: XOR<XOR<TopicUpdateToOneWithWhereWithoutAiModuleRatingsInput, TopicUpdateWithoutAiModuleRatingsInput>, TopicUncheckedUpdateWithoutAiModuleRatingsInput>
  }

  export type UserCreateNestedOneWithoutUserProgressInput = {
    create?: XOR<UserCreateWithoutUserProgressInput, UserUncheckedCreateWithoutUserProgressInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserProgressInput
    connect?: UserWhereUniqueInput
  }

  export type LearningPathCreateNestedOneWithoutUserProgressInput = {
    create?: XOR<LearningPathCreateWithoutUserProgressInput, LearningPathUncheckedCreateWithoutUserProgressInput>
    connectOrCreate?: LearningPathCreateOrConnectWithoutUserProgressInput
    connect?: LearningPathWhereUniqueInput
  }

  export type LearningPathItemCreateNestedOneWithoutUserProgressInput = {
    create?: XOR<LearningPathItemCreateWithoutUserProgressInput, LearningPathItemUncheckedCreateWithoutUserProgressInput>
    connectOrCreate?: LearningPathItemCreateOrConnectWithoutUserProgressInput
    connect?: LearningPathItemWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserProgressNestedInput = {
    create?: XOR<UserCreateWithoutUserProgressInput, UserUncheckedCreateWithoutUserProgressInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserProgressInput
    upsert?: UserUpsertWithoutUserProgressInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserProgressInput, UserUpdateWithoutUserProgressInput>, UserUncheckedUpdateWithoutUserProgressInput>
  }

  export type LearningPathUpdateOneRequiredWithoutUserProgressNestedInput = {
    create?: XOR<LearningPathCreateWithoutUserProgressInput, LearningPathUncheckedCreateWithoutUserProgressInput>
    connectOrCreate?: LearningPathCreateOrConnectWithoutUserProgressInput
    upsert?: LearningPathUpsertWithoutUserProgressInput
    connect?: LearningPathWhereUniqueInput
    update?: XOR<XOR<LearningPathUpdateToOneWithWhereWithoutUserProgressInput, LearningPathUpdateWithoutUserProgressInput>, LearningPathUncheckedUpdateWithoutUserProgressInput>
  }

  export type LearningPathItemUpdateOneRequiredWithoutUserProgressNestedInput = {
    create?: XOR<LearningPathItemCreateWithoutUserProgressInput, LearningPathItemUncheckedCreateWithoutUserProgressInput>
    connectOrCreate?: LearningPathItemCreateOrConnectWithoutUserProgressInput
    upsert?: LearningPathItemUpsertWithoutUserProgressInput
    connect?: LearningPathItemWhereUniqueInput
    update?: XOR<XOR<LearningPathItemUpdateToOneWithWhereWithoutUserProgressInput, LearningPathItemUpdateWithoutUserProgressInput>, LearningPathItemUncheckedUpdateWithoutUserProgressInput>
  }

  export type AIChatMessageCreateNestedManyWithoutChatInput = {
    create?: XOR<AIChatMessageCreateWithoutChatInput, AIChatMessageUncheckedCreateWithoutChatInput> | AIChatMessageCreateWithoutChatInput[] | AIChatMessageUncheckedCreateWithoutChatInput[]
    connectOrCreate?: AIChatMessageCreateOrConnectWithoutChatInput | AIChatMessageCreateOrConnectWithoutChatInput[]
    createMany?: AIChatMessageCreateManyChatInputEnvelope
    connect?: AIChatMessageWhereUniqueInput | AIChatMessageWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutAIChatInput = {
    create?: XOR<UserCreateWithoutAIChatInput, UserUncheckedCreateWithoutAIChatInput>
    connectOrCreate?: UserCreateOrConnectWithoutAIChatInput
    connect?: UserWhereUniqueInput
  }

  export type AIChatMessageUncheckedCreateNestedManyWithoutChatInput = {
    create?: XOR<AIChatMessageCreateWithoutChatInput, AIChatMessageUncheckedCreateWithoutChatInput> | AIChatMessageCreateWithoutChatInput[] | AIChatMessageUncheckedCreateWithoutChatInput[]
    connectOrCreate?: AIChatMessageCreateOrConnectWithoutChatInput | AIChatMessageCreateOrConnectWithoutChatInput[]
    createMany?: AIChatMessageCreateManyChatInputEnvelope
    connect?: AIChatMessageWhereUniqueInput | AIChatMessageWhereUniqueInput[]
  }

  export type AIChatMessageUpdateManyWithoutChatNestedInput = {
    create?: XOR<AIChatMessageCreateWithoutChatInput, AIChatMessageUncheckedCreateWithoutChatInput> | AIChatMessageCreateWithoutChatInput[] | AIChatMessageUncheckedCreateWithoutChatInput[]
    connectOrCreate?: AIChatMessageCreateOrConnectWithoutChatInput | AIChatMessageCreateOrConnectWithoutChatInput[]
    upsert?: AIChatMessageUpsertWithWhereUniqueWithoutChatInput | AIChatMessageUpsertWithWhereUniqueWithoutChatInput[]
    createMany?: AIChatMessageCreateManyChatInputEnvelope
    set?: AIChatMessageWhereUniqueInput | AIChatMessageWhereUniqueInput[]
    disconnect?: AIChatMessageWhereUniqueInput | AIChatMessageWhereUniqueInput[]
    delete?: AIChatMessageWhereUniqueInput | AIChatMessageWhereUniqueInput[]
    connect?: AIChatMessageWhereUniqueInput | AIChatMessageWhereUniqueInput[]
    update?: AIChatMessageUpdateWithWhereUniqueWithoutChatInput | AIChatMessageUpdateWithWhereUniqueWithoutChatInput[]
    updateMany?: AIChatMessageUpdateManyWithWhereWithoutChatInput | AIChatMessageUpdateManyWithWhereWithoutChatInput[]
    deleteMany?: AIChatMessageScalarWhereInput | AIChatMessageScalarWhereInput[]
  }

  export type UserUpdateOneWithoutAIChatNestedInput = {
    create?: XOR<UserCreateWithoutAIChatInput, UserUncheckedCreateWithoutAIChatInput>
    connectOrCreate?: UserCreateOrConnectWithoutAIChatInput
    upsert?: UserUpsertWithoutAIChatInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAIChatInput, UserUpdateWithoutAIChatInput>, UserUncheckedUpdateWithoutAIChatInput>
  }

  export type AIChatMessageUncheckedUpdateManyWithoutChatNestedInput = {
    create?: XOR<AIChatMessageCreateWithoutChatInput, AIChatMessageUncheckedCreateWithoutChatInput> | AIChatMessageCreateWithoutChatInput[] | AIChatMessageUncheckedCreateWithoutChatInput[]
    connectOrCreate?: AIChatMessageCreateOrConnectWithoutChatInput | AIChatMessageCreateOrConnectWithoutChatInput[]
    upsert?: AIChatMessageUpsertWithWhereUniqueWithoutChatInput | AIChatMessageUpsertWithWhereUniqueWithoutChatInput[]
    createMany?: AIChatMessageCreateManyChatInputEnvelope
    set?: AIChatMessageWhereUniqueInput | AIChatMessageWhereUniqueInput[]
    disconnect?: AIChatMessageWhereUniqueInput | AIChatMessageWhereUniqueInput[]
    delete?: AIChatMessageWhereUniqueInput | AIChatMessageWhereUniqueInput[]
    connect?: AIChatMessageWhereUniqueInput | AIChatMessageWhereUniqueInput[]
    update?: AIChatMessageUpdateWithWhereUniqueWithoutChatInput | AIChatMessageUpdateWithWhereUniqueWithoutChatInput[]
    updateMany?: AIChatMessageUpdateManyWithWhereWithoutChatInput | AIChatMessageUpdateManyWithWhereWithoutChatInput[]
    deleteMany?: AIChatMessageScalarWhereInput | AIChatMessageScalarWhereInput[]
  }

  export type AIChatCreateNestedOneWithoutMessagesInput = {
    create?: XOR<AIChatCreateWithoutMessagesInput, AIChatUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: AIChatCreateOrConnectWithoutMessagesInput
    connect?: AIChatWhereUniqueInput
  }

  export type AIChatUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<AIChatCreateWithoutMessagesInput, AIChatUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: AIChatCreateOrConnectWithoutMessagesInput
    upsert?: AIChatUpsertWithoutMessagesInput
    connect?: AIChatWhereUniqueInput
    update?: XOR<XOR<AIChatUpdateToOneWithWhereWithoutMessagesInput, AIChatUpdateWithoutMessagesInput>, AIChatUncheckedUpdateWithoutMessagesInput>
  }

  export type UserCreateNestedOneWithoutPracticeAttemptsInput = {
    create?: XOR<UserCreateWithoutPracticeAttemptsInput, UserUncheckedCreateWithoutPracticeAttemptsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPracticeAttemptsInput
    connect?: UserWhereUniqueInput
  }

  export type AIModuleCreateNestedOneWithoutPracticeAttemptsInput = {
    create?: XOR<AIModuleCreateWithoutPracticeAttemptsInput, AIModuleUncheckedCreateWithoutPracticeAttemptsInput>
    connectOrCreate?: AIModuleCreateOrConnectWithoutPracticeAttemptsInput
    connect?: AIModuleWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPracticeAttemptsNestedInput = {
    create?: XOR<UserCreateWithoutPracticeAttemptsInput, UserUncheckedCreateWithoutPracticeAttemptsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPracticeAttemptsInput
    upsert?: UserUpsertWithoutPracticeAttemptsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPracticeAttemptsInput, UserUpdateWithoutPracticeAttemptsInput>, UserUncheckedUpdateWithoutPracticeAttemptsInput>
  }

  export type AIModuleUpdateOneRequiredWithoutPracticeAttemptsNestedInput = {
    create?: XOR<AIModuleCreateWithoutPracticeAttemptsInput, AIModuleUncheckedCreateWithoutPracticeAttemptsInput>
    connectOrCreate?: AIModuleCreateOrConnectWithoutPracticeAttemptsInput
    upsert?: AIModuleUpsertWithoutPracticeAttemptsInput
    connect?: AIModuleWhereUniqueInput
    update?: XOR<XOR<AIModuleUpdateToOneWithWhereWithoutPracticeAttemptsInput, AIModuleUpdateWithoutPracticeAttemptsInput>, AIModuleUncheckedUpdateWithoutPracticeAttemptsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    oauth_token_secret?: string | null
    oauth_token?: string | null
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    oauth_token_secret?: string | null
    oauth_token?: string | null
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ActivityCreateWithoutUserInput = {
    id?: string
    type: string
    description: string
    createdAt?: Date | string
  }

  export type ActivityUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    description: string
    createdAt?: Date | string
  }

  export type ActivityCreateOrConnectWithoutUserInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput>
  }

  export type ActivityCreateManyUserInputEnvelope = {
    data: ActivityCreateManyUserInput | ActivityCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LearningPreferencesCreateWithoutUserInput = {
    id?: string
    visualLearning: number
    auditoryLearning: number
    kinestheticLearning: number
  }

  export type LearningPreferencesUncheckedCreateWithoutUserInput = {
    id?: string
    visualLearning: number
    auditoryLearning: number
    kinestheticLearning: number
  }

  export type LearningPreferencesCreateOrConnectWithoutUserInput = {
    where: LearningPreferencesWhereUniqueInput
    create: XOR<LearningPreferencesCreateWithoutUserInput, LearningPreferencesUncheckedCreateWithoutUserInput>
  }

  export type TopicCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    progress?: ProgressCreateNestedManyWithoutTopicInput
    learningPathItems?: LearningPathItemCreateNestedManyWithoutTopicInput
    contentItems?: ContentItemCreateNestedManyWithoutTopicInput
    analyticsEntries?: AnalyticsEntryCreateNestedManyWithoutTopicInput
    comments?: CommentCreateNestedManyWithoutTopicInput
    prerequisites?: PrerequisiteCreateNestedManyWithoutTopicInput
    aiModules?: AIModuleCreateNestedManyWithoutTopicInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptCreateNestedManyWithoutTopicInput
    aiModuleRatings?: AIModuleRatingCreateNestedManyWithoutTopicInput
  }

  export type TopicUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    progress?: ProgressUncheckedCreateNestedManyWithoutTopicInput
    learningPathItems?: LearningPathItemUncheckedCreateNestedManyWithoutTopicInput
    contentItems?: ContentItemUncheckedCreateNestedManyWithoutTopicInput
    analyticsEntries?: AnalyticsEntryUncheckedCreateNestedManyWithoutTopicInput
    comments?: CommentUncheckedCreateNestedManyWithoutTopicInput
    prerequisites?: PrerequisiteUncheckedCreateNestedManyWithoutTopicInput
    aiModules?: AIModuleUncheckedCreateNestedManyWithoutTopicInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedCreateNestedManyWithoutTopicInput
    aiModuleRatings?: AIModuleRatingUncheckedCreateNestedManyWithoutTopicInput
  }

  export type TopicCreateOrConnectWithoutUserInput = {
    where: TopicWhereUniqueInput
    create: XOR<TopicCreateWithoutUserInput, TopicUncheckedCreateWithoutUserInput>
  }

  export type TopicCreateManyUserInputEnvelope = {
    data: TopicCreateManyUserInput | TopicCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProgressCreateWithoutUserInput = {
    id?: string
    completed: number
    topic: TopicCreateNestedOneWithoutProgressInput
  }

  export type ProgressUncheckedCreateWithoutUserInput = {
    id?: string
    topicId: string
    completed: number
  }

  export type ProgressCreateOrConnectWithoutUserInput = {
    where: ProgressWhereUniqueInput
    create: XOR<ProgressCreateWithoutUserInput, ProgressUncheckedCreateWithoutUserInput>
  }

  export type ProgressCreateManyUserInputEnvelope = {
    data: ProgressCreateManyUserInput | ProgressCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BadgeCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    earnedAt?: Date | string
  }

  export type BadgeUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    earnedAt?: Date | string
  }

  export type BadgeCreateOrConnectWithoutUserInput = {
    where: BadgeWhereUniqueInput
    create: XOR<BadgeCreateWithoutUserInput, BadgeUncheckedCreateWithoutUserInput>
  }

  export type BadgeCreateManyUserInputEnvelope = {
    data: BadgeCreateManyUserInput | BadgeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UpcomingReviewCreateWithoutUserInput = {
    id?: string
    topicId: string
    dueDate: Date | string
  }

  export type UpcomingReviewUncheckedCreateWithoutUserInput = {
    id?: string
    topicId: string
    dueDate: Date | string
  }

  export type UpcomingReviewCreateOrConnectWithoutUserInput = {
    where: UpcomingReviewWhereUniqueInput
    create: XOR<UpcomingReviewCreateWithoutUserInput, UpcomingReviewUncheckedCreateWithoutUserInput>
  }

  export type UpcomingReviewCreateManyUserInputEnvelope = {
    data: UpcomingReviewCreateManyUserInput | UpcomingReviewCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LearningPathCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    shareId?: string | null
    sharedAt?: Date | string | null
    items?: LearningPathItemCreateNestedManyWithoutLearningPathInput
    prerequisites?: PrerequisiteCreateNestedManyWithoutLearningPathInput
    aiModuleItems?: AIModuleLearningPathItemCreateNestedManyWithoutLearningPathInput
    UserProgress?: UserProgressCreateNestedManyWithoutLearningPathInput
  }

  export type LearningPathUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    shareId?: string | null
    sharedAt?: Date | string | null
    items?: LearningPathItemUncheckedCreateNestedManyWithoutLearningPathInput
    prerequisites?: PrerequisiteUncheckedCreateNestedManyWithoutLearningPathInput
    aiModuleItems?: AIModuleLearningPathItemUncheckedCreateNestedManyWithoutLearningPathInput
    UserProgress?: UserProgressUncheckedCreateNestedManyWithoutLearningPathInput
  }

  export type LearningPathCreateOrConnectWithoutUserInput = {
    where: LearningPathWhereUniqueInput
    create: XOR<LearningPathCreateWithoutUserInput, LearningPathUncheckedCreateWithoutUserInput>
  }

  export type LearningPathCreateManyUserInputEnvelope = {
    data: LearningPathCreateManyUserInput | LearningPathCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BookmarkCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    contentItem: ContentItemCreateNestedOneWithoutBookmarksInput
  }

  export type BookmarkUncheckedCreateWithoutUserInput = {
    id?: string
    contentItemId: string
    createdAt?: Date | string
  }

  export type BookmarkCreateOrConnectWithoutUserInput = {
    where: BookmarkWhereUniqueInput
    create: XOR<BookmarkCreateWithoutUserInput, BookmarkUncheckedCreateWithoutUserInput>
  }

  export type BookmarkCreateManyUserInputEnvelope = {
    data: BookmarkCreateManyUserInput | BookmarkCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type QuizAttemptCreateWithoutUserInput = {
    id?: string
    score: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    answers?: NullableJsonNullValueInput | InputJsonValue
    contentItem: ContentItemCreateNestedOneWithoutQuizAttemptsInput
  }

  export type QuizAttemptUncheckedCreateWithoutUserInput = {
    id?: string
    contentItemId: string
    score: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    answers?: NullableJsonNullValueInput | InputJsonValue
  }

  export type QuizAttemptCreateOrConnectWithoutUserInput = {
    where: QuizAttemptWhereUniqueInput
    create: XOR<QuizAttemptCreateWithoutUserInput, QuizAttemptUncheckedCreateWithoutUserInput>
  }

  export type QuizAttemptCreateManyUserInputEnvelope = {
    data: QuizAttemptCreateManyUserInput | QuizAttemptCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type KnowledgeNodeCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: KnowledgeNodeCreateNestedOneWithoutChildrenInput
    children?: KnowledgeNodeCreateNestedManyWithoutParentInput
  }

  export type KnowledgeNodeUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: KnowledgeNodeUncheckedCreateNestedManyWithoutParentInput
  }

  export type KnowledgeNodeCreateOrConnectWithoutUserInput = {
    where: KnowledgeNodeWhereUniqueInput
    create: XOR<KnowledgeNodeCreateWithoutUserInput, KnowledgeNodeUncheckedCreateWithoutUserInput>
  }

  export type KnowledgeNodeCreateManyUserInputEnvelope = {
    data: KnowledgeNodeCreateManyUserInput | KnowledgeNodeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LeaderboardEntryCreateWithoutUserInput = {
    id?: string
    score: number
    type: string
    startDate: Date | string
    endDate: Date | string
  }

  export type LeaderboardEntryUncheckedCreateWithoutUserInput = {
    id?: string
    score: number
    type: string
    startDate: Date | string
    endDate: Date | string
  }

  export type LeaderboardEntryCreateOrConnectWithoutUserInput = {
    where: LeaderboardEntryWhereUniqueInput
    create: XOR<LeaderboardEntryCreateWithoutUserInput, LeaderboardEntryUncheckedCreateWithoutUserInput>
  }

  export type LeaderboardEntryCreateManyUserInputEnvelope = {
    data: LeaderboardEntryCreateManyUserInput | LeaderboardEntryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReviewSessionCreateWithoutUserInput = {
    id?: string
    dueDate: Date | string
    completed?: boolean
    isUrgent?: boolean
    items?: ReviewItemCreateNestedManyWithoutReviewSessionInput
  }

  export type ReviewSessionUncheckedCreateWithoutUserInput = {
    id?: string
    dueDate: Date | string
    completed?: boolean
    isUrgent?: boolean
    items?: ReviewItemUncheckedCreateNestedManyWithoutReviewSessionInput
  }

  export type ReviewSessionCreateOrConnectWithoutUserInput = {
    where: ReviewSessionWhereUniqueInput
    create: XOR<ReviewSessionCreateWithoutUserInput, ReviewSessionUncheckedCreateWithoutUserInput>
  }

  export type ReviewSessionCreateManyUserInputEnvelope = {
    data: ReviewSessionCreateManyUserInput | ReviewSessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceMemberCreateWithoutUserInput = {
    id?: string
    role: string
    joinedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutMembersInput
    breakoutRooms?: BreakoutRoomCreateNestedManyWithoutParticipantsInput
  }

  export type WorkspaceMemberUncheckedCreateWithoutUserInput = {
    id?: string
    workspaceId: string
    role: string
    joinedAt?: Date | string
    breakoutRooms?: BreakoutRoomUncheckedCreateNestedManyWithoutParticipantsInput
  }

  export type WorkspaceMemberCreateOrConnectWithoutUserInput = {
    where: WorkspaceMemberWhereUniqueInput
    create: XOR<WorkspaceMemberCreateWithoutUserInput, WorkspaceMemberUncheckedCreateWithoutUserInput>
  }

  export type WorkspaceMemberCreateManyUserInputEnvelope = {
    data: WorkspaceMemberCreateManyUserInput | WorkspaceMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ChatMessageCreateWithoutUserInput = {
    id?: string
    content: string
    createdAt?: Date | string
    chat: ChatCreateNestedOneWithoutMessagesInput
  }

  export type ChatMessageUncheckedCreateWithoutUserInput = {
    id?: string
    chatId: string
    content: string
    createdAt?: Date | string
  }

  export type ChatMessageCreateOrConnectWithoutUserInput = {
    where: ChatMessageWhereUniqueInput
    create: XOR<ChatMessageCreateWithoutUserInput, ChatMessageUncheckedCreateWithoutUserInput>
  }

  export type ChatMessageCreateManyUserInputEnvelope = {
    data: ChatMessageCreateManyUserInput | ChatMessageCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceCreateWithoutOwnerInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberCreateNestedManyWithoutWorkspaceInput
    whiteboards?: WhiteboardCreateNestedManyWithoutWorkspaceInput
    chats?: ChatCreateNestedManyWithoutWorkspaceInput
    breakoutRooms?: BreakoutRoomCreateNestedManyWithoutWorkspaceInput
    livePolls?: LivePollCreateNestedManyWithoutWorkspaceInput
    sessionSummaries?: SessionSummaryCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutOwnerInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberUncheckedCreateNestedManyWithoutWorkspaceInput
    whiteboards?: WhiteboardUncheckedCreateNestedManyWithoutWorkspaceInput
    chats?: ChatUncheckedCreateNestedManyWithoutWorkspaceInput
    breakoutRooms?: BreakoutRoomUncheckedCreateNestedManyWithoutWorkspaceInput
    livePolls?: LivePollUncheckedCreateNestedManyWithoutWorkspaceInput
    sessionSummaries?: SessionSummaryUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutOwnerInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutOwnerInput, WorkspaceUncheckedCreateWithoutOwnerInput>
  }

  export type WorkspaceCreateManyOwnerInputEnvelope = {
    data: WorkspaceCreateManyOwnerInput | WorkspaceCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type UserSettingsCreateWithoutUserInput = {
    id?: string
    notificationPreferences: JsonNullValueInput | InputJsonValue
    voiceSettings: JsonNullValueInput | InputJsonValue
    privacySettings: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSettingsUncheckedCreateWithoutUserInput = {
    id?: string
    notificationPreferences: JsonNullValueInput | InputJsonValue
    voiceSettings: JsonNullValueInput | InputJsonValue
    privacySettings: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSettingsCreateOrConnectWithoutUserInput = {
    where: UserSettingsWhereUniqueInput
    create: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
  }

  export type AnalyticsEntryCreateWithoutUserInput = {
    id?: string
    timeSpent: number
    score?: number | null
    date?: Date | string
    topic: TopicCreateNestedOneWithoutAnalyticsEntriesInput
  }

  export type AnalyticsEntryUncheckedCreateWithoutUserInput = {
    id?: string
    topicId: string
    timeSpent: number
    score?: number | null
    date?: Date | string
  }

  export type AnalyticsEntryCreateOrConnectWithoutUserInput = {
    where: AnalyticsEntryWhereUniqueInput
    create: XOR<AnalyticsEntryCreateWithoutUserInput, AnalyticsEntryUncheckedCreateWithoutUserInput>
  }

  export type AnalyticsEntryCreateManyUserInputEnvelope = {
    data: AnalyticsEntryCreateManyUserInput | AnalyticsEntryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    type: string
    message: string
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    message: string
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PasswordlessTokenCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
  }

  export type PasswordlessTokenUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
  }

  export type PasswordlessTokenCreateOrConnectWithoutUserInput = {
    where: PasswordlessTokenWhereUniqueInput
    create: XOR<PasswordlessTokenCreateWithoutUserInput, PasswordlessTokenUncheckedCreateWithoutUserInput>
  }

  export type PasswordlessTokenCreateManyUserInputEnvelope = {
    data: PasswordlessTokenCreateManyUserInput | PasswordlessTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DailyChallengeCreateWithoutUserInput = {
    id?: string
    title: string
    description: string
    reward: string
    completed?: boolean
    createdAt?: Date | string
    completedAt?: Date | string | null
  }

  export type DailyChallengeUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    description: string
    reward: string
    completed?: boolean
    createdAt?: Date | string
    completedAt?: Date | string | null
  }

  export type DailyChallengeCreateOrConnectWithoutUserInput = {
    where: DailyChallengeWhereUniqueInput
    create: XOR<DailyChallengeCreateWithoutUserInput, DailyChallengeUncheckedCreateWithoutUserInput>
  }

  export type DailyChallengeCreateManyUserInputEnvelope = {
    data: DailyChallengeCreateManyUserInput | DailyChallengeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ExternalGoalCreateWithoutUserInput = {
    id?: string
    platform: string
    title: string
    progress: number
    dueDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExternalGoalUncheckedCreateWithoutUserInput = {
    id?: string
    platform: string
    title: string
    progress: number
    dueDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExternalGoalCreateOrConnectWithoutUserInput = {
    where: ExternalGoalWhereUniqueInput
    create: XOR<ExternalGoalCreateWithoutUserInput, ExternalGoalUncheckedCreateWithoutUserInput>
  }

  export type ExternalGoalCreateManyUserInputEnvelope = {
    data: ExternalGoalCreateManyUserInput | ExternalGoalCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutUserInput = {
    id?: string
    content: string
    createdAt?: Date | string
    topic: TopicCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutUserInput = {
    id?: string
    content: string
    topicId: string
    createdAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutUserInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentCreateManyUserInputEnvelope = {
    data: CommentCreateManyUserInput | CommentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ContentRatingCreateWithoutUserInput = {
    id?: string
    rating: number
    createdAt?: Date | string
    contentItem: ContentItemCreateNestedOneWithoutRatingsInput
  }

  export type ContentRatingUncheckedCreateWithoutUserInput = {
    id?: string
    contentItemId: string
    rating: number
    createdAt?: Date | string
  }

  export type ContentRatingCreateOrConnectWithoutUserInput = {
    where: ContentRatingWhereUniqueInput
    create: XOR<ContentRatingCreateWithoutUserInput, ContentRatingUncheckedCreateWithoutUserInput>
  }

  export type ContentRatingCreateManyUserInputEnvelope = {
    data: ContentRatingCreateManyUserInput | ContentRatingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ChallengeScoreCreateWithoutUserInput = {
    id?: string
    score: number
    createdAt?: Date | string
  }

  export type ChallengeScoreUncheckedCreateWithoutUserInput = {
    id?: string
    score: number
    createdAt?: Date | string
  }

  export type ChallengeScoreCreateOrConnectWithoutUserInput = {
    where: ChallengeScoreWhereUniqueInput
    create: XOR<ChallengeScoreCreateWithoutUserInput, ChallengeScoreUncheckedCreateWithoutUserInput>
  }

  export type ChallengeScoreCreateManyUserInputEnvelope = {
    data: ChallengeScoreCreateManyUserInput | ChallengeScoreCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PollVoteCreateWithoutUserInput = {
    id?: string
    option: string
    createdAt?: Date | string
    livePoll: LivePollCreateNestedOneWithoutVotesInput
  }

  export type PollVoteUncheckedCreateWithoutUserInput = {
    id?: string
    livePoolId: string
    option: string
    createdAt?: Date | string
  }

  export type PollVoteCreateOrConnectWithoutUserInput = {
    where: PollVoteWhereUniqueInput
    create: XOR<PollVoteCreateWithoutUserInput, PollVoteUncheckedCreateWithoutUserInput>
  }

  export type PollVoteCreateManyUserInputEnvelope = {
    data: PollVoteCreateManyUserInput | PollVoteCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AIRecommendationCreateWithoutUserInput = {
    id?: string
    content: string
    createdAt?: Date | string
  }

  export type AIRecommendationUncheckedCreateWithoutUserInput = {
    id?: string
    content: string
    createdAt?: Date | string
  }

  export type AIRecommendationCreateOrConnectWithoutUserInput = {
    where: AIRecommendationWhereUniqueInput
    create: XOR<AIRecommendationCreateWithoutUserInput, AIRecommendationUncheckedCreateWithoutUserInput>
  }

  export type AIRecommendationCreateManyUserInputEnvelope = {
    data: AIRecommendationCreateManyUserInput | AIRecommendationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AIModuleCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    content: JsonNullValueInput | InputJsonValue
    tags?: AIModuleCreatetagsInput | string[]
    difficulty?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    topic?: TopicCreateNestedOneWithoutAiModulesInput
    learningPathItems?: AIModuleLearningPathItemCreateNestedManyWithoutAiModuleInput
    quizAttempts?: AIModuleQuizAttemptCreateNestedManyWithoutAiModuleInput
    ratings?: AIModuleRatingCreateNestedManyWithoutAiModuleInput
    PracticeAttempts?: PracticeAttemptCreateNestedManyWithoutAiModuleInput
  }

  export type AIModuleUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    content: JsonNullValueInput | InputJsonValue
    tags?: AIModuleCreatetagsInput | string[]
    difficulty?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    topicId?: string | null
    learningPathItems?: AIModuleLearningPathItemUncheckedCreateNestedManyWithoutAiModuleInput
    quizAttempts?: AIModuleQuizAttemptUncheckedCreateNestedManyWithoutAiModuleInput
    ratings?: AIModuleRatingUncheckedCreateNestedManyWithoutAiModuleInput
    PracticeAttempts?: PracticeAttemptUncheckedCreateNestedManyWithoutAiModuleInput
  }

  export type AIModuleCreateOrConnectWithoutUserInput = {
    where: AIModuleWhereUniqueInput
    create: XOR<AIModuleCreateWithoutUserInput, AIModuleUncheckedCreateWithoutUserInput>
  }

  export type AIModuleCreateManyUserInputEnvelope = {
    data: AIModuleCreateManyUserInput | AIModuleCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AIModuleQuizAttemptCreateWithoutUserInput = {
    id?: string
    score: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    answers: JsonNullValueInput | InputJsonValue
    aiModule: AIModuleCreateNestedOneWithoutQuizAttemptsInput
    topic: TopicCreateNestedOneWithoutAiModuleQuizAttemptsInput
  }

  export type AIModuleQuizAttemptUncheckedCreateWithoutUserInput = {
    id?: string
    aiModuleId: string
    topicId: string
    score: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    answers: JsonNullValueInput | InputJsonValue
  }

  export type AIModuleQuizAttemptCreateOrConnectWithoutUserInput = {
    where: AIModuleQuizAttemptWhereUniqueInput
    create: XOR<AIModuleQuizAttemptCreateWithoutUserInput, AIModuleQuizAttemptUncheckedCreateWithoutUserInput>
  }

  export type AIModuleQuizAttemptCreateManyUserInputEnvelope = {
    data: AIModuleQuizAttemptCreateManyUserInput | AIModuleQuizAttemptCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AIModuleRatingCreateWithoutUserInput = {
    id?: string
    rating: number
    feedback?: string | null
    createdAt?: Date | string
    aiModule: AIModuleCreateNestedOneWithoutRatingsInput
    topic: TopicCreateNestedOneWithoutAiModuleRatingsInput
  }

  export type AIModuleRatingUncheckedCreateWithoutUserInput = {
    id?: string
    aiModuleId: string
    topicId: string
    rating: number
    feedback?: string | null
    createdAt?: Date | string
  }

  export type AIModuleRatingCreateOrConnectWithoutUserInput = {
    where: AIModuleRatingWhereUniqueInput
    create: XOR<AIModuleRatingCreateWithoutUserInput, AIModuleRatingUncheckedCreateWithoutUserInput>
  }

  export type AIModuleRatingCreateManyUserInputEnvelope = {
    data: AIModuleRatingCreateManyUserInput | AIModuleRatingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserProgressCreateWithoutUserInput = {
    id?: string
    status?: string
    updatedAt?: Date | string
    learningPath: LearningPathCreateNestedOneWithoutUserProgressInput
    module: LearningPathItemCreateNestedOneWithoutUserProgressInput
  }

  export type UserProgressUncheckedCreateWithoutUserInput = {
    id?: string
    learningPathId: string
    moduleId: string
    status?: string
    updatedAt?: Date | string
  }

  export type UserProgressCreateOrConnectWithoutUserInput = {
    where: UserProgressWhereUniqueInput
    create: XOR<UserProgressCreateWithoutUserInput, UserProgressUncheckedCreateWithoutUserInput>
  }

  export type UserProgressCreateManyUserInputEnvelope = {
    data: UserProgressCreateManyUserInput | UserProgressCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AIChatCreateWithoutUserInput = {
    id?: string
    title?: string | null
    createdAt?: Date | string
    messages?: AIChatMessageCreateNestedManyWithoutChatInput
  }

  export type AIChatUncheckedCreateWithoutUserInput = {
    id?: string
    title?: string | null
    createdAt?: Date | string
    messages?: AIChatMessageUncheckedCreateNestedManyWithoutChatInput
  }

  export type AIChatCreateOrConnectWithoutUserInput = {
    where: AIChatWhereUniqueInput
    create: XOR<AIChatCreateWithoutUserInput, AIChatUncheckedCreateWithoutUserInput>
  }

  export type AIChatCreateManyUserInputEnvelope = {
    data: AIChatCreateManyUserInput | AIChatCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PracticeAttemptCreateWithoutUserInput = {
    id?: string
    questions: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    score?: number | null
    averageEase?: number | null
    completedAt?: Date | string | null
    aiModule: AIModuleCreateNestedOneWithoutPracticeAttemptsInput
  }

  export type PracticeAttemptUncheckedCreateWithoutUserInput = {
    id?: string
    aiModuleId: string
    questions: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    score?: number | null
    averageEase?: number | null
    completedAt?: Date | string | null
  }

  export type PracticeAttemptCreateOrConnectWithoutUserInput = {
    where: PracticeAttemptWhereUniqueInput
    create: XOR<PracticeAttemptCreateWithoutUserInput, PracticeAttemptUncheckedCreateWithoutUserInput>
  }

  export type PracticeAttemptCreateManyUserInputEnvelope = {
    data: PracticeAttemptCreateManyUserInput | PracticeAttemptCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    oauth_token_secret?: StringNullableFilter<"Account"> | string | null
    oauth_token?: StringNullableFilter<"Account"> | string | null
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
  }

  export type ActivityUpsertWithWhereUniqueWithoutUserInput = {
    where: ActivityWhereUniqueInput
    update: XOR<ActivityUpdateWithoutUserInput, ActivityUncheckedUpdateWithoutUserInput>
    create: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput>
  }

  export type ActivityUpdateWithWhereUniqueWithoutUserInput = {
    where: ActivityWhereUniqueInput
    data: XOR<ActivityUpdateWithoutUserInput, ActivityUncheckedUpdateWithoutUserInput>
  }

  export type ActivityUpdateManyWithWhereWithoutUserInput = {
    where: ActivityScalarWhereInput
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutUserInput>
  }

  export type ActivityScalarWhereInput = {
    AND?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
    OR?: ActivityScalarWhereInput[]
    NOT?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
    id?: StringFilter<"Activity"> | string
    userId?: StringFilter<"Activity"> | string
    type?: StringFilter<"Activity"> | string
    description?: StringFilter<"Activity"> | string
    createdAt?: DateTimeFilter<"Activity"> | Date | string
  }

  export type LearningPreferencesUpsertWithoutUserInput = {
    update: XOR<LearningPreferencesUpdateWithoutUserInput, LearningPreferencesUncheckedUpdateWithoutUserInput>
    create: XOR<LearningPreferencesCreateWithoutUserInput, LearningPreferencesUncheckedCreateWithoutUserInput>
    where?: LearningPreferencesWhereInput
  }

  export type LearningPreferencesUpdateToOneWithWhereWithoutUserInput = {
    where?: LearningPreferencesWhereInput
    data: XOR<LearningPreferencesUpdateWithoutUserInput, LearningPreferencesUncheckedUpdateWithoutUserInput>
  }

  export type LearningPreferencesUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    visualLearning?: IntFieldUpdateOperationsInput | number
    auditoryLearning?: IntFieldUpdateOperationsInput | number
    kinestheticLearning?: IntFieldUpdateOperationsInput | number
  }

  export type LearningPreferencesUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    visualLearning?: IntFieldUpdateOperationsInput | number
    auditoryLearning?: IntFieldUpdateOperationsInput | number
    kinestheticLearning?: IntFieldUpdateOperationsInput | number
  }

  export type TopicUpsertWithWhereUniqueWithoutUserInput = {
    where: TopicWhereUniqueInput
    update: XOR<TopicUpdateWithoutUserInput, TopicUncheckedUpdateWithoutUserInput>
    create: XOR<TopicCreateWithoutUserInput, TopicUncheckedCreateWithoutUserInput>
  }

  export type TopicUpdateWithWhereUniqueWithoutUserInput = {
    where: TopicWhereUniqueInput
    data: XOR<TopicUpdateWithoutUserInput, TopicUncheckedUpdateWithoutUserInput>
  }

  export type TopicUpdateManyWithWhereWithoutUserInput = {
    where: TopicScalarWhereInput
    data: XOR<TopicUpdateManyMutationInput, TopicUncheckedUpdateManyWithoutUserInput>
  }

  export type TopicScalarWhereInput = {
    AND?: TopicScalarWhereInput | TopicScalarWhereInput[]
    OR?: TopicScalarWhereInput[]
    NOT?: TopicScalarWhereInput | TopicScalarWhereInput[]
    id?: StringFilter<"Topic"> | string
    title?: StringFilter<"Topic"> | string
    description?: StringNullableFilter<"Topic"> | string | null
    userId?: StringFilter<"Topic"> | string
  }

  export type ProgressUpsertWithWhereUniqueWithoutUserInput = {
    where: ProgressWhereUniqueInput
    update: XOR<ProgressUpdateWithoutUserInput, ProgressUncheckedUpdateWithoutUserInput>
    create: XOR<ProgressCreateWithoutUserInput, ProgressUncheckedCreateWithoutUserInput>
  }

  export type ProgressUpdateWithWhereUniqueWithoutUserInput = {
    where: ProgressWhereUniqueInput
    data: XOR<ProgressUpdateWithoutUserInput, ProgressUncheckedUpdateWithoutUserInput>
  }

  export type ProgressUpdateManyWithWhereWithoutUserInput = {
    where: ProgressScalarWhereInput
    data: XOR<ProgressUpdateManyMutationInput, ProgressUncheckedUpdateManyWithoutUserInput>
  }

  export type ProgressScalarWhereInput = {
    AND?: ProgressScalarWhereInput | ProgressScalarWhereInput[]
    OR?: ProgressScalarWhereInput[]
    NOT?: ProgressScalarWhereInput | ProgressScalarWhereInput[]
    id?: StringFilter<"Progress"> | string
    userId?: StringFilter<"Progress"> | string
    topicId?: StringFilter<"Progress"> | string
    completed?: FloatFilter<"Progress"> | number
  }

  export type BadgeUpsertWithWhereUniqueWithoutUserInput = {
    where: BadgeWhereUniqueInput
    update: XOR<BadgeUpdateWithoutUserInput, BadgeUncheckedUpdateWithoutUserInput>
    create: XOR<BadgeCreateWithoutUserInput, BadgeUncheckedCreateWithoutUserInput>
  }

  export type BadgeUpdateWithWhereUniqueWithoutUserInput = {
    where: BadgeWhereUniqueInput
    data: XOR<BadgeUpdateWithoutUserInput, BadgeUncheckedUpdateWithoutUserInput>
  }

  export type BadgeUpdateManyWithWhereWithoutUserInput = {
    where: BadgeScalarWhereInput
    data: XOR<BadgeUpdateManyMutationInput, BadgeUncheckedUpdateManyWithoutUserInput>
  }

  export type BadgeScalarWhereInput = {
    AND?: BadgeScalarWhereInput | BadgeScalarWhereInput[]
    OR?: BadgeScalarWhereInput[]
    NOT?: BadgeScalarWhereInput | BadgeScalarWhereInput[]
    id?: StringFilter<"Badge"> | string
    name?: StringFilter<"Badge"> | string
    description?: StringNullableFilter<"Badge"> | string | null
    imageUrl?: StringNullableFilter<"Badge"> | string | null
    userId?: StringFilter<"Badge"> | string
    earnedAt?: DateTimeFilter<"Badge"> | Date | string
  }

  export type UpcomingReviewUpsertWithWhereUniqueWithoutUserInput = {
    where: UpcomingReviewWhereUniqueInput
    update: XOR<UpcomingReviewUpdateWithoutUserInput, UpcomingReviewUncheckedUpdateWithoutUserInput>
    create: XOR<UpcomingReviewCreateWithoutUserInput, UpcomingReviewUncheckedCreateWithoutUserInput>
  }

  export type UpcomingReviewUpdateWithWhereUniqueWithoutUserInput = {
    where: UpcomingReviewWhereUniqueInput
    data: XOR<UpcomingReviewUpdateWithoutUserInput, UpcomingReviewUncheckedUpdateWithoutUserInput>
  }

  export type UpcomingReviewUpdateManyWithWhereWithoutUserInput = {
    where: UpcomingReviewScalarWhereInput
    data: XOR<UpcomingReviewUpdateManyMutationInput, UpcomingReviewUncheckedUpdateManyWithoutUserInput>
  }

  export type UpcomingReviewScalarWhereInput = {
    AND?: UpcomingReviewScalarWhereInput | UpcomingReviewScalarWhereInput[]
    OR?: UpcomingReviewScalarWhereInput[]
    NOT?: UpcomingReviewScalarWhereInput | UpcomingReviewScalarWhereInput[]
    id?: StringFilter<"UpcomingReview"> | string
    userId?: StringFilter<"UpcomingReview"> | string
    topicId?: StringFilter<"UpcomingReview"> | string
    dueDate?: DateTimeFilter<"UpcomingReview"> | Date | string
  }

  export type LearningPathUpsertWithWhereUniqueWithoutUserInput = {
    where: LearningPathWhereUniqueInput
    update: XOR<LearningPathUpdateWithoutUserInput, LearningPathUncheckedUpdateWithoutUserInput>
    create: XOR<LearningPathCreateWithoutUserInput, LearningPathUncheckedCreateWithoutUserInput>
  }

  export type LearningPathUpdateWithWhereUniqueWithoutUserInput = {
    where: LearningPathWhereUniqueInput
    data: XOR<LearningPathUpdateWithoutUserInput, LearningPathUncheckedUpdateWithoutUserInput>
  }

  export type LearningPathUpdateManyWithWhereWithoutUserInput = {
    where: LearningPathScalarWhereInput
    data: XOR<LearningPathUpdateManyMutationInput, LearningPathUncheckedUpdateManyWithoutUserInput>
  }

  export type LearningPathScalarWhereInput = {
    AND?: LearningPathScalarWhereInput | LearningPathScalarWhereInput[]
    OR?: LearningPathScalarWhereInput[]
    NOT?: LearningPathScalarWhereInput | LearningPathScalarWhereInput[]
    id?: StringFilter<"LearningPath"> | string
    title?: StringFilter<"LearningPath"> | string
    description?: StringNullableFilter<"LearningPath"> | string | null
    userId?: StringFilter<"LearningPath"> | string
    content?: JsonFilter<"LearningPath">
    createdAt?: DateTimeFilter<"LearningPath"> | Date | string
    updatedAt?: DateTimeFilter<"LearningPath"> | Date | string
    shareId?: StringNullableFilter<"LearningPath"> | string | null
    sharedAt?: DateTimeNullableFilter<"LearningPath"> | Date | string | null
  }

  export type BookmarkUpsertWithWhereUniqueWithoutUserInput = {
    where: BookmarkWhereUniqueInput
    update: XOR<BookmarkUpdateWithoutUserInput, BookmarkUncheckedUpdateWithoutUserInput>
    create: XOR<BookmarkCreateWithoutUserInput, BookmarkUncheckedCreateWithoutUserInput>
  }

  export type BookmarkUpdateWithWhereUniqueWithoutUserInput = {
    where: BookmarkWhereUniqueInput
    data: XOR<BookmarkUpdateWithoutUserInput, BookmarkUncheckedUpdateWithoutUserInput>
  }

  export type BookmarkUpdateManyWithWhereWithoutUserInput = {
    where: BookmarkScalarWhereInput
    data: XOR<BookmarkUpdateManyMutationInput, BookmarkUncheckedUpdateManyWithoutUserInput>
  }

  export type BookmarkScalarWhereInput = {
    AND?: BookmarkScalarWhereInput | BookmarkScalarWhereInput[]
    OR?: BookmarkScalarWhereInput[]
    NOT?: BookmarkScalarWhereInput | BookmarkScalarWhereInput[]
    id?: StringFilter<"Bookmark"> | string
    userId?: StringFilter<"Bookmark"> | string
    contentItemId?: StringFilter<"Bookmark"> | string
    createdAt?: DateTimeFilter<"Bookmark"> | Date | string
  }

  export type QuizAttemptUpsertWithWhereUniqueWithoutUserInput = {
    where: QuizAttemptWhereUniqueInput
    update: XOR<QuizAttemptUpdateWithoutUserInput, QuizAttemptUncheckedUpdateWithoutUserInput>
    create: XOR<QuizAttemptCreateWithoutUserInput, QuizAttemptUncheckedCreateWithoutUserInput>
  }

  export type QuizAttemptUpdateWithWhereUniqueWithoutUserInput = {
    where: QuizAttemptWhereUniqueInput
    data: XOR<QuizAttemptUpdateWithoutUserInput, QuizAttemptUncheckedUpdateWithoutUserInput>
  }

  export type QuizAttemptUpdateManyWithWhereWithoutUserInput = {
    where: QuizAttemptScalarWhereInput
    data: XOR<QuizAttemptUpdateManyMutationInput, QuizAttemptUncheckedUpdateManyWithoutUserInput>
  }

  export type QuizAttemptScalarWhereInput = {
    AND?: QuizAttemptScalarWhereInput | QuizAttemptScalarWhereInput[]
    OR?: QuizAttemptScalarWhereInput[]
    NOT?: QuizAttemptScalarWhereInput | QuizAttemptScalarWhereInput[]
    id?: StringFilter<"QuizAttempt"> | string
    userId?: StringFilter<"QuizAttempt"> | string
    contentItemId?: StringFilter<"QuizAttempt"> | string
    score?: FloatFilter<"QuizAttempt"> | number
    startedAt?: DateTimeFilter<"QuizAttempt"> | Date | string
    completedAt?: DateTimeNullableFilter<"QuizAttempt"> | Date | string | null
    answers?: JsonNullableFilter<"QuizAttempt">
  }

  export type KnowledgeNodeUpsertWithWhereUniqueWithoutUserInput = {
    where: KnowledgeNodeWhereUniqueInput
    update: XOR<KnowledgeNodeUpdateWithoutUserInput, KnowledgeNodeUncheckedUpdateWithoutUserInput>
    create: XOR<KnowledgeNodeCreateWithoutUserInput, KnowledgeNodeUncheckedCreateWithoutUserInput>
  }

  export type KnowledgeNodeUpdateWithWhereUniqueWithoutUserInput = {
    where: KnowledgeNodeWhereUniqueInput
    data: XOR<KnowledgeNodeUpdateWithoutUserInput, KnowledgeNodeUncheckedUpdateWithoutUserInput>
  }

  export type KnowledgeNodeUpdateManyWithWhereWithoutUserInput = {
    where: KnowledgeNodeScalarWhereInput
    data: XOR<KnowledgeNodeUpdateManyMutationInput, KnowledgeNodeUncheckedUpdateManyWithoutUserInput>
  }

  export type KnowledgeNodeScalarWhereInput = {
    AND?: KnowledgeNodeScalarWhereInput | KnowledgeNodeScalarWhereInput[]
    OR?: KnowledgeNodeScalarWhereInput[]
    NOT?: KnowledgeNodeScalarWhereInput | KnowledgeNodeScalarWhereInput[]
    id?: StringFilter<"KnowledgeNode"> | string
    title?: StringFilter<"KnowledgeNode"> | string
    description?: StringNullableFilter<"KnowledgeNode"> | string | null
    userId?: StringFilter<"KnowledgeNode"> | string
    parentId?: StringNullableFilter<"KnowledgeNode"> | string | null
    createdAt?: DateTimeFilter<"KnowledgeNode"> | Date | string
    updatedAt?: DateTimeFilter<"KnowledgeNode"> | Date | string
  }

  export type LeaderboardEntryUpsertWithWhereUniqueWithoutUserInput = {
    where: LeaderboardEntryWhereUniqueInput
    update: XOR<LeaderboardEntryUpdateWithoutUserInput, LeaderboardEntryUncheckedUpdateWithoutUserInput>
    create: XOR<LeaderboardEntryCreateWithoutUserInput, LeaderboardEntryUncheckedCreateWithoutUserInput>
  }

  export type LeaderboardEntryUpdateWithWhereUniqueWithoutUserInput = {
    where: LeaderboardEntryWhereUniqueInput
    data: XOR<LeaderboardEntryUpdateWithoutUserInput, LeaderboardEntryUncheckedUpdateWithoutUserInput>
  }

  export type LeaderboardEntryUpdateManyWithWhereWithoutUserInput = {
    where: LeaderboardEntryScalarWhereInput
    data: XOR<LeaderboardEntryUpdateManyMutationInput, LeaderboardEntryUncheckedUpdateManyWithoutUserInput>
  }

  export type LeaderboardEntryScalarWhereInput = {
    AND?: LeaderboardEntryScalarWhereInput | LeaderboardEntryScalarWhereInput[]
    OR?: LeaderboardEntryScalarWhereInput[]
    NOT?: LeaderboardEntryScalarWhereInput | LeaderboardEntryScalarWhereInput[]
    id?: StringFilter<"LeaderboardEntry"> | string
    userId?: StringFilter<"LeaderboardEntry"> | string
    score?: IntFilter<"LeaderboardEntry"> | number
    type?: StringFilter<"LeaderboardEntry"> | string
    startDate?: DateTimeFilter<"LeaderboardEntry"> | Date | string
    endDate?: DateTimeFilter<"LeaderboardEntry"> | Date | string
  }

  export type ReviewSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: ReviewSessionWhereUniqueInput
    update: XOR<ReviewSessionUpdateWithoutUserInput, ReviewSessionUncheckedUpdateWithoutUserInput>
    create: XOR<ReviewSessionCreateWithoutUserInput, ReviewSessionUncheckedCreateWithoutUserInput>
  }

  export type ReviewSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: ReviewSessionWhereUniqueInput
    data: XOR<ReviewSessionUpdateWithoutUserInput, ReviewSessionUncheckedUpdateWithoutUserInput>
  }

  export type ReviewSessionUpdateManyWithWhereWithoutUserInput = {
    where: ReviewSessionScalarWhereInput
    data: XOR<ReviewSessionUpdateManyMutationInput, ReviewSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type ReviewSessionScalarWhereInput = {
    AND?: ReviewSessionScalarWhereInput | ReviewSessionScalarWhereInput[]
    OR?: ReviewSessionScalarWhereInput[]
    NOT?: ReviewSessionScalarWhereInput | ReviewSessionScalarWhereInput[]
    id?: StringFilter<"ReviewSession"> | string
    userId?: StringFilter<"ReviewSession"> | string
    dueDate?: DateTimeFilter<"ReviewSession"> | Date | string
    completed?: BoolFilter<"ReviewSession"> | boolean
    isUrgent?: BoolFilter<"ReviewSession"> | boolean
  }

  export type WorkspaceMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: WorkspaceMemberWhereUniqueInput
    update: XOR<WorkspaceMemberUpdateWithoutUserInput, WorkspaceMemberUncheckedUpdateWithoutUserInput>
    create: XOR<WorkspaceMemberCreateWithoutUserInput, WorkspaceMemberUncheckedCreateWithoutUserInput>
  }

  export type WorkspaceMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: WorkspaceMemberWhereUniqueInput
    data: XOR<WorkspaceMemberUpdateWithoutUserInput, WorkspaceMemberUncheckedUpdateWithoutUserInput>
  }

  export type WorkspaceMemberUpdateManyWithWhereWithoutUserInput = {
    where: WorkspaceMemberScalarWhereInput
    data: XOR<WorkspaceMemberUpdateManyMutationInput, WorkspaceMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type WorkspaceMemberScalarWhereInput = {
    AND?: WorkspaceMemberScalarWhereInput | WorkspaceMemberScalarWhereInput[]
    OR?: WorkspaceMemberScalarWhereInput[]
    NOT?: WorkspaceMemberScalarWhereInput | WorkspaceMemberScalarWhereInput[]
    id?: StringFilter<"WorkspaceMember"> | string
    userId?: StringFilter<"WorkspaceMember"> | string
    workspaceId?: StringFilter<"WorkspaceMember"> | string
    role?: StringFilter<"WorkspaceMember"> | string
    joinedAt?: DateTimeFilter<"WorkspaceMember"> | Date | string
  }

  export type ChatMessageUpsertWithWhereUniqueWithoutUserInput = {
    where: ChatMessageWhereUniqueInput
    update: XOR<ChatMessageUpdateWithoutUserInput, ChatMessageUncheckedUpdateWithoutUserInput>
    create: XOR<ChatMessageCreateWithoutUserInput, ChatMessageUncheckedCreateWithoutUserInput>
  }

  export type ChatMessageUpdateWithWhereUniqueWithoutUserInput = {
    where: ChatMessageWhereUniqueInput
    data: XOR<ChatMessageUpdateWithoutUserInput, ChatMessageUncheckedUpdateWithoutUserInput>
  }

  export type ChatMessageUpdateManyWithWhereWithoutUserInput = {
    where: ChatMessageScalarWhereInput
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyWithoutUserInput>
  }

  export type ChatMessageScalarWhereInput = {
    AND?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
    OR?: ChatMessageScalarWhereInput[]
    NOT?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
    id?: StringFilter<"ChatMessage"> | string
    chatId?: StringFilter<"ChatMessage"> | string
    userId?: StringFilter<"ChatMessage"> | string
    content?: StringFilter<"ChatMessage"> | string
    createdAt?: DateTimeFilter<"ChatMessage"> | Date | string
  }

  export type WorkspaceUpsertWithWhereUniqueWithoutOwnerInput = {
    where: WorkspaceWhereUniqueInput
    update: XOR<WorkspaceUpdateWithoutOwnerInput, WorkspaceUncheckedUpdateWithoutOwnerInput>
    create: XOR<WorkspaceCreateWithoutOwnerInput, WorkspaceUncheckedCreateWithoutOwnerInput>
  }

  export type WorkspaceUpdateWithWhereUniqueWithoutOwnerInput = {
    where: WorkspaceWhereUniqueInput
    data: XOR<WorkspaceUpdateWithoutOwnerInput, WorkspaceUncheckedUpdateWithoutOwnerInput>
  }

  export type WorkspaceUpdateManyWithWhereWithoutOwnerInput = {
    where: WorkspaceScalarWhereInput
    data: XOR<WorkspaceUpdateManyMutationInput, WorkspaceUncheckedUpdateManyWithoutOwnerInput>
  }

  export type WorkspaceScalarWhereInput = {
    AND?: WorkspaceScalarWhereInput | WorkspaceScalarWhereInput[]
    OR?: WorkspaceScalarWhereInput[]
    NOT?: WorkspaceScalarWhereInput | WorkspaceScalarWhereInput[]
    id?: StringFilter<"Workspace"> | string
    name?: StringFilter<"Workspace"> | string
    description?: StringNullableFilter<"Workspace"> | string | null
    createdAt?: DateTimeFilter<"Workspace"> | Date | string
    updatedAt?: DateTimeFilter<"Workspace"> | Date | string
    ownerId?: StringFilter<"Workspace"> | string
  }

  export type UserSettingsUpsertWithoutUserInput = {
    update: XOR<UserSettingsUpdateWithoutUserInput, UserSettingsUncheckedUpdateWithoutUserInput>
    create: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    where?: UserSettingsWhereInput
  }

  export type UserSettingsUpdateToOneWithWhereWithoutUserInput = {
    where?: UserSettingsWhereInput
    data: XOR<UserSettingsUpdateWithoutUserInput, UserSettingsUncheckedUpdateWithoutUserInput>
  }

  export type UserSettingsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationPreferences?: JsonNullValueInput | InputJsonValue
    voiceSettings?: JsonNullValueInput | InputJsonValue
    privacySettings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationPreferences?: JsonNullValueInput | InputJsonValue
    voiceSettings?: JsonNullValueInput | InputJsonValue
    privacySettings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsEntryUpsertWithWhereUniqueWithoutUserInput = {
    where: AnalyticsEntryWhereUniqueInput
    update: XOR<AnalyticsEntryUpdateWithoutUserInput, AnalyticsEntryUncheckedUpdateWithoutUserInput>
    create: XOR<AnalyticsEntryCreateWithoutUserInput, AnalyticsEntryUncheckedCreateWithoutUserInput>
  }

  export type AnalyticsEntryUpdateWithWhereUniqueWithoutUserInput = {
    where: AnalyticsEntryWhereUniqueInput
    data: XOR<AnalyticsEntryUpdateWithoutUserInput, AnalyticsEntryUncheckedUpdateWithoutUserInput>
  }

  export type AnalyticsEntryUpdateManyWithWhereWithoutUserInput = {
    where: AnalyticsEntryScalarWhereInput
    data: XOR<AnalyticsEntryUpdateManyMutationInput, AnalyticsEntryUncheckedUpdateManyWithoutUserInput>
  }

  export type AnalyticsEntryScalarWhereInput = {
    AND?: AnalyticsEntryScalarWhereInput | AnalyticsEntryScalarWhereInput[]
    OR?: AnalyticsEntryScalarWhereInput[]
    NOT?: AnalyticsEntryScalarWhereInput | AnalyticsEntryScalarWhereInput[]
    id?: StringFilter<"AnalyticsEntry"> | string
    userId?: StringFilter<"AnalyticsEntry"> | string
    topicId?: StringFilter<"AnalyticsEntry"> | string
    timeSpent?: IntFilter<"AnalyticsEntry"> | number
    score?: FloatNullableFilter<"AnalyticsEntry"> | number | null
    date?: DateTimeFilter<"AnalyticsEntry"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type PasswordlessTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: PasswordlessTokenWhereUniqueInput
    update: XOR<PasswordlessTokenUpdateWithoutUserInput, PasswordlessTokenUncheckedUpdateWithoutUserInput>
    create: XOR<PasswordlessTokenCreateWithoutUserInput, PasswordlessTokenUncheckedCreateWithoutUserInput>
  }

  export type PasswordlessTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: PasswordlessTokenWhereUniqueInput
    data: XOR<PasswordlessTokenUpdateWithoutUserInput, PasswordlessTokenUncheckedUpdateWithoutUserInput>
  }

  export type PasswordlessTokenUpdateManyWithWhereWithoutUserInput = {
    where: PasswordlessTokenScalarWhereInput
    data: XOR<PasswordlessTokenUpdateManyMutationInput, PasswordlessTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type PasswordlessTokenScalarWhereInput = {
    AND?: PasswordlessTokenScalarWhereInput | PasswordlessTokenScalarWhereInput[]
    OR?: PasswordlessTokenScalarWhereInput[]
    NOT?: PasswordlessTokenScalarWhereInput | PasswordlessTokenScalarWhereInput[]
    id?: StringFilter<"PasswordlessToken"> | string
    token?: StringFilter<"PasswordlessToken"> | string
    expiresAt?: DateTimeFilter<"PasswordlessToken"> | Date | string
    userId?: StringFilter<"PasswordlessToken"> | string
  }

  export type DailyChallengeUpsertWithWhereUniqueWithoutUserInput = {
    where: DailyChallengeWhereUniqueInput
    update: XOR<DailyChallengeUpdateWithoutUserInput, DailyChallengeUncheckedUpdateWithoutUserInput>
    create: XOR<DailyChallengeCreateWithoutUserInput, DailyChallengeUncheckedCreateWithoutUserInput>
  }

  export type DailyChallengeUpdateWithWhereUniqueWithoutUserInput = {
    where: DailyChallengeWhereUniqueInput
    data: XOR<DailyChallengeUpdateWithoutUserInput, DailyChallengeUncheckedUpdateWithoutUserInput>
  }

  export type DailyChallengeUpdateManyWithWhereWithoutUserInput = {
    where: DailyChallengeScalarWhereInput
    data: XOR<DailyChallengeUpdateManyMutationInput, DailyChallengeUncheckedUpdateManyWithoutUserInput>
  }

  export type DailyChallengeScalarWhereInput = {
    AND?: DailyChallengeScalarWhereInput | DailyChallengeScalarWhereInput[]
    OR?: DailyChallengeScalarWhereInput[]
    NOT?: DailyChallengeScalarWhereInput | DailyChallengeScalarWhereInput[]
    id?: StringFilter<"DailyChallenge"> | string
    userId?: StringFilter<"DailyChallenge"> | string
    title?: StringFilter<"DailyChallenge"> | string
    description?: StringFilter<"DailyChallenge"> | string
    reward?: StringFilter<"DailyChallenge"> | string
    completed?: BoolFilter<"DailyChallenge"> | boolean
    createdAt?: DateTimeFilter<"DailyChallenge"> | Date | string
    completedAt?: DateTimeNullableFilter<"DailyChallenge"> | Date | string | null
  }

  export type ExternalGoalUpsertWithWhereUniqueWithoutUserInput = {
    where: ExternalGoalWhereUniqueInput
    update: XOR<ExternalGoalUpdateWithoutUserInput, ExternalGoalUncheckedUpdateWithoutUserInput>
    create: XOR<ExternalGoalCreateWithoutUserInput, ExternalGoalUncheckedCreateWithoutUserInput>
  }

  export type ExternalGoalUpdateWithWhereUniqueWithoutUserInput = {
    where: ExternalGoalWhereUniqueInput
    data: XOR<ExternalGoalUpdateWithoutUserInput, ExternalGoalUncheckedUpdateWithoutUserInput>
  }

  export type ExternalGoalUpdateManyWithWhereWithoutUserInput = {
    where: ExternalGoalScalarWhereInput
    data: XOR<ExternalGoalUpdateManyMutationInput, ExternalGoalUncheckedUpdateManyWithoutUserInput>
  }

  export type ExternalGoalScalarWhereInput = {
    AND?: ExternalGoalScalarWhereInput | ExternalGoalScalarWhereInput[]
    OR?: ExternalGoalScalarWhereInput[]
    NOT?: ExternalGoalScalarWhereInput | ExternalGoalScalarWhereInput[]
    id?: StringFilter<"ExternalGoal"> | string
    userId?: StringFilter<"ExternalGoal"> | string
    platform?: StringFilter<"ExternalGoal"> | string
    title?: StringFilter<"ExternalGoal"> | string
    progress?: FloatFilter<"ExternalGoal"> | number
    dueDate?: DateTimeFilter<"ExternalGoal"> | Date | string
    createdAt?: DateTimeFilter<"ExternalGoal"> | Date | string
    updatedAt?: DateTimeFilter<"ExternalGoal"> | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
  }

  export type CommentUpdateManyWithWhereWithoutUserInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutUserInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    userId?: StringFilter<"Comment"> | string
    topicId?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
  }

  export type ContentRatingUpsertWithWhereUniqueWithoutUserInput = {
    where: ContentRatingWhereUniqueInput
    update: XOR<ContentRatingUpdateWithoutUserInput, ContentRatingUncheckedUpdateWithoutUserInput>
    create: XOR<ContentRatingCreateWithoutUserInput, ContentRatingUncheckedCreateWithoutUserInput>
  }

  export type ContentRatingUpdateWithWhereUniqueWithoutUserInput = {
    where: ContentRatingWhereUniqueInput
    data: XOR<ContentRatingUpdateWithoutUserInput, ContentRatingUncheckedUpdateWithoutUserInput>
  }

  export type ContentRatingUpdateManyWithWhereWithoutUserInput = {
    where: ContentRatingScalarWhereInput
    data: XOR<ContentRatingUpdateManyMutationInput, ContentRatingUncheckedUpdateManyWithoutUserInput>
  }

  export type ContentRatingScalarWhereInput = {
    AND?: ContentRatingScalarWhereInput | ContentRatingScalarWhereInput[]
    OR?: ContentRatingScalarWhereInput[]
    NOT?: ContentRatingScalarWhereInput | ContentRatingScalarWhereInput[]
    id?: StringFilter<"ContentRating"> | string
    userId?: StringFilter<"ContentRating"> | string
    contentItemId?: StringFilter<"ContentRating"> | string
    rating?: IntFilter<"ContentRating"> | number
    createdAt?: DateTimeFilter<"ContentRating"> | Date | string
  }

  export type ChallengeScoreUpsertWithWhereUniqueWithoutUserInput = {
    where: ChallengeScoreWhereUniqueInput
    update: XOR<ChallengeScoreUpdateWithoutUserInput, ChallengeScoreUncheckedUpdateWithoutUserInput>
    create: XOR<ChallengeScoreCreateWithoutUserInput, ChallengeScoreUncheckedCreateWithoutUserInput>
  }

  export type ChallengeScoreUpdateWithWhereUniqueWithoutUserInput = {
    where: ChallengeScoreWhereUniqueInput
    data: XOR<ChallengeScoreUpdateWithoutUserInput, ChallengeScoreUncheckedUpdateWithoutUserInput>
  }

  export type ChallengeScoreUpdateManyWithWhereWithoutUserInput = {
    where: ChallengeScoreScalarWhereInput
    data: XOR<ChallengeScoreUpdateManyMutationInput, ChallengeScoreUncheckedUpdateManyWithoutUserInput>
  }

  export type ChallengeScoreScalarWhereInput = {
    AND?: ChallengeScoreScalarWhereInput | ChallengeScoreScalarWhereInput[]
    OR?: ChallengeScoreScalarWhereInput[]
    NOT?: ChallengeScoreScalarWhereInput | ChallengeScoreScalarWhereInput[]
    id?: StringFilter<"ChallengeScore"> | string
    userId?: StringFilter<"ChallengeScore"> | string
    score?: IntFilter<"ChallengeScore"> | number
    createdAt?: DateTimeFilter<"ChallengeScore"> | Date | string
  }

  export type PollVoteUpsertWithWhereUniqueWithoutUserInput = {
    where: PollVoteWhereUniqueInput
    update: XOR<PollVoteUpdateWithoutUserInput, PollVoteUncheckedUpdateWithoutUserInput>
    create: XOR<PollVoteCreateWithoutUserInput, PollVoteUncheckedCreateWithoutUserInput>
  }

  export type PollVoteUpdateWithWhereUniqueWithoutUserInput = {
    where: PollVoteWhereUniqueInput
    data: XOR<PollVoteUpdateWithoutUserInput, PollVoteUncheckedUpdateWithoutUserInput>
  }

  export type PollVoteUpdateManyWithWhereWithoutUserInput = {
    where: PollVoteScalarWhereInput
    data: XOR<PollVoteUpdateManyMutationInput, PollVoteUncheckedUpdateManyWithoutUserInput>
  }

  export type PollVoteScalarWhereInput = {
    AND?: PollVoteScalarWhereInput | PollVoteScalarWhereInput[]
    OR?: PollVoteScalarWhereInput[]
    NOT?: PollVoteScalarWhereInput | PollVoteScalarWhereInput[]
    id?: StringFilter<"PollVote"> | string
    livePoolId?: StringFilter<"PollVote"> | string
    userId?: StringFilter<"PollVote"> | string
    option?: StringFilter<"PollVote"> | string
    createdAt?: DateTimeFilter<"PollVote"> | Date | string
  }

  export type AIRecommendationUpsertWithWhereUniqueWithoutUserInput = {
    where: AIRecommendationWhereUniqueInput
    update: XOR<AIRecommendationUpdateWithoutUserInput, AIRecommendationUncheckedUpdateWithoutUserInput>
    create: XOR<AIRecommendationCreateWithoutUserInput, AIRecommendationUncheckedCreateWithoutUserInput>
  }

  export type AIRecommendationUpdateWithWhereUniqueWithoutUserInput = {
    where: AIRecommendationWhereUniqueInput
    data: XOR<AIRecommendationUpdateWithoutUserInput, AIRecommendationUncheckedUpdateWithoutUserInput>
  }

  export type AIRecommendationUpdateManyWithWhereWithoutUserInput = {
    where: AIRecommendationScalarWhereInput
    data: XOR<AIRecommendationUpdateManyMutationInput, AIRecommendationUncheckedUpdateManyWithoutUserInput>
  }

  export type AIRecommendationScalarWhereInput = {
    AND?: AIRecommendationScalarWhereInput | AIRecommendationScalarWhereInput[]
    OR?: AIRecommendationScalarWhereInput[]
    NOT?: AIRecommendationScalarWhereInput | AIRecommendationScalarWhereInput[]
    id?: StringFilter<"AIRecommendation"> | string
    userId?: StringFilter<"AIRecommendation"> | string
    content?: StringFilter<"AIRecommendation"> | string
    createdAt?: DateTimeFilter<"AIRecommendation"> | Date | string
  }

  export type AIModuleUpsertWithWhereUniqueWithoutUserInput = {
    where: AIModuleWhereUniqueInput
    update: XOR<AIModuleUpdateWithoutUserInput, AIModuleUncheckedUpdateWithoutUserInput>
    create: XOR<AIModuleCreateWithoutUserInput, AIModuleUncheckedCreateWithoutUserInput>
  }

  export type AIModuleUpdateWithWhereUniqueWithoutUserInput = {
    where: AIModuleWhereUniqueInput
    data: XOR<AIModuleUpdateWithoutUserInput, AIModuleUncheckedUpdateWithoutUserInput>
  }

  export type AIModuleUpdateManyWithWhereWithoutUserInput = {
    where: AIModuleScalarWhereInput
    data: XOR<AIModuleUpdateManyMutationInput, AIModuleUncheckedUpdateManyWithoutUserInput>
  }

  export type AIModuleScalarWhereInput = {
    AND?: AIModuleScalarWhereInput | AIModuleScalarWhereInput[]
    OR?: AIModuleScalarWhereInput[]
    NOT?: AIModuleScalarWhereInput | AIModuleScalarWhereInput[]
    id?: StringFilter<"AIModule"> | string
    title?: StringFilter<"AIModule"> | string
    description?: StringNullableFilter<"AIModule"> | string | null
    content?: JsonFilter<"AIModule">
    tags?: StringNullableListFilter<"AIModule">
    difficulty?: StringNullableFilter<"AIModule"> | string | null
    status?: StringFilter<"AIModule"> | string
    createdAt?: DateTimeFilter<"AIModule"> | Date | string
    updatedAt?: DateTimeFilter<"AIModule"> | Date | string
    userId?: StringNullableFilter<"AIModule"> | string | null
    topicId?: StringNullableFilter<"AIModule"> | string | null
  }

  export type AIModuleQuizAttemptUpsertWithWhereUniqueWithoutUserInput = {
    where: AIModuleQuizAttemptWhereUniqueInput
    update: XOR<AIModuleQuizAttemptUpdateWithoutUserInput, AIModuleQuizAttemptUncheckedUpdateWithoutUserInput>
    create: XOR<AIModuleQuizAttemptCreateWithoutUserInput, AIModuleQuizAttemptUncheckedCreateWithoutUserInput>
  }

  export type AIModuleQuizAttemptUpdateWithWhereUniqueWithoutUserInput = {
    where: AIModuleQuizAttemptWhereUniqueInput
    data: XOR<AIModuleQuizAttemptUpdateWithoutUserInput, AIModuleQuizAttemptUncheckedUpdateWithoutUserInput>
  }

  export type AIModuleQuizAttemptUpdateManyWithWhereWithoutUserInput = {
    where: AIModuleQuizAttemptScalarWhereInput
    data: XOR<AIModuleQuizAttemptUpdateManyMutationInput, AIModuleQuizAttemptUncheckedUpdateManyWithoutUserInput>
  }

  export type AIModuleQuizAttemptScalarWhereInput = {
    AND?: AIModuleQuizAttemptScalarWhereInput | AIModuleQuizAttemptScalarWhereInput[]
    OR?: AIModuleQuizAttemptScalarWhereInput[]
    NOT?: AIModuleQuizAttemptScalarWhereInput | AIModuleQuizAttemptScalarWhereInput[]
    id?: StringFilter<"AIModuleQuizAttempt"> | string
    userId?: StringFilter<"AIModuleQuizAttempt"> | string
    aiModuleId?: StringFilter<"AIModuleQuizAttempt"> | string
    topicId?: StringFilter<"AIModuleQuizAttempt"> | string
    score?: FloatFilter<"AIModuleQuizAttempt"> | number
    startedAt?: DateTimeFilter<"AIModuleQuizAttempt"> | Date | string
    completedAt?: DateTimeNullableFilter<"AIModuleQuizAttempt"> | Date | string | null
    answers?: JsonFilter<"AIModuleQuizAttempt">
  }

  export type AIModuleRatingUpsertWithWhereUniqueWithoutUserInput = {
    where: AIModuleRatingWhereUniqueInput
    update: XOR<AIModuleRatingUpdateWithoutUserInput, AIModuleRatingUncheckedUpdateWithoutUserInput>
    create: XOR<AIModuleRatingCreateWithoutUserInput, AIModuleRatingUncheckedCreateWithoutUserInput>
  }

  export type AIModuleRatingUpdateWithWhereUniqueWithoutUserInput = {
    where: AIModuleRatingWhereUniqueInput
    data: XOR<AIModuleRatingUpdateWithoutUserInput, AIModuleRatingUncheckedUpdateWithoutUserInput>
  }

  export type AIModuleRatingUpdateManyWithWhereWithoutUserInput = {
    where: AIModuleRatingScalarWhereInput
    data: XOR<AIModuleRatingUpdateManyMutationInput, AIModuleRatingUncheckedUpdateManyWithoutUserInput>
  }

  export type AIModuleRatingScalarWhereInput = {
    AND?: AIModuleRatingScalarWhereInput | AIModuleRatingScalarWhereInput[]
    OR?: AIModuleRatingScalarWhereInput[]
    NOT?: AIModuleRatingScalarWhereInput | AIModuleRatingScalarWhereInput[]
    id?: StringFilter<"AIModuleRating"> | string
    userId?: StringFilter<"AIModuleRating"> | string
    aiModuleId?: StringFilter<"AIModuleRating"> | string
    topicId?: StringFilter<"AIModuleRating"> | string
    rating?: IntFilter<"AIModuleRating"> | number
    feedback?: StringNullableFilter<"AIModuleRating"> | string | null
    createdAt?: DateTimeFilter<"AIModuleRating"> | Date | string
  }

  export type UserProgressUpsertWithWhereUniqueWithoutUserInput = {
    where: UserProgressWhereUniqueInput
    update: XOR<UserProgressUpdateWithoutUserInput, UserProgressUncheckedUpdateWithoutUserInput>
    create: XOR<UserProgressCreateWithoutUserInput, UserProgressUncheckedCreateWithoutUserInput>
  }

  export type UserProgressUpdateWithWhereUniqueWithoutUserInput = {
    where: UserProgressWhereUniqueInput
    data: XOR<UserProgressUpdateWithoutUserInput, UserProgressUncheckedUpdateWithoutUserInput>
  }

  export type UserProgressUpdateManyWithWhereWithoutUserInput = {
    where: UserProgressScalarWhereInput
    data: XOR<UserProgressUpdateManyMutationInput, UserProgressUncheckedUpdateManyWithoutUserInput>
  }

  export type UserProgressScalarWhereInput = {
    AND?: UserProgressScalarWhereInput | UserProgressScalarWhereInput[]
    OR?: UserProgressScalarWhereInput[]
    NOT?: UserProgressScalarWhereInput | UserProgressScalarWhereInput[]
    id?: StringFilter<"UserProgress"> | string
    userId?: StringFilter<"UserProgress"> | string
    learningPathId?: StringFilter<"UserProgress"> | string
    moduleId?: StringFilter<"UserProgress"> | string
    status?: StringFilter<"UserProgress"> | string
    updatedAt?: DateTimeFilter<"UserProgress"> | Date | string
  }

  export type AIChatUpsertWithWhereUniqueWithoutUserInput = {
    where: AIChatWhereUniqueInput
    update: XOR<AIChatUpdateWithoutUserInput, AIChatUncheckedUpdateWithoutUserInput>
    create: XOR<AIChatCreateWithoutUserInput, AIChatUncheckedCreateWithoutUserInput>
  }

  export type AIChatUpdateWithWhereUniqueWithoutUserInput = {
    where: AIChatWhereUniqueInput
    data: XOR<AIChatUpdateWithoutUserInput, AIChatUncheckedUpdateWithoutUserInput>
  }

  export type AIChatUpdateManyWithWhereWithoutUserInput = {
    where: AIChatScalarWhereInput
    data: XOR<AIChatUpdateManyMutationInput, AIChatUncheckedUpdateManyWithoutUserInput>
  }

  export type AIChatScalarWhereInput = {
    AND?: AIChatScalarWhereInput | AIChatScalarWhereInput[]
    OR?: AIChatScalarWhereInput[]
    NOT?: AIChatScalarWhereInput | AIChatScalarWhereInput[]
    id?: StringFilter<"AIChat"> | string
    title?: StringNullableFilter<"AIChat"> | string | null
    createdAt?: DateTimeFilter<"AIChat"> | Date | string
    userId?: StringFilter<"AIChat"> | string
  }

  export type PracticeAttemptUpsertWithWhereUniqueWithoutUserInput = {
    where: PracticeAttemptWhereUniqueInput
    update: XOR<PracticeAttemptUpdateWithoutUserInput, PracticeAttemptUncheckedUpdateWithoutUserInput>
    create: XOR<PracticeAttemptCreateWithoutUserInput, PracticeAttemptUncheckedCreateWithoutUserInput>
  }

  export type PracticeAttemptUpdateWithWhereUniqueWithoutUserInput = {
    where: PracticeAttemptWhereUniqueInput
    data: XOR<PracticeAttemptUpdateWithoutUserInput, PracticeAttemptUncheckedUpdateWithoutUserInput>
  }

  export type PracticeAttemptUpdateManyWithWhereWithoutUserInput = {
    where: PracticeAttemptScalarWhereInput
    data: XOR<PracticeAttemptUpdateManyMutationInput, PracticeAttemptUncheckedUpdateManyWithoutUserInput>
  }

  export type PracticeAttemptScalarWhereInput = {
    AND?: PracticeAttemptScalarWhereInput | PracticeAttemptScalarWhereInput[]
    OR?: PracticeAttemptScalarWhereInput[]
    NOT?: PracticeAttemptScalarWhereInput | PracticeAttemptScalarWhereInput[]
    id?: StringFilter<"PracticeAttempt"> | string
    userId?: StringFilter<"PracticeAttempt"> | string
    aiModuleId?: StringFilter<"PracticeAttempt"> | string
    questions?: JsonFilter<"PracticeAttempt">
    createdAt?: DateTimeFilter<"PracticeAttempt"> | Date | string
    updatedAt?: DateTimeFilter<"PracticeAttempt"> | Date | string
    score?: FloatNullableFilter<"PracticeAttempt"> | number | null
    averageEase?: FloatNullableFilter<"PracticeAttempt"> | number | null
    completedAt?: DateTimeNullableFilter<"PracticeAttempt"> | Date | string | null
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    sessions?: SessionCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesCreateNestedOneWithoutUserInput
    topics?: TopicCreateNestedManyWithoutUserInput
    progress?: ProgressCreateNestedManyWithoutUserInput
    badges?: BadgeCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutUserInput
    aiModules?: AIModuleCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressCreateNestedManyWithoutUserInput
    AIChat?: AIChatCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesUncheckedCreateNestedOneWithoutUserInput
    topics?: TopicUncheckedCreateNestedManyWithoutUserInput
    progress?: ProgressUncheckedCreateNestedManyWithoutUserInput
    badges?: BadgeUncheckedCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewUncheckedCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathUncheckedCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionUncheckedCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceUncheckedCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenUncheckedCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeUncheckedCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingUncheckedCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreUncheckedCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutUserInput
    aiModules?: AIModuleUncheckedCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingUncheckedCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    AIChat?: AIChatUncheckedCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    sessions?: SessionUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUpdateOneWithoutUserNestedInput
    topics?: TopicUpdateManyWithoutUserNestedInput
    progress?: ProgressUpdateManyWithoutUserNestedInput
    badges?: BadgeUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUncheckedUpdateOneWithoutUserNestedInput
    topics?: TopicUncheckedUpdateManyWithoutUserNestedInput
    progress?: ProgressUncheckedUpdateManyWithoutUserNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUncheckedUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUncheckedUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUncheckedUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUncheckedUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUncheckedUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUncheckedUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUncheckedUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUncheckedUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUncheckedUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUncheckedUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUncheckedUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesCreateNestedOneWithoutUserInput
    topics?: TopicCreateNestedManyWithoutUserInput
    progress?: ProgressCreateNestedManyWithoutUserInput
    badges?: BadgeCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutUserInput
    aiModules?: AIModuleCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressCreateNestedManyWithoutUserInput
    AIChat?: AIChatCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesUncheckedCreateNestedOneWithoutUserInput
    topics?: TopicUncheckedCreateNestedManyWithoutUserInput
    progress?: ProgressUncheckedCreateNestedManyWithoutUserInput
    badges?: BadgeUncheckedCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewUncheckedCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathUncheckedCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionUncheckedCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceUncheckedCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenUncheckedCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeUncheckedCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingUncheckedCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreUncheckedCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutUserInput
    aiModules?: AIModuleUncheckedCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingUncheckedCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    AIChat?: AIChatUncheckedCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUpdateOneWithoutUserNestedInput
    topics?: TopicUpdateManyWithoutUserNestedInput
    progress?: ProgressUpdateManyWithoutUserNestedInput
    badges?: BadgeUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUncheckedUpdateOneWithoutUserNestedInput
    topics?: TopicUncheckedUpdateManyWithoutUserNestedInput
    progress?: ProgressUncheckedUpdateManyWithoutUserNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUncheckedUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUncheckedUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUncheckedUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUncheckedUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUncheckedUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUncheckedUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUncheckedUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUncheckedUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUncheckedUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUncheckedUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUncheckedUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutActivitiesInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesCreateNestedOneWithoutUserInput
    topics?: TopicCreateNestedManyWithoutUserInput
    progress?: ProgressCreateNestedManyWithoutUserInput
    badges?: BadgeCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutUserInput
    aiModules?: AIModuleCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressCreateNestedManyWithoutUserInput
    AIChat?: AIChatCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutActivitiesInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesUncheckedCreateNestedOneWithoutUserInput
    topics?: TopicUncheckedCreateNestedManyWithoutUserInput
    progress?: ProgressUncheckedCreateNestedManyWithoutUserInput
    badges?: BadgeUncheckedCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewUncheckedCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathUncheckedCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionUncheckedCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceUncheckedCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenUncheckedCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeUncheckedCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingUncheckedCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreUncheckedCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutUserInput
    aiModules?: AIModuleUncheckedCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingUncheckedCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    AIChat?: AIChatUncheckedCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutActivitiesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
  }

  export type UserUpsertWithoutActivitiesInput = {
    update: XOR<UserUpdateWithoutActivitiesInput, UserUncheckedUpdateWithoutActivitiesInput>
    create: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutActivitiesInput, UserUncheckedUpdateWithoutActivitiesInput>
  }

  export type UserUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUpdateOneWithoutUserNestedInput
    topics?: TopicUpdateManyWithoutUserNestedInput
    progress?: ProgressUpdateManyWithoutUserNestedInput
    badges?: BadgeUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUncheckedUpdateOneWithoutUserNestedInput
    topics?: TopicUncheckedUpdateManyWithoutUserNestedInput
    progress?: ProgressUncheckedUpdateManyWithoutUserNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUncheckedUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUncheckedUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUncheckedUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUncheckedUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUncheckedUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUncheckedUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUncheckedUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUncheckedUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUncheckedUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUncheckedUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUncheckedUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutLearningPreferencesInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    topics?: TopicCreateNestedManyWithoutUserInput
    progress?: ProgressCreateNestedManyWithoutUserInput
    badges?: BadgeCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutUserInput
    aiModules?: AIModuleCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressCreateNestedManyWithoutUserInput
    AIChat?: AIChatCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLearningPreferencesInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    topics?: TopicUncheckedCreateNestedManyWithoutUserInput
    progress?: ProgressUncheckedCreateNestedManyWithoutUserInput
    badges?: BadgeUncheckedCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewUncheckedCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathUncheckedCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionUncheckedCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceUncheckedCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenUncheckedCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeUncheckedCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingUncheckedCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreUncheckedCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutUserInput
    aiModules?: AIModuleUncheckedCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingUncheckedCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    AIChat?: AIChatUncheckedCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLearningPreferencesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLearningPreferencesInput, UserUncheckedCreateWithoutLearningPreferencesInput>
  }

  export type UserUpsertWithoutLearningPreferencesInput = {
    update: XOR<UserUpdateWithoutLearningPreferencesInput, UserUncheckedUpdateWithoutLearningPreferencesInput>
    create: XOR<UserCreateWithoutLearningPreferencesInput, UserUncheckedCreateWithoutLearningPreferencesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLearningPreferencesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLearningPreferencesInput, UserUncheckedUpdateWithoutLearningPreferencesInput>
  }

  export type UserUpdateWithoutLearningPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    topics?: TopicUpdateManyWithoutUserNestedInput
    progress?: ProgressUpdateManyWithoutUserNestedInput
    badges?: BadgeUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLearningPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    topics?: TopicUncheckedUpdateManyWithoutUserNestedInput
    progress?: ProgressUncheckedUpdateManyWithoutUserNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUncheckedUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUncheckedUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUncheckedUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUncheckedUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUncheckedUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUncheckedUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUncheckedUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUncheckedUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUncheckedUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUncheckedUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUncheckedUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutTopicsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesCreateNestedOneWithoutUserInput
    progress?: ProgressCreateNestedManyWithoutUserInput
    badges?: BadgeCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutUserInput
    aiModules?: AIModuleCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressCreateNestedManyWithoutUserInput
    AIChat?: AIChatCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTopicsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesUncheckedCreateNestedOneWithoutUserInput
    progress?: ProgressUncheckedCreateNestedManyWithoutUserInput
    badges?: BadgeUncheckedCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewUncheckedCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathUncheckedCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionUncheckedCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceUncheckedCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenUncheckedCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeUncheckedCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingUncheckedCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreUncheckedCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutUserInput
    aiModules?: AIModuleUncheckedCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingUncheckedCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    AIChat?: AIChatUncheckedCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTopicsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTopicsInput, UserUncheckedCreateWithoutTopicsInput>
  }

  export type ProgressCreateWithoutTopicInput = {
    id?: string
    completed: number
    user: UserCreateNestedOneWithoutProgressInput
  }

  export type ProgressUncheckedCreateWithoutTopicInput = {
    id?: string
    userId: string
    completed: number
  }

  export type ProgressCreateOrConnectWithoutTopicInput = {
    where: ProgressWhereUniqueInput
    create: XOR<ProgressCreateWithoutTopicInput, ProgressUncheckedCreateWithoutTopicInput>
  }

  export type ProgressCreateManyTopicInputEnvelope = {
    data: ProgressCreateManyTopicInput | ProgressCreateManyTopicInput[]
    skipDuplicates?: boolean
  }

  export type LearningPathItemCreateWithoutTopicInput = {
    id?: string
    order: number
    confidence?: number
    learningPath: LearningPathCreateNestedOneWithoutItemsInput
    UserProgress?: UserProgressCreateNestedManyWithoutModuleInput
  }

  export type LearningPathItemUncheckedCreateWithoutTopicInput = {
    id?: string
    order: number
    learningPathId: string
    confidence?: number
    UserProgress?: UserProgressUncheckedCreateNestedManyWithoutModuleInput
  }

  export type LearningPathItemCreateOrConnectWithoutTopicInput = {
    where: LearningPathItemWhereUniqueInput
    create: XOR<LearningPathItemCreateWithoutTopicInput, LearningPathItemUncheckedCreateWithoutTopicInput>
  }

  export type LearningPathItemCreateManyTopicInputEnvelope = {
    data: LearningPathItemCreateManyTopicInput | LearningPathItemCreateManyTopicInput[]
    skipDuplicates?: boolean
  }

  export type ContentItemCreateWithoutTopicInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    type: string
    difficulty: string
    createdAt?: Date | string
    updatedAt?: Date | string
    version?: string
    bookmarks?: BookmarkCreateNestedManyWithoutContentItemInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutContentItemInput
    reviewItems?: ReviewItemCreateNestedManyWithoutContentItemInput
    ratings?: ContentRatingCreateNestedManyWithoutContentItemInput
    aiPlaylistItems?: AIPlaylistItemCreateNestedManyWithoutContentItemInput
  }

  export type ContentItemUncheckedCreateWithoutTopicInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    type: string
    difficulty: string
    createdAt?: Date | string
    updatedAt?: Date | string
    version?: string
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutContentItemInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutContentItemInput
    reviewItems?: ReviewItemUncheckedCreateNestedManyWithoutContentItemInput
    ratings?: ContentRatingUncheckedCreateNestedManyWithoutContentItemInput
    aiPlaylistItems?: AIPlaylistItemUncheckedCreateNestedManyWithoutContentItemInput
  }

  export type ContentItemCreateOrConnectWithoutTopicInput = {
    where: ContentItemWhereUniqueInput
    create: XOR<ContentItemCreateWithoutTopicInput, ContentItemUncheckedCreateWithoutTopicInput>
  }

  export type ContentItemCreateManyTopicInputEnvelope = {
    data: ContentItemCreateManyTopicInput | ContentItemCreateManyTopicInput[]
    skipDuplicates?: boolean
  }

  export type AnalyticsEntryCreateWithoutTopicInput = {
    id?: string
    timeSpent: number
    score?: number | null
    date?: Date | string
    user: UserCreateNestedOneWithoutAnalyticsEntriesInput
  }

  export type AnalyticsEntryUncheckedCreateWithoutTopicInput = {
    id?: string
    userId: string
    timeSpent: number
    score?: number | null
    date?: Date | string
  }

  export type AnalyticsEntryCreateOrConnectWithoutTopicInput = {
    where: AnalyticsEntryWhereUniqueInput
    create: XOR<AnalyticsEntryCreateWithoutTopicInput, AnalyticsEntryUncheckedCreateWithoutTopicInput>
  }

  export type AnalyticsEntryCreateManyTopicInputEnvelope = {
    data: AnalyticsEntryCreateManyTopicInput | AnalyticsEntryCreateManyTopicInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutTopicInput = {
    id?: string
    content: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutTopicInput = {
    id?: string
    content: string
    userId: string
    createdAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutTopicInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutTopicInput, CommentUncheckedCreateWithoutTopicInput>
  }

  export type CommentCreateManyTopicInputEnvelope = {
    data: CommentCreateManyTopicInput | CommentCreateManyTopicInput[]
    skipDuplicates?: boolean
  }

  export type PrerequisiteCreateWithoutTopicInput = {
    id?: string
    completed?: boolean
    learningPath: LearningPathCreateNestedOneWithoutPrerequisitesInput
  }

  export type PrerequisiteUncheckedCreateWithoutTopicInput = {
    id?: string
    learningPathId: string
    completed?: boolean
  }

  export type PrerequisiteCreateOrConnectWithoutTopicInput = {
    where: PrerequisiteWhereUniqueInput
    create: XOR<PrerequisiteCreateWithoutTopicInput, PrerequisiteUncheckedCreateWithoutTopicInput>
  }

  export type PrerequisiteCreateManyTopicInputEnvelope = {
    data: PrerequisiteCreateManyTopicInput | PrerequisiteCreateManyTopicInput[]
    skipDuplicates?: boolean
  }

  export type AIModuleCreateWithoutTopicInput = {
    id?: string
    title: string
    description?: string | null
    content: JsonNullValueInput | InputJsonValue
    tags?: AIModuleCreatetagsInput | string[]
    difficulty?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutAiModulesInput
    learningPathItems?: AIModuleLearningPathItemCreateNestedManyWithoutAiModuleInput
    quizAttempts?: AIModuleQuizAttemptCreateNestedManyWithoutAiModuleInput
    ratings?: AIModuleRatingCreateNestedManyWithoutAiModuleInput
    PracticeAttempts?: PracticeAttemptCreateNestedManyWithoutAiModuleInput
  }

  export type AIModuleUncheckedCreateWithoutTopicInput = {
    id?: string
    title: string
    description?: string | null
    content: JsonNullValueInput | InputJsonValue
    tags?: AIModuleCreatetagsInput | string[]
    difficulty?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    learningPathItems?: AIModuleLearningPathItemUncheckedCreateNestedManyWithoutAiModuleInput
    quizAttempts?: AIModuleQuizAttemptUncheckedCreateNestedManyWithoutAiModuleInput
    ratings?: AIModuleRatingUncheckedCreateNestedManyWithoutAiModuleInput
    PracticeAttempts?: PracticeAttemptUncheckedCreateNestedManyWithoutAiModuleInput
  }

  export type AIModuleCreateOrConnectWithoutTopicInput = {
    where: AIModuleWhereUniqueInput
    create: XOR<AIModuleCreateWithoutTopicInput, AIModuleUncheckedCreateWithoutTopicInput>
  }

  export type AIModuleCreateManyTopicInputEnvelope = {
    data: AIModuleCreateManyTopicInput | AIModuleCreateManyTopicInput[]
    skipDuplicates?: boolean
  }

  export type AIModuleQuizAttemptCreateWithoutTopicInput = {
    id?: string
    score: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    answers: JsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutAiModuleQuizAttemptsInput
    aiModule: AIModuleCreateNestedOneWithoutQuizAttemptsInput
  }

  export type AIModuleQuizAttemptUncheckedCreateWithoutTopicInput = {
    id?: string
    userId: string
    aiModuleId: string
    score: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    answers: JsonNullValueInput | InputJsonValue
  }

  export type AIModuleQuizAttemptCreateOrConnectWithoutTopicInput = {
    where: AIModuleQuizAttemptWhereUniqueInput
    create: XOR<AIModuleQuizAttemptCreateWithoutTopicInput, AIModuleQuizAttemptUncheckedCreateWithoutTopicInput>
  }

  export type AIModuleQuizAttemptCreateManyTopicInputEnvelope = {
    data: AIModuleQuizAttemptCreateManyTopicInput | AIModuleQuizAttemptCreateManyTopicInput[]
    skipDuplicates?: boolean
  }

  export type AIModuleRatingCreateWithoutTopicInput = {
    id?: string
    rating: number
    feedback?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAiModuleRatingsInput
    aiModule: AIModuleCreateNestedOneWithoutRatingsInput
  }

  export type AIModuleRatingUncheckedCreateWithoutTopicInput = {
    id?: string
    userId: string
    aiModuleId: string
    rating: number
    feedback?: string | null
    createdAt?: Date | string
  }

  export type AIModuleRatingCreateOrConnectWithoutTopicInput = {
    where: AIModuleRatingWhereUniqueInput
    create: XOR<AIModuleRatingCreateWithoutTopicInput, AIModuleRatingUncheckedCreateWithoutTopicInput>
  }

  export type AIModuleRatingCreateManyTopicInputEnvelope = {
    data: AIModuleRatingCreateManyTopicInput | AIModuleRatingCreateManyTopicInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutTopicsInput = {
    update: XOR<UserUpdateWithoutTopicsInput, UserUncheckedUpdateWithoutTopicsInput>
    create: XOR<UserCreateWithoutTopicsInput, UserUncheckedCreateWithoutTopicsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTopicsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTopicsInput, UserUncheckedUpdateWithoutTopicsInput>
  }

  export type UserUpdateWithoutTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUpdateOneWithoutUserNestedInput
    progress?: ProgressUpdateManyWithoutUserNestedInput
    badges?: BadgeUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUncheckedUpdateOneWithoutUserNestedInput
    progress?: ProgressUncheckedUpdateManyWithoutUserNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUncheckedUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUncheckedUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUncheckedUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUncheckedUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUncheckedUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUncheckedUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUncheckedUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUncheckedUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUncheckedUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUncheckedUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUncheckedUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProgressUpsertWithWhereUniqueWithoutTopicInput = {
    where: ProgressWhereUniqueInput
    update: XOR<ProgressUpdateWithoutTopicInput, ProgressUncheckedUpdateWithoutTopicInput>
    create: XOR<ProgressCreateWithoutTopicInput, ProgressUncheckedCreateWithoutTopicInput>
  }

  export type ProgressUpdateWithWhereUniqueWithoutTopicInput = {
    where: ProgressWhereUniqueInput
    data: XOR<ProgressUpdateWithoutTopicInput, ProgressUncheckedUpdateWithoutTopicInput>
  }

  export type ProgressUpdateManyWithWhereWithoutTopicInput = {
    where: ProgressScalarWhereInput
    data: XOR<ProgressUpdateManyMutationInput, ProgressUncheckedUpdateManyWithoutTopicInput>
  }

  export type LearningPathItemUpsertWithWhereUniqueWithoutTopicInput = {
    where: LearningPathItemWhereUniqueInput
    update: XOR<LearningPathItemUpdateWithoutTopicInput, LearningPathItemUncheckedUpdateWithoutTopicInput>
    create: XOR<LearningPathItemCreateWithoutTopicInput, LearningPathItemUncheckedCreateWithoutTopicInput>
  }

  export type LearningPathItemUpdateWithWhereUniqueWithoutTopicInput = {
    where: LearningPathItemWhereUniqueInput
    data: XOR<LearningPathItemUpdateWithoutTopicInput, LearningPathItemUncheckedUpdateWithoutTopicInput>
  }

  export type LearningPathItemUpdateManyWithWhereWithoutTopicInput = {
    where: LearningPathItemScalarWhereInput
    data: XOR<LearningPathItemUpdateManyMutationInput, LearningPathItemUncheckedUpdateManyWithoutTopicInput>
  }

  export type LearningPathItemScalarWhereInput = {
    AND?: LearningPathItemScalarWhereInput | LearningPathItemScalarWhereInput[]
    OR?: LearningPathItemScalarWhereInput[]
    NOT?: LearningPathItemScalarWhereInput | LearningPathItemScalarWhereInput[]
    id?: StringFilter<"LearningPathItem"> | string
    order?: IntFilter<"LearningPathItem"> | number
    learningPathId?: StringFilter<"LearningPathItem"> | string
    topicId?: StringFilter<"LearningPathItem"> | string
    confidence?: IntFilter<"LearningPathItem"> | number
  }

  export type ContentItemUpsertWithWhereUniqueWithoutTopicInput = {
    where: ContentItemWhereUniqueInput
    update: XOR<ContentItemUpdateWithoutTopicInput, ContentItemUncheckedUpdateWithoutTopicInput>
    create: XOR<ContentItemCreateWithoutTopicInput, ContentItemUncheckedCreateWithoutTopicInput>
  }

  export type ContentItemUpdateWithWhereUniqueWithoutTopicInput = {
    where: ContentItemWhereUniqueInput
    data: XOR<ContentItemUpdateWithoutTopicInput, ContentItemUncheckedUpdateWithoutTopicInput>
  }

  export type ContentItemUpdateManyWithWhereWithoutTopicInput = {
    where: ContentItemScalarWhereInput
    data: XOR<ContentItemUpdateManyMutationInput, ContentItemUncheckedUpdateManyWithoutTopicInput>
  }

  export type ContentItemScalarWhereInput = {
    AND?: ContentItemScalarWhereInput | ContentItemScalarWhereInput[]
    OR?: ContentItemScalarWhereInput[]
    NOT?: ContentItemScalarWhereInput | ContentItemScalarWhereInput[]
    id?: StringFilter<"ContentItem"> | string
    title?: StringFilter<"ContentItem"> | string
    description?: StringNullableFilter<"ContentItem"> | string | null
    content?: StringFilter<"ContentItem"> | string
    type?: StringFilter<"ContentItem"> | string
    difficulty?: StringFilter<"ContentItem"> | string
    topicId?: StringFilter<"ContentItem"> | string
    createdAt?: DateTimeFilter<"ContentItem"> | Date | string
    updatedAt?: DateTimeFilter<"ContentItem"> | Date | string
    version?: StringFilter<"ContentItem"> | string
  }

  export type AnalyticsEntryUpsertWithWhereUniqueWithoutTopicInput = {
    where: AnalyticsEntryWhereUniqueInput
    update: XOR<AnalyticsEntryUpdateWithoutTopicInput, AnalyticsEntryUncheckedUpdateWithoutTopicInput>
    create: XOR<AnalyticsEntryCreateWithoutTopicInput, AnalyticsEntryUncheckedCreateWithoutTopicInput>
  }

  export type AnalyticsEntryUpdateWithWhereUniqueWithoutTopicInput = {
    where: AnalyticsEntryWhereUniqueInput
    data: XOR<AnalyticsEntryUpdateWithoutTopicInput, AnalyticsEntryUncheckedUpdateWithoutTopicInput>
  }

  export type AnalyticsEntryUpdateManyWithWhereWithoutTopicInput = {
    where: AnalyticsEntryScalarWhereInput
    data: XOR<AnalyticsEntryUpdateManyMutationInput, AnalyticsEntryUncheckedUpdateManyWithoutTopicInput>
  }

  export type CommentUpsertWithWhereUniqueWithoutTopicInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutTopicInput, CommentUncheckedUpdateWithoutTopicInput>
    create: XOR<CommentCreateWithoutTopicInput, CommentUncheckedCreateWithoutTopicInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutTopicInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutTopicInput, CommentUncheckedUpdateWithoutTopicInput>
  }

  export type CommentUpdateManyWithWhereWithoutTopicInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutTopicInput>
  }

  export type PrerequisiteUpsertWithWhereUniqueWithoutTopicInput = {
    where: PrerequisiteWhereUniqueInput
    update: XOR<PrerequisiteUpdateWithoutTopicInput, PrerequisiteUncheckedUpdateWithoutTopicInput>
    create: XOR<PrerequisiteCreateWithoutTopicInput, PrerequisiteUncheckedCreateWithoutTopicInput>
  }

  export type PrerequisiteUpdateWithWhereUniqueWithoutTopicInput = {
    where: PrerequisiteWhereUniqueInput
    data: XOR<PrerequisiteUpdateWithoutTopicInput, PrerequisiteUncheckedUpdateWithoutTopicInput>
  }

  export type PrerequisiteUpdateManyWithWhereWithoutTopicInput = {
    where: PrerequisiteScalarWhereInput
    data: XOR<PrerequisiteUpdateManyMutationInput, PrerequisiteUncheckedUpdateManyWithoutTopicInput>
  }

  export type PrerequisiteScalarWhereInput = {
    AND?: PrerequisiteScalarWhereInput | PrerequisiteScalarWhereInput[]
    OR?: PrerequisiteScalarWhereInput[]
    NOT?: PrerequisiteScalarWhereInput | PrerequisiteScalarWhereInput[]
    id?: StringFilter<"Prerequisite"> | string
    learningPathId?: StringFilter<"Prerequisite"> | string
    topicId?: StringFilter<"Prerequisite"> | string
    completed?: BoolFilter<"Prerequisite"> | boolean
  }

  export type AIModuleUpsertWithWhereUniqueWithoutTopicInput = {
    where: AIModuleWhereUniqueInput
    update: XOR<AIModuleUpdateWithoutTopicInput, AIModuleUncheckedUpdateWithoutTopicInput>
    create: XOR<AIModuleCreateWithoutTopicInput, AIModuleUncheckedCreateWithoutTopicInput>
  }

  export type AIModuleUpdateWithWhereUniqueWithoutTopicInput = {
    where: AIModuleWhereUniqueInput
    data: XOR<AIModuleUpdateWithoutTopicInput, AIModuleUncheckedUpdateWithoutTopicInput>
  }

  export type AIModuleUpdateManyWithWhereWithoutTopicInput = {
    where: AIModuleScalarWhereInput
    data: XOR<AIModuleUpdateManyMutationInput, AIModuleUncheckedUpdateManyWithoutTopicInput>
  }

  export type AIModuleQuizAttemptUpsertWithWhereUniqueWithoutTopicInput = {
    where: AIModuleQuizAttemptWhereUniqueInput
    update: XOR<AIModuleQuizAttemptUpdateWithoutTopicInput, AIModuleQuizAttemptUncheckedUpdateWithoutTopicInput>
    create: XOR<AIModuleQuizAttemptCreateWithoutTopicInput, AIModuleQuizAttemptUncheckedCreateWithoutTopicInput>
  }

  export type AIModuleQuizAttemptUpdateWithWhereUniqueWithoutTopicInput = {
    where: AIModuleQuizAttemptWhereUniqueInput
    data: XOR<AIModuleQuizAttemptUpdateWithoutTopicInput, AIModuleQuizAttemptUncheckedUpdateWithoutTopicInput>
  }

  export type AIModuleQuizAttemptUpdateManyWithWhereWithoutTopicInput = {
    where: AIModuleQuizAttemptScalarWhereInput
    data: XOR<AIModuleQuizAttemptUpdateManyMutationInput, AIModuleQuizAttemptUncheckedUpdateManyWithoutTopicInput>
  }

  export type AIModuleRatingUpsertWithWhereUniqueWithoutTopicInput = {
    where: AIModuleRatingWhereUniqueInput
    update: XOR<AIModuleRatingUpdateWithoutTopicInput, AIModuleRatingUncheckedUpdateWithoutTopicInput>
    create: XOR<AIModuleRatingCreateWithoutTopicInput, AIModuleRatingUncheckedCreateWithoutTopicInput>
  }

  export type AIModuleRatingUpdateWithWhereUniqueWithoutTopicInput = {
    where: AIModuleRatingWhereUniqueInput
    data: XOR<AIModuleRatingUpdateWithoutTopicInput, AIModuleRatingUncheckedUpdateWithoutTopicInput>
  }

  export type AIModuleRatingUpdateManyWithWhereWithoutTopicInput = {
    where: AIModuleRatingScalarWhereInput
    data: XOR<AIModuleRatingUpdateManyMutationInput, AIModuleRatingUncheckedUpdateManyWithoutTopicInput>
  }

  export type UserCreateWithoutProgressInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesCreateNestedOneWithoutUserInput
    topics?: TopicCreateNestedManyWithoutUserInput
    badges?: BadgeCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutUserInput
    aiModules?: AIModuleCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressCreateNestedManyWithoutUserInput
    AIChat?: AIChatCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProgressInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesUncheckedCreateNestedOneWithoutUserInput
    topics?: TopicUncheckedCreateNestedManyWithoutUserInput
    badges?: BadgeUncheckedCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewUncheckedCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathUncheckedCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionUncheckedCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceUncheckedCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenUncheckedCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeUncheckedCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingUncheckedCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreUncheckedCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutUserInput
    aiModules?: AIModuleUncheckedCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingUncheckedCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    AIChat?: AIChatUncheckedCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProgressInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProgressInput, UserUncheckedCreateWithoutProgressInput>
  }

  export type TopicCreateWithoutProgressInput = {
    id?: string
    title: string
    description?: string | null
    user: UserCreateNestedOneWithoutTopicsInput
    learningPathItems?: LearningPathItemCreateNestedManyWithoutTopicInput
    contentItems?: ContentItemCreateNestedManyWithoutTopicInput
    analyticsEntries?: AnalyticsEntryCreateNestedManyWithoutTopicInput
    comments?: CommentCreateNestedManyWithoutTopicInput
    prerequisites?: PrerequisiteCreateNestedManyWithoutTopicInput
    aiModules?: AIModuleCreateNestedManyWithoutTopicInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptCreateNestedManyWithoutTopicInput
    aiModuleRatings?: AIModuleRatingCreateNestedManyWithoutTopicInput
  }

  export type TopicUncheckedCreateWithoutProgressInput = {
    id?: string
    title: string
    description?: string | null
    userId: string
    learningPathItems?: LearningPathItemUncheckedCreateNestedManyWithoutTopicInput
    contentItems?: ContentItemUncheckedCreateNestedManyWithoutTopicInput
    analyticsEntries?: AnalyticsEntryUncheckedCreateNestedManyWithoutTopicInput
    comments?: CommentUncheckedCreateNestedManyWithoutTopicInput
    prerequisites?: PrerequisiteUncheckedCreateNestedManyWithoutTopicInput
    aiModules?: AIModuleUncheckedCreateNestedManyWithoutTopicInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedCreateNestedManyWithoutTopicInput
    aiModuleRatings?: AIModuleRatingUncheckedCreateNestedManyWithoutTopicInput
  }

  export type TopicCreateOrConnectWithoutProgressInput = {
    where: TopicWhereUniqueInput
    create: XOR<TopicCreateWithoutProgressInput, TopicUncheckedCreateWithoutProgressInput>
  }

  export type UserUpsertWithoutProgressInput = {
    update: XOR<UserUpdateWithoutProgressInput, UserUncheckedUpdateWithoutProgressInput>
    create: XOR<UserCreateWithoutProgressInput, UserUncheckedCreateWithoutProgressInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProgressInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProgressInput, UserUncheckedUpdateWithoutProgressInput>
  }

  export type UserUpdateWithoutProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUpdateOneWithoutUserNestedInput
    topics?: TopicUpdateManyWithoutUserNestedInput
    badges?: BadgeUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUncheckedUpdateOneWithoutUserNestedInput
    topics?: TopicUncheckedUpdateManyWithoutUserNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUncheckedUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUncheckedUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUncheckedUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUncheckedUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUncheckedUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUncheckedUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUncheckedUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUncheckedUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUncheckedUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUncheckedUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUncheckedUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TopicUpsertWithoutProgressInput = {
    update: XOR<TopicUpdateWithoutProgressInput, TopicUncheckedUpdateWithoutProgressInput>
    create: XOR<TopicCreateWithoutProgressInput, TopicUncheckedCreateWithoutProgressInput>
    where?: TopicWhereInput
  }

  export type TopicUpdateToOneWithWhereWithoutProgressInput = {
    where?: TopicWhereInput
    data: XOR<TopicUpdateWithoutProgressInput, TopicUncheckedUpdateWithoutProgressInput>
  }

  export type TopicUpdateWithoutProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutTopicsNestedInput
    learningPathItems?: LearningPathItemUpdateManyWithoutTopicNestedInput
    contentItems?: ContentItemUpdateManyWithoutTopicNestedInput
    analyticsEntries?: AnalyticsEntryUpdateManyWithoutTopicNestedInput
    comments?: CommentUpdateManyWithoutTopicNestedInput
    prerequisites?: PrerequisiteUpdateManyWithoutTopicNestedInput
    aiModules?: AIModuleUpdateManyWithoutTopicNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUpdateManyWithoutTopicNestedInput
    aiModuleRatings?: AIModuleRatingUpdateManyWithoutTopicNestedInput
  }

  export type TopicUncheckedUpdateWithoutProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    learningPathItems?: LearningPathItemUncheckedUpdateManyWithoutTopicNestedInput
    contentItems?: ContentItemUncheckedUpdateManyWithoutTopicNestedInput
    analyticsEntries?: AnalyticsEntryUncheckedUpdateManyWithoutTopicNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTopicNestedInput
    prerequisites?: PrerequisiteUncheckedUpdateManyWithoutTopicNestedInput
    aiModules?: AIModuleUncheckedUpdateManyWithoutTopicNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedUpdateManyWithoutTopicNestedInput
    aiModuleRatings?: AIModuleRatingUncheckedUpdateManyWithoutTopicNestedInput
  }

  export type UserCreateWithoutBadgesInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesCreateNestedOneWithoutUserInput
    topics?: TopicCreateNestedManyWithoutUserInput
    progress?: ProgressCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutUserInput
    aiModules?: AIModuleCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressCreateNestedManyWithoutUserInput
    AIChat?: AIChatCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBadgesInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesUncheckedCreateNestedOneWithoutUserInput
    topics?: TopicUncheckedCreateNestedManyWithoutUserInput
    progress?: ProgressUncheckedCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewUncheckedCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathUncheckedCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionUncheckedCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceUncheckedCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenUncheckedCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeUncheckedCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingUncheckedCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreUncheckedCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutUserInput
    aiModules?: AIModuleUncheckedCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingUncheckedCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    AIChat?: AIChatUncheckedCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBadgesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBadgesInput, UserUncheckedCreateWithoutBadgesInput>
  }

  export type UserUpsertWithoutBadgesInput = {
    update: XOR<UserUpdateWithoutBadgesInput, UserUncheckedUpdateWithoutBadgesInput>
    create: XOR<UserCreateWithoutBadgesInput, UserUncheckedCreateWithoutBadgesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBadgesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBadgesInput, UserUncheckedUpdateWithoutBadgesInput>
  }

  export type UserUpdateWithoutBadgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUpdateOneWithoutUserNestedInput
    topics?: TopicUpdateManyWithoutUserNestedInput
    progress?: ProgressUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBadgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUncheckedUpdateOneWithoutUserNestedInput
    topics?: TopicUncheckedUpdateManyWithoutUserNestedInput
    progress?: ProgressUncheckedUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUncheckedUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUncheckedUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUncheckedUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUncheckedUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUncheckedUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUncheckedUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUncheckedUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUncheckedUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUncheckedUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUncheckedUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUncheckedUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutUpcomingReviewsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesCreateNestedOneWithoutUserInput
    topics?: TopicCreateNestedManyWithoutUserInput
    progress?: ProgressCreateNestedManyWithoutUserInput
    badges?: BadgeCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutUserInput
    aiModules?: AIModuleCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressCreateNestedManyWithoutUserInput
    AIChat?: AIChatCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUpcomingReviewsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesUncheckedCreateNestedOneWithoutUserInput
    topics?: TopicUncheckedCreateNestedManyWithoutUserInput
    progress?: ProgressUncheckedCreateNestedManyWithoutUserInput
    badges?: BadgeUncheckedCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathUncheckedCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionUncheckedCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceUncheckedCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenUncheckedCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeUncheckedCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingUncheckedCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreUncheckedCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutUserInput
    aiModules?: AIModuleUncheckedCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingUncheckedCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    AIChat?: AIChatUncheckedCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUpcomingReviewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUpcomingReviewsInput, UserUncheckedCreateWithoutUpcomingReviewsInput>
  }

  export type UserUpsertWithoutUpcomingReviewsInput = {
    update: XOR<UserUpdateWithoutUpcomingReviewsInput, UserUncheckedUpdateWithoutUpcomingReviewsInput>
    create: XOR<UserCreateWithoutUpcomingReviewsInput, UserUncheckedCreateWithoutUpcomingReviewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUpcomingReviewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUpcomingReviewsInput, UserUncheckedUpdateWithoutUpcomingReviewsInput>
  }

  export type UserUpdateWithoutUpcomingReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUpdateOneWithoutUserNestedInput
    topics?: TopicUpdateManyWithoutUserNestedInput
    progress?: ProgressUpdateManyWithoutUserNestedInput
    badges?: BadgeUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUpcomingReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUncheckedUpdateOneWithoutUserNestedInput
    topics?: TopicUncheckedUpdateManyWithoutUserNestedInput
    progress?: ProgressUncheckedUpdateManyWithoutUserNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUncheckedUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUncheckedUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUncheckedUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUncheckedUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUncheckedUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUncheckedUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUncheckedUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUncheckedUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUncheckedUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUncheckedUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutLearningPathsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesCreateNestedOneWithoutUserInput
    topics?: TopicCreateNestedManyWithoutUserInput
    progress?: ProgressCreateNestedManyWithoutUserInput
    badges?: BadgeCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutUserInput
    aiModules?: AIModuleCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressCreateNestedManyWithoutUserInput
    AIChat?: AIChatCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLearningPathsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesUncheckedCreateNestedOneWithoutUserInput
    topics?: TopicUncheckedCreateNestedManyWithoutUserInput
    progress?: ProgressUncheckedCreateNestedManyWithoutUserInput
    badges?: BadgeUncheckedCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewUncheckedCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionUncheckedCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceUncheckedCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenUncheckedCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeUncheckedCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingUncheckedCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreUncheckedCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutUserInput
    aiModules?: AIModuleUncheckedCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingUncheckedCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    AIChat?: AIChatUncheckedCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLearningPathsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLearningPathsInput, UserUncheckedCreateWithoutLearningPathsInput>
  }

  export type LearningPathItemCreateWithoutLearningPathInput = {
    id?: string
    order: number
    confidence?: number
    topic: TopicCreateNestedOneWithoutLearningPathItemsInput
    UserProgress?: UserProgressCreateNestedManyWithoutModuleInput
  }

  export type LearningPathItemUncheckedCreateWithoutLearningPathInput = {
    id?: string
    order: number
    topicId: string
    confidence?: number
    UserProgress?: UserProgressUncheckedCreateNestedManyWithoutModuleInput
  }

  export type LearningPathItemCreateOrConnectWithoutLearningPathInput = {
    where: LearningPathItemWhereUniqueInput
    create: XOR<LearningPathItemCreateWithoutLearningPathInput, LearningPathItemUncheckedCreateWithoutLearningPathInput>
  }

  export type LearningPathItemCreateManyLearningPathInputEnvelope = {
    data: LearningPathItemCreateManyLearningPathInput | LearningPathItemCreateManyLearningPathInput[]
    skipDuplicates?: boolean
  }

  export type PrerequisiteCreateWithoutLearningPathInput = {
    id?: string
    completed?: boolean
    topic: TopicCreateNestedOneWithoutPrerequisitesInput
  }

  export type PrerequisiteUncheckedCreateWithoutLearningPathInput = {
    id?: string
    topicId: string
    completed?: boolean
  }

  export type PrerequisiteCreateOrConnectWithoutLearningPathInput = {
    where: PrerequisiteWhereUniqueInput
    create: XOR<PrerequisiteCreateWithoutLearningPathInput, PrerequisiteUncheckedCreateWithoutLearningPathInput>
  }

  export type PrerequisiteCreateManyLearningPathInputEnvelope = {
    data: PrerequisiteCreateManyLearningPathInput | PrerequisiteCreateManyLearningPathInput[]
    skipDuplicates?: boolean
  }

  export type AIModuleLearningPathItemCreateWithoutLearningPathInput = {
    id?: string
    order: number
    confidence?: number
    aiModule: AIModuleCreateNestedOneWithoutLearningPathItemsInput
  }

  export type AIModuleLearningPathItemUncheckedCreateWithoutLearningPathInput = {
    id?: string
    order: number
    aiModuleId: string
    confidence?: number
  }

  export type AIModuleLearningPathItemCreateOrConnectWithoutLearningPathInput = {
    where: AIModuleLearningPathItemWhereUniqueInput
    create: XOR<AIModuleLearningPathItemCreateWithoutLearningPathInput, AIModuleLearningPathItemUncheckedCreateWithoutLearningPathInput>
  }

  export type AIModuleLearningPathItemCreateManyLearningPathInputEnvelope = {
    data: AIModuleLearningPathItemCreateManyLearningPathInput | AIModuleLearningPathItemCreateManyLearningPathInput[]
    skipDuplicates?: boolean
  }

  export type UserProgressCreateWithoutLearningPathInput = {
    id?: string
    status?: string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserProgressInput
    module: LearningPathItemCreateNestedOneWithoutUserProgressInput
  }

  export type UserProgressUncheckedCreateWithoutLearningPathInput = {
    id?: string
    userId: string
    moduleId: string
    status?: string
    updatedAt?: Date | string
  }

  export type UserProgressCreateOrConnectWithoutLearningPathInput = {
    where: UserProgressWhereUniqueInput
    create: XOR<UserProgressCreateWithoutLearningPathInput, UserProgressUncheckedCreateWithoutLearningPathInput>
  }

  export type UserProgressCreateManyLearningPathInputEnvelope = {
    data: UserProgressCreateManyLearningPathInput | UserProgressCreateManyLearningPathInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutLearningPathsInput = {
    update: XOR<UserUpdateWithoutLearningPathsInput, UserUncheckedUpdateWithoutLearningPathsInput>
    create: XOR<UserCreateWithoutLearningPathsInput, UserUncheckedCreateWithoutLearningPathsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLearningPathsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLearningPathsInput, UserUncheckedUpdateWithoutLearningPathsInput>
  }

  export type UserUpdateWithoutLearningPathsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUpdateOneWithoutUserNestedInput
    topics?: TopicUpdateManyWithoutUserNestedInput
    progress?: ProgressUpdateManyWithoutUserNestedInput
    badges?: BadgeUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLearningPathsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUncheckedUpdateOneWithoutUserNestedInput
    topics?: TopicUncheckedUpdateManyWithoutUserNestedInput
    progress?: ProgressUncheckedUpdateManyWithoutUserNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUncheckedUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUncheckedUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUncheckedUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUncheckedUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUncheckedUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUncheckedUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUncheckedUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUncheckedUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUncheckedUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUncheckedUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUncheckedUpdateManyWithoutUserNestedInput
  }

  export type LearningPathItemUpsertWithWhereUniqueWithoutLearningPathInput = {
    where: LearningPathItemWhereUniqueInput
    update: XOR<LearningPathItemUpdateWithoutLearningPathInput, LearningPathItemUncheckedUpdateWithoutLearningPathInput>
    create: XOR<LearningPathItemCreateWithoutLearningPathInput, LearningPathItemUncheckedCreateWithoutLearningPathInput>
  }

  export type LearningPathItemUpdateWithWhereUniqueWithoutLearningPathInput = {
    where: LearningPathItemWhereUniqueInput
    data: XOR<LearningPathItemUpdateWithoutLearningPathInput, LearningPathItemUncheckedUpdateWithoutLearningPathInput>
  }

  export type LearningPathItemUpdateManyWithWhereWithoutLearningPathInput = {
    where: LearningPathItemScalarWhereInput
    data: XOR<LearningPathItemUpdateManyMutationInput, LearningPathItemUncheckedUpdateManyWithoutLearningPathInput>
  }

  export type PrerequisiteUpsertWithWhereUniqueWithoutLearningPathInput = {
    where: PrerequisiteWhereUniqueInput
    update: XOR<PrerequisiteUpdateWithoutLearningPathInput, PrerequisiteUncheckedUpdateWithoutLearningPathInput>
    create: XOR<PrerequisiteCreateWithoutLearningPathInput, PrerequisiteUncheckedCreateWithoutLearningPathInput>
  }

  export type PrerequisiteUpdateWithWhereUniqueWithoutLearningPathInput = {
    where: PrerequisiteWhereUniqueInput
    data: XOR<PrerequisiteUpdateWithoutLearningPathInput, PrerequisiteUncheckedUpdateWithoutLearningPathInput>
  }

  export type PrerequisiteUpdateManyWithWhereWithoutLearningPathInput = {
    where: PrerequisiteScalarWhereInput
    data: XOR<PrerequisiteUpdateManyMutationInput, PrerequisiteUncheckedUpdateManyWithoutLearningPathInput>
  }

  export type AIModuleLearningPathItemUpsertWithWhereUniqueWithoutLearningPathInput = {
    where: AIModuleLearningPathItemWhereUniqueInput
    update: XOR<AIModuleLearningPathItemUpdateWithoutLearningPathInput, AIModuleLearningPathItemUncheckedUpdateWithoutLearningPathInput>
    create: XOR<AIModuleLearningPathItemCreateWithoutLearningPathInput, AIModuleLearningPathItemUncheckedCreateWithoutLearningPathInput>
  }

  export type AIModuleLearningPathItemUpdateWithWhereUniqueWithoutLearningPathInput = {
    where: AIModuleLearningPathItemWhereUniqueInput
    data: XOR<AIModuleLearningPathItemUpdateWithoutLearningPathInput, AIModuleLearningPathItemUncheckedUpdateWithoutLearningPathInput>
  }

  export type AIModuleLearningPathItemUpdateManyWithWhereWithoutLearningPathInput = {
    where: AIModuleLearningPathItemScalarWhereInput
    data: XOR<AIModuleLearningPathItemUpdateManyMutationInput, AIModuleLearningPathItemUncheckedUpdateManyWithoutLearningPathInput>
  }

  export type AIModuleLearningPathItemScalarWhereInput = {
    AND?: AIModuleLearningPathItemScalarWhereInput | AIModuleLearningPathItemScalarWhereInput[]
    OR?: AIModuleLearningPathItemScalarWhereInput[]
    NOT?: AIModuleLearningPathItemScalarWhereInput | AIModuleLearningPathItemScalarWhereInput[]
    id?: StringFilter<"AIModuleLearningPathItem"> | string
    order?: IntFilter<"AIModuleLearningPathItem"> | number
    learningPathId?: StringFilter<"AIModuleLearningPathItem"> | string
    aiModuleId?: StringFilter<"AIModuleLearningPathItem"> | string
    confidence?: IntFilter<"AIModuleLearningPathItem"> | number
  }

  export type UserProgressUpsertWithWhereUniqueWithoutLearningPathInput = {
    where: UserProgressWhereUniqueInput
    update: XOR<UserProgressUpdateWithoutLearningPathInput, UserProgressUncheckedUpdateWithoutLearningPathInput>
    create: XOR<UserProgressCreateWithoutLearningPathInput, UserProgressUncheckedCreateWithoutLearningPathInput>
  }

  export type UserProgressUpdateWithWhereUniqueWithoutLearningPathInput = {
    where: UserProgressWhereUniqueInput
    data: XOR<UserProgressUpdateWithoutLearningPathInput, UserProgressUncheckedUpdateWithoutLearningPathInput>
  }

  export type UserProgressUpdateManyWithWhereWithoutLearningPathInput = {
    where: UserProgressScalarWhereInput
    data: XOR<UserProgressUpdateManyMutationInput, UserProgressUncheckedUpdateManyWithoutLearningPathInput>
  }

  export type LearningPathCreateWithoutItemsInput = {
    id?: string
    title: string
    description?: string | null
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    shareId?: string | null
    sharedAt?: Date | string | null
    user: UserCreateNestedOneWithoutLearningPathsInput
    prerequisites?: PrerequisiteCreateNestedManyWithoutLearningPathInput
    aiModuleItems?: AIModuleLearningPathItemCreateNestedManyWithoutLearningPathInput
    UserProgress?: UserProgressCreateNestedManyWithoutLearningPathInput
  }

  export type LearningPathUncheckedCreateWithoutItemsInput = {
    id?: string
    title: string
    description?: string | null
    userId: string
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    shareId?: string | null
    sharedAt?: Date | string | null
    prerequisites?: PrerequisiteUncheckedCreateNestedManyWithoutLearningPathInput
    aiModuleItems?: AIModuleLearningPathItemUncheckedCreateNestedManyWithoutLearningPathInput
    UserProgress?: UserProgressUncheckedCreateNestedManyWithoutLearningPathInput
  }

  export type LearningPathCreateOrConnectWithoutItemsInput = {
    where: LearningPathWhereUniqueInput
    create: XOR<LearningPathCreateWithoutItemsInput, LearningPathUncheckedCreateWithoutItemsInput>
  }

  export type TopicCreateWithoutLearningPathItemsInput = {
    id?: string
    title: string
    description?: string | null
    user: UserCreateNestedOneWithoutTopicsInput
    progress?: ProgressCreateNestedManyWithoutTopicInput
    contentItems?: ContentItemCreateNestedManyWithoutTopicInput
    analyticsEntries?: AnalyticsEntryCreateNestedManyWithoutTopicInput
    comments?: CommentCreateNestedManyWithoutTopicInput
    prerequisites?: PrerequisiteCreateNestedManyWithoutTopicInput
    aiModules?: AIModuleCreateNestedManyWithoutTopicInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptCreateNestedManyWithoutTopicInput
    aiModuleRatings?: AIModuleRatingCreateNestedManyWithoutTopicInput
  }

  export type TopicUncheckedCreateWithoutLearningPathItemsInput = {
    id?: string
    title: string
    description?: string | null
    userId: string
    progress?: ProgressUncheckedCreateNestedManyWithoutTopicInput
    contentItems?: ContentItemUncheckedCreateNestedManyWithoutTopicInput
    analyticsEntries?: AnalyticsEntryUncheckedCreateNestedManyWithoutTopicInput
    comments?: CommentUncheckedCreateNestedManyWithoutTopicInput
    prerequisites?: PrerequisiteUncheckedCreateNestedManyWithoutTopicInput
    aiModules?: AIModuleUncheckedCreateNestedManyWithoutTopicInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedCreateNestedManyWithoutTopicInput
    aiModuleRatings?: AIModuleRatingUncheckedCreateNestedManyWithoutTopicInput
  }

  export type TopicCreateOrConnectWithoutLearningPathItemsInput = {
    where: TopicWhereUniqueInput
    create: XOR<TopicCreateWithoutLearningPathItemsInput, TopicUncheckedCreateWithoutLearningPathItemsInput>
  }

  export type UserProgressCreateWithoutModuleInput = {
    id?: string
    status?: string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserProgressInput
    learningPath: LearningPathCreateNestedOneWithoutUserProgressInput
  }

  export type UserProgressUncheckedCreateWithoutModuleInput = {
    id?: string
    userId: string
    learningPathId: string
    status?: string
    updatedAt?: Date | string
  }

  export type UserProgressCreateOrConnectWithoutModuleInput = {
    where: UserProgressWhereUniqueInput
    create: XOR<UserProgressCreateWithoutModuleInput, UserProgressUncheckedCreateWithoutModuleInput>
  }

  export type UserProgressCreateManyModuleInputEnvelope = {
    data: UserProgressCreateManyModuleInput | UserProgressCreateManyModuleInput[]
    skipDuplicates?: boolean
  }

  export type LearningPathUpsertWithoutItemsInput = {
    update: XOR<LearningPathUpdateWithoutItemsInput, LearningPathUncheckedUpdateWithoutItemsInput>
    create: XOR<LearningPathCreateWithoutItemsInput, LearningPathUncheckedCreateWithoutItemsInput>
    where?: LearningPathWhereInput
  }

  export type LearningPathUpdateToOneWithWhereWithoutItemsInput = {
    where?: LearningPathWhereInput
    data: XOR<LearningPathUpdateWithoutItemsInput, LearningPathUncheckedUpdateWithoutItemsInput>
  }

  export type LearningPathUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shareId?: NullableStringFieldUpdateOperationsInput | string | null
    sharedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutLearningPathsNestedInput
    prerequisites?: PrerequisiteUpdateManyWithoutLearningPathNestedInput
    aiModuleItems?: AIModuleLearningPathItemUpdateManyWithoutLearningPathNestedInput
    UserProgress?: UserProgressUpdateManyWithoutLearningPathNestedInput
  }

  export type LearningPathUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shareId?: NullableStringFieldUpdateOperationsInput | string | null
    sharedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prerequisites?: PrerequisiteUncheckedUpdateManyWithoutLearningPathNestedInput
    aiModuleItems?: AIModuleLearningPathItemUncheckedUpdateManyWithoutLearningPathNestedInput
    UserProgress?: UserProgressUncheckedUpdateManyWithoutLearningPathNestedInput
  }

  export type TopicUpsertWithoutLearningPathItemsInput = {
    update: XOR<TopicUpdateWithoutLearningPathItemsInput, TopicUncheckedUpdateWithoutLearningPathItemsInput>
    create: XOR<TopicCreateWithoutLearningPathItemsInput, TopicUncheckedCreateWithoutLearningPathItemsInput>
    where?: TopicWhereInput
  }

  export type TopicUpdateToOneWithWhereWithoutLearningPathItemsInput = {
    where?: TopicWhereInput
    data: XOR<TopicUpdateWithoutLearningPathItemsInput, TopicUncheckedUpdateWithoutLearningPathItemsInput>
  }

  export type TopicUpdateWithoutLearningPathItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutTopicsNestedInput
    progress?: ProgressUpdateManyWithoutTopicNestedInput
    contentItems?: ContentItemUpdateManyWithoutTopicNestedInput
    analyticsEntries?: AnalyticsEntryUpdateManyWithoutTopicNestedInput
    comments?: CommentUpdateManyWithoutTopicNestedInput
    prerequisites?: PrerequisiteUpdateManyWithoutTopicNestedInput
    aiModules?: AIModuleUpdateManyWithoutTopicNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUpdateManyWithoutTopicNestedInput
    aiModuleRatings?: AIModuleRatingUpdateManyWithoutTopicNestedInput
  }

  export type TopicUncheckedUpdateWithoutLearningPathItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    progress?: ProgressUncheckedUpdateManyWithoutTopicNestedInput
    contentItems?: ContentItemUncheckedUpdateManyWithoutTopicNestedInput
    analyticsEntries?: AnalyticsEntryUncheckedUpdateManyWithoutTopicNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTopicNestedInput
    prerequisites?: PrerequisiteUncheckedUpdateManyWithoutTopicNestedInput
    aiModules?: AIModuleUncheckedUpdateManyWithoutTopicNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedUpdateManyWithoutTopicNestedInput
    aiModuleRatings?: AIModuleRatingUncheckedUpdateManyWithoutTopicNestedInput
  }

  export type UserProgressUpsertWithWhereUniqueWithoutModuleInput = {
    where: UserProgressWhereUniqueInput
    update: XOR<UserProgressUpdateWithoutModuleInput, UserProgressUncheckedUpdateWithoutModuleInput>
    create: XOR<UserProgressCreateWithoutModuleInput, UserProgressUncheckedCreateWithoutModuleInput>
  }

  export type UserProgressUpdateWithWhereUniqueWithoutModuleInput = {
    where: UserProgressWhereUniqueInput
    data: XOR<UserProgressUpdateWithoutModuleInput, UserProgressUncheckedUpdateWithoutModuleInput>
  }

  export type UserProgressUpdateManyWithWhereWithoutModuleInput = {
    where: UserProgressScalarWhereInput
    data: XOR<UserProgressUpdateManyMutationInput, UserProgressUncheckedUpdateManyWithoutModuleInput>
  }

  export type TopicCreateWithoutContentItemsInput = {
    id?: string
    title: string
    description?: string | null
    user: UserCreateNestedOneWithoutTopicsInput
    progress?: ProgressCreateNestedManyWithoutTopicInput
    learningPathItems?: LearningPathItemCreateNestedManyWithoutTopicInput
    analyticsEntries?: AnalyticsEntryCreateNestedManyWithoutTopicInput
    comments?: CommentCreateNestedManyWithoutTopicInput
    prerequisites?: PrerequisiteCreateNestedManyWithoutTopicInput
    aiModules?: AIModuleCreateNestedManyWithoutTopicInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptCreateNestedManyWithoutTopicInput
    aiModuleRatings?: AIModuleRatingCreateNestedManyWithoutTopicInput
  }

  export type TopicUncheckedCreateWithoutContentItemsInput = {
    id?: string
    title: string
    description?: string | null
    userId: string
    progress?: ProgressUncheckedCreateNestedManyWithoutTopicInput
    learningPathItems?: LearningPathItemUncheckedCreateNestedManyWithoutTopicInput
    analyticsEntries?: AnalyticsEntryUncheckedCreateNestedManyWithoutTopicInput
    comments?: CommentUncheckedCreateNestedManyWithoutTopicInput
    prerequisites?: PrerequisiteUncheckedCreateNestedManyWithoutTopicInput
    aiModules?: AIModuleUncheckedCreateNestedManyWithoutTopicInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedCreateNestedManyWithoutTopicInput
    aiModuleRatings?: AIModuleRatingUncheckedCreateNestedManyWithoutTopicInput
  }

  export type TopicCreateOrConnectWithoutContentItemsInput = {
    where: TopicWhereUniqueInput
    create: XOR<TopicCreateWithoutContentItemsInput, TopicUncheckedCreateWithoutContentItemsInput>
  }

  export type BookmarkCreateWithoutContentItemInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutBookmarksInput
  }

  export type BookmarkUncheckedCreateWithoutContentItemInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type BookmarkCreateOrConnectWithoutContentItemInput = {
    where: BookmarkWhereUniqueInput
    create: XOR<BookmarkCreateWithoutContentItemInput, BookmarkUncheckedCreateWithoutContentItemInput>
  }

  export type BookmarkCreateManyContentItemInputEnvelope = {
    data: BookmarkCreateManyContentItemInput | BookmarkCreateManyContentItemInput[]
    skipDuplicates?: boolean
  }

  export type QuizAttemptCreateWithoutContentItemInput = {
    id?: string
    score: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    answers?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutQuizAttemptsInput
  }

  export type QuizAttemptUncheckedCreateWithoutContentItemInput = {
    id?: string
    userId: string
    score: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    answers?: NullableJsonNullValueInput | InputJsonValue
  }

  export type QuizAttemptCreateOrConnectWithoutContentItemInput = {
    where: QuizAttemptWhereUniqueInput
    create: XOR<QuizAttemptCreateWithoutContentItemInput, QuizAttemptUncheckedCreateWithoutContentItemInput>
  }

  export type QuizAttemptCreateManyContentItemInputEnvelope = {
    data: QuizAttemptCreateManyContentItemInput | QuizAttemptCreateManyContentItemInput[]
    skipDuplicates?: boolean
  }

  export type ReviewItemCreateWithoutContentItemInput = {
    id?: string
    type: string
    question: string
    answer: string
    userAnswer?: string | null
    isCorrect?: boolean | null
    answeredAt?: Date | string | null
    reviewSession: ReviewSessionCreateNestedOneWithoutItemsInput
  }

  export type ReviewItemUncheckedCreateWithoutContentItemInput = {
    id?: string
    reviewSessionId: string
    type: string
    question: string
    answer: string
    userAnswer?: string | null
    isCorrect?: boolean | null
    answeredAt?: Date | string | null
  }

  export type ReviewItemCreateOrConnectWithoutContentItemInput = {
    where: ReviewItemWhereUniqueInput
    create: XOR<ReviewItemCreateWithoutContentItemInput, ReviewItemUncheckedCreateWithoutContentItemInput>
  }

  export type ReviewItemCreateManyContentItemInputEnvelope = {
    data: ReviewItemCreateManyContentItemInput | ReviewItemCreateManyContentItemInput[]
    skipDuplicates?: boolean
  }

  export type ContentRatingCreateWithoutContentItemInput = {
    id?: string
    rating: number
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutContentRatingsInput
  }

  export type ContentRatingUncheckedCreateWithoutContentItemInput = {
    id?: string
    userId: string
    rating: number
    createdAt?: Date | string
  }

  export type ContentRatingCreateOrConnectWithoutContentItemInput = {
    where: ContentRatingWhereUniqueInput
    create: XOR<ContentRatingCreateWithoutContentItemInput, ContentRatingUncheckedCreateWithoutContentItemInput>
  }

  export type ContentRatingCreateManyContentItemInputEnvelope = {
    data: ContentRatingCreateManyContentItemInput | ContentRatingCreateManyContentItemInput[]
    skipDuplicates?: boolean
  }

  export type AIPlaylistItemCreateWithoutContentItemInput = {
    id?: string
    order: number
    playlist: AIPlaylistCreateNestedOneWithoutItemsInput
  }

  export type AIPlaylistItemUncheckedCreateWithoutContentItemInput = {
    id?: string
    playlistId: string
    order: number
  }

  export type AIPlaylistItemCreateOrConnectWithoutContentItemInput = {
    where: AIPlaylistItemWhereUniqueInput
    create: XOR<AIPlaylistItemCreateWithoutContentItemInput, AIPlaylistItemUncheckedCreateWithoutContentItemInput>
  }

  export type AIPlaylistItemCreateManyContentItemInputEnvelope = {
    data: AIPlaylistItemCreateManyContentItemInput | AIPlaylistItemCreateManyContentItemInput[]
    skipDuplicates?: boolean
  }

  export type TopicUpsertWithoutContentItemsInput = {
    update: XOR<TopicUpdateWithoutContentItemsInput, TopicUncheckedUpdateWithoutContentItemsInput>
    create: XOR<TopicCreateWithoutContentItemsInput, TopicUncheckedCreateWithoutContentItemsInput>
    where?: TopicWhereInput
  }

  export type TopicUpdateToOneWithWhereWithoutContentItemsInput = {
    where?: TopicWhereInput
    data: XOR<TopicUpdateWithoutContentItemsInput, TopicUncheckedUpdateWithoutContentItemsInput>
  }

  export type TopicUpdateWithoutContentItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutTopicsNestedInput
    progress?: ProgressUpdateManyWithoutTopicNestedInput
    learningPathItems?: LearningPathItemUpdateManyWithoutTopicNestedInput
    analyticsEntries?: AnalyticsEntryUpdateManyWithoutTopicNestedInput
    comments?: CommentUpdateManyWithoutTopicNestedInput
    prerequisites?: PrerequisiteUpdateManyWithoutTopicNestedInput
    aiModules?: AIModuleUpdateManyWithoutTopicNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUpdateManyWithoutTopicNestedInput
    aiModuleRatings?: AIModuleRatingUpdateManyWithoutTopicNestedInput
  }

  export type TopicUncheckedUpdateWithoutContentItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    progress?: ProgressUncheckedUpdateManyWithoutTopicNestedInput
    learningPathItems?: LearningPathItemUncheckedUpdateManyWithoutTopicNestedInput
    analyticsEntries?: AnalyticsEntryUncheckedUpdateManyWithoutTopicNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTopicNestedInput
    prerequisites?: PrerequisiteUncheckedUpdateManyWithoutTopicNestedInput
    aiModules?: AIModuleUncheckedUpdateManyWithoutTopicNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedUpdateManyWithoutTopicNestedInput
    aiModuleRatings?: AIModuleRatingUncheckedUpdateManyWithoutTopicNestedInput
  }

  export type BookmarkUpsertWithWhereUniqueWithoutContentItemInput = {
    where: BookmarkWhereUniqueInput
    update: XOR<BookmarkUpdateWithoutContentItemInput, BookmarkUncheckedUpdateWithoutContentItemInput>
    create: XOR<BookmarkCreateWithoutContentItemInput, BookmarkUncheckedCreateWithoutContentItemInput>
  }

  export type BookmarkUpdateWithWhereUniqueWithoutContentItemInput = {
    where: BookmarkWhereUniqueInput
    data: XOR<BookmarkUpdateWithoutContentItemInput, BookmarkUncheckedUpdateWithoutContentItemInput>
  }

  export type BookmarkUpdateManyWithWhereWithoutContentItemInput = {
    where: BookmarkScalarWhereInput
    data: XOR<BookmarkUpdateManyMutationInput, BookmarkUncheckedUpdateManyWithoutContentItemInput>
  }

  export type QuizAttemptUpsertWithWhereUniqueWithoutContentItemInput = {
    where: QuizAttemptWhereUniqueInput
    update: XOR<QuizAttemptUpdateWithoutContentItemInput, QuizAttemptUncheckedUpdateWithoutContentItemInput>
    create: XOR<QuizAttemptCreateWithoutContentItemInput, QuizAttemptUncheckedCreateWithoutContentItemInput>
  }

  export type QuizAttemptUpdateWithWhereUniqueWithoutContentItemInput = {
    where: QuizAttemptWhereUniqueInput
    data: XOR<QuizAttemptUpdateWithoutContentItemInput, QuizAttemptUncheckedUpdateWithoutContentItemInput>
  }

  export type QuizAttemptUpdateManyWithWhereWithoutContentItemInput = {
    where: QuizAttemptScalarWhereInput
    data: XOR<QuizAttemptUpdateManyMutationInput, QuizAttemptUncheckedUpdateManyWithoutContentItemInput>
  }

  export type ReviewItemUpsertWithWhereUniqueWithoutContentItemInput = {
    where: ReviewItemWhereUniqueInput
    update: XOR<ReviewItemUpdateWithoutContentItemInput, ReviewItemUncheckedUpdateWithoutContentItemInput>
    create: XOR<ReviewItemCreateWithoutContentItemInput, ReviewItemUncheckedCreateWithoutContentItemInput>
  }

  export type ReviewItemUpdateWithWhereUniqueWithoutContentItemInput = {
    where: ReviewItemWhereUniqueInput
    data: XOR<ReviewItemUpdateWithoutContentItemInput, ReviewItemUncheckedUpdateWithoutContentItemInput>
  }

  export type ReviewItemUpdateManyWithWhereWithoutContentItemInput = {
    where: ReviewItemScalarWhereInput
    data: XOR<ReviewItemUpdateManyMutationInput, ReviewItemUncheckedUpdateManyWithoutContentItemInput>
  }

  export type ReviewItemScalarWhereInput = {
    AND?: ReviewItemScalarWhereInput | ReviewItemScalarWhereInput[]
    OR?: ReviewItemScalarWhereInput[]
    NOT?: ReviewItemScalarWhereInput | ReviewItemScalarWhereInput[]
    id?: StringFilter<"ReviewItem"> | string
    reviewSessionId?: StringFilter<"ReviewItem"> | string
    contentItemId?: StringFilter<"ReviewItem"> | string
    type?: StringFilter<"ReviewItem"> | string
    question?: StringFilter<"ReviewItem"> | string
    answer?: StringFilter<"ReviewItem"> | string
    userAnswer?: StringNullableFilter<"ReviewItem"> | string | null
    isCorrect?: BoolNullableFilter<"ReviewItem"> | boolean | null
    answeredAt?: DateTimeNullableFilter<"ReviewItem"> | Date | string | null
  }

  export type ContentRatingUpsertWithWhereUniqueWithoutContentItemInput = {
    where: ContentRatingWhereUniqueInput
    update: XOR<ContentRatingUpdateWithoutContentItemInput, ContentRatingUncheckedUpdateWithoutContentItemInput>
    create: XOR<ContentRatingCreateWithoutContentItemInput, ContentRatingUncheckedCreateWithoutContentItemInput>
  }

  export type ContentRatingUpdateWithWhereUniqueWithoutContentItemInput = {
    where: ContentRatingWhereUniqueInput
    data: XOR<ContentRatingUpdateWithoutContentItemInput, ContentRatingUncheckedUpdateWithoutContentItemInput>
  }

  export type ContentRatingUpdateManyWithWhereWithoutContentItemInput = {
    where: ContentRatingScalarWhereInput
    data: XOR<ContentRatingUpdateManyMutationInput, ContentRatingUncheckedUpdateManyWithoutContentItemInput>
  }

  export type AIPlaylistItemUpsertWithWhereUniqueWithoutContentItemInput = {
    where: AIPlaylistItemWhereUniqueInput
    update: XOR<AIPlaylistItemUpdateWithoutContentItemInput, AIPlaylistItemUncheckedUpdateWithoutContentItemInput>
    create: XOR<AIPlaylistItemCreateWithoutContentItemInput, AIPlaylistItemUncheckedCreateWithoutContentItemInput>
  }

  export type AIPlaylistItemUpdateWithWhereUniqueWithoutContentItemInput = {
    where: AIPlaylistItemWhereUniqueInput
    data: XOR<AIPlaylistItemUpdateWithoutContentItemInput, AIPlaylistItemUncheckedUpdateWithoutContentItemInput>
  }

  export type AIPlaylistItemUpdateManyWithWhereWithoutContentItemInput = {
    where: AIPlaylistItemScalarWhereInput
    data: XOR<AIPlaylistItemUpdateManyMutationInput, AIPlaylistItemUncheckedUpdateManyWithoutContentItemInput>
  }

  export type AIPlaylistItemScalarWhereInput = {
    AND?: AIPlaylistItemScalarWhereInput | AIPlaylistItemScalarWhereInput[]
    OR?: AIPlaylistItemScalarWhereInput[]
    NOT?: AIPlaylistItemScalarWhereInput | AIPlaylistItemScalarWhereInput[]
    id?: StringFilter<"AIPlaylistItem"> | string
    playlistId?: StringFilter<"AIPlaylistItem"> | string
    contentItemId?: StringFilter<"AIPlaylistItem"> | string
    order?: IntFilter<"AIPlaylistItem"> | number
  }

  export type UserCreateWithoutContentRatingsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesCreateNestedOneWithoutUserInput
    topics?: TopicCreateNestedManyWithoutUserInput
    progress?: ProgressCreateNestedManyWithoutUserInput
    badges?: BadgeCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutUserInput
    aiModules?: AIModuleCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressCreateNestedManyWithoutUserInput
    AIChat?: AIChatCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutContentRatingsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesUncheckedCreateNestedOneWithoutUserInput
    topics?: TopicUncheckedCreateNestedManyWithoutUserInput
    progress?: ProgressUncheckedCreateNestedManyWithoutUserInput
    badges?: BadgeUncheckedCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewUncheckedCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathUncheckedCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionUncheckedCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceUncheckedCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenUncheckedCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeUncheckedCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreUncheckedCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutUserInput
    aiModules?: AIModuleUncheckedCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingUncheckedCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    AIChat?: AIChatUncheckedCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutContentRatingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutContentRatingsInput, UserUncheckedCreateWithoutContentRatingsInput>
  }

  export type ContentItemCreateWithoutRatingsInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    type: string
    difficulty: string
    createdAt?: Date | string
    updatedAt?: Date | string
    version?: string
    topic: TopicCreateNestedOneWithoutContentItemsInput
    bookmarks?: BookmarkCreateNestedManyWithoutContentItemInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutContentItemInput
    reviewItems?: ReviewItemCreateNestedManyWithoutContentItemInput
    aiPlaylistItems?: AIPlaylistItemCreateNestedManyWithoutContentItemInput
  }

  export type ContentItemUncheckedCreateWithoutRatingsInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    type: string
    difficulty: string
    topicId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    version?: string
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutContentItemInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutContentItemInput
    reviewItems?: ReviewItemUncheckedCreateNestedManyWithoutContentItemInput
    aiPlaylistItems?: AIPlaylistItemUncheckedCreateNestedManyWithoutContentItemInput
  }

  export type ContentItemCreateOrConnectWithoutRatingsInput = {
    where: ContentItemWhereUniqueInput
    create: XOR<ContentItemCreateWithoutRatingsInput, ContentItemUncheckedCreateWithoutRatingsInput>
  }

  export type UserUpsertWithoutContentRatingsInput = {
    update: XOR<UserUpdateWithoutContentRatingsInput, UserUncheckedUpdateWithoutContentRatingsInput>
    create: XOR<UserCreateWithoutContentRatingsInput, UserUncheckedCreateWithoutContentRatingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutContentRatingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutContentRatingsInput, UserUncheckedUpdateWithoutContentRatingsInput>
  }

  export type UserUpdateWithoutContentRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUpdateOneWithoutUserNestedInput
    topics?: TopicUpdateManyWithoutUserNestedInput
    progress?: ProgressUpdateManyWithoutUserNestedInput
    badges?: BadgeUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutContentRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUncheckedUpdateOneWithoutUserNestedInput
    topics?: TopicUncheckedUpdateManyWithoutUserNestedInput
    progress?: ProgressUncheckedUpdateManyWithoutUserNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUncheckedUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUncheckedUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUncheckedUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUncheckedUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUncheckedUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUncheckedUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUncheckedUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUncheckedUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUncheckedUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUncheckedUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ContentItemUpsertWithoutRatingsInput = {
    update: XOR<ContentItemUpdateWithoutRatingsInput, ContentItemUncheckedUpdateWithoutRatingsInput>
    create: XOR<ContentItemCreateWithoutRatingsInput, ContentItemUncheckedCreateWithoutRatingsInput>
    where?: ContentItemWhereInput
  }

  export type ContentItemUpdateToOneWithWhereWithoutRatingsInput = {
    where?: ContentItemWhereInput
    data: XOR<ContentItemUpdateWithoutRatingsInput, ContentItemUncheckedUpdateWithoutRatingsInput>
  }

  export type ContentItemUpdateWithoutRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: StringFieldUpdateOperationsInput | string
    topic?: TopicUpdateOneRequiredWithoutContentItemsNestedInput
    bookmarks?: BookmarkUpdateManyWithoutContentItemNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutContentItemNestedInput
    reviewItems?: ReviewItemUpdateManyWithoutContentItemNestedInput
    aiPlaylistItems?: AIPlaylistItemUpdateManyWithoutContentItemNestedInput
  }

  export type ContentItemUncheckedUpdateWithoutRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: StringFieldUpdateOperationsInput | string
    bookmarks?: BookmarkUncheckedUpdateManyWithoutContentItemNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutContentItemNestedInput
    reviewItems?: ReviewItemUncheckedUpdateManyWithoutContentItemNestedInput
    aiPlaylistItems?: AIPlaylistItemUncheckedUpdateManyWithoutContentItemNestedInput
  }

  export type UserCreateWithoutBookmarksInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesCreateNestedOneWithoutUserInput
    topics?: TopicCreateNestedManyWithoutUserInput
    progress?: ProgressCreateNestedManyWithoutUserInput
    badges?: BadgeCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutUserInput
    aiModules?: AIModuleCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressCreateNestedManyWithoutUserInput
    AIChat?: AIChatCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBookmarksInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesUncheckedCreateNestedOneWithoutUserInput
    topics?: TopicUncheckedCreateNestedManyWithoutUserInput
    progress?: ProgressUncheckedCreateNestedManyWithoutUserInput
    badges?: BadgeUncheckedCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewUncheckedCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionUncheckedCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceUncheckedCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenUncheckedCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeUncheckedCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingUncheckedCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreUncheckedCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutUserInput
    aiModules?: AIModuleUncheckedCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingUncheckedCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    AIChat?: AIChatUncheckedCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBookmarksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBookmarksInput, UserUncheckedCreateWithoutBookmarksInput>
  }

  export type ContentItemCreateWithoutBookmarksInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    type: string
    difficulty: string
    createdAt?: Date | string
    updatedAt?: Date | string
    version?: string
    topic: TopicCreateNestedOneWithoutContentItemsInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutContentItemInput
    reviewItems?: ReviewItemCreateNestedManyWithoutContentItemInput
    ratings?: ContentRatingCreateNestedManyWithoutContentItemInput
    aiPlaylistItems?: AIPlaylistItemCreateNestedManyWithoutContentItemInput
  }

  export type ContentItemUncheckedCreateWithoutBookmarksInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    type: string
    difficulty: string
    topicId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    version?: string
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutContentItemInput
    reviewItems?: ReviewItemUncheckedCreateNestedManyWithoutContentItemInput
    ratings?: ContentRatingUncheckedCreateNestedManyWithoutContentItemInput
    aiPlaylistItems?: AIPlaylistItemUncheckedCreateNestedManyWithoutContentItemInput
  }

  export type ContentItemCreateOrConnectWithoutBookmarksInput = {
    where: ContentItemWhereUniqueInput
    create: XOR<ContentItemCreateWithoutBookmarksInput, ContentItemUncheckedCreateWithoutBookmarksInput>
  }

  export type UserUpsertWithoutBookmarksInput = {
    update: XOR<UserUpdateWithoutBookmarksInput, UserUncheckedUpdateWithoutBookmarksInput>
    create: XOR<UserCreateWithoutBookmarksInput, UserUncheckedCreateWithoutBookmarksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBookmarksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBookmarksInput, UserUncheckedUpdateWithoutBookmarksInput>
  }

  export type UserUpdateWithoutBookmarksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUpdateOneWithoutUserNestedInput
    topics?: TopicUpdateManyWithoutUserNestedInput
    progress?: ProgressUpdateManyWithoutUserNestedInput
    badges?: BadgeUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBookmarksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUncheckedUpdateOneWithoutUserNestedInput
    topics?: TopicUncheckedUpdateManyWithoutUserNestedInput
    progress?: ProgressUncheckedUpdateManyWithoutUserNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUncheckedUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUncheckedUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUncheckedUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUncheckedUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUncheckedUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUncheckedUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUncheckedUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUncheckedUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUncheckedUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUncheckedUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ContentItemUpsertWithoutBookmarksInput = {
    update: XOR<ContentItemUpdateWithoutBookmarksInput, ContentItemUncheckedUpdateWithoutBookmarksInput>
    create: XOR<ContentItemCreateWithoutBookmarksInput, ContentItemUncheckedCreateWithoutBookmarksInput>
    where?: ContentItemWhereInput
  }

  export type ContentItemUpdateToOneWithWhereWithoutBookmarksInput = {
    where?: ContentItemWhereInput
    data: XOR<ContentItemUpdateWithoutBookmarksInput, ContentItemUncheckedUpdateWithoutBookmarksInput>
  }

  export type ContentItemUpdateWithoutBookmarksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: StringFieldUpdateOperationsInput | string
    topic?: TopicUpdateOneRequiredWithoutContentItemsNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutContentItemNestedInput
    reviewItems?: ReviewItemUpdateManyWithoutContentItemNestedInput
    ratings?: ContentRatingUpdateManyWithoutContentItemNestedInput
    aiPlaylistItems?: AIPlaylistItemUpdateManyWithoutContentItemNestedInput
  }

  export type ContentItemUncheckedUpdateWithoutBookmarksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: StringFieldUpdateOperationsInput | string
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutContentItemNestedInput
    reviewItems?: ReviewItemUncheckedUpdateManyWithoutContentItemNestedInput
    ratings?: ContentRatingUncheckedUpdateManyWithoutContentItemNestedInput
    aiPlaylistItems?: AIPlaylistItemUncheckedUpdateManyWithoutContentItemNestedInput
  }

  export type UserCreateWithoutQuizAttemptsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesCreateNestedOneWithoutUserInput
    topics?: TopicCreateNestedManyWithoutUserInput
    progress?: ProgressCreateNestedManyWithoutUserInput
    badges?: BadgeCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutUserInput
    aiModules?: AIModuleCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressCreateNestedManyWithoutUserInput
    AIChat?: AIChatCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutQuizAttemptsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesUncheckedCreateNestedOneWithoutUserInput
    topics?: TopicUncheckedCreateNestedManyWithoutUserInput
    progress?: ProgressUncheckedCreateNestedManyWithoutUserInput
    badges?: BadgeUncheckedCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewUncheckedCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathUncheckedCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionUncheckedCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceUncheckedCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenUncheckedCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeUncheckedCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingUncheckedCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreUncheckedCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutUserInput
    aiModules?: AIModuleUncheckedCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingUncheckedCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    AIChat?: AIChatUncheckedCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutQuizAttemptsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutQuizAttemptsInput, UserUncheckedCreateWithoutQuizAttemptsInput>
  }

  export type ContentItemCreateWithoutQuizAttemptsInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    type: string
    difficulty: string
    createdAt?: Date | string
    updatedAt?: Date | string
    version?: string
    topic: TopicCreateNestedOneWithoutContentItemsInput
    bookmarks?: BookmarkCreateNestedManyWithoutContentItemInput
    reviewItems?: ReviewItemCreateNestedManyWithoutContentItemInput
    ratings?: ContentRatingCreateNestedManyWithoutContentItemInput
    aiPlaylistItems?: AIPlaylistItemCreateNestedManyWithoutContentItemInput
  }

  export type ContentItemUncheckedCreateWithoutQuizAttemptsInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    type: string
    difficulty: string
    topicId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    version?: string
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutContentItemInput
    reviewItems?: ReviewItemUncheckedCreateNestedManyWithoutContentItemInput
    ratings?: ContentRatingUncheckedCreateNestedManyWithoutContentItemInput
    aiPlaylistItems?: AIPlaylistItemUncheckedCreateNestedManyWithoutContentItemInput
  }

  export type ContentItemCreateOrConnectWithoutQuizAttemptsInput = {
    where: ContentItemWhereUniqueInput
    create: XOR<ContentItemCreateWithoutQuizAttemptsInput, ContentItemUncheckedCreateWithoutQuizAttemptsInput>
  }

  export type UserUpsertWithoutQuizAttemptsInput = {
    update: XOR<UserUpdateWithoutQuizAttemptsInput, UserUncheckedUpdateWithoutQuizAttemptsInput>
    create: XOR<UserCreateWithoutQuizAttemptsInput, UserUncheckedCreateWithoutQuizAttemptsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutQuizAttemptsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutQuizAttemptsInput, UserUncheckedUpdateWithoutQuizAttemptsInput>
  }

  export type UserUpdateWithoutQuizAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUpdateOneWithoutUserNestedInput
    topics?: TopicUpdateManyWithoutUserNestedInput
    progress?: ProgressUpdateManyWithoutUserNestedInput
    badges?: BadgeUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutQuizAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUncheckedUpdateOneWithoutUserNestedInput
    topics?: TopicUncheckedUpdateManyWithoutUserNestedInput
    progress?: ProgressUncheckedUpdateManyWithoutUserNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUncheckedUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUncheckedUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUncheckedUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUncheckedUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUncheckedUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUncheckedUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUncheckedUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUncheckedUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUncheckedUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUncheckedUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUncheckedUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ContentItemUpsertWithoutQuizAttemptsInput = {
    update: XOR<ContentItemUpdateWithoutQuizAttemptsInput, ContentItemUncheckedUpdateWithoutQuizAttemptsInput>
    create: XOR<ContentItemCreateWithoutQuizAttemptsInput, ContentItemUncheckedCreateWithoutQuizAttemptsInput>
    where?: ContentItemWhereInput
  }

  export type ContentItemUpdateToOneWithWhereWithoutQuizAttemptsInput = {
    where?: ContentItemWhereInput
    data: XOR<ContentItemUpdateWithoutQuizAttemptsInput, ContentItemUncheckedUpdateWithoutQuizAttemptsInput>
  }

  export type ContentItemUpdateWithoutQuizAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: StringFieldUpdateOperationsInput | string
    topic?: TopicUpdateOneRequiredWithoutContentItemsNestedInput
    bookmarks?: BookmarkUpdateManyWithoutContentItemNestedInput
    reviewItems?: ReviewItemUpdateManyWithoutContentItemNestedInput
    ratings?: ContentRatingUpdateManyWithoutContentItemNestedInput
    aiPlaylistItems?: AIPlaylistItemUpdateManyWithoutContentItemNestedInput
  }

  export type ContentItemUncheckedUpdateWithoutQuizAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: StringFieldUpdateOperationsInput | string
    bookmarks?: BookmarkUncheckedUpdateManyWithoutContentItemNestedInput
    reviewItems?: ReviewItemUncheckedUpdateManyWithoutContentItemNestedInput
    ratings?: ContentRatingUncheckedUpdateManyWithoutContentItemNestedInput
    aiPlaylistItems?: AIPlaylistItemUncheckedUpdateManyWithoutContentItemNestedInput
  }

  export type UserCreateWithoutKnowledgeNodesInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesCreateNestedOneWithoutUserInput
    topics?: TopicCreateNestedManyWithoutUserInput
    progress?: ProgressCreateNestedManyWithoutUserInput
    badges?: BadgeCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutUserInput
    aiModules?: AIModuleCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressCreateNestedManyWithoutUserInput
    AIChat?: AIChatCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutKnowledgeNodesInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesUncheckedCreateNestedOneWithoutUserInput
    topics?: TopicUncheckedCreateNestedManyWithoutUserInput
    progress?: ProgressUncheckedCreateNestedManyWithoutUserInput
    badges?: BadgeUncheckedCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewUncheckedCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathUncheckedCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionUncheckedCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceUncheckedCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenUncheckedCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeUncheckedCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingUncheckedCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreUncheckedCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutUserInput
    aiModules?: AIModuleUncheckedCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingUncheckedCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    AIChat?: AIChatUncheckedCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutKnowledgeNodesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutKnowledgeNodesInput, UserUncheckedCreateWithoutKnowledgeNodesInput>
  }

  export type KnowledgeNodeCreateWithoutChildrenInput = {
    id?: string
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutKnowledgeNodesInput
    parent?: KnowledgeNodeCreateNestedOneWithoutChildrenInput
  }

  export type KnowledgeNodeUncheckedCreateWithoutChildrenInput = {
    id?: string
    title: string
    description?: string | null
    userId: string
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KnowledgeNodeCreateOrConnectWithoutChildrenInput = {
    where: KnowledgeNodeWhereUniqueInput
    create: XOR<KnowledgeNodeCreateWithoutChildrenInput, KnowledgeNodeUncheckedCreateWithoutChildrenInput>
  }

  export type KnowledgeNodeCreateWithoutParentInput = {
    id?: string
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutKnowledgeNodesInput
    children?: KnowledgeNodeCreateNestedManyWithoutParentInput
  }

  export type KnowledgeNodeUncheckedCreateWithoutParentInput = {
    id?: string
    title: string
    description?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: KnowledgeNodeUncheckedCreateNestedManyWithoutParentInput
  }

  export type KnowledgeNodeCreateOrConnectWithoutParentInput = {
    where: KnowledgeNodeWhereUniqueInput
    create: XOR<KnowledgeNodeCreateWithoutParentInput, KnowledgeNodeUncheckedCreateWithoutParentInput>
  }

  export type KnowledgeNodeCreateManyParentInputEnvelope = {
    data: KnowledgeNodeCreateManyParentInput | KnowledgeNodeCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutKnowledgeNodesInput = {
    update: XOR<UserUpdateWithoutKnowledgeNodesInput, UserUncheckedUpdateWithoutKnowledgeNodesInput>
    create: XOR<UserCreateWithoutKnowledgeNodesInput, UserUncheckedCreateWithoutKnowledgeNodesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutKnowledgeNodesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutKnowledgeNodesInput, UserUncheckedUpdateWithoutKnowledgeNodesInput>
  }

  export type UserUpdateWithoutKnowledgeNodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUpdateOneWithoutUserNestedInput
    topics?: TopicUpdateManyWithoutUserNestedInput
    progress?: ProgressUpdateManyWithoutUserNestedInput
    badges?: BadgeUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutKnowledgeNodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUncheckedUpdateOneWithoutUserNestedInput
    topics?: TopicUncheckedUpdateManyWithoutUserNestedInput
    progress?: ProgressUncheckedUpdateManyWithoutUserNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUncheckedUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUncheckedUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUncheckedUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUncheckedUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUncheckedUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUncheckedUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUncheckedUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUncheckedUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUncheckedUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUncheckedUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUncheckedUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUncheckedUpdateManyWithoutUserNestedInput
  }

  export type KnowledgeNodeUpsertWithoutChildrenInput = {
    update: XOR<KnowledgeNodeUpdateWithoutChildrenInput, KnowledgeNodeUncheckedUpdateWithoutChildrenInput>
    create: XOR<KnowledgeNodeCreateWithoutChildrenInput, KnowledgeNodeUncheckedCreateWithoutChildrenInput>
    where?: KnowledgeNodeWhereInput
  }

  export type KnowledgeNodeUpdateToOneWithWhereWithoutChildrenInput = {
    where?: KnowledgeNodeWhereInput
    data: XOR<KnowledgeNodeUpdateWithoutChildrenInput, KnowledgeNodeUncheckedUpdateWithoutChildrenInput>
  }

  export type KnowledgeNodeUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutKnowledgeNodesNestedInput
    parent?: KnowledgeNodeUpdateOneWithoutChildrenNestedInput
  }

  export type KnowledgeNodeUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeNodeUpsertWithWhereUniqueWithoutParentInput = {
    where: KnowledgeNodeWhereUniqueInput
    update: XOR<KnowledgeNodeUpdateWithoutParentInput, KnowledgeNodeUncheckedUpdateWithoutParentInput>
    create: XOR<KnowledgeNodeCreateWithoutParentInput, KnowledgeNodeUncheckedCreateWithoutParentInput>
  }

  export type KnowledgeNodeUpdateWithWhereUniqueWithoutParentInput = {
    where: KnowledgeNodeWhereUniqueInput
    data: XOR<KnowledgeNodeUpdateWithoutParentInput, KnowledgeNodeUncheckedUpdateWithoutParentInput>
  }

  export type KnowledgeNodeUpdateManyWithWhereWithoutParentInput = {
    where: KnowledgeNodeScalarWhereInput
    data: XOR<KnowledgeNodeUpdateManyMutationInput, KnowledgeNodeUncheckedUpdateManyWithoutParentInput>
  }

  export type UserCreateWithoutLeaderboardEntriesInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesCreateNestedOneWithoutUserInput
    topics?: TopicCreateNestedManyWithoutUserInput
    progress?: ProgressCreateNestedManyWithoutUserInput
    badges?: BadgeCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutUserInput
    aiModules?: AIModuleCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressCreateNestedManyWithoutUserInput
    AIChat?: AIChatCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLeaderboardEntriesInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesUncheckedCreateNestedOneWithoutUserInput
    topics?: TopicUncheckedCreateNestedManyWithoutUserInput
    progress?: ProgressUncheckedCreateNestedManyWithoutUserInput
    badges?: BadgeUncheckedCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewUncheckedCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathUncheckedCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeUncheckedCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionUncheckedCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceUncheckedCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenUncheckedCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeUncheckedCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingUncheckedCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreUncheckedCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutUserInput
    aiModules?: AIModuleUncheckedCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingUncheckedCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    AIChat?: AIChatUncheckedCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLeaderboardEntriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLeaderboardEntriesInput, UserUncheckedCreateWithoutLeaderboardEntriesInput>
  }

  export type UserUpsertWithoutLeaderboardEntriesInput = {
    update: XOR<UserUpdateWithoutLeaderboardEntriesInput, UserUncheckedUpdateWithoutLeaderboardEntriesInput>
    create: XOR<UserCreateWithoutLeaderboardEntriesInput, UserUncheckedCreateWithoutLeaderboardEntriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLeaderboardEntriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLeaderboardEntriesInput, UserUncheckedUpdateWithoutLeaderboardEntriesInput>
  }

  export type UserUpdateWithoutLeaderboardEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUpdateOneWithoutUserNestedInput
    topics?: TopicUpdateManyWithoutUserNestedInput
    progress?: ProgressUpdateManyWithoutUserNestedInput
    badges?: BadgeUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLeaderboardEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUncheckedUpdateOneWithoutUserNestedInput
    topics?: TopicUncheckedUpdateManyWithoutUserNestedInput
    progress?: ProgressUncheckedUpdateManyWithoutUserNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUncheckedUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUncheckedUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUncheckedUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUncheckedUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUncheckedUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUncheckedUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUncheckedUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUncheckedUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUncheckedUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUncheckedUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUncheckedUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUncheckedUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutReviewSessionsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesCreateNestedOneWithoutUserInput
    topics?: TopicCreateNestedManyWithoutUserInput
    progress?: ProgressCreateNestedManyWithoutUserInput
    badges?: BadgeCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutUserInput
    aiModules?: AIModuleCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressCreateNestedManyWithoutUserInput
    AIChat?: AIChatCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReviewSessionsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesUncheckedCreateNestedOneWithoutUserInput
    topics?: TopicUncheckedCreateNestedManyWithoutUserInput
    progress?: ProgressUncheckedCreateNestedManyWithoutUserInput
    badges?: BadgeUncheckedCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewUncheckedCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathUncheckedCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceUncheckedCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenUncheckedCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeUncheckedCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingUncheckedCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreUncheckedCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutUserInput
    aiModules?: AIModuleUncheckedCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingUncheckedCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    AIChat?: AIChatUncheckedCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReviewSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewSessionsInput, UserUncheckedCreateWithoutReviewSessionsInput>
  }

  export type ReviewItemCreateWithoutReviewSessionInput = {
    id?: string
    type: string
    question: string
    answer: string
    userAnswer?: string | null
    isCorrect?: boolean | null
    answeredAt?: Date | string | null
    contentItem: ContentItemCreateNestedOneWithoutReviewItemsInput
  }

  export type ReviewItemUncheckedCreateWithoutReviewSessionInput = {
    id?: string
    contentItemId: string
    type: string
    question: string
    answer: string
    userAnswer?: string | null
    isCorrect?: boolean | null
    answeredAt?: Date | string | null
  }

  export type ReviewItemCreateOrConnectWithoutReviewSessionInput = {
    where: ReviewItemWhereUniqueInput
    create: XOR<ReviewItemCreateWithoutReviewSessionInput, ReviewItemUncheckedCreateWithoutReviewSessionInput>
  }

  export type ReviewItemCreateManyReviewSessionInputEnvelope = {
    data: ReviewItemCreateManyReviewSessionInput | ReviewItemCreateManyReviewSessionInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutReviewSessionsInput = {
    update: XOR<UserUpdateWithoutReviewSessionsInput, UserUncheckedUpdateWithoutReviewSessionsInput>
    create: XOR<UserCreateWithoutReviewSessionsInput, UserUncheckedCreateWithoutReviewSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewSessionsInput, UserUncheckedUpdateWithoutReviewSessionsInput>
  }

  export type UserUpdateWithoutReviewSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUpdateOneWithoutUserNestedInput
    topics?: TopicUpdateManyWithoutUserNestedInput
    progress?: ProgressUpdateManyWithoutUserNestedInput
    badges?: BadgeUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUncheckedUpdateOneWithoutUserNestedInput
    topics?: TopicUncheckedUpdateManyWithoutUserNestedInput
    progress?: ProgressUncheckedUpdateManyWithoutUserNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUncheckedUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUncheckedUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUncheckedUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUncheckedUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUncheckedUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUncheckedUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUncheckedUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUncheckedUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUncheckedUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUncheckedUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ReviewItemUpsertWithWhereUniqueWithoutReviewSessionInput = {
    where: ReviewItemWhereUniqueInput
    update: XOR<ReviewItemUpdateWithoutReviewSessionInput, ReviewItemUncheckedUpdateWithoutReviewSessionInput>
    create: XOR<ReviewItemCreateWithoutReviewSessionInput, ReviewItemUncheckedCreateWithoutReviewSessionInput>
  }

  export type ReviewItemUpdateWithWhereUniqueWithoutReviewSessionInput = {
    where: ReviewItemWhereUniqueInput
    data: XOR<ReviewItemUpdateWithoutReviewSessionInput, ReviewItemUncheckedUpdateWithoutReviewSessionInput>
  }

  export type ReviewItemUpdateManyWithWhereWithoutReviewSessionInput = {
    where: ReviewItemScalarWhereInput
    data: XOR<ReviewItemUpdateManyMutationInput, ReviewItemUncheckedUpdateManyWithoutReviewSessionInput>
  }

  export type ReviewSessionCreateWithoutItemsInput = {
    id?: string
    dueDate: Date | string
    completed?: boolean
    isUrgent?: boolean
    user: UserCreateNestedOneWithoutReviewSessionsInput
  }

  export type ReviewSessionUncheckedCreateWithoutItemsInput = {
    id?: string
    userId: string
    dueDate: Date | string
    completed?: boolean
    isUrgent?: boolean
  }

  export type ReviewSessionCreateOrConnectWithoutItemsInput = {
    where: ReviewSessionWhereUniqueInput
    create: XOR<ReviewSessionCreateWithoutItemsInput, ReviewSessionUncheckedCreateWithoutItemsInput>
  }

  export type ContentItemCreateWithoutReviewItemsInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    type: string
    difficulty: string
    createdAt?: Date | string
    updatedAt?: Date | string
    version?: string
    topic: TopicCreateNestedOneWithoutContentItemsInput
    bookmarks?: BookmarkCreateNestedManyWithoutContentItemInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutContentItemInput
    ratings?: ContentRatingCreateNestedManyWithoutContentItemInput
    aiPlaylistItems?: AIPlaylistItemCreateNestedManyWithoutContentItemInput
  }

  export type ContentItemUncheckedCreateWithoutReviewItemsInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    type: string
    difficulty: string
    topicId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    version?: string
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutContentItemInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutContentItemInput
    ratings?: ContentRatingUncheckedCreateNestedManyWithoutContentItemInput
    aiPlaylistItems?: AIPlaylistItemUncheckedCreateNestedManyWithoutContentItemInput
  }

  export type ContentItemCreateOrConnectWithoutReviewItemsInput = {
    where: ContentItemWhereUniqueInput
    create: XOR<ContentItemCreateWithoutReviewItemsInput, ContentItemUncheckedCreateWithoutReviewItemsInput>
  }

  export type ReviewSessionUpsertWithoutItemsInput = {
    update: XOR<ReviewSessionUpdateWithoutItemsInput, ReviewSessionUncheckedUpdateWithoutItemsInput>
    create: XOR<ReviewSessionCreateWithoutItemsInput, ReviewSessionUncheckedCreateWithoutItemsInput>
    where?: ReviewSessionWhereInput
  }

  export type ReviewSessionUpdateToOneWithWhereWithoutItemsInput = {
    where?: ReviewSessionWhereInput
    data: XOR<ReviewSessionUpdateWithoutItemsInput, ReviewSessionUncheckedUpdateWithoutItemsInput>
  }

  export type ReviewSessionUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    isUrgent?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutReviewSessionsNestedInput
  }

  export type ReviewSessionUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    isUrgent?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ContentItemUpsertWithoutReviewItemsInput = {
    update: XOR<ContentItemUpdateWithoutReviewItemsInput, ContentItemUncheckedUpdateWithoutReviewItemsInput>
    create: XOR<ContentItemCreateWithoutReviewItemsInput, ContentItemUncheckedCreateWithoutReviewItemsInput>
    where?: ContentItemWhereInput
  }

  export type ContentItemUpdateToOneWithWhereWithoutReviewItemsInput = {
    where?: ContentItemWhereInput
    data: XOR<ContentItemUpdateWithoutReviewItemsInput, ContentItemUncheckedUpdateWithoutReviewItemsInput>
  }

  export type ContentItemUpdateWithoutReviewItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: StringFieldUpdateOperationsInput | string
    topic?: TopicUpdateOneRequiredWithoutContentItemsNestedInput
    bookmarks?: BookmarkUpdateManyWithoutContentItemNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutContentItemNestedInput
    ratings?: ContentRatingUpdateManyWithoutContentItemNestedInput
    aiPlaylistItems?: AIPlaylistItemUpdateManyWithoutContentItemNestedInput
  }

  export type ContentItemUncheckedUpdateWithoutReviewItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: StringFieldUpdateOperationsInput | string
    bookmarks?: BookmarkUncheckedUpdateManyWithoutContentItemNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutContentItemNestedInput
    ratings?: ContentRatingUncheckedUpdateManyWithoutContentItemNestedInput
    aiPlaylistItems?: AIPlaylistItemUncheckedUpdateManyWithoutContentItemNestedInput
  }

  export type UserCreateWithoutOwnedWorkspacesInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesCreateNestedOneWithoutUserInput
    topics?: TopicCreateNestedManyWithoutUserInput
    progress?: ProgressCreateNestedManyWithoutUserInput
    badges?: BadgeCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutUserInput
    aiModules?: AIModuleCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressCreateNestedManyWithoutUserInput
    AIChat?: AIChatCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOwnedWorkspacesInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesUncheckedCreateNestedOneWithoutUserInput
    topics?: TopicUncheckedCreateNestedManyWithoutUserInput
    progress?: ProgressUncheckedCreateNestedManyWithoutUserInput
    badges?: BadgeUncheckedCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewUncheckedCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathUncheckedCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionUncheckedCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenUncheckedCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeUncheckedCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingUncheckedCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreUncheckedCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutUserInput
    aiModules?: AIModuleUncheckedCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingUncheckedCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    AIChat?: AIChatUncheckedCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOwnedWorkspacesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOwnedWorkspacesInput, UserUncheckedCreateWithoutOwnedWorkspacesInput>
  }

  export type WorkspaceMemberCreateWithoutWorkspaceInput = {
    id?: string
    role: string
    joinedAt?: Date | string
    user: UserCreateNestedOneWithoutWorkspacesInput
    breakoutRooms?: BreakoutRoomCreateNestedManyWithoutParticipantsInput
  }

  export type WorkspaceMemberUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    userId: string
    role: string
    joinedAt?: Date | string
    breakoutRooms?: BreakoutRoomUncheckedCreateNestedManyWithoutParticipantsInput
  }

  export type WorkspaceMemberCreateOrConnectWithoutWorkspaceInput = {
    where: WorkspaceMemberWhereUniqueInput
    create: XOR<WorkspaceMemberCreateWithoutWorkspaceInput, WorkspaceMemberUncheckedCreateWithoutWorkspaceInput>
  }

  export type WorkspaceMemberCreateManyWorkspaceInputEnvelope = {
    data: WorkspaceMemberCreateManyWorkspaceInput | WorkspaceMemberCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type WhiteboardCreateWithoutWorkspaceInput = {
    id?: string
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: WhiteboardVersionCreateNestedManyWithoutWhiteboardInput
  }

  export type WhiteboardUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: WhiteboardVersionUncheckedCreateNestedManyWithoutWhiteboardInput
  }

  export type WhiteboardCreateOrConnectWithoutWorkspaceInput = {
    where: WhiteboardWhereUniqueInput
    create: XOR<WhiteboardCreateWithoutWorkspaceInput, WhiteboardUncheckedCreateWithoutWorkspaceInput>
  }

  export type WhiteboardCreateManyWorkspaceInputEnvelope = {
    data: WhiteboardCreateManyWorkspaceInput | WhiteboardCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type ChatCreateWithoutWorkspaceInput = {
    id?: string
    messages?: ChatMessageCreateNestedManyWithoutChatInput
  }

  export type ChatUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    messages?: ChatMessageUncheckedCreateNestedManyWithoutChatInput
  }

  export type ChatCreateOrConnectWithoutWorkspaceInput = {
    where: ChatWhereUniqueInput
    create: XOR<ChatCreateWithoutWorkspaceInput, ChatUncheckedCreateWithoutWorkspaceInput>
  }

  export type ChatCreateManyWorkspaceInputEnvelope = {
    data: ChatCreateManyWorkspaceInput | ChatCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type BreakoutRoomCreateWithoutWorkspaceInput = {
    id?: string
    name: string
    createdAt?: Date | string
    endedAt?: Date | string | null
    participants?: WorkspaceMemberCreateNestedManyWithoutBreakoutRoomsInput
  }

  export type BreakoutRoomUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    name: string
    createdAt?: Date | string
    endedAt?: Date | string | null
    participants?: WorkspaceMemberUncheckedCreateNestedManyWithoutBreakoutRoomsInput
  }

  export type BreakoutRoomCreateOrConnectWithoutWorkspaceInput = {
    where: BreakoutRoomWhereUniqueInput
    create: XOR<BreakoutRoomCreateWithoutWorkspaceInput, BreakoutRoomUncheckedCreateWithoutWorkspaceInput>
  }

  export type BreakoutRoomCreateManyWorkspaceInputEnvelope = {
    data: BreakoutRoomCreateManyWorkspaceInput | BreakoutRoomCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type LivePollCreateWithoutWorkspaceInput = {
    id?: string
    question: string
    options: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    endedAt?: Date | string | null
    votes?: PollVoteCreateNestedManyWithoutLivePollInput
  }

  export type LivePollUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    question: string
    options: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    endedAt?: Date | string | null
    votes?: PollVoteUncheckedCreateNestedManyWithoutLivePollInput
  }

  export type LivePollCreateOrConnectWithoutWorkspaceInput = {
    where: LivePollWhereUniqueInput
    create: XOR<LivePollCreateWithoutWorkspaceInput, LivePollUncheckedCreateWithoutWorkspaceInput>
  }

  export type LivePollCreateManyWorkspaceInputEnvelope = {
    data: LivePollCreateManyWorkspaceInput | LivePollCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type SessionSummaryCreateWithoutWorkspaceInput = {
    id?: string
    content: string
    createdAt?: Date | string
    createdBy: string
  }

  export type SessionSummaryUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    content: string
    createdAt?: Date | string
    createdBy: string
  }

  export type SessionSummaryCreateOrConnectWithoutWorkspaceInput = {
    where: SessionSummaryWhereUniqueInput
    create: XOR<SessionSummaryCreateWithoutWorkspaceInput, SessionSummaryUncheckedCreateWithoutWorkspaceInput>
  }

  export type SessionSummaryCreateManyWorkspaceInputEnvelope = {
    data: SessionSummaryCreateManyWorkspaceInput | SessionSummaryCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutOwnedWorkspacesInput = {
    update: XOR<UserUpdateWithoutOwnedWorkspacesInput, UserUncheckedUpdateWithoutOwnedWorkspacesInput>
    create: XOR<UserCreateWithoutOwnedWorkspacesInput, UserUncheckedCreateWithoutOwnedWorkspacesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOwnedWorkspacesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOwnedWorkspacesInput, UserUncheckedUpdateWithoutOwnedWorkspacesInput>
  }

  export type UserUpdateWithoutOwnedWorkspacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUpdateOneWithoutUserNestedInput
    topics?: TopicUpdateManyWithoutUserNestedInput
    progress?: ProgressUpdateManyWithoutUserNestedInput
    badges?: BadgeUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOwnedWorkspacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUncheckedUpdateOneWithoutUserNestedInput
    topics?: TopicUncheckedUpdateManyWithoutUserNestedInput
    progress?: ProgressUncheckedUpdateManyWithoutUserNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUncheckedUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUncheckedUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUncheckedUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUncheckedUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUncheckedUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUncheckedUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUncheckedUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUncheckedUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUncheckedUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUncheckedUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WorkspaceMemberUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: WorkspaceMemberWhereUniqueInput
    update: XOR<WorkspaceMemberUpdateWithoutWorkspaceInput, WorkspaceMemberUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<WorkspaceMemberCreateWithoutWorkspaceInput, WorkspaceMemberUncheckedCreateWithoutWorkspaceInput>
  }

  export type WorkspaceMemberUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: WorkspaceMemberWhereUniqueInput
    data: XOR<WorkspaceMemberUpdateWithoutWorkspaceInput, WorkspaceMemberUncheckedUpdateWithoutWorkspaceInput>
  }

  export type WorkspaceMemberUpdateManyWithWhereWithoutWorkspaceInput = {
    where: WorkspaceMemberScalarWhereInput
    data: XOR<WorkspaceMemberUpdateManyMutationInput, WorkspaceMemberUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type WhiteboardUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: WhiteboardWhereUniqueInput
    update: XOR<WhiteboardUpdateWithoutWorkspaceInput, WhiteboardUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<WhiteboardCreateWithoutWorkspaceInput, WhiteboardUncheckedCreateWithoutWorkspaceInput>
  }

  export type WhiteboardUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: WhiteboardWhereUniqueInput
    data: XOR<WhiteboardUpdateWithoutWorkspaceInput, WhiteboardUncheckedUpdateWithoutWorkspaceInput>
  }

  export type WhiteboardUpdateManyWithWhereWithoutWorkspaceInput = {
    where: WhiteboardScalarWhereInput
    data: XOR<WhiteboardUpdateManyMutationInput, WhiteboardUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type WhiteboardScalarWhereInput = {
    AND?: WhiteboardScalarWhereInput | WhiteboardScalarWhereInput[]
    OR?: WhiteboardScalarWhereInput[]
    NOT?: WhiteboardScalarWhereInput | WhiteboardScalarWhereInput[]
    id?: StringFilter<"Whiteboard"> | string
    workspaceId?: StringFilter<"Whiteboard"> | string
    content?: JsonFilter<"Whiteboard">
    createdAt?: DateTimeFilter<"Whiteboard"> | Date | string
    updatedAt?: DateTimeFilter<"Whiteboard"> | Date | string
  }

  export type ChatUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: ChatWhereUniqueInput
    update: XOR<ChatUpdateWithoutWorkspaceInput, ChatUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<ChatCreateWithoutWorkspaceInput, ChatUncheckedCreateWithoutWorkspaceInput>
  }

  export type ChatUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: ChatWhereUniqueInput
    data: XOR<ChatUpdateWithoutWorkspaceInput, ChatUncheckedUpdateWithoutWorkspaceInput>
  }

  export type ChatUpdateManyWithWhereWithoutWorkspaceInput = {
    where: ChatScalarWhereInput
    data: XOR<ChatUpdateManyMutationInput, ChatUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type ChatScalarWhereInput = {
    AND?: ChatScalarWhereInput | ChatScalarWhereInput[]
    OR?: ChatScalarWhereInput[]
    NOT?: ChatScalarWhereInput | ChatScalarWhereInput[]
    id?: StringFilter<"Chat"> | string
    workspaceId?: StringFilter<"Chat"> | string
  }

  export type BreakoutRoomUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: BreakoutRoomWhereUniqueInput
    update: XOR<BreakoutRoomUpdateWithoutWorkspaceInput, BreakoutRoomUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<BreakoutRoomCreateWithoutWorkspaceInput, BreakoutRoomUncheckedCreateWithoutWorkspaceInput>
  }

  export type BreakoutRoomUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: BreakoutRoomWhereUniqueInput
    data: XOR<BreakoutRoomUpdateWithoutWorkspaceInput, BreakoutRoomUncheckedUpdateWithoutWorkspaceInput>
  }

  export type BreakoutRoomUpdateManyWithWhereWithoutWorkspaceInput = {
    where: BreakoutRoomScalarWhereInput
    data: XOR<BreakoutRoomUpdateManyMutationInput, BreakoutRoomUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type BreakoutRoomScalarWhereInput = {
    AND?: BreakoutRoomScalarWhereInput | BreakoutRoomScalarWhereInput[]
    OR?: BreakoutRoomScalarWhereInput[]
    NOT?: BreakoutRoomScalarWhereInput | BreakoutRoomScalarWhereInput[]
    id?: StringFilter<"BreakoutRoom"> | string
    workspaceId?: StringFilter<"BreakoutRoom"> | string
    name?: StringFilter<"BreakoutRoom"> | string
    createdAt?: DateTimeFilter<"BreakoutRoom"> | Date | string
    endedAt?: DateTimeNullableFilter<"BreakoutRoom"> | Date | string | null
  }

  export type LivePollUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: LivePollWhereUniqueInput
    update: XOR<LivePollUpdateWithoutWorkspaceInput, LivePollUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<LivePollCreateWithoutWorkspaceInput, LivePollUncheckedCreateWithoutWorkspaceInput>
  }

  export type LivePollUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: LivePollWhereUniqueInput
    data: XOR<LivePollUpdateWithoutWorkspaceInput, LivePollUncheckedUpdateWithoutWorkspaceInput>
  }

  export type LivePollUpdateManyWithWhereWithoutWorkspaceInput = {
    where: LivePollScalarWhereInput
    data: XOR<LivePollUpdateManyMutationInput, LivePollUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type LivePollScalarWhereInput = {
    AND?: LivePollScalarWhereInput | LivePollScalarWhereInput[]
    OR?: LivePollScalarWhereInput[]
    NOT?: LivePollScalarWhereInput | LivePollScalarWhereInput[]
    id?: StringFilter<"LivePoll"> | string
    workspaceId?: StringFilter<"LivePoll"> | string
    question?: StringFilter<"LivePoll"> | string
    options?: JsonFilter<"LivePoll">
    createdAt?: DateTimeFilter<"LivePoll"> | Date | string
    endedAt?: DateTimeNullableFilter<"LivePoll"> | Date | string | null
  }

  export type SessionSummaryUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: SessionSummaryWhereUniqueInput
    update: XOR<SessionSummaryUpdateWithoutWorkspaceInput, SessionSummaryUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<SessionSummaryCreateWithoutWorkspaceInput, SessionSummaryUncheckedCreateWithoutWorkspaceInput>
  }

  export type SessionSummaryUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: SessionSummaryWhereUniqueInput
    data: XOR<SessionSummaryUpdateWithoutWorkspaceInput, SessionSummaryUncheckedUpdateWithoutWorkspaceInput>
  }

  export type SessionSummaryUpdateManyWithWhereWithoutWorkspaceInput = {
    where: SessionSummaryScalarWhereInput
    data: XOR<SessionSummaryUpdateManyMutationInput, SessionSummaryUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type SessionSummaryScalarWhereInput = {
    AND?: SessionSummaryScalarWhereInput | SessionSummaryScalarWhereInput[]
    OR?: SessionSummaryScalarWhereInput[]
    NOT?: SessionSummaryScalarWhereInput | SessionSummaryScalarWhereInput[]
    id?: StringFilter<"SessionSummary"> | string
    workspaceId?: StringFilter<"SessionSummary"> | string
    content?: StringFilter<"SessionSummary"> | string
    createdAt?: DateTimeFilter<"SessionSummary"> | Date | string
    createdBy?: StringFilter<"SessionSummary"> | string
  }

  export type UserCreateWithoutWorkspacesInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesCreateNestedOneWithoutUserInput
    topics?: TopicCreateNestedManyWithoutUserInput
    progress?: ProgressCreateNestedManyWithoutUserInput
    badges?: BadgeCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutUserInput
    aiModules?: AIModuleCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressCreateNestedManyWithoutUserInput
    AIChat?: AIChatCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWorkspacesInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesUncheckedCreateNestedOneWithoutUserInput
    topics?: TopicUncheckedCreateNestedManyWithoutUserInput
    progress?: ProgressUncheckedCreateNestedManyWithoutUserInput
    badges?: BadgeUncheckedCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewUncheckedCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathUncheckedCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceUncheckedCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenUncheckedCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeUncheckedCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingUncheckedCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreUncheckedCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutUserInput
    aiModules?: AIModuleUncheckedCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingUncheckedCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    AIChat?: AIChatUncheckedCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWorkspacesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWorkspacesInput, UserUncheckedCreateWithoutWorkspacesInput>
  }

  export type WorkspaceCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedWorkspacesInput
    whiteboards?: WhiteboardCreateNestedManyWithoutWorkspaceInput
    chats?: ChatCreateNestedManyWithoutWorkspaceInput
    breakoutRooms?: BreakoutRoomCreateNestedManyWithoutWorkspaceInput
    livePolls?: LivePollCreateNestedManyWithoutWorkspaceInput
    sessionSummaries?: SessionSummaryCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    whiteboards?: WhiteboardUncheckedCreateNestedManyWithoutWorkspaceInput
    chats?: ChatUncheckedCreateNestedManyWithoutWorkspaceInput
    breakoutRooms?: BreakoutRoomUncheckedCreateNestedManyWithoutWorkspaceInput
    livePolls?: LivePollUncheckedCreateNestedManyWithoutWorkspaceInput
    sessionSummaries?: SessionSummaryUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutMembersInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutMembersInput, WorkspaceUncheckedCreateWithoutMembersInput>
  }

  export type BreakoutRoomCreateWithoutParticipantsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    endedAt?: Date | string | null
    workspace: WorkspaceCreateNestedOneWithoutBreakoutRoomsInput
  }

  export type BreakoutRoomUncheckedCreateWithoutParticipantsInput = {
    id?: string
    workspaceId: string
    name: string
    createdAt?: Date | string
    endedAt?: Date | string | null
  }

  export type BreakoutRoomCreateOrConnectWithoutParticipantsInput = {
    where: BreakoutRoomWhereUniqueInput
    create: XOR<BreakoutRoomCreateWithoutParticipantsInput, BreakoutRoomUncheckedCreateWithoutParticipantsInput>
  }

  export type UserUpsertWithoutWorkspacesInput = {
    update: XOR<UserUpdateWithoutWorkspacesInput, UserUncheckedUpdateWithoutWorkspacesInput>
    create: XOR<UserCreateWithoutWorkspacesInput, UserUncheckedCreateWithoutWorkspacesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWorkspacesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWorkspacesInput, UserUncheckedUpdateWithoutWorkspacesInput>
  }

  export type UserUpdateWithoutWorkspacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUpdateOneWithoutUserNestedInput
    topics?: TopicUpdateManyWithoutUserNestedInput
    progress?: ProgressUpdateManyWithoutUserNestedInput
    badges?: BadgeUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWorkspacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUncheckedUpdateOneWithoutUserNestedInput
    topics?: TopicUncheckedUpdateManyWithoutUserNestedInput
    progress?: ProgressUncheckedUpdateManyWithoutUserNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUncheckedUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUncheckedUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUncheckedUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUncheckedUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUncheckedUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUncheckedUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUncheckedUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUncheckedUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUncheckedUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUncheckedUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WorkspaceUpsertWithoutMembersInput = {
    update: XOR<WorkspaceUpdateWithoutMembersInput, WorkspaceUncheckedUpdateWithoutMembersInput>
    create: XOR<WorkspaceCreateWithoutMembersInput, WorkspaceUncheckedCreateWithoutMembersInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutMembersInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutMembersInput, WorkspaceUncheckedUpdateWithoutMembersInput>
  }

  export type WorkspaceUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedWorkspacesNestedInput
    whiteboards?: WhiteboardUpdateManyWithoutWorkspaceNestedInput
    chats?: ChatUpdateManyWithoutWorkspaceNestedInput
    breakoutRooms?: BreakoutRoomUpdateManyWithoutWorkspaceNestedInput
    livePolls?: LivePollUpdateManyWithoutWorkspaceNestedInput
    sessionSummaries?: SessionSummaryUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    whiteboards?: WhiteboardUncheckedUpdateManyWithoutWorkspaceNestedInput
    chats?: ChatUncheckedUpdateManyWithoutWorkspaceNestedInput
    breakoutRooms?: BreakoutRoomUncheckedUpdateManyWithoutWorkspaceNestedInput
    livePolls?: LivePollUncheckedUpdateManyWithoutWorkspaceNestedInput
    sessionSummaries?: SessionSummaryUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type BreakoutRoomUpsertWithWhereUniqueWithoutParticipantsInput = {
    where: BreakoutRoomWhereUniqueInput
    update: XOR<BreakoutRoomUpdateWithoutParticipantsInput, BreakoutRoomUncheckedUpdateWithoutParticipantsInput>
    create: XOR<BreakoutRoomCreateWithoutParticipantsInput, BreakoutRoomUncheckedCreateWithoutParticipantsInput>
  }

  export type BreakoutRoomUpdateWithWhereUniqueWithoutParticipantsInput = {
    where: BreakoutRoomWhereUniqueInput
    data: XOR<BreakoutRoomUpdateWithoutParticipantsInput, BreakoutRoomUncheckedUpdateWithoutParticipantsInput>
  }

  export type BreakoutRoomUpdateManyWithWhereWithoutParticipantsInput = {
    where: BreakoutRoomScalarWhereInput
    data: XOR<BreakoutRoomUpdateManyMutationInput, BreakoutRoomUncheckedUpdateManyWithoutParticipantsInput>
  }

  export type WorkspaceCreateWithoutWhiteboardsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedWorkspacesInput
    members?: WorkspaceMemberCreateNestedManyWithoutWorkspaceInput
    chats?: ChatCreateNestedManyWithoutWorkspaceInput
    breakoutRooms?: BreakoutRoomCreateNestedManyWithoutWorkspaceInput
    livePolls?: LivePollCreateNestedManyWithoutWorkspaceInput
    sessionSummaries?: SessionSummaryCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutWhiteboardsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    members?: WorkspaceMemberUncheckedCreateNestedManyWithoutWorkspaceInput
    chats?: ChatUncheckedCreateNestedManyWithoutWorkspaceInput
    breakoutRooms?: BreakoutRoomUncheckedCreateNestedManyWithoutWorkspaceInput
    livePolls?: LivePollUncheckedCreateNestedManyWithoutWorkspaceInput
    sessionSummaries?: SessionSummaryUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutWhiteboardsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutWhiteboardsInput, WorkspaceUncheckedCreateWithoutWhiteboardsInput>
  }

  export type WhiteboardVersionCreateWithoutWhiteboardInput = {
    id?: string
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy: string
    versionNumber: number
  }

  export type WhiteboardVersionUncheckedCreateWithoutWhiteboardInput = {
    id?: string
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy: string
    versionNumber: number
  }

  export type WhiteboardVersionCreateOrConnectWithoutWhiteboardInput = {
    where: WhiteboardVersionWhereUniqueInput
    create: XOR<WhiteboardVersionCreateWithoutWhiteboardInput, WhiteboardVersionUncheckedCreateWithoutWhiteboardInput>
  }

  export type WhiteboardVersionCreateManyWhiteboardInputEnvelope = {
    data: WhiteboardVersionCreateManyWhiteboardInput | WhiteboardVersionCreateManyWhiteboardInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceUpsertWithoutWhiteboardsInput = {
    update: XOR<WorkspaceUpdateWithoutWhiteboardsInput, WorkspaceUncheckedUpdateWithoutWhiteboardsInput>
    create: XOR<WorkspaceCreateWithoutWhiteboardsInput, WorkspaceUncheckedCreateWithoutWhiteboardsInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutWhiteboardsInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutWhiteboardsInput, WorkspaceUncheckedUpdateWithoutWhiteboardsInput>
  }

  export type WorkspaceUpdateWithoutWhiteboardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedWorkspacesNestedInput
    members?: WorkspaceMemberUpdateManyWithoutWorkspaceNestedInput
    chats?: ChatUpdateManyWithoutWorkspaceNestedInput
    breakoutRooms?: BreakoutRoomUpdateManyWithoutWorkspaceNestedInput
    livePolls?: LivePollUpdateManyWithoutWorkspaceNestedInput
    sessionSummaries?: SessionSummaryUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutWhiteboardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    members?: WorkspaceMemberUncheckedUpdateManyWithoutWorkspaceNestedInput
    chats?: ChatUncheckedUpdateManyWithoutWorkspaceNestedInput
    breakoutRooms?: BreakoutRoomUncheckedUpdateManyWithoutWorkspaceNestedInput
    livePolls?: LivePollUncheckedUpdateManyWithoutWorkspaceNestedInput
    sessionSummaries?: SessionSummaryUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type WhiteboardVersionUpsertWithWhereUniqueWithoutWhiteboardInput = {
    where: WhiteboardVersionWhereUniqueInput
    update: XOR<WhiteboardVersionUpdateWithoutWhiteboardInput, WhiteboardVersionUncheckedUpdateWithoutWhiteboardInput>
    create: XOR<WhiteboardVersionCreateWithoutWhiteboardInput, WhiteboardVersionUncheckedCreateWithoutWhiteboardInput>
  }

  export type WhiteboardVersionUpdateWithWhereUniqueWithoutWhiteboardInput = {
    where: WhiteboardVersionWhereUniqueInput
    data: XOR<WhiteboardVersionUpdateWithoutWhiteboardInput, WhiteboardVersionUncheckedUpdateWithoutWhiteboardInput>
  }

  export type WhiteboardVersionUpdateManyWithWhereWithoutWhiteboardInput = {
    where: WhiteboardVersionScalarWhereInput
    data: XOR<WhiteboardVersionUpdateManyMutationInput, WhiteboardVersionUncheckedUpdateManyWithoutWhiteboardInput>
  }

  export type WhiteboardVersionScalarWhereInput = {
    AND?: WhiteboardVersionScalarWhereInput | WhiteboardVersionScalarWhereInput[]
    OR?: WhiteboardVersionScalarWhereInput[]
    NOT?: WhiteboardVersionScalarWhereInput | WhiteboardVersionScalarWhereInput[]
    id?: StringFilter<"WhiteboardVersion"> | string
    whiteboardId?: StringFilter<"WhiteboardVersion"> | string
    content?: JsonFilter<"WhiteboardVersion">
    createdAt?: DateTimeFilter<"WhiteboardVersion"> | Date | string
    createdBy?: StringFilter<"WhiteboardVersion"> | string
    versionNumber?: IntFilter<"WhiteboardVersion"> | number
  }

  export type WhiteboardCreateWithoutVersionsInput = {
    id?: string
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutWhiteboardsInput
  }

  export type WhiteboardUncheckedCreateWithoutVersionsInput = {
    id?: string
    workspaceId: string
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhiteboardCreateOrConnectWithoutVersionsInput = {
    where: WhiteboardWhereUniqueInput
    create: XOR<WhiteboardCreateWithoutVersionsInput, WhiteboardUncheckedCreateWithoutVersionsInput>
  }

  export type WhiteboardUpsertWithoutVersionsInput = {
    update: XOR<WhiteboardUpdateWithoutVersionsInput, WhiteboardUncheckedUpdateWithoutVersionsInput>
    create: XOR<WhiteboardCreateWithoutVersionsInput, WhiteboardUncheckedCreateWithoutVersionsInput>
    where?: WhiteboardWhereInput
  }

  export type WhiteboardUpdateToOneWithWhereWithoutVersionsInput = {
    where?: WhiteboardWhereInput
    data: XOR<WhiteboardUpdateWithoutVersionsInput, WhiteboardUncheckedUpdateWithoutVersionsInput>
  }

  export type WhiteboardUpdateWithoutVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutWhiteboardsNestedInput
  }

  export type WhiteboardUncheckedUpdateWithoutVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceCreateWithoutBreakoutRoomsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedWorkspacesInput
    members?: WorkspaceMemberCreateNestedManyWithoutWorkspaceInput
    whiteboards?: WhiteboardCreateNestedManyWithoutWorkspaceInput
    chats?: ChatCreateNestedManyWithoutWorkspaceInput
    livePolls?: LivePollCreateNestedManyWithoutWorkspaceInput
    sessionSummaries?: SessionSummaryCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutBreakoutRoomsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    members?: WorkspaceMemberUncheckedCreateNestedManyWithoutWorkspaceInput
    whiteboards?: WhiteboardUncheckedCreateNestedManyWithoutWorkspaceInput
    chats?: ChatUncheckedCreateNestedManyWithoutWorkspaceInput
    livePolls?: LivePollUncheckedCreateNestedManyWithoutWorkspaceInput
    sessionSummaries?: SessionSummaryUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutBreakoutRoomsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutBreakoutRoomsInput, WorkspaceUncheckedCreateWithoutBreakoutRoomsInput>
  }

  export type WorkspaceMemberCreateWithoutBreakoutRoomsInput = {
    id?: string
    role: string
    joinedAt?: Date | string
    user: UserCreateNestedOneWithoutWorkspacesInput
    workspace: WorkspaceCreateNestedOneWithoutMembersInput
  }

  export type WorkspaceMemberUncheckedCreateWithoutBreakoutRoomsInput = {
    id?: string
    userId: string
    workspaceId: string
    role: string
    joinedAt?: Date | string
  }

  export type WorkspaceMemberCreateOrConnectWithoutBreakoutRoomsInput = {
    where: WorkspaceMemberWhereUniqueInput
    create: XOR<WorkspaceMemberCreateWithoutBreakoutRoomsInput, WorkspaceMemberUncheckedCreateWithoutBreakoutRoomsInput>
  }

  export type WorkspaceUpsertWithoutBreakoutRoomsInput = {
    update: XOR<WorkspaceUpdateWithoutBreakoutRoomsInput, WorkspaceUncheckedUpdateWithoutBreakoutRoomsInput>
    create: XOR<WorkspaceCreateWithoutBreakoutRoomsInput, WorkspaceUncheckedCreateWithoutBreakoutRoomsInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutBreakoutRoomsInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutBreakoutRoomsInput, WorkspaceUncheckedUpdateWithoutBreakoutRoomsInput>
  }

  export type WorkspaceUpdateWithoutBreakoutRoomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedWorkspacesNestedInput
    members?: WorkspaceMemberUpdateManyWithoutWorkspaceNestedInput
    whiteboards?: WhiteboardUpdateManyWithoutWorkspaceNestedInput
    chats?: ChatUpdateManyWithoutWorkspaceNestedInput
    livePolls?: LivePollUpdateManyWithoutWorkspaceNestedInput
    sessionSummaries?: SessionSummaryUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutBreakoutRoomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    members?: WorkspaceMemberUncheckedUpdateManyWithoutWorkspaceNestedInput
    whiteboards?: WhiteboardUncheckedUpdateManyWithoutWorkspaceNestedInput
    chats?: ChatUncheckedUpdateManyWithoutWorkspaceNestedInput
    livePolls?: LivePollUncheckedUpdateManyWithoutWorkspaceNestedInput
    sessionSummaries?: SessionSummaryUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceMemberUpsertWithWhereUniqueWithoutBreakoutRoomsInput = {
    where: WorkspaceMemberWhereUniqueInput
    update: XOR<WorkspaceMemberUpdateWithoutBreakoutRoomsInput, WorkspaceMemberUncheckedUpdateWithoutBreakoutRoomsInput>
    create: XOR<WorkspaceMemberCreateWithoutBreakoutRoomsInput, WorkspaceMemberUncheckedCreateWithoutBreakoutRoomsInput>
  }

  export type WorkspaceMemberUpdateWithWhereUniqueWithoutBreakoutRoomsInput = {
    where: WorkspaceMemberWhereUniqueInput
    data: XOR<WorkspaceMemberUpdateWithoutBreakoutRoomsInput, WorkspaceMemberUncheckedUpdateWithoutBreakoutRoomsInput>
  }

  export type WorkspaceMemberUpdateManyWithWhereWithoutBreakoutRoomsInput = {
    where: WorkspaceMemberScalarWhereInput
    data: XOR<WorkspaceMemberUpdateManyMutationInput, WorkspaceMemberUncheckedUpdateManyWithoutBreakoutRoomsInput>
  }

  export type WorkspaceCreateWithoutLivePollsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedWorkspacesInput
    members?: WorkspaceMemberCreateNestedManyWithoutWorkspaceInput
    whiteboards?: WhiteboardCreateNestedManyWithoutWorkspaceInput
    chats?: ChatCreateNestedManyWithoutWorkspaceInput
    breakoutRooms?: BreakoutRoomCreateNestedManyWithoutWorkspaceInput
    sessionSummaries?: SessionSummaryCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutLivePollsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    members?: WorkspaceMemberUncheckedCreateNestedManyWithoutWorkspaceInput
    whiteboards?: WhiteboardUncheckedCreateNestedManyWithoutWorkspaceInput
    chats?: ChatUncheckedCreateNestedManyWithoutWorkspaceInput
    breakoutRooms?: BreakoutRoomUncheckedCreateNestedManyWithoutWorkspaceInput
    sessionSummaries?: SessionSummaryUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutLivePollsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutLivePollsInput, WorkspaceUncheckedCreateWithoutLivePollsInput>
  }

  export type PollVoteCreateWithoutLivePollInput = {
    id?: string
    option: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutPollVotesInput
  }

  export type PollVoteUncheckedCreateWithoutLivePollInput = {
    id?: string
    userId: string
    option: string
    createdAt?: Date | string
  }

  export type PollVoteCreateOrConnectWithoutLivePollInput = {
    where: PollVoteWhereUniqueInput
    create: XOR<PollVoteCreateWithoutLivePollInput, PollVoteUncheckedCreateWithoutLivePollInput>
  }

  export type PollVoteCreateManyLivePollInputEnvelope = {
    data: PollVoteCreateManyLivePollInput | PollVoteCreateManyLivePollInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceUpsertWithoutLivePollsInput = {
    update: XOR<WorkspaceUpdateWithoutLivePollsInput, WorkspaceUncheckedUpdateWithoutLivePollsInput>
    create: XOR<WorkspaceCreateWithoutLivePollsInput, WorkspaceUncheckedCreateWithoutLivePollsInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutLivePollsInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutLivePollsInput, WorkspaceUncheckedUpdateWithoutLivePollsInput>
  }

  export type WorkspaceUpdateWithoutLivePollsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedWorkspacesNestedInput
    members?: WorkspaceMemberUpdateManyWithoutWorkspaceNestedInput
    whiteboards?: WhiteboardUpdateManyWithoutWorkspaceNestedInput
    chats?: ChatUpdateManyWithoutWorkspaceNestedInput
    breakoutRooms?: BreakoutRoomUpdateManyWithoutWorkspaceNestedInput
    sessionSummaries?: SessionSummaryUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutLivePollsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    members?: WorkspaceMemberUncheckedUpdateManyWithoutWorkspaceNestedInput
    whiteboards?: WhiteboardUncheckedUpdateManyWithoutWorkspaceNestedInput
    chats?: ChatUncheckedUpdateManyWithoutWorkspaceNestedInput
    breakoutRooms?: BreakoutRoomUncheckedUpdateManyWithoutWorkspaceNestedInput
    sessionSummaries?: SessionSummaryUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type PollVoteUpsertWithWhereUniqueWithoutLivePollInput = {
    where: PollVoteWhereUniqueInput
    update: XOR<PollVoteUpdateWithoutLivePollInput, PollVoteUncheckedUpdateWithoutLivePollInput>
    create: XOR<PollVoteCreateWithoutLivePollInput, PollVoteUncheckedCreateWithoutLivePollInput>
  }

  export type PollVoteUpdateWithWhereUniqueWithoutLivePollInput = {
    where: PollVoteWhereUniqueInput
    data: XOR<PollVoteUpdateWithoutLivePollInput, PollVoteUncheckedUpdateWithoutLivePollInput>
  }

  export type PollVoteUpdateManyWithWhereWithoutLivePollInput = {
    where: PollVoteScalarWhereInput
    data: XOR<PollVoteUpdateManyMutationInput, PollVoteUncheckedUpdateManyWithoutLivePollInput>
  }

  export type LivePollCreateWithoutVotesInput = {
    id?: string
    question: string
    options: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    endedAt?: Date | string | null
    workspace: WorkspaceCreateNestedOneWithoutLivePollsInput
  }

  export type LivePollUncheckedCreateWithoutVotesInput = {
    id?: string
    workspaceId: string
    question: string
    options: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    endedAt?: Date | string | null
  }

  export type LivePollCreateOrConnectWithoutVotesInput = {
    where: LivePollWhereUniqueInput
    create: XOR<LivePollCreateWithoutVotesInput, LivePollUncheckedCreateWithoutVotesInput>
  }

  export type UserCreateWithoutPollVotesInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesCreateNestedOneWithoutUserInput
    topics?: TopicCreateNestedManyWithoutUserInput
    progress?: ProgressCreateNestedManyWithoutUserInput
    badges?: BadgeCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutUserInput
    aiModules?: AIModuleCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressCreateNestedManyWithoutUserInput
    AIChat?: AIChatCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPollVotesInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesUncheckedCreateNestedOneWithoutUserInput
    topics?: TopicUncheckedCreateNestedManyWithoutUserInput
    progress?: ProgressUncheckedCreateNestedManyWithoutUserInput
    badges?: BadgeUncheckedCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewUncheckedCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathUncheckedCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionUncheckedCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceUncheckedCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenUncheckedCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeUncheckedCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingUncheckedCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreUncheckedCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutUserInput
    aiModules?: AIModuleUncheckedCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingUncheckedCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    AIChat?: AIChatUncheckedCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPollVotesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPollVotesInput, UserUncheckedCreateWithoutPollVotesInput>
  }

  export type LivePollUpsertWithoutVotesInput = {
    update: XOR<LivePollUpdateWithoutVotesInput, LivePollUncheckedUpdateWithoutVotesInput>
    create: XOR<LivePollCreateWithoutVotesInput, LivePollUncheckedCreateWithoutVotesInput>
    where?: LivePollWhereInput
  }

  export type LivePollUpdateToOneWithWhereWithoutVotesInput = {
    where?: LivePollWhereInput
    data: XOR<LivePollUpdateWithoutVotesInput, LivePollUncheckedUpdateWithoutVotesInput>
  }

  export type LivePollUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workspace?: WorkspaceUpdateOneRequiredWithoutLivePollsNestedInput
  }

  export type LivePollUncheckedUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUpsertWithoutPollVotesInput = {
    update: XOR<UserUpdateWithoutPollVotesInput, UserUncheckedUpdateWithoutPollVotesInput>
    create: XOR<UserCreateWithoutPollVotesInput, UserUncheckedCreateWithoutPollVotesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPollVotesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPollVotesInput, UserUncheckedUpdateWithoutPollVotesInput>
  }

  export type UserUpdateWithoutPollVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUpdateOneWithoutUserNestedInput
    topics?: TopicUpdateManyWithoutUserNestedInput
    progress?: ProgressUpdateManyWithoutUserNestedInput
    badges?: BadgeUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPollVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUncheckedUpdateOneWithoutUserNestedInput
    topics?: TopicUncheckedUpdateManyWithoutUserNestedInput
    progress?: ProgressUncheckedUpdateManyWithoutUserNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUncheckedUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUncheckedUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUncheckedUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUncheckedUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUncheckedUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUncheckedUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUncheckedUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUncheckedUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUncheckedUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUncheckedUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUncheckedUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WorkspaceCreateWithoutSessionSummariesInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedWorkspacesInput
    members?: WorkspaceMemberCreateNestedManyWithoutWorkspaceInput
    whiteboards?: WhiteboardCreateNestedManyWithoutWorkspaceInput
    chats?: ChatCreateNestedManyWithoutWorkspaceInput
    breakoutRooms?: BreakoutRoomCreateNestedManyWithoutWorkspaceInput
    livePolls?: LivePollCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutSessionSummariesInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    members?: WorkspaceMemberUncheckedCreateNestedManyWithoutWorkspaceInput
    whiteboards?: WhiteboardUncheckedCreateNestedManyWithoutWorkspaceInput
    chats?: ChatUncheckedCreateNestedManyWithoutWorkspaceInput
    breakoutRooms?: BreakoutRoomUncheckedCreateNestedManyWithoutWorkspaceInput
    livePolls?: LivePollUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutSessionSummariesInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutSessionSummariesInput, WorkspaceUncheckedCreateWithoutSessionSummariesInput>
  }

  export type WorkspaceUpsertWithoutSessionSummariesInput = {
    update: XOR<WorkspaceUpdateWithoutSessionSummariesInput, WorkspaceUncheckedUpdateWithoutSessionSummariesInput>
    create: XOR<WorkspaceCreateWithoutSessionSummariesInput, WorkspaceUncheckedCreateWithoutSessionSummariesInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutSessionSummariesInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutSessionSummariesInput, WorkspaceUncheckedUpdateWithoutSessionSummariesInput>
  }

  export type WorkspaceUpdateWithoutSessionSummariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedWorkspacesNestedInput
    members?: WorkspaceMemberUpdateManyWithoutWorkspaceNestedInput
    whiteboards?: WhiteboardUpdateManyWithoutWorkspaceNestedInput
    chats?: ChatUpdateManyWithoutWorkspaceNestedInput
    breakoutRooms?: BreakoutRoomUpdateManyWithoutWorkspaceNestedInput
    livePolls?: LivePollUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutSessionSummariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    members?: WorkspaceMemberUncheckedUpdateManyWithoutWorkspaceNestedInput
    whiteboards?: WhiteboardUncheckedUpdateManyWithoutWorkspaceNestedInput
    chats?: ChatUncheckedUpdateManyWithoutWorkspaceNestedInput
    breakoutRooms?: BreakoutRoomUncheckedUpdateManyWithoutWorkspaceNestedInput
    livePolls?: LivePollUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceCreateWithoutChatsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedWorkspacesInput
    members?: WorkspaceMemberCreateNestedManyWithoutWorkspaceInput
    whiteboards?: WhiteboardCreateNestedManyWithoutWorkspaceInput
    breakoutRooms?: BreakoutRoomCreateNestedManyWithoutWorkspaceInput
    livePolls?: LivePollCreateNestedManyWithoutWorkspaceInput
    sessionSummaries?: SessionSummaryCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutChatsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    members?: WorkspaceMemberUncheckedCreateNestedManyWithoutWorkspaceInput
    whiteboards?: WhiteboardUncheckedCreateNestedManyWithoutWorkspaceInput
    breakoutRooms?: BreakoutRoomUncheckedCreateNestedManyWithoutWorkspaceInput
    livePolls?: LivePollUncheckedCreateNestedManyWithoutWorkspaceInput
    sessionSummaries?: SessionSummaryUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutChatsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutChatsInput, WorkspaceUncheckedCreateWithoutChatsInput>
  }

  export type ChatMessageCreateWithoutChatInput = {
    id?: string
    content: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutChatMessagesInput
  }

  export type ChatMessageUncheckedCreateWithoutChatInput = {
    id?: string
    userId: string
    content: string
    createdAt?: Date | string
  }

  export type ChatMessageCreateOrConnectWithoutChatInput = {
    where: ChatMessageWhereUniqueInput
    create: XOR<ChatMessageCreateWithoutChatInput, ChatMessageUncheckedCreateWithoutChatInput>
  }

  export type ChatMessageCreateManyChatInputEnvelope = {
    data: ChatMessageCreateManyChatInput | ChatMessageCreateManyChatInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceUpsertWithoutChatsInput = {
    update: XOR<WorkspaceUpdateWithoutChatsInput, WorkspaceUncheckedUpdateWithoutChatsInput>
    create: XOR<WorkspaceCreateWithoutChatsInput, WorkspaceUncheckedCreateWithoutChatsInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutChatsInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutChatsInput, WorkspaceUncheckedUpdateWithoutChatsInput>
  }

  export type WorkspaceUpdateWithoutChatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedWorkspacesNestedInput
    members?: WorkspaceMemberUpdateManyWithoutWorkspaceNestedInput
    whiteboards?: WhiteboardUpdateManyWithoutWorkspaceNestedInput
    breakoutRooms?: BreakoutRoomUpdateManyWithoutWorkspaceNestedInput
    livePolls?: LivePollUpdateManyWithoutWorkspaceNestedInput
    sessionSummaries?: SessionSummaryUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutChatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    members?: WorkspaceMemberUncheckedUpdateManyWithoutWorkspaceNestedInput
    whiteboards?: WhiteboardUncheckedUpdateManyWithoutWorkspaceNestedInput
    breakoutRooms?: BreakoutRoomUncheckedUpdateManyWithoutWorkspaceNestedInput
    livePolls?: LivePollUncheckedUpdateManyWithoutWorkspaceNestedInput
    sessionSummaries?: SessionSummaryUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type ChatMessageUpsertWithWhereUniqueWithoutChatInput = {
    where: ChatMessageWhereUniqueInput
    update: XOR<ChatMessageUpdateWithoutChatInput, ChatMessageUncheckedUpdateWithoutChatInput>
    create: XOR<ChatMessageCreateWithoutChatInput, ChatMessageUncheckedCreateWithoutChatInput>
  }

  export type ChatMessageUpdateWithWhereUniqueWithoutChatInput = {
    where: ChatMessageWhereUniqueInput
    data: XOR<ChatMessageUpdateWithoutChatInput, ChatMessageUncheckedUpdateWithoutChatInput>
  }

  export type ChatMessageUpdateManyWithWhereWithoutChatInput = {
    where: ChatMessageScalarWhereInput
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyWithoutChatInput>
  }

  export type ChatCreateWithoutMessagesInput = {
    id?: string
    workspace: WorkspaceCreateNestedOneWithoutChatsInput
  }

  export type ChatUncheckedCreateWithoutMessagesInput = {
    id?: string
    workspaceId: string
  }

  export type ChatCreateOrConnectWithoutMessagesInput = {
    where: ChatWhereUniqueInput
    create: XOR<ChatCreateWithoutMessagesInput, ChatUncheckedCreateWithoutMessagesInput>
  }

  export type UserCreateWithoutChatMessagesInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesCreateNestedOneWithoutUserInput
    topics?: TopicCreateNestedManyWithoutUserInput
    progress?: ProgressCreateNestedManyWithoutUserInput
    badges?: BadgeCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutUserInput
    aiModules?: AIModuleCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressCreateNestedManyWithoutUserInput
    AIChat?: AIChatCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutChatMessagesInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesUncheckedCreateNestedOneWithoutUserInput
    topics?: TopicUncheckedCreateNestedManyWithoutUserInput
    progress?: ProgressUncheckedCreateNestedManyWithoutUserInput
    badges?: BadgeUncheckedCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewUncheckedCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathUncheckedCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionUncheckedCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberUncheckedCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceUncheckedCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenUncheckedCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeUncheckedCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingUncheckedCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreUncheckedCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutUserInput
    aiModules?: AIModuleUncheckedCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingUncheckedCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    AIChat?: AIChatUncheckedCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutChatMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChatMessagesInput, UserUncheckedCreateWithoutChatMessagesInput>
  }

  export type ChatUpsertWithoutMessagesInput = {
    update: XOR<ChatUpdateWithoutMessagesInput, ChatUncheckedUpdateWithoutMessagesInput>
    create: XOR<ChatCreateWithoutMessagesInput, ChatUncheckedCreateWithoutMessagesInput>
    where?: ChatWhereInput
  }

  export type ChatUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ChatWhereInput
    data: XOR<ChatUpdateWithoutMessagesInput, ChatUncheckedUpdateWithoutMessagesInput>
  }

  export type ChatUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspace?: WorkspaceUpdateOneRequiredWithoutChatsNestedInput
  }

  export type ChatUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
  }

  export type UserUpsertWithoutChatMessagesInput = {
    update: XOR<UserUpdateWithoutChatMessagesInput, UserUncheckedUpdateWithoutChatMessagesInput>
    create: XOR<UserCreateWithoutChatMessagesInput, UserUncheckedCreateWithoutChatMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChatMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChatMessagesInput, UserUncheckedUpdateWithoutChatMessagesInput>
  }

  export type UserUpdateWithoutChatMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUpdateOneWithoutUserNestedInput
    topics?: TopicUpdateManyWithoutUserNestedInput
    progress?: ProgressUpdateManyWithoutUserNestedInput
    badges?: BadgeUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutChatMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUncheckedUpdateOneWithoutUserNestedInput
    topics?: TopicUncheckedUpdateManyWithoutUserNestedInput
    progress?: ProgressUncheckedUpdateManyWithoutUserNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUncheckedUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUncheckedUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUncheckedUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUncheckedUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUncheckedUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUncheckedUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUncheckedUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUncheckedUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUncheckedUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUncheckedUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUncheckedUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUncheckedUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSettingsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesCreateNestedOneWithoutUserInput
    topics?: TopicCreateNestedManyWithoutUserInput
    progress?: ProgressCreateNestedManyWithoutUserInput
    badges?: BadgeCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceCreateNestedManyWithoutOwnerInput
    analyticsEntries?: AnalyticsEntryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutUserInput
    aiModules?: AIModuleCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressCreateNestedManyWithoutUserInput
    AIChat?: AIChatCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSettingsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesUncheckedCreateNestedOneWithoutUserInput
    topics?: TopicUncheckedCreateNestedManyWithoutUserInput
    progress?: ProgressUncheckedCreateNestedManyWithoutUserInput
    badges?: BadgeUncheckedCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewUncheckedCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathUncheckedCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionUncheckedCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceUncheckedCreateNestedManyWithoutOwnerInput
    analyticsEntries?: AnalyticsEntryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenUncheckedCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeUncheckedCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingUncheckedCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreUncheckedCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutUserInput
    aiModules?: AIModuleUncheckedCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingUncheckedCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    AIChat?: AIChatUncheckedCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSettingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSettingsInput, UserUncheckedCreateWithoutSettingsInput>
  }

  export type UserUpsertWithoutSettingsInput = {
    update: XOR<UserUpdateWithoutSettingsInput, UserUncheckedUpdateWithoutSettingsInput>
    create: XOR<UserCreateWithoutSettingsInput, UserUncheckedCreateWithoutSettingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSettingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSettingsInput, UserUncheckedUpdateWithoutSettingsInput>
  }

  export type UserUpdateWithoutSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUpdateOneWithoutUserNestedInput
    topics?: TopicUpdateManyWithoutUserNestedInput
    progress?: ProgressUpdateManyWithoutUserNestedInput
    badges?: BadgeUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUpdateManyWithoutOwnerNestedInput
    analyticsEntries?: AnalyticsEntryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUncheckedUpdateOneWithoutUserNestedInput
    topics?: TopicUncheckedUpdateManyWithoutUserNestedInput
    progress?: ProgressUncheckedUpdateManyWithoutUserNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUncheckedUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUncheckedUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUncheckedUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUncheckedUpdateManyWithoutOwnerNestedInput
    analyticsEntries?: AnalyticsEntryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUncheckedUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUncheckedUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUncheckedUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUncheckedUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUncheckedUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUncheckedUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUncheckedUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAnalyticsEntriesInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesCreateNestedOneWithoutUserInput
    topics?: TopicCreateNestedManyWithoutUserInput
    progress?: ProgressCreateNestedManyWithoutUserInput
    badges?: BadgeCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutUserInput
    aiModules?: AIModuleCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressCreateNestedManyWithoutUserInput
    AIChat?: AIChatCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAnalyticsEntriesInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesUncheckedCreateNestedOneWithoutUserInput
    topics?: TopicUncheckedCreateNestedManyWithoutUserInput
    progress?: ProgressUncheckedCreateNestedManyWithoutUserInput
    badges?: BadgeUncheckedCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewUncheckedCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathUncheckedCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionUncheckedCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceUncheckedCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenUncheckedCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeUncheckedCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingUncheckedCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreUncheckedCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutUserInput
    aiModules?: AIModuleUncheckedCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingUncheckedCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    AIChat?: AIChatUncheckedCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAnalyticsEntriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAnalyticsEntriesInput, UserUncheckedCreateWithoutAnalyticsEntriesInput>
  }

  export type TopicCreateWithoutAnalyticsEntriesInput = {
    id?: string
    title: string
    description?: string | null
    user: UserCreateNestedOneWithoutTopicsInput
    progress?: ProgressCreateNestedManyWithoutTopicInput
    learningPathItems?: LearningPathItemCreateNestedManyWithoutTopicInput
    contentItems?: ContentItemCreateNestedManyWithoutTopicInput
    comments?: CommentCreateNestedManyWithoutTopicInput
    prerequisites?: PrerequisiteCreateNestedManyWithoutTopicInput
    aiModules?: AIModuleCreateNestedManyWithoutTopicInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptCreateNestedManyWithoutTopicInput
    aiModuleRatings?: AIModuleRatingCreateNestedManyWithoutTopicInput
  }

  export type TopicUncheckedCreateWithoutAnalyticsEntriesInput = {
    id?: string
    title: string
    description?: string | null
    userId: string
    progress?: ProgressUncheckedCreateNestedManyWithoutTopicInput
    learningPathItems?: LearningPathItemUncheckedCreateNestedManyWithoutTopicInput
    contentItems?: ContentItemUncheckedCreateNestedManyWithoutTopicInput
    comments?: CommentUncheckedCreateNestedManyWithoutTopicInput
    prerequisites?: PrerequisiteUncheckedCreateNestedManyWithoutTopicInput
    aiModules?: AIModuleUncheckedCreateNestedManyWithoutTopicInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedCreateNestedManyWithoutTopicInput
    aiModuleRatings?: AIModuleRatingUncheckedCreateNestedManyWithoutTopicInput
  }

  export type TopicCreateOrConnectWithoutAnalyticsEntriesInput = {
    where: TopicWhereUniqueInput
    create: XOR<TopicCreateWithoutAnalyticsEntriesInput, TopicUncheckedCreateWithoutAnalyticsEntriesInput>
  }

  export type UserUpsertWithoutAnalyticsEntriesInput = {
    update: XOR<UserUpdateWithoutAnalyticsEntriesInput, UserUncheckedUpdateWithoutAnalyticsEntriesInput>
    create: XOR<UserCreateWithoutAnalyticsEntriesInput, UserUncheckedCreateWithoutAnalyticsEntriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAnalyticsEntriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAnalyticsEntriesInput, UserUncheckedUpdateWithoutAnalyticsEntriesInput>
  }

  export type UserUpdateWithoutAnalyticsEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUpdateOneWithoutUserNestedInput
    topics?: TopicUpdateManyWithoutUserNestedInput
    progress?: ProgressUpdateManyWithoutUserNestedInput
    badges?: BadgeUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAnalyticsEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUncheckedUpdateOneWithoutUserNestedInput
    topics?: TopicUncheckedUpdateManyWithoutUserNestedInput
    progress?: ProgressUncheckedUpdateManyWithoutUserNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUncheckedUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUncheckedUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUncheckedUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUncheckedUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUncheckedUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUncheckedUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUncheckedUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUncheckedUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUncheckedUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUncheckedUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUncheckedUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TopicUpsertWithoutAnalyticsEntriesInput = {
    update: XOR<TopicUpdateWithoutAnalyticsEntriesInput, TopicUncheckedUpdateWithoutAnalyticsEntriesInput>
    create: XOR<TopicCreateWithoutAnalyticsEntriesInput, TopicUncheckedCreateWithoutAnalyticsEntriesInput>
    where?: TopicWhereInput
  }

  export type TopicUpdateToOneWithWhereWithoutAnalyticsEntriesInput = {
    where?: TopicWhereInput
    data: XOR<TopicUpdateWithoutAnalyticsEntriesInput, TopicUncheckedUpdateWithoutAnalyticsEntriesInput>
  }

  export type TopicUpdateWithoutAnalyticsEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutTopicsNestedInput
    progress?: ProgressUpdateManyWithoutTopicNestedInput
    learningPathItems?: LearningPathItemUpdateManyWithoutTopicNestedInput
    contentItems?: ContentItemUpdateManyWithoutTopicNestedInput
    comments?: CommentUpdateManyWithoutTopicNestedInput
    prerequisites?: PrerequisiteUpdateManyWithoutTopicNestedInput
    aiModules?: AIModuleUpdateManyWithoutTopicNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUpdateManyWithoutTopicNestedInput
    aiModuleRatings?: AIModuleRatingUpdateManyWithoutTopicNestedInput
  }

  export type TopicUncheckedUpdateWithoutAnalyticsEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    progress?: ProgressUncheckedUpdateManyWithoutTopicNestedInput
    learningPathItems?: LearningPathItemUncheckedUpdateManyWithoutTopicNestedInput
    contentItems?: ContentItemUncheckedUpdateManyWithoutTopicNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTopicNestedInput
    prerequisites?: PrerequisiteUncheckedUpdateManyWithoutTopicNestedInput
    aiModules?: AIModuleUncheckedUpdateManyWithoutTopicNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedUpdateManyWithoutTopicNestedInput
    aiModuleRatings?: AIModuleRatingUncheckedUpdateManyWithoutTopicNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesCreateNestedOneWithoutUserInput
    topics?: TopicCreateNestedManyWithoutUserInput
    progress?: ProgressCreateNestedManyWithoutUserInput
    badges?: BadgeCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutUserInput
    aiModules?: AIModuleCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressCreateNestedManyWithoutUserInput
    AIChat?: AIChatCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesUncheckedCreateNestedOneWithoutUserInput
    topics?: TopicUncheckedCreateNestedManyWithoutUserInput
    progress?: ProgressUncheckedCreateNestedManyWithoutUserInput
    badges?: BadgeUncheckedCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewUncheckedCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathUncheckedCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionUncheckedCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceUncheckedCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryUncheckedCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenUncheckedCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeUncheckedCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingUncheckedCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreUncheckedCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutUserInput
    aiModules?: AIModuleUncheckedCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingUncheckedCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    AIChat?: AIChatUncheckedCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUpdateOneWithoutUserNestedInput
    topics?: TopicUpdateManyWithoutUserNestedInput
    progress?: ProgressUpdateManyWithoutUserNestedInput
    badges?: BadgeUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUncheckedUpdateOneWithoutUserNestedInput
    topics?: TopicUncheckedUpdateManyWithoutUserNestedInput
    progress?: ProgressUncheckedUpdateManyWithoutUserNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUncheckedUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUncheckedUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUncheckedUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUncheckedUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUncheckedUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUncheckedUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUncheckedUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUncheckedUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUncheckedUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUncheckedUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUncheckedUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUncheckedUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPasswordlessTokensInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesCreateNestedOneWithoutUserInput
    topics?: TopicCreateNestedManyWithoutUserInput
    progress?: ProgressCreateNestedManyWithoutUserInput
    badges?: BadgeCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutUserInput
    aiModules?: AIModuleCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressCreateNestedManyWithoutUserInput
    AIChat?: AIChatCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPasswordlessTokensInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesUncheckedCreateNestedOneWithoutUserInput
    topics?: TopicUncheckedCreateNestedManyWithoutUserInput
    progress?: ProgressUncheckedCreateNestedManyWithoutUserInput
    badges?: BadgeUncheckedCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewUncheckedCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathUncheckedCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionUncheckedCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceUncheckedCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeUncheckedCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingUncheckedCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreUncheckedCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutUserInput
    aiModules?: AIModuleUncheckedCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingUncheckedCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    AIChat?: AIChatUncheckedCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPasswordlessTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPasswordlessTokensInput, UserUncheckedCreateWithoutPasswordlessTokensInput>
  }

  export type UserUpsertWithoutPasswordlessTokensInput = {
    update: XOR<UserUpdateWithoutPasswordlessTokensInput, UserUncheckedUpdateWithoutPasswordlessTokensInput>
    create: XOR<UserCreateWithoutPasswordlessTokensInput, UserUncheckedCreateWithoutPasswordlessTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPasswordlessTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPasswordlessTokensInput, UserUncheckedUpdateWithoutPasswordlessTokensInput>
  }

  export type UserUpdateWithoutPasswordlessTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUpdateOneWithoutUserNestedInput
    topics?: TopicUpdateManyWithoutUserNestedInput
    progress?: ProgressUpdateManyWithoutUserNestedInput
    badges?: BadgeUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPasswordlessTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUncheckedUpdateOneWithoutUserNestedInput
    topics?: TopicUncheckedUpdateManyWithoutUserNestedInput
    progress?: ProgressUncheckedUpdateManyWithoutUserNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUncheckedUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUncheckedUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUncheckedUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUncheckedUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUncheckedUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUncheckedUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUncheckedUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUncheckedUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUncheckedUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUncheckedUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutDailyChallengesInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesCreateNestedOneWithoutUserInput
    topics?: TopicCreateNestedManyWithoutUserInput
    progress?: ProgressCreateNestedManyWithoutUserInput
    badges?: BadgeCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutUserInput
    aiModules?: AIModuleCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressCreateNestedManyWithoutUserInput
    AIChat?: AIChatCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDailyChallengesInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesUncheckedCreateNestedOneWithoutUserInput
    topics?: TopicUncheckedCreateNestedManyWithoutUserInput
    progress?: ProgressUncheckedCreateNestedManyWithoutUserInput
    badges?: BadgeUncheckedCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewUncheckedCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathUncheckedCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionUncheckedCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceUncheckedCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenUncheckedCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingUncheckedCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreUncheckedCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutUserInput
    aiModules?: AIModuleUncheckedCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingUncheckedCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    AIChat?: AIChatUncheckedCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDailyChallengesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDailyChallengesInput, UserUncheckedCreateWithoutDailyChallengesInput>
  }

  export type UserUpsertWithoutDailyChallengesInput = {
    update: XOR<UserUpdateWithoutDailyChallengesInput, UserUncheckedUpdateWithoutDailyChallengesInput>
    create: XOR<UserCreateWithoutDailyChallengesInput, UserUncheckedCreateWithoutDailyChallengesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDailyChallengesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDailyChallengesInput, UserUncheckedUpdateWithoutDailyChallengesInput>
  }

  export type UserUpdateWithoutDailyChallengesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUpdateOneWithoutUserNestedInput
    topics?: TopicUpdateManyWithoutUserNestedInput
    progress?: ProgressUpdateManyWithoutUserNestedInput
    badges?: BadgeUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDailyChallengesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUncheckedUpdateOneWithoutUserNestedInput
    topics?: TopicUncheckedUpdateManyWithoutUserNestedInput
    progress?: ProgressUncheckedUpdateManyWithoutUserNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUncheckedUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUncheckedUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUncheckedUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUncheckedUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUncheckedUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUncheckedUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUncheckedUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUncheckedUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUncheckedUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUncheckedUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutExternalGoalsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesCreateNestedOneWithoutUserInput
    topics?: TopicCreateNestedManyWithoutUserInput
    progress?: ProgressCreateNestedManyWithoutUserInput
    badges?: BadgeCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutUserInput
    aiModules?: AIModuleCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressCreateNestedManyWithoutUserInput
    AIChat?: AIChatCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutExternalGoalsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesUncheckedCreateNestedOneWithoutUserInput
    topics?: TopicUncheckedCreateNestedManyWithoutUserInput
    progress?: ProgressUncheckedCreateNestedManyWithoutUserInput
    badges?: BadgeUncheckedCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewUncheckedCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathUncheckedCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionUncheckedCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceUncheckedCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenUncheckedCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingUncheckedCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreUncheckedCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutUserInput
    aiModules?: AIModuleUncheckedCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingUncheckedCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    AIChat?: AIChatUncheckedCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutExternalGoalsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutExternalGoalsInput, UserUncheckedCreateWithoutExternalGoalsInput>
  }

  export type UserUpsertWithoutExternalGoalsInput = {
    update: XOR<UserUpdateWithoutExternalGoalsInput, UserUncheckedUpdateWithoutExternalGoalsInput>
    create: XOR<UserCreateWithoutExternalGoalsInput, UserUncheckedCreateWithoutExternalGoalsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutExternalGoalsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutExternalGoalsInput, UserUncheckedUpdateWithoutExternalGoalsInput>
  }

  export type UserUpdateWithoutExternalGoalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUpdateOneWithoutUserNestedInput
    topics?: TopicUpdateManyWithoutUserNestedInput
    progress?: ProgressUpdateManyWithoutUserNestedInput
    badges?: BadgeUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutExternalGoalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUncheckedUpdateOneWithoutUserNestedInput
    topics?: TopicUncheckedUpdateManyWithoutUserNestedInput
    progress?: ProgressUncheckedUpdateManyWithoutUserNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUncheckedUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUncheckedUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUncheckedUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUncheckedUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUncheckedUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUncheckedUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUncheckedUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUncheckedUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUncheckedUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUncheckedUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUncheckedUpdateManyWithoutUserNestedInput
  }

  export type LearningPathCreateWithoutPrerequisitesInput = {
    id?: string
    title: string
    description?: string | null
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    shareId?: string | null
    sharedAt?: Date | string | null
    user: UserCreateNestedOneWithoutLearningPathsInput
    items?: LearningPathItemCreateNestedManyWithoutLearningPathInput
    aiModuleItems?: AIModuleLearningPathItemCreateNestedManyWithoutLearningPathInput
    UserProgress?: UserProgressCreateNestedManyWithoutLearningPathInput
  }

  export type LearningPathUncheckedCreateWithoutPrerequisitesInput = {
    id?: string
    title: string
    description?: string | null
    userId: string
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    shareId?: string | null
    sharedAt?: Date | string | null
    items?: LearningPathItemUncheckedCreateNestedManyWithoutLearningPathInput
    aiModuleItems?: AIModuleLearningPathItemUncheckedCreateNestedManyWithoutLearningPathInput
    UserProgress?: UserProgressUncheckedCreateNestedManyWithoutLearningPathInput
  }

  export type LearningPathCreateOrConnectWithoutPrerequisitesInput = {
    where: LearningPathWhereUniqueInput
    create: XOR<LearningPathCreateWithoutPrerequisitesInput, LearningPathUncheckedCreateWithoutPrerequisitesInput>
  }

  export type TopicCreateWithoutPrerequisitesInput = {
    id?: string
    title: string
    description?: string | null
    user: UserCreateNestedOneWithoutTopicsInput
    progress?: ProgressCreateNestedManyWithoutTopicInput
    learningPathItems?: LearningPathItemCreateNestedManyWithoutTopicInput
    contentItems?: ContentItemCreateNestedManyWithoutTopicInput
    analyticsEntries?: AnalyticsEntryCreateNestedManyWithoutTopicInput
    comments?: CommentCreateNestedManyWithoutTopicInput
    aiModules?: AIModuleCreateNestedManyWithoutTopicInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptCreateNestedManyWithoutTopicInput
    aiModuleRatings?: AIModuleRatingCreateNestedManyWithoutTopicInput
  }

  export type TopicUncheckedCreateWithoutPrerequisitesInput = {
    id?: string
    title: string
    description?: string | null
    userId: string
    progress?: ProgressUncheckedCreateNestedManyWithoutTopicInput
    learningPathItems?: LearningPathItemUncheckedCreateNestedManyWithoutTopicInput
    contentItems?: ContentItemUncheckedCreateNestedManyWithoutTopicInput
    analyticsEntries?: AnalyticsEntryUncheckedCreateNestedManyWithoutTopicInput
    comments?: CommentUncheckedCreateNestedManyWithoutTopicInput
    aiModules?: AIModuleUncheckedCreateNestedManyWithoutTopicInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedCreateNestedManyWithoutTopicInput
    aiModuleRatings?: AIModuleRatingUncheckedCreateNestedManyWithoutTopicInput
  }

  export type TopicCreateOrConnectWithoutPrerequisitesInput = {
    where: TopicWhereUniqueInput
    create: XOR<TopicCreateWithoutPrerequisitesInput, TopicUncheckedCreateWithoutPrerequisitesInput>
  }

  export type LearningPathUpsertWithoutPrerequisitesInput = {
    update: XOR<LearningPathUpdateWithoutPrerequisitesInput, LearningPathUncheckedUpdateWithoutPrerequisitesInput>
    create: XOR<LearningPathCreateWithoutPrerequisitesInput, LearningPathUncheckedCreateWithoutPrerequisitesInput>
    where?: LearningPathWhereInput
  }

  export type LearningPathUpdateToOneWithWhereWithoutPrerequisitesInput = {
    where?: LearningPathWhereInput
    data: XOR<LearningPathUpdateWithoutPrerequisitesInput, LearningPathUncheckedUpdateWithoutPrerequisitesInput>
  }

  export type LearningPathUpdateWithoutPrerequisitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shareId?: NullableStringFieldUpdateOperationsInput | string | null
    sharedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutLearningPathsNestedInput
    items?: LearningPathItemUpdateManyWithoutLearningPathNestedInput
    aiModuleItems?: AIModuleLearningPathItemUpdateManyWithoutLearningPathNestedInput
    UserProgress?: UserProgressUpdateManyWithoutLearningPathNestedInput
  }

  export type LearningPathUncheckedUpdateWithoutPrerequisitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shareId?: NullableStringFieldUpdateOperationsInput | string | null
    sharedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: LearningPathItemUncheckedUpdateManyWithoutLearningPathNestedInput
    aiModuleItems?: AIModuleLearningPathItemUncheckedUpdateManyWithoutLearningPathNestedInput
    UserProgress?: UserProgressUncheckedUpdateManyWithoutLearningPathNestedInput
  }

  export type TopicUpsertWithoutPrerequisitesInput = {
    update: XOR<TopicUpdateWithoutPrerequisitesInput, TopicUncheckedUpdateWithoutPrerequisitesInput>
    create: XOR<TopicCreateWithoutPrerequisitesInput, TopicUncheckedCreateWithoutPrerequisitesInput>
    where?: TopicWhereInput
  }

  export type TopicUpdateToOneWithWhereWithoutPrerequisitesInput = {
    where?: TopicWhereInput
    data: XOR<TopicUpdateWithoutPrerequisitesInput, TopicUncheckedUpdateWithoutPrerequisitesInput>
  }

  export type TopicUpdateWithoutPrerequisitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutTopicsNestedInput
    progress?: ProgressUpdateManyWithoutTopicNestedInput
    learningPathItems?: LearningPathItemUpdateManyWithoutTopicNestedInput
    contentItems?: ContentItemUpdateManyWithoutTopicNestedInput
    analyticsEntries?: AnalyticsEntryUpdateManyWithoutTopicNestedInput
    comments?: CommentUpdateManyWithoutTopicNestedInput
    aiModules?: AIModuleUpdateManyWithoutTopicNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUpdateManyWithoutTopicNestedInput
    aiModuleRatings?: AIModuleRatingUpdateManyWithoutTopicNestedInput
  }

  export type TopicUncheckedUpdateWithoutPrerequisitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    progress?: ProgressUncheckedUpdateManyWithoutTopicNestedInput
    learningPathItems?: LearningPathItemUncheckedUpdateManyWithoutTopicNestedInput
    contentItems?: ContentItemUncheckedUpdateManyWithoutTopicNestedInput
    analyticsEntries?: AnalyticsEntryUncheckedUpdateManyWithoutTopicNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTopicNestedInput
    aiModules?: AIModuleUncheckedUpdateManyWithoutTopicNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedUpdateManyWithoutTopicNestedInput
    aiModuleRatings?: AIModuleRatingUncheckedUpdateManyWithoutTopicNestedInput
  }

  export type UserCreateWithoutCommentsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesCreateNestedOneWithoutUserInput
    topics?: TopicCreateNestedManyWithoutUserInput
    progress?: ProgressCreateNestedManyWithoutUserInput
    badges?: BadgeCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutUserInput
    aiModules?: AIModuleCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressCreateNestedManyWithoutUserInput
    AIChat?: AIChatCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommentsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesUncheckedCreateNestedOneWithoutUserInput
    topics?: TopicUncheckedCreateNestedManyWithoutUserInput
    progress?: ProgressUncheckedCreateNestedManyWithoutUserInput
    badges?: BadgeUncheckedCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewUncheckedCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathUncheckedCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionUncheckedCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceUncheckedCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenUncheckedCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeUncheckedCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalUncheckedCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingUncheckedCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreUncheckedCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutUserInput
    aiModules?: AIModuleUncheckedCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingUncheckedCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    AIChat?: AIChatUncheckedCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
  }

  export type TopicCreateWithoutCommentsInput = {
    id?: string
    title: string
    description?: string | null
    user: UserCreateNestedOneWithoutTopicsInput
    progress?: ProgressCreateNestedManyWithoutTopicInput
    learningPathItems?: LearningPathItemCreateNestedManyWithoutTopicInput
    contentItems?: ContentItemCreateNestedManyWithoutTopicInput
    analyticsEntries?: AnalyticsEntryCreateNestedManyWithoutTopicInput
    prerequisites?: PrerequisiteCreateNestedManyWithoutTopicInput
    aiModules?: AIModuleCreateNestedManyWithoutTopicInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptCreateNestedManyWithoutTopicInput
    aiModuleRatings?: AIModuleRatingCreateNestedManyWithoutTopicInput
  }

  export type TopicUncheckedCreateWithoutCommentsInput = {
    id?: string
    title: string
    description?: string | null
    userId: string
    progress?: ProgressUncheckedCreateNestedManyWithoutTopicInput
    learningPathItems?: LearningPathItemUncheckedCreateNestedManyWithoutTopicInput
    contentItems?: ContentItemUncheckedCreateNestedManyWithoutTopicInput
    analyticsEntries?: AnalyticsEntryUncheckedCreateNestedManyWithoutTopicInput
    prerequisites?: PrerequisiteUncheckedCreateNestedManyWithoutTopicInput
    aiModules?: AIModuleUncheckedCreateNestedManyWithoutTopicInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedCreateNestedManyWithoutTopicInput
    aiModuleRatings?: AIModuleRatingUncheckedCreateNestedManyWithoutTopicInput
  }

  export type TopicCreateOrConnectWithoutCommentsInput = {
    where: TopicWhereUniqueInput
    create: XOR<TopicCreateWithoutCommentsInput, TopicUncheckedCreateWithoutCommentsInput>
  }

  export type UserUpsertWithoutCommentsInput = {
    update: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUpdateOneWithoutUserNestedInput
    topics?: TopicUpdateManyWithoutUserNestedInput
    progress?: ProgressUpdateManyWithoutUserNestedInput
    badges?: BadgeUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUncheckedUpdateOneWithoutUserNestedInput
    topics?: TopicUncheckedUpdateManyWithoutUserNestedInput
    progress?: ProgressUncheckedUpdateManyWithoutUserNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUncheckedUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUncheckedUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUncheckedUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUncheckedUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUncheckedUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUncheckedUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUncheckedUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUncheckedUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUncheckedUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUncheckedUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUncheckedUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUncheckedUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TopicUpsertWithoutCommentsInput = {
    update: XOR<TopicUpdateWithoutCommentsInput, TopicUncheckedUpdateWithoutCommentsInput>
    create: XOR<TopicCreateWithoutCommentsInput, TopicUncheckedCreateWithoutCommentsInput>
    where?: TopicWhereInput
  }

  export type TopicUpdateToOneWithWhereWithoutCommentsInput = {
    where?: TopicWhereInput
    data: XOR<TopicUpdateWithoutCommentsInput, TopicUncheckedUpdateWithoutCommentsInput>
  }

  export type TopicUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutTopicsNestedInput
    progress?: ProgressUpdateManyWithoutTopicNestedInput
    learningPathItems?: LearningPathItemUpdateManyWithoutTopicNestedInput
    contentItems?: ContentItemUpdateManyWithoutTopicNestedInput
    analyticsEntries?: AnalyticsEntryUpdateManyWithoutTopicNestedInput
    prerequisites?: PrerequisiteUpdateManyWithoutTopicNestedInput
    aiModules?: AIModuleUpdateManyWithoutTopicNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUpdateManyWithoutTopicNestedInput
    aiModuleRatings?: AIModuleRatingUpdateManyWithoutTopicNestedInput
  }

  export type TopicUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    progress?: ProgressUncheckedUpdateManyWithoutTopicNestedInput
    learningPathItems?: LearningPathItemUncheckedUpdateManyWithoutTopicNestedInput
    contentItems?: ContentItemUncheckedUpdateManyWithoutTopicNestedInput
    analyticsEntries?: AnalyticsEntryUncheckedUpdateManyWithoutTopicNestedInput
    prerequisites?: PrerequisiteUncheckedUpdateManyWithoutTopicNestedInput
    aiModules?: AIModuleUncheckedUpdateManyWithoutTopicNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedUpdateManyWithoutTopicNestedInput
    aiModuleRatings?: AIModuleRatingUncheckedUpdateManyWithoutTopicNestedInput
  }

  export type AIPlaylistItemCreateWithoutPlaylistInput = {
    id?: string
    order: number
    contentItem: ContentItemCreateNestedOneWithoutAiPlaylistItemsInput
  }

  export type AIPlaylistItemUncheckedCreateWithoutPlaylistInput = {
    id?: string
    contentItemId: string
    order: number
  }

  export type AIPlaylistItemCreateOrConnectWithoutPlaylistInput = {
    where: AIPlaylistItemWhereUniqueInput
    create: XOR<AIPlaylistItemCreateWithoutPlaylistInput, AIPlaylistItemUncheckedCreateWithoutPlaylistInput>
  }

  export type AIPlaylistItemCreateManyPlaylistInputEnvelope = {
    data: AIPlaylistItemCreateManyPlaylistInput | AIPlaylistItemCreateManyPlaylistInput[]
    skipDuplicates?: boolean
  }

  export type AIPlaylistItemUpsertWithWhereUniqueWithoutPlaylistInput = {
    where: AIPlaylistItemWhereUniqueInput
    update: XOR<AIPlaylistItemUpdateWithoutPlaylistInput, AIPlaylistItemUncheckedUpdateWithoutPlaylistInput>
    create: XOR<AIPlaylistItemCreateWithoutPlaylistInput, AIPlaylistItemUncheckedCreateWithoutPlaylistInput>
  }

  export type AIPlaylistItemUpdateWithWhereUniqueWithoutPlaylistInput = {
    where: AIPlaylistItemWhereUniqueInput
    data: XOR<AIPlaylistItemUpdateWithoutPlaylistInput, AIPlaylistItemUncheckedUpdateWithoutPlaylistInput>
  }

  export type AIPlaylistItemUpdateManyWithWhereWithoutPlaylistInput = {
    where: AIPlaylistItemScalarWhereInput
    data: XOR<AIPlaylistItemUpdateManyMutationInput, AIPlaylistItemUncheckedUpdateManyWithoutPlaylistInput>
  }

  export type AIPlaylistCreateWithoutItemsInput = {
    id?: string
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIPlaylistUncheckedCreateWithoutItemsInput = {
    id?: string
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIPlaylistCreateOrConnectWithoutItemsInput = {
    where: AIPlaylistWhereUniqueInput
    create: XOR<AIPlaylistCreateWithoutItemsInput, AIPlaylistUncheckedCreateWithoutItemsInput>
  }

  export type ContentItemCreateWithoutAiPlaylistItemsInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    type: string
    difficulty: string
    createdAt?: Date | string
    updatedAt?: Date | string
    version?: string
    topic: TopicCreateNestedOneWithoutContentItemsInput
    bookmarks?: BookmarkCreateNestedManyWithoutContentItemInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutContentItemInput
    reviewItems?: ReviewItemCreateNestedManyWithoutContentItemInput
    ratings?: ContentRatingCreateNestedManyWithoutContentItemInput
  }

  export type ContentItemUncheckedCreateWithoutAiPlaylistItemsInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    type: string
    difficulty: string
    topicId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    version?: string
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutContentItemInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutContentItemInput
    reviewItems?: ReviewItemUncheckedCreateNestedManyWithoutContentItemInput
    ratings?: ContentRatingUncheckedCreateNestedManyWithoutContentItemInput
  }

  export type ContentItemCreateOrConnectWithoutAiPlaylistItemsInput = {
    where: ContentItemWhereUniqueInput
    create: XOR<ContentItemCreateWithoutAiPlaylistItemsInput, ContentItemUncheckedCreateWithoutAiPlaylistItemsInput>
  }

  export type AIPlaylistUpsertWithoutItemsInput = {
    update: XOR<AIPlaylistUpdateWithoutItemsInput, AIPlaylistUncheckedUpdateWithoutItemsInput>
    create: XOR<AIPlaylistCreateWithoutItemsInput, AIPlaylistUncheckedCreateWithoutItemsInput>
    where?: AIPlaylistWhereInput
  }

  export type AIPlaylistUpdateToOneWithWhereWithoutItemsInput = {
    where?: AIPlaylistWhereInput
    data: XOR<AIPlaylistUpdateWithoutItemsInput, AIPlaylistUncheckedUpdateWithoutItemsInput>
  }

  export type AIPlaylistUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIPlaylistUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentItemUpsertWithoutAiPlaylistItemsInput = {
    update: XOR<ContentItemUpdateWithoutAiPlaylistItemsInput, ContentItemUncheckedUpdateWithoutAiPlaylistItemsInput>
    create: XOR<ContentItemCreateWithoutAiPlaylistItemsInput, ContentItemUncheckedCreateWithoutAiPlaylistItemsInput>
    where?: ContentItemWhereInput
  }

  export type ContentItemUpdateToOneWithWhereWithoutAiPlaylistItemsInput = {
    where?: ContentItemWhereInput
    data: XOR<ContentItemUpdateWithoutAiPlaylistItemsInput, ContentItemUncheckedUpdateWithoutAiPlaylistItemsInput>
  }

  export type ContentItemUpdateWithoutAiPlaylistItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: StringFieldUpdateOperationsInput | string
    topic?: TopicUpdateOneRequiredWithoutContentItemsNestedInput
    bookmarks?: BookmarkUpdateManyWithoutContentItemNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutContentItemNestedInput
    reviewItems?: ReviewItemUpdateManyWithoutContentItemNestedInput
    ratings?: ContentRatingUpdateManyWithoutContentItemNestedInput
  }

  export type ContentItemUncheckedUpdateWithoutAiPlaylistItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: StringFieldUpdateOperationsInput | string
    bookmarks?: BookmarkUncheckedUpdateManyWithoutContentItemNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutContentItemNestedInput
    reviewItems?: ReviewItemUncheckedUpdateManyWithoutContentItemNestedInput
    ratings?: ContentRatingUncheckedUpdateManyWithoutContentItemNestedInput
  }

  export type UserCreateWithoutChallengeScoresInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesCreateNestedOneWithoutUserInput
    topics?: TopicCreateNestedManyWithoutUserInput
    progress?: ProgressCreateNestedManyWithoutUserInput
    badges?: BadgeCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutUserInput
    aiModules?: AIModuleCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressCreateNestedManyWithoutUserInput
    AIChat?: AIChatCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutChallengeScoresInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesUncheckedCreateNestedOneWithoutUserInput
    topics?: TopicUncheckedCreateNestedManyWithoutUserInput
    progress?: ProgressUncheckedCreateNestedManyWithoutUserInput
    badges?: BadgeUncheckedCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewUncheckedCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathUncheckedCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionUncheckedCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceUncheckedCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenUncheckedCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeUncheckedCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingUncheckedCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutUserInput
    aiModules?: AIModuleUncheckedCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingUncheckedCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    AIChat?: AIChatUncheckedCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutChallengeScoresInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChallengeScoresInput, UserUncheckedCreateWithoutChallengeScoresInput>
  }

  export type UserUpsertWithoutChallengeScoresInput = {
    update: XOR<UserUpdateWithoutChallengeScoresInput, UserUncheckedUpdateWithoutChallengeScoresInput>
    create: XOR<UserCreateWithoutChallengeScoresInput, UserUncheckedCreateWithoutChallengeScoresInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChallengeScoresInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChallengeScoresInput, UserUncheckedUpdateWithoutChallengeScoresInput>
  }

  export type UserUpdateWithoutChallengeScoresInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUpdateOneWithoutUserNestedInput
    topics?: TopicUpdateManyWithoutUserNestedInput
    progress?: ProgressUpdateManyWithoutUserNestedInput
    badges?: BadgeUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutChallengeScoresInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUncheckedUpdateOneWithoutUserNestedInput
    topics?: TopicUncheckedUpdateManyWithoutUserNestedInput
    progress?: ProgressUncheckedUpdateManyWithoutUserNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUncheckedUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUncheckedUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUncheckedUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUncheckedUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUncheckedUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUncheckedUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUncheckedUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUncheckedUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUncheckedUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUncheckedUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAiRecommendationsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesCreateNestedOneWithoutUserInput
    topics?: TopicCreateNestedManyWithoutUserInput
    progress?: ProgressCreateNestedManyWithoutUserInput
    badges?: BadgeCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    aiModules?: AIModuleCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressCreateNestedManyWithoutUserInput
    AIChat?: AIChatCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAiRecommendationsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesUncheckedCreateNestedOneWithoutUserInput
    topics?: TopicUncheckedCreateNestedManyWithoutUserInput
    progress?: ProgressUncheckedCreateNestedManyWithoutUserInput
    badges?: BadgeUncheckedCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewUncheckedCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathUncheckedCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionUncheckedCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceUncheckedCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenUncheckedCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeUncheckedCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingUncheckedCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreUncheckedCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    aiModules?: AIModuleUncheckedCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingUncheckedCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    AIChat?: AIChatUncheckedCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAiRecommendationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAiRecommendationsInput, UserUncheckedCreateWithoutAiRecommendationsInput>
  }

  export type UserUpsertWithoutAiRecommendationsInput = {
    update: XOR<UserUpdateWithoutAiRecommendationsInput, UserUncheckedUpdateWithoutAiRecommendationsInput>
    create: XOR<UserCreateWithoutAiRecommendationsInput, UserUncheckedCreateWithoutAiRecommendationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAiRecommendationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAiRecommendationsInput, UserUncheckedUpdateWithoutAiRecommendationsInput>
  }

  export type UserUpdateWithoutAiRecommendationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUpdateOneWithoutUserNestedInput
    topics?: TopicUpdateManyWithoutUserNestedInput
    progress?: ProgressUpdateManyWithoutUserNestedInput
    badges?: BadgeUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAiRecommendationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUncheckedUpdateOneWithoutUserNestedInput
    topics?: TopicUncheckedUpdateManyWithoutUserNestedInput
    progress?: ProgressUncheckedUpdateManyWithoutUserNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUncheckedUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUncheckedUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUncheckedUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUncheckedUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUncheckedUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUncheckedUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUncheckedUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUncheckedUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUncheckedUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUncheckedUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUncheckedUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAiModulesInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesCreateNestedOneWithoutUserInput
    topics?: TopicCreateNestedManyWithoutUserInput
    progress?: ProgressCreateNestedManyWithoutUserInput
    badges?: BadgeCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressCreateNestedManyWithoutUserInput
    AIChat?: AIChatCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAiModulesInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesUncheckedCreateNestedOneWithoutUserInput
    topics?: TopicUncheckedCreateNestedManyWithoutUserInput
    progress?: ProgressUncheckedCreateNestedManyWithoutUserInput
    badges?: BadgeUncheckedCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewUncheckedCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathUncheckedCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionUncheckedCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceUncheckedCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenUncheckedCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeUncheckedCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingUncheckedCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreUncheckedCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingUncheckedCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    AIChat?: AIChatUncheckedCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAiModulesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAiModulesInput, UserUncheckedCreateWithoutAiModulesInput>
  }

  export type TopicCreateWithoutAiModulesInput = {
    id?: string
    title: string
    description?: string | null
    user: UserCreateNestedOneWithoutTopicsInput
    progress?: ProgressCreateNestedManyWithoutTopicInput
    learningPathItems?: LearningPathItemCreateNestedManyWithoutTopicInput
    contentItems?: ContentItemCreateNestedManyWithoutTopicInput
    analyticsEntries?: AnalyticsEntryCreateNestedManyWithoutTopicInput
    comments?: CommentCreateNestedManyWithoutTopicInput
    prerequisites?: PrerequisiteCreateNestedManyWithoutTopicInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptCreateNestedManyWithoutTopicInput
    aiModuleRatings?: AIModuleRatingCreateNestedManyWithoutTopicInput
  }

  export type TopicUncheckedCreateWithoutAiModulesInput = {
    id?: string
    title: string
    description?: string | null
    userId: string
    progress?: ProgressUncheckedCreateNestedManyWithoutTopicInput
    learningPathItems?: LearningPathItemUncheckedCreateNestedManyWithoutTopicInput
    contentItems?: ContentItemUncheckedCreateNestedManyWithoutTopicInput
    analyticsEntries?: AnalyticsEntryUncheckedCreateNestedManyWithoutTopicInput
    comments?: CommentUncheckedCreateNestedManyWithoutTopicInput
    prerequisites?: PrerequisiteUncheckedCreateNestedManyWithoutTopicInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedCreateNestedManyWithoutTopicInput
    aiModuleRatings?: AIModuleRatingUncheckedCreateNestedManyWithoutTopicInput
  }

  export type TopicCreateOrConnectWithoutAiModulesInput = {
    where: TopicWhereUniqueInput
    create: XOR<TopicCreateWithoutAiModulesInput, TopicUncheckedCreateWithoutAiModulesInput>
  }

  export type AIModuleLearningPathItemCreateWithoutAiModuleInput = {
    id?: string
    order: number
    confidence?: number
    learningPath: LearningPathCreateNestedOneWithoutAiModuleItemsInput
  }

  export type AIModuleLearningPathItemUncheckedCreateWithoutAiModuleInput = {
    id?: string
    order: number
    learningPathId: string
    confidence?: number
  }

  export type AIModuleLearningPathItemCreateOrConnectWithoutAiModuleInput = {
    where: AIModuleLearningPathItemWhereUniqueInput
    create: XOR<AIModuleLearningPathItemCreateWithoutAiModuleInput, AIModuleLearningPathItemUncheckedCreateWithoutAiModuleInput>
  }

  export type AIModuleLearningPathItemCreateManyAiModuleInputEnvelope = {
    data: AIModuleLearningPathItemCreateManyAiModuleInput | AIModuleLearningPathItemCreateManyAiModuleInput[]
    skipDuplicates?: boolean
  }

  export type AIModuleQuizAttemptCreateWithoutAiModuleInput = {
    id?: string
    score: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    answers: JsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutAiModuleQuizAttemptsInput
    topic: TopicCreateNestedOneWithoutAiModuleQuizAttemptsInput
  }

  export type AIModuleQuizAttemptUncheckedCreateWithoutAiModuleInput = {
    id?: string
    userId: string
    topicId: string
    score: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    answers: JsonNullValueInput | InputJsonValue
  }

  export type AIModuleQuizAttemptCreateOrConnectWithoutAiModuleInput = {
    where: AIModuleQuizAttemptWhereUniqueInput
    create: XOR<AIModuleQuizAttemptCreateWithoutAiModuleInput, AIModuleQuizAttemptUncheckedCreateWithoutAiModuleInput>
  }

  export type AIModuleQuizAttemptCreateManyAiModuleInputEnvelope = {
    data: AIModuleQuizAttemptCreateManyAiModuleInput | AIModuleQuizAttemptCreateManyAiModuleInput[]
    skipDuplicates?: boolean
  }

  export type AIModuleRatingCreateWithoutAiModuleInput = {
    id?: string
    rating: number
    feedback?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAiModuleRatingsInput
    topic: TopicCreateNestedOneWithoutAiModuleRatingsInput
  }

  export type AIModuleRatingUncheckedCreateWithoutAiModuleInput = {
    id?: string
    userId: string
    topicId: string
    rating: number
    feedback?: string | null
    createdAt?: Date | string
  }

  export type AIModuleRatingCreateOrConnectWithoutAiModuleInput = {
    where: AIModuleRatingWhereUniqueInput
    create: XOR<AIModuleRatingCreateWithoutAiModuleInput, AIModuleRatingUncheckedCreateWithoutAiModuleInput>
  }

  export type AIModuleRatingCreateManyAiModuleInputEnvelope = {
    data: AIModuleRatingCreateManyAiModuleInput | AIModuleRatingCreateManyAiModuleInput[]
    skipDuplicates?: boolean
  }

  export type PracticeAttemptCreateWithoutAiModuleInput = {
    id?: string
    questions: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    score?: number | null
    averageEase?: number | null
    completedAt?: Date | string | null
    user: UserCreateNestedOneWithoutPracticeAttemptsInput
  }

  export type PracticeAttemptUncheckedCreateWithoutAiModuleInput = {
    id?: string
    userId: string
    questions: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    score?: number | null
    averageEase?: number | null
    completedAt?: Date | string | null
  }

  export type PracticeAttemptCreateOrConnectWithoutAiModuleInput = {
    where: PracticeAttemptWhereUniqueInput
    create: XOR<PracticeAttemptCreateWithoutAiModuleInput, PracticeAttemptUncheckedCreateWithoutAiModuleInput>
  }

  export type PracticeAttemptCreateManyAiModuleInputEnvelope = {
    data: PracticeAttemptCreateManyAiModuleInput | PracticeAttemptCreateManyAiModuleInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAiModulesInput = {
    update: XOR<UserUpdateWithoutAiModulesInput, UserUncheckedUpdateWithoutAiModulesInput>
    create: XOR<UserCreateWithoutAiModulesInput, UserUncheckedCreateWithoutAiModulesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAiModulesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAiModulesInput, UserUncheckedUpdateWithoutAiModulesInput>
  }

  export type UserUpdateWithoutAiModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUpdateOneWithoutUserNestedInput
    topics?: TopicUpdateManyWithoutUserNestedInput
    progress?: ProgressUpdateManyWithoutUserNestedInput
    badges?: BadgeUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAiModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUncheckedUpdateOneWithoutUserNestedInput
    topics?: TopicUncheckedUpdateManyWithoutUserNestedInput
    progress?: ProgressUncheckedUpdateManyWithoutUserNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUncheckedUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUncheckedUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUncheckedUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUncheckedUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUncheckedUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUncheckedUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUncheckedUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUncheckedUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUncheckedUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUncheckedUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TopicUpsertWithoutAiModulesInput = {
    update: XOR<TopicUpdateWithoutAiModulesInput, TopicUncheckedUpdateWithoutAiModulesInput>
    create: XOR<TopicCreateWithoutAiModulesInput, TopicUncheckedCreateWithoutAiModulesInput>
    where?: TopicWhereInput
  }

  export type TopicUpdateToOneWithWhereWithoutAiModulesInput = {
    where?: TopicWhereInput
    data: XOR<TopicUpdateWithoutAiModulesInput, TopicUncheckedUpdateWithoutAiModulesInput>
  }

  export type TopicUpdateWithoutAiModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutTopicsNestedInput
    progress?: ProgressUpdateManyWithoutTopicNestedInput
    learningPathItems?: LearningPathItemUpdateManyWithoutTopicNestedInput
    contentItems?: ContentItemUpdateManyWithoutTopicNestedInput
    analyticsEntries?: AnalyticsEntryUpdateManyWithoutTopicNestedInput
    comments?: CommentUpdateManyWithoutTopicNestedInput
    prerequisites?: PrerequisiteUpdateManyWithoutTopicNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUpdateManyWithoutTopicNestedInput
    aiModuleRatings?: AIModuleRatingUpdateManyWithoutTopicNestedInput
  }

  export type TopicUncheckedUpdateWithoutAiModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    progress?: ProgressUncheckedUpdateManyWithoutTopicNestedInput
    learningPathItems?: LearningPathItemUncheckedUpdateManyWithoutTopicNestedInput
    contentItems?: ContentItemUncheckedUpdateManyWithoutTopicNestedInput
    analyticsEntries?: AnalyticsEntryUncheckedUpdateManyWithoutTopicNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTopicNestedInput
    prerequisites?: PrerequisiteUncheckedUpdateManyWithoutTopicNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedUpdateManyWithoutTopicNestedInput
    aiModuleRatings?: AIModuleRatingUncheckedUpdateManyWithoutTopicNestedInput
  }

  export type AIModuleLearningPathItemUpsertWithWhereUniqueWithoutAiModuleInput = {
    where: AIModuleLearningPathItemWhereUniqueInput
    update: XOR<AIModuleLearningPathItemUpdateWithoutAiModuleInput, AIModuleLearningPathItemUncheckedUpdateWithoutAiModuleInput>
    create: XOR<AIModuleLearningPathItemCreateWithoutAiModuleInput, AIModuleLearningPathItemUncheckedCreateWithoutAiModuleInput>
  }

  export type AIModuleLearningPathItemUpdateWithWhereUniqueWithoutAiModuleInput = {
    where: AIModuleLearningPathItemWhereUniqueInput
    data: XOR<AIModuleLearningPathItemUpdateWithoutAiModuleInput, AIModuleLearningPathItemUncheckedUpdateWithoutAiModuleInput>
  }

  export type AIModuleLearningPathItemUpdateManyWithWhereWithoutAiModuleInput = {
    where: AIModuleLearningPathItemScalarWhereInput
    data: XOR<AIModuleLearningPathItemUpdateManyMutationInput, AIModuleLearningPathItemUncheckedUpdateManyWithoutAiModuleInput>
  }

  export type AIModuleQuizAttemptUpsertWithWhereUniqueWithoutAiModuleInput = {
    where: AIModuleQuizAttemptWhereUniqueInput
    update: XOR<AIModuleQuizAttemptUpdateWithoutAiModuleInput, AIModuleQuizAttemptUncheckedUpdateWithoutAiModuleInput>
    create: XOR<AIModuleQuizAttemptCreateWithoutAiModuleInput, AIModuleQuizAttemptUncheckedCreateWithoutAiModuleInput>
  }

  export type AIModuleQuizAttemptUpdateWithWhereUniqueWithoutAiModuleInput = {
    where: AIModuleQuizAttemptWhereUniqueInput
    data: XOR<AIModuleQuizAttemptUpdateWithoutAiModuleInput, AIModuleQuizAttemptUncheckedUpdateWithoutAiModuleInput>
  }

  export type AIModuleQuizAttemptUpdateManyWithWhereWithoutAiModuleInput = {
    where: AIModuleQuizAttemptScalarWhereInput
    data: XOR<AIModuleQuizAttemptUpdateManyMutationInput, AIModuleQuizAttemptUncheckedUpdateManyWithoutAiModuleInput>
  }

  export type AIModuleRatingUpsertWithWhereUniqueWithoutAiModuleInput = {
    where: AIModuleRatingWhereUniqueInput
    update: XOR<AIModuleRatingUpdateWithoutAiModuleInput, AIModuleRatingUncheckedUpdateWithoutAiModuleInput>
    create: XOR<AIModuleRatingCreateWithoutAiModuleInput, AIModuleRatingUncheckedCreateWithoutAiModuleInput>
  }

  export type AIModuleRatingUpdateWithWhereUniqueWithoutAiModuleInput = {
    where: AIModuleRatingWhereUniqueInput
    data: XOR<AIModuleRatingUpdateWithoutAiModuleInput, AIModuleRatingUncheckedUpdateWithoutAiModuleInput>
  }

  export type AIModuleRatingUpdateManyWithWhereWithoutAiModuleInput = {
    where: AIModuleRatingScalarWhereInput
    data: XOR<AIModuleRatingUpdateManyMutationInput, AIModuleRatingUncheckedUpdateManyWithoutAiModuleInput>
  }

  export type PracticeAttemptUpsertWithWhereUniqueWithoutAiModuleInput = {
    where: PracticeAttemptWhereUniqueInput
    update: XOR<PracticeAttemptUpdateWithoutAiModuleInput, PracticeAttemptUncheckedUpdateWithoutAiModuleInput>
    create: XOR<PracticeAttemptCreateWithoutAiModuleInput, PracticeAttemptUncheckedCreateWithoutAiModuleInput>
  }

  export type PracticeAttemptUpdateWithWhereUniqueWithoutAiModuleInput = {
    where: PracticeAttemptWhereUniqueInput
    data: XOR<PracticeAttemptUpdateWithoutAiModuleInput, PracticeAttemptUncheckedUpdateWithoutAiModuleInput>
  }

  export type PracticeAttemptUpdateManyWithWhereWithoutAiModuleInput = {
    where: PracticeAttemptScalarWhereInput
    data: XOR<PracticeAttemptUpdateManyMutationInput, PracticeAttemptUncheckedUpdateManyWithoutAiModuleInput>
  }

  export type LearningPathCreateWithoutAiModuleItemsInput = {
    id?: string
    title: string
    description?: string | null
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    shareId?: string | null
    sharedAt?: Date | string | null
    user: UserCreateNestedOneWithoutLearningPathsInput
    items?: LearningPathItemCreateNestedManyWithoutLearningPathInput
    prerequisites?: PrerequisiteCreateNestedManyWithoutLearningPathInput
    UserProgress?: UserProgressCreateNestedManyWithoutLearningPathInput
  }

  export type LearningPathUncheckedCreateWithoutAiModuleItemsInput = {
    id?: string
    title: string
    description?: string | null
    userId: string
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    shareId?: string | null
    sharedAt?: Date | string | null
    items?: LearningPathItemUncheckedCreateNestedManyWithoutLearningPathInput
    prerequisites?: PrerequisiteUncheckedCreateNestedManyWithoutLearningPathInput
    UserProgress?: UserProgressUncheckedCreateNestedManyWithoutLearningPathInput
  }

  export type LearningPathCreateOrConnectWithoutAiModuleItemsInput = {
    where: LearningPathWhereUniqueInput
    create: XOR<LearningPathCreateWithoutAiModuleItemsInput, LearningPathUncheckedCreateWithoutAiModuleItemsInput>
  }

  export type AIModuleCreateWithoutLearningPathItemsInput = {
    id?: string
    title: string
    description?: string | null
    content: JsonNullValueInput | InputJsonValue
    tags?: AIModuleCreatetagsInput | string[]
    difficulty?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutAiModulesInput
    topic?: TopicCreateNestedOneWithoutAiModulesInput
    quizAttempts?: AIModuleQuizAttemptCreateNestedManyWithoutAiModuleInput
    ratings?: AIModuleRatingCreateNestedManyWithoutAiModuleInput
    PracticeAttempts?: PracticeAttemptCreateNestedManyWithoutAiModuleInput
  }

  export type AIModuleUncheckedCreateWithoutLearningPathItemsInput = {
    id?: string
    title: string
    description?: string | null
    content: JsonNullValueInput | InputJsonValue
    tags?: AIModuleCreatetagsInput | string[]
    difficulty?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    topicId?: string | null
    quizAttempts?: AIModuleQuizAttemptUncheckedCreateNestedManyWithoutAiModuleInput
    ratings?: AIModuleRatingUncheckedCreateNestedManyWithoutAiModuleInput
    PracticeAttempts?: PracticeAttemptUncheckedCreateNestedManyWithoutAiModuleInput
  }

  export type AIModuleCreateOrConnectWithoutLearningPathItemsInput = {
    where: AIModuleWhereUniqueInput
    create: XOR<AIModuleCreateWithoutLearningPathItemsInput, AIModuleUncheckedCreateWithoutLearningPathItemsInput>
  }

  export type LearningPathUpsertWithoutAiModuleItemsInput = {
    update: XOR<LearningPathUpdateWithoutAiModuleItemsInput, LearningPathUncheckedUpdateWithoutAiModuleItemsInput>
    create: XOR<LearningPathCreateWithoutAiModuleItemsInput, LearningPathUncheckedCreateWithoutAiModuleItemsInput>
    where?: LearningPathWhereInput
  }

  export type LearningPathUpdateToOneWithWhereWithoutAiModuleItemsInput = {
    where?: LearningPathWhereInput
    data: XOR<LearningPathUpdateWithoutAiModuleItemsInput, LearningPathUncheckedUpdateWithoutAiModuleItemsInput>
  }

  export type LearningPathUpdateWithoutAiModuleItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shareId?: NullableStringFieldUpdateOperationsInput | string | null
    sharedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutLearningPathsNestedInput
    items?: LearningPathItemUpdateManyWithoutLearningPathNestedInput
    prerequisites?: PrerequisiteUpdateManyWithoutLearningPathNestedInput
    UserProgress?: UserProgressUpdateManyWithoutLearningPathNestedInput
  }

  export type LearningPathUncheckedUpdateWithoutAiModuleItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shareId?: NullableStringFieldUpdateOperationsInput | string | null
    sharedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: LearningPathItemUncheckedUpdateManyWithoutLearningPathNestedInput
    prerequisites?: PrerequisiteUncheckedUpdateManyWithoutLearningPathNestedInput
    UserProgress?: UserProgressUncheckedUpdateManyWithoutLearningPathNestedInput
  }

  export type AIModuleUpsertWithoutLearningPathItemsInput = {
    update: XOR<AIModuleUpdateWithoutLearningPathItemsInput, AIModuleUncheckedUpdateWithoutLearningPathItemsInput>
    create: XOR<AIModuleCreateWithoutLearningPathItemsInput, AIModuleUncheckedCreateWithoutLearningPathItemsInput>
    where?: AIModuleWhereInput
  }

  export type AIModuleUpdateToOneWithWhereWithoutLearningPathItemsInput = {
    where?: AIModuleWhereInput
    data: XOR<AIModuleUpdateWithoutLearningPathItemsInput, AIModuleUncheckedUpdateWithoutLearningPathItemsInput>
  }

  export type AIModuleUpdateWithoutLearningPathItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    tags?: AIModuleUpdatetagsInput | string[]
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAiModulesNestedInput
    topic?: TopicUpdateOneWithoutAiModulesNestedInput
    quizAttempts?: AIModuleQuizAttemptUpdateManyWithoutAiModuleNestedInput
    ratings?: AIModuleRatingUpdateManyWithoutAiModuleNestedInput
    PracticeAttempts?: PracticeAttemptUpdateManyWithoutAiModuleNestedInput
  }

  export type AIModuleUncheckedUpdateWithoutLearningPathItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    tags?: AIModuleUpdatetagsInput | string[]
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    quizAttempts?: AIModuleQuizAttemptUncheckedUpdateManyWithoutAiModuleNestedInput
    ratings?: AIModuleRatingUncheckedUpdateManyWithoutAiModuleNestedInput
    PracticeAttempts?: PracticeAttemptUncheckedUpdateManyWithoutAiModuleNestedInput
  }

  export type UserCreateWithoutAiModuleQuizAttemptsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesCreateNestedOneWithoutUserInput
    topics?: TopicCreateNestedManyWithoutUserInput
    progress?: ProgressCreateNestedManyWithoutUserInput
    badges?: BadgeCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutUserInput
    aiModules?: AIModuleCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressCreateNestedManyWithoutUserInput
    AIChat?: AIChatCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAiModuleQuizAttemptsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesUncheckedCreateNestedOneWithoutUserInput
    topics?: TopicUncheckedCreateNestedManyWithoutUserInput
    progress?: ProgressUncheckedCreateNestedManyWithoutUserInput
    badges?: BadgeUncheckedCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewUncheckedCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathUncheckedCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionUncheckedCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceUncheckedCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenUncheckedCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeUncheckedCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingUncheckedCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreUncheckedCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutUserInput
    aiModules?: AIModuleUncheckedCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingUncheckedCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    AIChat?: AIChatUncheckedCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAiModuleQuizAttemptsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAiModuleQuizAttemptsInput, UserUncheckedCreateWithoutAiModuleQuizAttemptsInput>
  }

  export type AIModuleCreateWithoutQuizAttemptsInput = {
    id?: string
    title: string
    description?: string | null
    content: JsonNullValueInput | InputJsonValue
    tags?: AIModuleCreatetagsInput | string[]
    difficulty?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutAiModulesInput
    topic?: TopicCreateNestedOneWithoutAiModulesInput
    learningPathItems?: AIModuleLearningPathItemCreateNestedManyWithoutAiModuleInput
    ratings?: AIModuleRatingCreateNestedManyWithoutAiModuleInput
    PracticeAttempts?: PracticeAttemptCreateNestedManyWithoutAiModuleInput
  }

  export type AIModuleUncheckedCreateWithoutQuizAttemptsInput = {
    id?: string
    title: string
    description?: string | null
    content: JsonNullValueInput | InputJsonValue
    tags?: AIModuleCreatetagsInput | string[]
    difficulty?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    topicId?: string | null
    learningPathItems?: AIModuleLearningPathItemUncheckedCreateNestedManyWithoutAiModuleInput
    ratings?: AIModuleRatingUncheckedCreateNestedManyWithoutAiModuleInput
    PracticeAttempts?: PracticeAttemptUncheckedCreateNestedManyWithoutAiModuleInput
  }

  export type AIModuleCreateOrConnectWithoutQuizAttemptsInput = {
    where: AIModuleWhereUniqueInput
    create: XOR<AIModuleCreateWithoutQuizAttemptsInput, AIModuleUncheckedCreateWithoutQuizAttemptsInput>
  }

  export type TopicCreateWithoutAiModuleQuizAttemptsInput = {
    id?: string
    title: string
    description?: string | null
    user: UserCreateNestedOneWithoutTopicsInput
    progress?: ProgressCreateNestedManyWithoutTopicInput
    learningPathItems?: LearningPathItemCreateNestedManyWithoutTopicInput
    contentItems?: ContentItemCreateNestedManyWithoutTopicInput
    analyticsEntries?: AnalyticsEntryCreateNestedManyWithoutTopicInput
    comments?: CommentCreateNestedManyWithoutTopicInput
    prerequisites?: PrerequisiteCreateNestedManyWithoutTopicInput
    aiModules?: AIModuleCreateNestedManyWithoutTopicInput
    aiModuleRatings?: AIModuleRatingCreateNestedManyWithoutTopicInput
  }

  export type TopicUncheckedCreateWithoutAiModuleQuizAttemptsInput = {
    id?: string
    title: string
    description?: string | null
    userId: string
    progress?: ProgressUncheckedCreateNestedManyWithoutTopicInput
    learningPathItems?: LearningPathItemUncheckedCreateNestedManyWithoutTopicInput
    contentItems?: ContentItemUncheckedCreateNestedManyWithoutTopicInput
    analyticsEntries?: AnalyticsEntryUncheckedCreateNestedManyWithoutTopicInput
    comments?: CommentUncheckedCreateNestedManyWithoutTopicInput
    prerequisites?: PrerequisiteUncheckedCreateNestedManyWithoutTopicInput
    aiModules?: AIModuleUncheckedCreateNestedManyWithoutTopicInput
    aiModuleRatings?: AIModuleRatingUncheckedCreateNestedManyWithoutTopicInput
  }

  export type TopicCreateOrConnectWithoutAiModuleQuizAttemptsInput = {
    where: TopicWhereUniqueInput
    create: XOR<TopicCreateWithoutAiModuleQuizAttemptsInput, TopicUncheckedCreateWithoutAiModuleQuizAttemptsInput>
  }

  export type UserUpsertWithoutAiModuleQuizAttemptsInput = {
    update: XOR<UserUpdateWithoutAiModuleQuizAttemptsInput, UserUncheckedUpdateWithoutAiModuleQuizAttemptsInput>
    create: XOR<UserCreateWithoutAiModuleQuizAttemptsInput, UserUncheckedCreateWithoutAiModuleQuizAttemptsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAiModuleQuizAttemptsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAiModuleQuizAttemptsInput, UserUncheckedUpdateWithoutAiModuleQuizAttemptsInput>
  }

  export type UserUpdateWithoutAiModuleQuizAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUpdateOneWithoutUserNestedInput
    topics?: TopicUpdateManyWithoutUserNestedInput
    progress?: ProgressUpdateManyWithoutUserNestedInput
    badges?: BadgeUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAiModuleQuizAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUncheckedUpdateOneWithoutUserNestedInput
    topics?: TopicUncheckedUpdateManyWithoutUserNestedInput
    progress?: ProgressUncheckedUpdateManyWithoutUserNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUncheckedUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUncheckedUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUncheckedUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUncheckedUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUncheckedUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUncheckedUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUncheckedUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUncheckedUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUncheckedUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUncheckedUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUncheckedUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AIModuleUpsertWithoutQuizAttemptsInput = {
    update: XOR<AIModuleUpdateWithoutQuizAttemptsInput, AIModuleUncheckedUpdateWithoutQuizAttemptsInput>
    create: XOR<AIModuleCreateWithoutQuizAttemptsInput, AIModuleUncheckedCreateWithoutQuizAttemptsInput>
    where?: AIModuleWhereInput
  }

  export type AIModuleUpdateToOneWithWhereWithoutQuizAttemptsInput = {
    where?: AIModuleWhereInput
    data: XOR<AIModuleUpdateWithoutQuizAttemptsInput, AIModuleUncheckedUpdateWithoutQuizAttemptsInput>
  }

  export type AIModuleUpdateWithoutQuizAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    tags?: AIModuleUpdatetagsInput | string[]
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAiModulesNestedInput
    topic?: TopicUpdateOneWithoutAiModulesNestedInput
    learningPathItems?: AIModuleLearningPathItemUpdateManyWithoutAiModuleNestedInput
    ratings?: AIModuleRatingUpdateManyWithoutAiModuleNestedInput
    PracticeAttempts?: PracticeAttemptUpdateManyWithoutAiModuleNestedInput
  }

  export type AIModuleUncheckedUpdateWithoutQuizAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    tags?: AIModuleUpdatetagsInput | string[]
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    learningPathItems?: AIModuleLearningPathItemUncheckedUpdateManyWithoutAiModuleNestedInput
    ratings?: AIModuleRatingUncheckedUpdateManyWithoutAiModuleNestedInput
    PracticeAttempts?: PracticeAttemptUncheckedUpdateManyWithoutAiModuleNestedInput
  }

  export type TopicUpsertWithoutAiModuleQuizAttemptsInput = {
    update: XOR<TopicUpdateWithoutAiModuleQuizAttemptsInput, TopicUncheckedUpdateWithoutAiModuleQuizAttemptsInput>
    create: XOR<TopicCreateWithoutAiModuleQuizAttemptsInput, TopicUncheckedCreateWithoutAiModuleQuizAttemptsInput>
    where?: TopicWhereInput
  }

  export type TopicUpdateToOneWithWhereWithoutAiModuleQuizAttemptsInput = {
    where?: TopicWhereInput
    data: XOR<TopicUpdateWithoutAiModuleQuizAttemptsInput, TopicUncheckedUpdateWithoutAiModuleQuizAttemptsInput>
  }

  export type TopicUpdateWithoutAiModuleQuizAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutTopicsNestedInput
    progress?: ProgressUpdateManyWithoutTopicNestedInput
    learningPathItems?: LearningPathItemUpdateManyWithoutTopicNestedInput
    contentItems?: ContentItemUpdateManyWithoutTopicNestedInput
    analyticsEntries?: AnalyticsEntryUpdateManyWithoutTopicNestedInput
    comments?: CommentUpdateManyWithoutTopicNestedInput
    prerequisites?: PrerequisiteUpdateManyWithoutTopicNestedInput
    aiModules?: AIModuleUpdateManyWithoutTopicNestedInput
    aiModuleRatings?: AIModuleRatingUpdateManyWithoutTopicNestedInput
  }

  export type TopicUncheckedUpdateWithoutAiModuleQuizAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    progress?: ProgressUncheckedUpdateManyWithoutTopicNestedInput
    learningPathItems?: LearningPathItemUncheckedUpdateManyWithoutTopicNestedInput
    contentItems?: ContentItemUncheckedUpdateManyWithoutTopicNestedInput
    analyticsEntries?: AnalyticsEntryUncheckedUpdateManyWithoutTopicNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTopicNestedInput
    prerequisites?: PrerequisiteUncheckedUpdateManyWithoutTopicNestedInput
    aiModules?: AIModuleUncheckedUpdateManyWithoutTopicNestedInput
    aiModuleRatings?: AIModuleRatingUncheckedUpdateManyWithoutTopicNestedInput
  }

  export type UserCreateWithoutAiModuleRatingsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesCreateNestedOneWithoutUserInput
    topics?: TopicCreateNestedManyWithoutUserInput
    progress?: ProgressCreateNestedManyWithoutUserInput
    badges?: BadgeCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutUserInput
    aiModules?: AIModuleCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressCreateNestedManyWithoutUserInput
    AIChat?: AIChatCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAiModuleRatingsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesUncheckedCreateNestedOneWithoutUserInput
    topics?: TopicUncheckedCreateNestedManyWithoutUserInput
    progress?: ProgressUncheckedCreateNestedManyWithoutUserInput
    badges?: BadgeUncheckedCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewUncheckedCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathUncheckedCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionUncheckedCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceUncheckedCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenUncheckedCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeUncheckedCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingUncheckedCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreUncheckedCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutUserInput
    aiModules?: AIModuleUncheckedCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    AIChat?: AIChatUncheckedCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAiModuleRatingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAiModuleRatingsInput, UserUncheckedCreateWithoutAiModuleRatingsInput>
  }

  export type AIModuleCreateWithoutRatingsInput = {
    id?: string
    title: string
    description?: string | null
    content: JsonNullValueInput | InputJsonValue
    tags?: AIModuleCreatetagsInput | string[]
    difficulty?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutAiModulesInput
    topic?: TopicCreateNestedOneWithoutAiModulesInput
    learningPathItems?: AIModuleLearningPathItemCreateNestedManyWithoutAiModuleInput
    quizAttempts?: AIModuleQuizAttemptCreateNestedManyWithoutAiModuleInput
    PracticeAttempts?: PracticeAttemptCreateNestedManyWithoutAiModuleInput
  }

  export type AIModuleUncheckedCreateWithoutRatingsInput = {
    id?: string
    title: string
    description?: string | null
    content: JsonNullValueInput | InputJsonValue
    tags?: AIModuleCreatetagsInput | string[]
    difficulty?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    topicId?: string | null
    learningPathItems?: AIModuleLearningPathItemUncheckedCreateNestedManyWithoutAiModuleInput
    quizAttempts?: AIModuleQuizAttemptUncheckedCreateNestedManyWithoutAiModuleInput
    PracticeAttempts?: PracticeAttemptUncheckedCreateNestedManyWithoutAiModuleInput
  }

  export type AIModuleCreateOrConnectWithoutRatingsInput = {
    where: AIModuleWhereUniqueInput
    create: XOR<AIModuleCreateWithoutRatingsInput, AIModuleUncheckedCreateWithoutRatingsInput>
  }

  export type TopicCreateWithoutAiModuleRatingsInput = {
    id?: string
    title: string
    description?: string | null
    user: UserCreateNestedOneWithoutTopicsInput
    progress?: ProgressCreateNestedManyWithoutTopicInput
    learningPathItems?: LearningPathItemCreateNestedManyWithoutTopicInput
    contentItems?: ContentItemCreateNestedManyWithoutTopicInput
    analyticsEntries?: AnalyticsEntryCreateNestedManyWithoutTopicInput
    comments?: CommentCreateNestedManyWithoutTopicInput
    prerequisites?: PrerequisiteCreateNestedManyWithoutTopicInput
    aiModules?: AIModuleCreateNestedManyWithoutTopicInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptCreateNestedManyWithoutTopicInput
  }

  export type TopicUncheckedCreateWithoutAiModuleRatingsInput = {
    id?: string
    title: string
    description?: string | null
    userId: string
    progress?: ProgressUncheckedCreateNestedManyWithoutTopicInput
    learningPathItems?: LearningPathItemUncheckedCreateNestedManyWithoutTopicInput
    contentItems?: ContentItemUncheckedCreateNestedManyWithoutTopicInput
    analyticsEntries?: AnalyticsEntryUncheckedCreateNestedManyWithoutTopicInput
    comments?: CommentUncheckedCreateNestedManyWithoutTopicInput
    prerequisites?: PrerequisiteUncheckedCreateNestedManyWithoutTopicInput
    aiModules?: AIModuleUncheckedCreateNestedManyWithoutTopicInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedCreateNestedManyWithoutTopicInput
  }

  export type TopicCreateOrConnectWithoutAiModuleRatingsInput = {
    where: TopicWhereUniqueInput
    create: XOR<TopicCreateWithoutAiModuleRatingsInput, TopicUncheckedCreateWithoutAiModuleRatingsInput>
  }

  export type UserUpsertWithoutAiModuleRatingsInput = {
    update: XOR<UserUpdateWithoutAiModuleRatingsInput, UserUncheckedUpdateWithoutAiModuleRatingsInput>
    create: XOR<UserCreateWithoutAiModuleRatingsInput, UserUncheckedCreateWithoutAiModuleRatingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAiModuleRatingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAiModuleRatingsInput, UserUncheckedUpdateWithoutAiModuleRatingsInput>
  }

  export type UserUpdateWithoutAiModuleRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUpdateOneWithoutUserNestedInput
    topics?: TopicUpdateManyWithoutUserNestedInput
    progress?: ProgressUpdateManyWithoutUserNestedInput
    badges?: BadgeUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAiModuleRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUncheckedUpdateOneWithoutUserNestedInput
    topics?: TopicUncheckedUpdateManyWithoutUserNestedInput
    progress?: ProgressUncheckedUpdateManyWithoutUserNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUncheckedUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUncheckedUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUncheckedUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUncheckedUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUncheckedUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUncheckedUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUncheckedUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUncheckedUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUncheckedUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUncheckedUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AIModuleUpsertWithoutRatingsInput = {
    update: XOR<AIModuleUpdateWithoutRatingsInput, AIModuleUncheckedUpdateWithoutRatingsInput>
    create: XOR<AIModuleCreateWithoutRatingsInput, AIModuleUncheckedCreateWithoutRatingsInput>
    where?: AIModuleWhereInput
  }

  export type AIModuleUpdateToOneWithWhereWithoutRatingsInput = {
    where?: AIModuleWhereInput
    data: XOR<AIModuleUpdateWithoutRatingsInput, AIModuleUncheckedUpdateWithoutRatingsInput>
  }

  export type AIModuleUpdateWithoutRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    tags?: AIModuleUpdatetagsInput | string[]
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAiModulesNestedInput
    topic?: TopicUpdateOneWithoutAiModulesNestedInput
    learningPathItems?: AIModuleLearningPathItemUpdateManyWithoutAiModuleNestedInput
    quizAttempts?: AIModuleQuizAttemptUpdateManyWithoutAiModuleNestedInput
    PracticeAttempts?: PracticeAttemptUpdateManyWithoutAiModuleNestedInput
  }

  export type AIModuleUncheckedUpdateWithoutRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    tags?: AIModuleUpdatetagsInput | string[]
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    learningPathItems?: AIModuleLearningPathItemUncheckedUpdateManyWithoutAiModuleNestedInput
    quizAttempts?: AIModuleQuizAttemptUncheckedUpdateManyWithoutAiModuleNestedInput
    PracticeAttempts?: PracticeAttemptUncheckedUpdateManyWithoutAiModuleNestedInput
  }

  export type TopicUpsertWithoutAiModuleRatingsInput = {
    update: XOR<TopicUpdateWithoutAiModuleRatingsInput, TopicUncheckedUpdateWithoutAiModuleRatingsInput>
    create: XOR<TopicCreateWithoutAiModuleRatingsInput, TopicUncheckedCreateWithoutAiModuleRatingsInput>
    where?: TopicWhereInput
  }

  export type TopicUpdateToOneWithWhereWithoutAiModuleRatingsInput = {
    where?: TopicWhereInput
    data: XOR<TopicUpdateWithoutAiModuleRatingsInput, TopicUncheckedUpdateWithoutAiModuleRatingsInput>
  }

  export type TopicUpdateWithoutAiModuleRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutTopicsNestedInput
    progress?: ProgressUpdateManyWithoutTopicNestedInput
    learningPathItems?: LearningPathItemUpdateManyWithoutTopicNestedInput
    contentItems?: ContentItemUpdateManyWithoutTopicNestedInput
    analyticsEntries?: AnalyticsEntryUpdateManyWithoutTopicNestedInput
    comments?: CommentUpdateManyWithoutTopicNestedInput
    prerequisites?: PrerequisiteUpdateManyWithoutTopicNestedInput
    aiModules?: AIModuleUpdateManyWithoutTopicNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUpdateManyWithoutTopicNestedInput
  }

  export type TopicUncheckedUpdateWithoutAiModuleRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    progress?: ProgressUncheckedUpdateManyWithoutTopicNestedInput
    learningPathItems?: LearningPathItemUncheckedUpdateManyWithoutTopicNestedInput
    contentItems?: ContentItemUncheckedUpdateManyWithoutTopicNestedInput
    analyticsEntries?: AnalyticsEntryUncheckedUpdateManyWithoutTopicNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTopicNestedInput
    prerequisites?: PrerequisiteUncheckedUpdateManyWithoutTopicNestedInput
    aiModules?: AIModuleUncheckedUpdateManyWithoutTopicNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedUpdateManyWithoutTopicNestedInput
  }

  export type UserCreateWithoutUserProgressInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesCreateNestedOneWithoutUserInput
    topics?: TopicCreateNestedManyWithoutUserInput
    progress?: ProgressCreateNestedManyWithoutUserInput
    badges?: BadgeCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutUserInput
    aiModules?: AIModuleCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingCreateNestedManyWithoutUserInput
    AIChat?: AIChatCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserProgressInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesUncheckedCreateNestedOneWithoutUserInput
    topics?: TopicUncheckedCreateNestedManyWithoutUserInput
    progress?: ProgressUncheckedCreateNestedManyWithoutUserInput
    badges?: BadgeUncheckedCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewUncheckedCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathUncheckedCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionUncheckedCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceUncheckedCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenUncheckedCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeUncheckedCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingUncheckedCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreUncheckedCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutUserInput
    aiModules?: AIModuleUncheckedCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingUncheckedCreateNestedManyWithoutUserInput
    AIChat?: AIChatUncheckedCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserProgressInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserProgressInput, UserUncheckedCreateWithoutUserProgressInput>
  }

  export type LearningPathCreateWithoutUserProgressInput = {
    id?: string
    title: string
    description?: string | null
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    shareId?: string | null
    sharedAt?: Date | string | null
    user: UserCreateNestedOneWithoutLearningPathsInput
    items?: LearningPathItemCreateNestedManyWithoutLearningPathInput
    prerequisites?: PrerequisiteCreateNestedManyWithoutLearningPathInput
    aiModuleItems?: AIModuleLearningPathItemCreateNestedManyWithoutLearningPathInput
  }

  export type LearningPathUncheckedCreateWithoutUserProgressInput = {
    id?: string
    title: string
    description?: string | null
    userId: string
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    shareId?: string | null
    sharedAt?: Date | string | null
    items?: LearningPathItemUncheckedCreateNestedManyWithoutLearningPathInput
    prerequisites?: PrerequisiteUncheckedCreateNestedManyWithoutLearningPathInput
    aiModuleItems?: AIModuleLearningPathItemUncheckedCreateNestedManyWithoutLearningPathInput
  }

  export type LearningPathCreateOrConnectWithoutUserProgressInput = {
    where: LearningPathWhereUniqueInput
    create: XOR<LearningPathCreateWithoutUserProgressInput, LearningPathUncheckedCreateWithoutUserProgressInput>
  }

  export type LearningPathItemCreateWithoutUserProgressInput = {
    id?: string
    order: number
    confidence?: number
    learningPath: LearningPathCreateNestedOneWithoutItemsInput
    topic: TopicCreateNestedOneWithoutLearningPathItemsInput
  }

  export type LearningPathItemUncheckedCreateWithoutUserProgressInput = {
    id?: string
    order: number
    learningPathId: string
    topicId: string
    confidence?: number
  }

  export type LearningPathItemCreateOrConnectWithoutUserProgressInput = {
    where: LearningPathItemWhereUniqueInput
    create: XOR<LearningPathItemCreateWithoutUserProgressInput, LearningPathItemUncheckedCreateWithoutUserProgressInput>
  }

  export type UserUpsertWithoutUserProgressInput = {
    update: XOR<UserUpdateWithoutUserProgressInput, UserUncheckedUpdateWithoutUserProgressInput>
    create: XOR<UserCreateWithoutUserProgressInput, UserUncheckedCreateWithoutUserProgressInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserProgressInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserProgressInput, UserUncheckedUpdateWithoutUserProgressInput>
  }

  export type UserUpdateWithoutUserProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUpdateOneWithoutUserNestedInput
    topics?: TopicUpdateManyWithoutUserNestedInput
    progress?: ProgressUpdateManyWithoutUserNestedInput
    badges?: BadgeUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUncheckedUpdateOneWithoutUserNestedInput
    topics?: TopicUncheckedUpdateManyWithoutUserNestedInput
    progress?: ProgressUncheckedUpdateManyWithoutUserNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUncheckedUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUncheckedUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUncheckedUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUncheckedUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUncheckedUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUncheckedUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUncheckedUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUncheckedUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUncheckedUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUncheckedUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUncheckedUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUncheckedUpdateManyWithoutUserNestedInput
  }

  export type LearningPathUpsertWithoutUserProgressInput = {
    update: XOR<LearningPathUpdateWithoutUserProgressInput, LearningPathUncheckedUpdateWithoutUserProgressInput>
    create: XOR<LearningPathCreateWithoutUserProgressInput, LearningPathUncheckedCreateWithoutUserProgressInput>
    where?: LearningPathWhereInput
  }

  export type LearningPathUpdateToOneWithWhereWithoutUserProgressInput = {
    where?: LearningPathWhereInput
    data: XOR<LearningPathUpdateWithoutUserProgressInput, LearningPathUncheckedUpdateWithoutUserProgressInput>
  }

  export type LearningPathUpdateWithoutUserProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shareId?: NullableStringFieldUpdateOperationsInput | string | null
    sharedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutLearningPathsNestedInput
    items?: LearningPathItemUpdateManyWithoutLearningPathNestedInput
    prerequisites?: PrerequisiteUpdateManyWithoutLearningPathNestedInput
    aiModuleItems?: AIModuleLearningPathItemUpdateManyWithoutLearningPathNestedInput
  }

  export type LearningPathUncheckedUpdateWithoutUserProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shareId?: NullableStringFieldUpdateOperationsInput | string | null
    sharedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: LearningPathItemUncheckedUpdateManyWithoutLearningPathNestedInput
    prerequisites?: PrerequisiteUncheckedUpdateManyWithoutLearningPathNestedInput
    aiModuleItems?: AIModuleLearningPathItemUncheckedUpdateManyWithoutLearningPathNestedInput
  }

  export type LearningPathItemUpsertWithoutUserProgressInput = {
    update: XOR<LearningPathItemUpdateWithoutUserProgressInput, LearningPathItemUncheckedUpdateWithoutUserProgressInput>
    create: XOR<LearningPathItemCreateWithoutUserProgressInput, LearningPathItemUncheckedCreateWithoutUserProgressInput>
    where?: LearningPathItemWhereInput
  }

  export type LearningPathItemUpdateToOneWithWhereWithoutUserProgressInput = {
    where?: LearningPathItemWhereInput
    data: XOR<LearningPathItemUpdateWithoutUserProgressInput, LearningPathItemUncheckedUpdateWithoutUserProgressInput>
  }

  export type LearningPathItemUpdateWithoutUserProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    confidence?: IntFieldUpdateOperationsInput | number
    learningPath?: LearningPathUpdateOneRequiredWithoutItemsNestedInput
    topic?: TopicUpdateOneRequiredWithoutLearningPathItemsNestedInput
  }

  export type LearningPathItemUncheckedUpdateWithoutUserProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    learningPathId?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    confidence?: IntFieldUpdateOperationsInput | number
  }

  export type AIChatMessageCreateWithoutChatInput = {
    id?: string
    display?: string | null
    role: string
    content: string
    createdAt?: Date | string
  }

  export type AIChatMessageUncheckedCreateWithoutChatInput = {
    id?: string
    display?: string | null
    role: string
    content: string
    createdAt?: Date | string
  }

  export type AIChatMessageCreateOrConnectWithoutChatInput = {
    where: AIChatMessageWhereUniqueInput
    create: XOR<AIChatMessageCreateWithoutChatInput, AIChatMessageUncheckedCreateWithoutChatInput>
  }

  export type AIChatMessageCreateManyChatInputEnvelope = {
    data: AIChatMessageCreateManyChatInput | AIChatMessageCreateManyChatInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutAIChatInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesCreateNestedOneWithoutUserInput
    topics?: TopicCreateNestedManyWithoutUserInput
    progress?: ProgressCreateNestedManyWithoutUserInput
    badges?: BadgeCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutUserInput
    aiModules?: AIModuleCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAIChatInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesUncheckedCreateNestedOneWithoutUserInput
    topics?: TopicUncheckedCreateNestedManyWithoutUserInput
    progress?: ProgressUncheckedCreateNestedManyWithoutUserInput
    badges?: BadgeUncheckedCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewUncheckedCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathUncheckedCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionUncheckedCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceUncheckedCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenUncheckedCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeUncheckedCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingUncheckedCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreUncheckedCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutUserInput
    aiModules?: AIModuleUncheckedCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingUncheckedCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    PracticeAttempts?: PracticeAttemptUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAIChatInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAIChatInput, UserUncheckedCreateWithoutAIChatInput>
  }

  export type AIChatMessageUpsertWithWhereUniqueWithoutChatInput = {
    where: AIChatMessageWhereUniqueInput
    update: XOR<AIChatMessageUpdateWithoutChatInput, AIChatMessageUncheckedUpdateWithoutChatInput>
    create: XOR<AIChatMessageCreateWithoutChatInput, AIChatMessageUncheckedCreateWithoutChatInput>
  }

  export type AIChatMessageUpdateWithWhereUniqueWithoutChatInput = {
    where: AIChatMessageWhereUniqueInput
    data: XOR<AIChatMessageUpdateWithoutChatInput, AIChatMessageUncheckedUpdateWithoutChatInput>
  }

  export type AIChatMessageUpdateManyWithWhereWithoutChatInput = {
    where: AIChatMessageScalarWhereInput
    data: XOR<AIChatMessageUpdateManyMutationInput, AIChatMessageUncheckedUpdateManyWithoutChatInput>
  }

  export type AIChatMessageScalarWhereInput = {
    AND?: AIChatMessageScalarWhereInput | AIChatMessageScalarWhereInput[]
    OR?: AIChatMessageScalarWhereInput[]
    NOT?: AIChatMessageScalarWhereInput | AIChatMessageScalarWhereInput[]
    id?: StringFilter<"AIChatMessage"> | string
    chatId?: StringFilter<"AIChatMessage"> | string
    display?: StringNullableFilter<"AIChatMessage"> | string | null
    role?: StringFilter<"AIChatMessage"> | string
    content?: StringFilter<"AIChatMessage"> | string
    createdAt?: DateTimeFilter<"AIChatMessage"> | Date | string
  }

  export type UserUpsertWithoutAIChatInput = {
    update: XOR<UserUpdateWithoutAIChatInput, UserUncheckedUpdateWithoutAIChatInput>
    create: XOR<UserCreateWithoutAIChatInput, UserUncheckedCreateWithoutAIChatInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAIChatInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAIChatInput, UserUncheckedUpdateWithoutAIChatInput>
  }

  export type UserUpdateWithoutAIChatInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUpdateOneWithoutUserNestedInput
    topics?: TopicUpdateManyWithoutUserNestedInput
    progress?: ProgressUpdateManyWithoutUserNestedInput
    badges?: BadgeUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAIChatInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUncheckedUpdateOneWithoutUserNestedInput
    topics?: TopicUncheckedUpdateManyWithoutUserNestedInput
    progress?: ProgressUncheckedUpdateManyWithoutUserNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUncheckedUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUncheckedUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUncheckedUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUncheckedUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUncheckedUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUncheckedUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUncheckedUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUncheckedUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUncheckedUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUncheckedUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    PracticeAttempts?: PracticeAttemptUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AIChatCreateWithoutMessagesInput = {
    id?: string
    title?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutAIChatInput
  }

  export type AIChatUncheckedCreateWithoutMessagesInput = {
    id?: string
    title?: string | null
    createdAt?: Date | string
    userId: string
  }

  export type AIChatCreateOrConnectWithoutMessagesInput = {
    where: AIChatWhereUniqueInput
    create: XOR<AIChatCreateWithoutMessagesInput, AIChatUncheckedCreateWithoutMessagesInput>
  }

  export type AIChatUpsertWithoutMessagesInput = {
    update: XOR<AIChatUpdateWithoutMessagesInput, AIChatUncheckedUpdateWithoutMessagesInput>
    create: XOR<AIChatCreateWithoutMessagesInput, AIChatUncheckedCreateWithoutMessagesInput>
    where?: AIChatWhereInput
  }

  export type AIChatUpdateToOneWithWhereWithoutMessagesInput = {
    where?: AIChatWhereInput
    data: XOR<AIChatUpdateWithoutMessagesInput, AIChatUncheckedUpdateWithoutMessagesInput>
  }

  export type AIChatUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAIChatNestedInput
  }

  export type AIChatUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateWithoutPracticeAttemptsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesCreateNestedOneWithoutUserInput
    topics?: TopicCreateNestedManyWithoutUserInput
    progress?: ProgressCreateNestedManyWithoutUserInput
    badges?: BadgeCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutUserInput
    aiModules?: AIModuleCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressCreateNestedManyWithoutUserInput
    AIChat?: AIChatCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPracticeAttemptsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    bio?: string | null
    avatarUrl?: string | null
    password: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    xp?: number
    level?: number
    streak?: number
    lastStreakUpdate?: Date | string | null
    lastLoginDate?: Date | string
    isAdmin?: boolean
    role?: string | null
    interests?: UserCreateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: boolean
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    learningPreferences?: LearningPreferencesUncheckedCreateNestedOneWithoutUserInput
    topics?: TopicUncheckedCreateNestedManyWithoutUserInput
    progress?: ProgressUncheckedCreateNestedManyWithoutUserInput
    badges?: BadgeUncheckedCreateNestedManyWithoutUserInput
    upcomingReviews?: UpcomingReviewUncheckedCreateNestedManyWithoutUserInput
    learningPaths?: LearningPathUncheckedCreateNestedManyWithoutUserInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    knowledgeNodes?: KnowledgeNodeUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    reviewSessions?: ReviewSessionUncheckedCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceMemberUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutUserInput
    ownedWorkspaces?: WorkspaceUncheckedCreateNestedManyWithoutOwnerInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    analyticsEntries?: AnalyticsEntryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    passwordlessTokens?: PasswordlessTokenUncheckedCreateNestedManyWithoutUserInput
    dailyChallenges?: DailyChallengeUncheckedCreateNestedManyWithoutUserInput
    externalGoals?: ExternalGoalUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    contentRatings?: ContentRatingUncheckedCreateNestedManyWithoutUserInput
    challengeScores?: ChallengeScoreUncheckedCreateNestedManyWithoutUserInput
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutUserInput
    aiModules?: AIModuleUncheckedCreateNestedManyWithoutUserInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedCreateNestedManyWithoutUserInput
    aiModuleRatings?: AIModuleRatingUncheckedCreateNestedManyWithoutUserInput
    UserProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    AIChat?: AIChatUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPracticeAttemptsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPracticeAttemptsInput, UserUncheckedCreateWithoutPracticeAttemptsInput>
  }

  export type AIModuleCreateWithoutPracticeAttemptsInput = {
    id?: string
    title: string
    description?: string | null
    content: JsonNullValueInput | InputJsonValue
    tags?: AIModuleCreatetagsInput | string[]
    difficulty?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutAiModulesInput
    topic?: TopicCreateNestedOneWithoutAiModulesInput
    learningPathItems?: AIModuleLearningPathItemCreateNestedManyWithoutAiModuleInput
    quizAttempts?: AIModuleQuizAttemptCreateNestedManyWithoutAiModuleInput
    ratings?: AIModuleRatingCreateNestedManyWithoutAiModuleInput
  }

  export type AIModuleUncheckedCreateWithoutPracticeAttemptsInput = {
    id?: string
    title: string
    description?: string | null
    content: JsonNullValueInput | InputJsonValue
    tags?: AIModuleCreatetagsInput | string[]
    difficulty?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    topicId?: string | null
    learningPathItems?: AIModuleLearningPathItemUncheckedCreateNestedManyWithoutAiModuleInput
    quizAttempts?: AIModuleQuizAttemptUncheckedCreateNestedManyWithoutAiModuleInput
    ratings?: AIModuleRatingUncheckedCreateNestedManyWithoutAiModuleInput
  }

  export type AIModuleCreateOrConnectWithoutPracticeAttemptsInput = {
    where: AIModuleWhereUniqueInput
    create: XOR<AIModuleCreateWithoutPracticeAttemptsInput, AIModuleUncheckedCreateWithoutPracticeAttemptsInput>
  }

  export type UserUpsertWithoutPracticeAttemptsInput = {
    update: XOR<UserUpdateWithoutPracticeAttemptsInput, UserUncheckedUpdateWithoutPracticeAttemptsInput>
    create: XOR<UserCreateWithoutPracticeAttemptsInput, UserUncheckedCreateWithoutPracticeAttemptsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPracticeAttemptsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPracticeAttemptsInput, UserUncheckedUpdateWithoutPracticeAttemptsInput>
  }

  export type UserUpdateWithoutPracticeAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUpdateOneWithoutUserNestedInput
    topics?: TopicUpdateManyWithoutUserNestedInput
    progress?: ProgressUpdateManyWithoutUserNestedInput
    badges?: BadgeUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPracticeAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastStreakUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: UserUpdateinterestsInput | string[]
    learningStyle?: NullableJsonNullValueInput | InputJsonValue
    cramMode?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    learningPreferences?: LearningPreferencesUncheckedUpdateOneWithoutUserNestedInput
    topics?: TopicUncheckedUpdateManyWithoutUserNestedInput
    progress?: ProgressUncheckedUpdateManyWithoutUserNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    upcomingReviews?: UpcomingReviewUncheckedUpdateManyWithoutUserNestedInput
    learningPaths?: LearningPathUncheckedUpdateManyWithoutUserNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    knowledgeNodes?: KnowledgeNodeUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    reviewSessions?: ReviewSessionUncheckedUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceMemberUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutUserNestedInput
    ownedWorkspaces?: WorkspaceUncheckedUpdateManyWithoutOwnerNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    analyticsEntries?: AnalyticsEntryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    passwordlessTokens?: PasswordlessTokenUncheckedUpdateManyWithoutUserNestedInput
    dailyChallenges?: DailyChallengeUncheckedUpdateManyWithoutUserNestedInput
    externalGoals?: ExternalGoalUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    contentRatings?: ContentRatingUncheckedUpdateManyWithoutUserNestedInput
    challengeScores?: ChallengeScoreUncheckedUpdateManyWithoutUserNestedInput
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutUserNestedInput
    aiModules?: AIModuleUncheckedUpdateManyWithoutUserNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    aiModuleRatings?: AIModuleRatingUncheckedUpdateManyWithoutUserNestedInput
    UserProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    AIChat?: AIChatUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AIModuleUpsertWithoutPracticeAttemptsInput = {
    update: XOR<AIModuleUpdateWithoutPracticeAttemptsInput, AIModuleUncheckedUpdateWithoutPracticeAttemptsInput>
    create: XOR<AIModuleCreateWithoutPracticeAttemptsInput, AIModuleUncheckedCreateWithoutPracticeAttemptsInput>
    where?: AIModuleWhereInput
  }

  export type AIModuleUpdateToOneWithWhereWithoutPracticeAttemptsInput = {
    where?: AIModuleWhereInput
    data: XOR<AIModuleUpdateWithoutPracticeAttemptsInput, AIModuleUncheckedUpdateWithoutPracticeAttemptsInput>
  }

  export type AIModuleUpdateWithoutPracticeAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    tags?: AIModuleUpdatetagsInput | string[]
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAiModulesNestedInput
    topic?: TopicUpdateOneWithoutAiModulesNestedInput
    learningPathItems?: AIModuleLearningPathItemUpdateManyWithoutAiModuleNestedInput
    quizAttempts?: AIModuleQuizAttemptUpdateManyWithoutAiModuleNestedInput
    ratings?: AIModuleRatingUpdateManyWithoutAiModuleNestedInput
  }

  export type AIModuleUncheckedUpdateWithoutPracticeAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    tags?: AIModuleUpdatetagsInput | string[]
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    learningPathItems?: AIModuleLearningPathItemUncheckedUpdateManyWithoutAiModuleNestedInput
    quizAttempts?: AIModuleQuizAttemptUncheckedUpdateManyWithoutAiModuleNestedInput
    ratings?: AIModuleRatingUncheckedUpdateManyWithoutAiModuleNestedInput
  }

  export type AccountCreateManyUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    oauth_token_secret?: string | null
    oauth_token?: string | null
  }

  export type SessionCreateManyUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type ActivityCreateManyUserInput = {
    id?: string
    type: string
    description: string
    createdAt?: Date | string
  }

  export type TopicCreateManyUserInput = {
    id?: string
    title: string
    description?: string | null
  }

  export type ProgressCreateManyUserInput = {
    id?: string
    topicId: string
    completed: number
  }

  export type BadgeCreateManyUserInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    earnedAt?: Date | string
  }

  export type UpcomingReviewCreateManyUserInput = {
    id?: string
    topicId: string
    dueDate: Date | string
  }

  export type LearningPathCreateManyUserInput = {
    id?: string
    title: string
    description?: string | null
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    shareId?: string | null
    sharedAt?: Date | string | null
  }

  export type BookmarkCreateManyUserInput = {
    id?: string
    contentItemId: string
    createdAt?: Date | string
  }

  export type QuizAttemptCreateManyUserInput = {
    id?: string
    contentItemId: string
    score: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    answers?: NullableJsonNullValueInput | InputJsonValue
  }

  export type KnowledgeNodeCreateManyUserInput = {
    id?: string
    title: string
    description?: string | null
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaderboardEntryCreateManyUserInput = {
    id?: string
    score: number
    type: string
    startDate: Date | string
    endDate: Date | string
  }

  export type ReviewSessionCreateManyUserInput = {
    id?: string
    dueDate: Date | string
    completed?: boolean
    isUrgent?: boolean
  }

  export type WorkspaceMemberCreateManyUserInput = {
    id?: string
    workspaceId: string
    role: string
    joinedAt?: Date | string
  }

  export type ChatMessageCreateManyUserInput = {
    id?: string
    chatId: string
    content: string
    createdAt?: Date | string
  }

  export type WorkspaceCreateManyOwnerInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnalyticsEntryCreateManyUserInput = {
    id?: string
    topicId: string
    timeSpent: number
    score?: number | null
    date?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    type: string
    message: string
    read?: boolean
    createdAt?: Date | string
  }

  export type PasswordlessTokenCreateManyUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
  }

  export type DailyChallengeCreateManyUserInput = {
    id?: string
    title: string
    description: string
    reward: string
    completed?: boolean
    createdAt?: Date | string
    completedAt?: Date | string | null
  }

  export type ExternalGoalCreateManyUserInput = {
    id?: string
    platform: string
    title: string
    progress: number
    dueDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateManyUserInput = {
    id?: string
    content: string
    topicId: string
    createdAt?: Date | string
  }

  export type ContentRatingCreateManyUserInput = {
    id?: string
    contentItemId: string
    rating: number
    createdAt?: Date | string
  }

  export type ChallengeScoreCreateManyUserInput = {
    id?: string
    score: number
    createdAt?: Date | string
  }

  export type PollVoteCreateManyUserInput = {
    id?: string
    livePoolId: string
    option: string
    createdAt?: Date | string
  }

  export type AIRecommendationCreateManyUserInput = {
    id?: string
    content: string
    createdAt?: Date | string
  }

  export type AIModuleCreateManyUserInput = {
    id?: string
    title: string
    description?: string | null
    content: JsonNullValueInput | InputJsonValue
    tags?: AIModuleCreatetagsInput | string[]
    difficulty?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    topicId?: string | null
  }

  export type AIModuleQuizAttemptCreateManyUserInput = {
    id?: string
    aiModuleId: string
    topicId: string
    score: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    answers: JsonNullValueInput | InputJsonValue
  }

  export type AIModuleRatingCreateManyUserInput = {
    id?: string
    aiModuleId: string
    topicId: string
    rating: number
    feedback?: string | null
    createdAt?: Date | string
  }

  export type UserProgressCreateManyUserInput = {
    id?: string
    learningPathId: string
    moduleId: string
    status?: string
    updatedAt?: Date | string
  }

  export type AIChatCreateManyUserInput = {
    id?: string
    title?: string | null
    createdAt?: Date | string
  }

  export type PracticeAttemptCreateManyUserInput = {
    id?: string
    aiModuleId: string
    questions: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    score?: number | null
    averageEase?: number | null
    completedAt?: Date | string | null
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_token_secret?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_token?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_token_secret?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_token?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_token_secret?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_token?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TopicUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: ProgressUpdateManyWithoutTopicNestedInput
    learningPathItems?: LearningPathItemUpdateManyWithoutTopicNestedInput
    contentItems?: ContentItemUpdateManyWithoutTopicNestedInput
    analyticsEntries?: AnalyticsEntryUpdateManyWithoutTopicNestedInput
    comments?: CommentUpdateManyWithoutTopicNestedInput
    prerequisites?: PrerequisiteUpdateManyWithoutTopicNestedInput
    aiModules?: AIModuleUpdateManyWithoutTopicNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUpdateManyWithoutTopicNestedInput
    aiModuleRatings?: AIModuleRatingUpdateManyWithoutTopicNestedInput
  }

  export type TopicUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: ProgressUncheckedUpdateManyWithoutTopicNestedInput
    learningPathItems?: LearningPathItemUncheckedUpdateManyWithoutTopicNestedInput
    contentItems?: ContentItemUncheckedUpdateManyWithoutTopicNestedInput
    analyticsEntries?: AnalyticsEntryUncheckedUpdateManyWithoutTopicNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTopicNestedInput
    prerequisites?: PrerequisiteUncheckedUpdateManyWithoutTopicNestedInput
    aiModules?: AIModuleUncheckedUpdateManyWithoutTopicNestedInput
    aiModuleQuizAttempts?: AIModuleQuizAttemptUncheckedUpdateManyWithoutTopicNestedInput
    aiModuleRatings?: AIModuleRatingUncheckedUpdateManyWithoutTopicNestedInput
  }

  export type TopicUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProgressUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed?: FloatFieldUpdateOperationsInput | number
    topic?: TopicUpdateOneRequiredWithoutProgressNestedInput
  }

  export type ProgressUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    completed?: FloatFieldUpdateOperationsInput | number
  }

  export type ProgressUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    completed?: FloatFieldUpdateOperationsInput | number
  }

  export type BadgeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BadgeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BadgeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UpcomingReviewUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UpcomingReviewUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UpcomingReviewUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearningPathUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shareId?: NullableStringFieldUpdateOperationsInput | string | null
    sharedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: LearningPathItemUpdateManyWithoutLearningPathNestedInput
    prerequisites?: PrerequisiteUpdateManyWithoutLearningPathNestedInput
    aiModuleItems?: AIModuleLearningPathItemUpdateManyWithoutLearningPathNestedInput
    UserProgress?: UserProgressUpdateManyWithoutLearningPathNestedInput
  }

  export type LearningPathUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shareId?: NullableStringFieldUpdateOperationsInput | string | null
    sharedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: LearningPathItemUncheckedUpdateManyWithoutLearningPathNestedInput
    prerequisites?: PrerequisiteUncheckedUpdateManyWithoutLearningPathNestedInput
    aiModuleItems?: AIModuleLearningPathItemUncheckedUpdateManyWithoutLearningPathNestedInput
    UserProgress?: UserProgressUncheckedUpdateManyWithoutLearningPathNestedInput
  }

  export type LearningPathUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shareId?: NullableStringFieldUpdateOperationsInput | string | null
    sharedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BookmarkUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contentItem?: ContentItemUpdateOneRequiredWithoutBookmarksNestedInput
  }

  export type BookmarkUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentItemId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookmarkUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentItemId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizAttemptUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: NullableJsonNullValueInput | InputJsonValue
    contentItem?: ContentItemUpdateOneRequiredWithoutQuizAttemptsNestedInput
  }

  export type QuizAttemptUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentItemId?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: NullableJsonNullValueInput | InputJsonValue
  }

  export type QuizAttemptUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentItemId?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: NullableJsonNullValueInput | InputJsonValue
  }

  export type KnowledgeNodeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: KnowledgeNodeUpdateOneWithoutChildrenNestedInput
    children?: KnowledgeNodeUpdateManyWithoutParentNestedInput
  }

  export type KnowledgeNodeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: KnowledgeNodeUncheckedUpdateManyWithoutParentNestedInput
  }

  export type KnowledgeNodeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaderboardEntryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaderboardEntryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaderboardEntryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewSessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    isUrgent?: BoolFieldUpdateOperationsInput | boolean
    items?: ReviewItemUpdateManyWithoutReviewSessionNestedInput
  }

  export type ReviewSessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    isUrgent?: BoolFieldUpdateOperationsInput | boolean
    items?: ReviewItemUncheckedUpdateManyWithoutReviewSessionNestedInput
  }

  export type ReviewSessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    isUrgent?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WorkspaceMemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutMembersNestedInput
    breakoutRooms?: BreakoutRoomUpdateManyWithoutParticipantsNestedInput
  }

  export type WorkspaceMemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    breakoutRooms?: BreakoutRoomUncheckedUpdateManyWithoutParticipantsNestedInput
  }

  export type WorkspaceMemberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chat?: ChatUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type ChatMessageUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    chatId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    chatId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUpdateManyWithoutWorkspaceNestedInput
    whiteboards?: WhiteboardUpdateManyWithoutWorkspaceNestedInput
    chats?: ChatUpdateManyWithoutWorkspaceNestedInput
    breakoutRooms?: BreakoutRoomUpdateManyWithoutWorkspaceNestedInput
    livePolls?: LivePollUpdateManyWithoutWorkspaceNestedInput
    sessionSummaries?: SessionSummaryUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUncheckedUpdateManyWithoutWorkspaceNestedInput
    whiteboards?: WhiteboardUncheckedUpdateManyWithoutWorkspaceNestedInput
    chats?: ChatUncheckedUpdateManyWithoutWorkspaceNestedInput
    breakoutRooms?: BreakoutRoomUncheckedUpdateManyWithoutWorkspaceNestedInput
    livePolls?: LivePollUncheckedUpdateManyWithoutWorkspaceNestedInput
    sessionSummaries?: SessionSummaryUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsEntryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    timeSpent?: IntFieldUpdateOperationsInput | number
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    topic?: TopicUpdateOneRequiredWithoutAnalyticsEntriesNestedInput
  }

  export type AnalyticsEntryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    timeSpent?: IntFieldUpdateOperationsInput | number
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsEntryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    timeSpent?: IntFieldUpdateOperationsInput | number
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordlessTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordlessTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordlessTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyChallengeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    reward?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DailyChallengeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    reward?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DailyChallengeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    reward?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ExternalGoalUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExternalGoalUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExternalGoalUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topic?: TopicUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentRatingUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contentItem?: ContentItemUpdateOneRequiredWithoutRatingsNestedInput
  }

  export type ContentRatingUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentItemId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentRatingUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentItemId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeScoreUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeScoreUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeScoreUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PollVoteUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    option?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    livePoll?: LivePollUpdateOneRequiredWithoutVotesNestedInput
  }

  export type PollVoteUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    livePoolId?: StringFieldUpdateOperationsInput | string
    option?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PollVoteUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    livePoolId?: StringFieldUpdateOperationsInput | string
    option?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIRecommendationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIRecommendationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIRecommendationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIModuleUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    tags?: AIModuleUpdatetagsInput | string[]
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topic?: TopicUpdateOneWithoutAiModulesNestedInput
    learningPathItems?: AIModuleLearningPathItemUpdateManyWithoutAiModuleNestedInput
    quizAttempts?: AIModuleQuizAttemptUpdateManyWithoutAiModuleNestedInput
    ratings?: AIModuleRatingUpdateManyWithoutAiModuleNestedInput
    PracticeAttempts?: PracticeAttemptUpdateManyWithoutAiModuleNestedInput
  }

  export type AIModuleUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    tags?: AIModuleUpdatetagsInput | string[]
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    learningPathItems?: AIModuleLearningPathItemUncheckedUpdateManyWithoutAiModuleNestedInput
    quizAttempts?: AIModuleQuizAttemptUncheckedUpdateManyWithoutAiModuleNestedInput
    ratings?: AIModuleRatingUncheckedUpdateManyWithoutAiModuleNestedInput
    PracticeAttempts?: PracticeAttemptUncheckedUpdateManyWithoutAiModuleNestedInput
  }

  export type AIModuleUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    tags?: AIModuleUpdatetagsInput | string[]
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AIModuleQuizAttemptUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: JsonNullValueInput | InputJsonValue
    aiModule?: AIModuleUpdateOneRequiredWithoutQuizAttemptsNestedInput
    topic?: TopicUpdateOneRequiredWithoutAiModuleQuizAttemptsNestedInput
  }

  export type AIModuleQuizAttemptUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    aiModuleId?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: JsonNullValueInput | InputJsonValue
  }

  export type AIModuleQuizAttemptUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    aiModuleId?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: JsonNullValueInput | InputJsonValue
  }

  export type AIModuleRatingUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiModule?: AIModuleUpdateOneRequiredWithoutRatingsNestedInput
    topic?: TopicUpdateOneRequiredWithoutAiModuleRatingsNestedInput
  }

  export type AIModuleRatingUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    aiModuleId?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIModuleRatingUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    aiModuleId?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProgressUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    learningPath?: LearningPathUpdateOneRequiredWithoutUserProgressNestedInput
    module?: LearningPathItemUpdateOneRequiredWithoutUserProgressNestedInput
  }

  export type UserProgressUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    learningPathId?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProgressUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    learningPathId?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIChatUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: AIChatMessageUpdateManyWithoutChatNestedInput
  }

  export type AIChatUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: AIChatMessageUncheckedUpdateManyWithoutChatNestedInput
  }

  export type AIChatUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PracticeAttemptUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    questions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    averageEase?: NullableFloatFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiModule?: AIModuleUpdateOneRequiredWithoutPracticeAttemptsNestedInput
  }

  export type PracticeAttemptUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    aiModuleId?: StringFieldUpdateOperationsInput | string
    questions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    averageEase?: NullableFloatFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PracticeAttemptUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    aiModuleId?: StringFieldUpdateOperationsInput | string
    questions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    averageEase?: NullableFloatFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProgressCreateManyTopicInput = {
    id?: string
    userId: string
    completed: number
  }

  export type LearningPathItemCreateManyTopicInput = {
    id?: string
    order: number
    learningPathId: string
    confidence?: number
  }

  export type ContentItemCreateManyTopicInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    type: string
    difficulty: string
    createdAt?: Date | string
    updatedAt?: Date | string
    version?: string
  }

  export type AnalyticsEntryCreateManyTopicInput = {
    id?: string
    userId: string
    timeSpent: number
    score?: number | null
    date?: Date | string
  }

  export type CommentCreateManyTopicInput = {
    id?: string
    content: string
    userId: string
    createdAt?: Date | string
  }

  export type PrerequisiteCreateManyTopicInput = {
    id?: string
    learningPathId: string
    completed?: boolean
  }

  export type AIModuleCreateManyTopicInput = {
    id?: string
    title: string
    description?: string | null
    content: JsonNullValueInput | InputJsonValue
    tags?: AIModuleCreatetagsInput | string[]
    difficulty?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
  }

  export type AIModuleQuizAttemptCreateManyTopicInput = {
    id?: string
    userId: string
    aiModuleId: string
    score: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    answers: JsonNullValueInput | InputJsonValue
  }

  export type AIModuleRatingCreateManyTopicInput = {
    id?: string
    userId: string
    aiModuleId: string
    rating: number
    feedback?: string | null
    createdAt?: Date | string
  }

  export type ProgressUpdateWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed?: FloatFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutProgressNestedInput
  }

  export type ProgressUncheckedUpdateWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    completed?: FloatFieldUpdateOperationsInput | number
  }

  export type ProgressUncheckedUpdateManyWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    completed?: FloatFieldUpdateOperationsInput | number
  }

  export type LearningPathItemUpdateWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    confidence?: IntFieldUpdateOperationsInput | number
    learningPath?: LearningPathUpdateOneRequiredWithoutItemsNestedInput
    UserProgress?: UserProgressUpdateManyWithoutModuleNestedInput
  }

  export type LearningPathItemUncheckedUpdateWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    learningPathId?: StringFieldUpdateOperationsInput | string
    confidence?: IntFieldUpdateOperationsInput | number
    UserProgress?: UserProgressUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type LearningPathItemUncheckedUpdateManyWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    learningPathId?: StringFieldUpdateOperationsInput | string
    confidence?: IntFieldUpdateOperationsInput | number
  }

  export type ContentItemUpdateWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: StringFieldUpdateOperationsInput | string
    bookmarks?: BookmarkUpdateManyWithoutContentItemNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutContentItemNestedInput
    reviewItems?: ReviewItemUpdateManyWithoutContentItemNestedInput
    ratings?: ContentRatingUpdateManyWithoutContentItemNestedInput
    aiPlaylistItems?: AIPlaylistItemUpdateManyWithoutContentItemNestedInput
  }

  export type ContentItemUncheckedUpdateWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: StringFieldUpdateOperationsInput | string
    bookmarks?: BookmarkUncheckedUpdateManyWithoutContentItemNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutContentItemNestedInput
    reviewItems?: ReviewItemUncheckedUpdateManyWithoutContentItemNestedInput
    ratings?: ContentRatingUncheckedUpdateManyWithoutContentItemNestedInput
    aiPlaylistItems?: AIPlaylistItemUncheckedUpdateManyWithoutContentItemNestedInput
  }

  export type ContentItemUncheckedUpdateManyWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: StringFieldUpdateOperationsInput | string
  }

  export type AnalyticsEntryUpdateWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    timeSpent?: IntFieldUpdateOperationsInput | number
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAnalyticsEntriesNestedInput
  }

  export type AnalyticsEntryUncheckedUpdateWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    timeSpent?: IntFieldUpdateOperationsInput | number
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsEntryUncheckedUpdateManyWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    timeSpent?: IntFieldUpdateOperationsInput | number
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrerequisiteUpdateWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    learningPath?: LearningPathUpdateOneRequiredWithoutPrerequisitesNestedInput
  }

  export type PrerequisiteUncheckedUpdateWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    learningPathId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PrerequisiteUncheckedUpdateManyWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    learningPathId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AIModuleUpdateWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    tags?: AIModuleUpdatetagsInput | string[]
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAiModulesNestedInput
    learningPathItems?: AIModuleLearningPathItemUpdateManyWithoutAiModuleNestedInput
    quizAttempts?: AIModuleQuizAttemptUpdateManyWithoutAiModuleNestedInput
    ratings?: AIModuleRatingUpdateManyWithoutAiModuleNestedInput
    PracticeAttempts?: PracticeAttemptUpdateManyWithoutAiModuleNestedInput
  }

  export type AIModuleUncheckedUpdateWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    tags?: AIModuleUpdatetagsInput | string[]
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    learningPathItems?: AIModuleLearningPathItemUncheckedUpdateManyWithoutAiModuleNestedInput
    quizAttempts?: AIModuleQuizAttemptUncheckedUpdateManyWithoutAiModuleNestedInput
    ratings?: AIModuleRatingUncheckedUpdateManyWithoutAiModuleNestedInput
    PracticeAttempts?: PracticeAttemptUncheckedUpdateManyWithoutAiModuleNestedInput
  }

  export type AIModuleUncheckedUpdateManyWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    tags?: AIModuleUpdatetagsInput | string[]
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AIModuleQuizAttemptUpdateWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: JsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutAiModuleQuizAttemptsNestedInput
    aiModule?: AIModuleUpdateOneRequiredWithoutQuizAttemptsNestedInput
  }

  export type AIModuleQuizAttemptUncheckedUpdateWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    aiModuleId?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: JsonNullValueInput | InputJsonValue
  }

  export type AIModuleQuizAttemptUncheckedUpdateManyWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    aiModuleId?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: JsonNullValueInput | InputJsonValue
  }

  export type AIModuleRatingUpdateWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAiModuleRatingsNestedInput
    aiModule?: AIModuleUpdateOneRequiredWithoutRatingsNestedInput
  }

  export type AIModuleRatingUncheckedUpdateWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    aiModuleId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIModuleRatingUncheckedUpdateManyWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    aiModuleId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearningPathItemCreateManyLearningPathInput = {
    id?: string
    order: number
    topicId: string
    confidence?: number
  }

  export type PrerequisiteCreateManyLearningPathInput = {
    id?: string
    topicId: string
    completed?: boolean
  }

  export type AIModuleLearningPathItemCreateManyLearningPathInput = {
    id?: string
    order: number
    aiModuleId: string
    confidence?: number
  }

  export type UserProgressCreateManyLearningPathInput = {
    id?: string
    userId: string
    moduleId: string
    status?: string
    updatedAt?: Date | string
  }

  export type LearningPathItemUpdateWithoutLearningPathInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    confidence?: IntFieldUpdateOperationsInput | number
    topic?: TopicUpdateOneRequiredWithoutLearningPathItemsNestedInput
    UserProgress?: UserProgressUpdateManyWithoutModuleNestedInput
  }

  export type LearningPathItemUncheckedUpdateWithoutLearningPathInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    topicId?: StringFieldUpdateOperationsInput | string
    confidence?: IntFieldUpdateOperationsInput | number
    UserProgress?: UserProgressUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type LearningPathItemUncheckedUpdateManyWithoutLearningPathInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    topicId?: StringFieldUpdateOperationsInput | string
    confidence?: IntFieldUpdateOperationsInput | number
  }

  export type PrerequisiteUpdateWithoutLearningPathInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    topic?: TopicUpdateOneRequiredWithoutPrerequisitesNestedInput
  }

  export type PrerequisiteUncheckedUpdateWithoutLearningPathInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PrerequisiteUncheckedUpdateManyWithoutLearningPathInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AIModuleLearningPathItemUpdateWithoutLearningPathInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    confidence?: IntFieldUpdateOperationsInput | number
    aiModule?: AIModuleUpdateOneRequiredWithoutLearningPathItemsNestedInput
  }

  export type AIModuleLearningPathItemUncheckedUpdateWithoutLearningPathInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    aiModuleId?: StringFieldUpdateOperationsInput | string
    confidence?: IntFieldUpdateOperationsInput | number
  }

  export type AIModuleLearningPathItemUncheckedUpdateManyWithoutLearningPathInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    aiModuleId?: StringFieldUpdateOperationsInput | string
    confidence?: IntFieldUpdateOperationsInput | number
  }

  export type UserProgressUpdateWithoutLearningPathInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserProgressNestedInput
    module?: LearningPathItemUpdateOneRequiredWithoutUserProgressNestedInput
  }

  export type UserProgressUncheckedUpdateWithoutLearningPathInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProgressUncheckedUpdateManyWithoutLearningPathInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProgressCreateManyModuleInput = {
    id?: string
    userId: string
    learningPathId: string
    status?: string
    updatedAt?: Date | string
  }

  export type UserProgressUpdateWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserProgressNestedInput
    learningPath?: LearningPathUpdateOneRequiredWithoutUserProgressNestedInput
  }

  export type UserProgressUncheckedUpdateWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    learningPathId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProgressUncheckedUpdateManyWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    learningPathId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookmarkCreateManyContentItemInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type QuizAttemptCreateManyContentItemInput = {
    id?: string
    userId: string
    score: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    answers?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ReviewItemCreateManyContentItemInput = {
    id?: string
    reviewSessionId: string
    type: string
    question: string
    answer: string
    userAnswer?: string | null
    isCorrect?: boolean | null
    answeredAt?: Date | string | null
  }

  export type ContentRatingCreateManyContentItemInput = {
    id?: string
    userId: string
    rating: number
    createdAt?: Date | string
  }

  export type AIPlaylistItemCreateManyContentItemInput = {
    id?: string
    playlistId: string
    order: number
  }

  export type BookmarkUpdateWithoutContentItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBookmarksNestedInput
  }

  export type BookmarkUncheckedUpdateWithoutContentItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookmarkUncheckedUpdateManyWithoutContentItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizAttemptUpdateWithoutContentItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutQuizAttemptsNestedInput
  }

  export type QuizAttemptUncheckedUpdateWithoutContentItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: NullableJsonNullValueInput | InputJsonValue
  }

  export type QuizAttemptUncheckedUpdateManyWithoutContentItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ReviewItemUpdateWithoutContentItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    userAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    isCorrect?: NullableBoolFieldUpdateOperationsInput | boolean | null
    answeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewSession?: ReviewSessionUpdateOneRequiredWithoutItemsNestedInput
  }

  export type ReviewItemUncheckedUpdateWithoutContentItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewSessionId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    userAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    isCorrect?: NullableBoolFieldUpdateOperationsInput | boolean | null
    answeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReviewItemUncheckedUpdateManyWithoutContentItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewSessionId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    userAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    isCorrect?: NullableBoolFieldUpdateOperationsInput | boolean | null
    answeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContentRatingUpdateWithoutContentItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutContentRatingsNestedInput
  }

  export type ContentRatingUncheckedUpdateWithoutContentItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentRatingUncheckedUpdateManyWithoutContentItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIPlaylistItemUpdateWithoutContentItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    playlist?: AIPlaylistUpdateOneRequiredWithoutItemsNestedInput
  }

  export type AIPlaylistItemUncheckedUpdateWithoutContentItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    playlistId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type AIPlaylistItemUncheckedUpdateManyWithoutContentItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    playlistId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type KnowledgeNodeCreateManyParentInput = {
    id?: string
    title: string
    description?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KnowledgeNodeUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutKnowledgeNodesNestedInput
    children?: KnowledgeNodeUpdateManyWithoutParentNestedInput
  }

  export type KnowledgeNodeUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: KnowledgeNodeUncheckedUpdateManyWithoutParentNestedInput
  }

  export type KnowledgeNodeUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewItemCreateManyReviewSessionInput = {
    id?: string
    contentItemId: string
    type: string
    question: string
    answer: string
    userAnswer?: string | null
    isCorrect?: boolean | null
    answeredAt?: Date | string | null
  }

  export type ReviewItemUpdateWithoutReviewSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    userAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    isCorrect?: NullableBoolFieldUpdateOperationsInput | boolean | null
    answeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contentItem?: ContentItemUpdateOneRequiredWithoutReviewItemsNestedInput
  }

  export type ReviewItemUncheckedUpdateWithoutReviewSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentItemId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    userAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    isCorrect?: NullableBoolFieldUpdateOperationsInput | boolean | null
    answeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReviewItemUncheckedUpdateManyWithoutReviewSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentItemId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    userAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    isCorrect?: NullableBoolFieldUpdateOperationsInput | boolean | null
    answeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkspaceMemberCreateManyWorkspaceInput = {
    id?: string
    userId: string
    role: string
    joinedAt?: Date | string
  }

  export type WhiteboardCreateManyWorkspaceInput = {
    id?: string
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatCreateManyWorkspaceInput = {
    id?: string
  }

  export type BreakoutRoomCreateManyWorkspaceInput = {
    id?: string
    name: string
    createdAt?: Date | string
    endedAt?: Date | string | null
  }

  export type LivePollCreateManyWorkspaceInput = {
    id?: string
    question: string
    options: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    endedAt?: Date | string | null
  }

  export type SessionSummaryCreateManyWorkspaceInput = {
    id?: string
    content: string
    createdAt?: Date | string
    createdBy: string
  }

  export type WorkspaceMemberUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWorkspacesNestedInput
    breakoutRooms?: BreakoutRoomUpdateManyWithoutParticipantsNestedInput
  }

  export type WorkspaceMemberUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    breakoutRooms?: BreakoutRoomUncheckedUpdateManyWithoutParticipantsNestedInput
  }

  export type WorkspaceMemberUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhiteboardUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: WhiteboardVersionUpdateManyWithoutWhiteboardNestedInput
  }

  export type WhiteboardUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: WhiteboardVersionUncheckedUpdateManyWithoutWhiteboardNestedInput
  }

  export type WhiteboardUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    messages?: ChatMessageUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    messages?: ChatMessageUncheckedUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type BreakoutRoomUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    participants?: WorkspaceMemberUpdateManyWithoutBreakoutRoomsNestedInput
  }

  export type BreakoutRoomUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    participants?: WorkspaceMemberUncheckedUpdateManyWithoutBreakoutRoomsNestedInput
  }

  export type BreakoutRoomUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LivePollUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    votes?: PollVoteUpdateManyWithoutLivePollNestedInput
  }

  export type LivePollUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    votes?: PollVoteUncheckedUpdateManyWithoutLivePollNestedInput
  }

  export type LivePollUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SessionSummaryUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type SessionSummaryUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type SessionSummaryUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type BreakoutRoomUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workspace?: WorkspaceUpdateOneRequiredWithoutBreakoutRoomsNestedInput
  }

  export type BreakoutRoomUncheckedUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BreakoutRoomUncheckedUpdateManyWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WhiteboardVersionCreateManyWhiteboardInput = {
    id?: string
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy: string
    versionNumber: number
  }

  export type WhiteboardVersionUpdateWithoutWhiteboardInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
  }

  export type WhiteboardVersionUncheckedUpdateWithoutWhiteboardInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
  }

  export type WhiteboardVersionUncheckedUpdateManyWithoutWhiteboardInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
  }

  export type WorkspaceMemberUpdateWithoutBreakoutRoomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWorkspacesNestedInput
    workspace?: WorkspaceUpdateOneRequiredWithoutMembersNestedInput
  }

  export type WorkspaceMemberUncheckedUpdateWithoutBreakoutRoomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceMemberUncheckedUpdateManyWithoutBreakoutRoomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PollVoteCreateManyLivePollInput = {
    id?: string
    userId: string
    option: string
    createdAt?: Date | string
  }

  export type PollVoteUpdateWithoutLivePollInput = {
    id?: StringFieldUpdateOperationsInput | string
    option?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPollVotesNestedInput
  }

  export type PollVoteUncheckedUpdateWithoutLivePollInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    option?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PollVoteUncheckedUpdateManyWithoutLivePollInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    option?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageCreateManyChatInput = {
    id?: string
    userId: string
    content: string
    createdAt?: Date | string
  }

  export type ChatMessageUpdateWithoutChatInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutChatMessagesNestedInput
  }

  export type ChatMessageUncheckedUpdateWithoutChatInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUncheckedUpdateManyWithoutChatInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIPlaylistItemCreateManyPlaylistInput = {
    id?: string
    contentItemId: string
    order: number
  }

  export type AIPlaylistItemUpdateWithoutPlaylistInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    contentItem?: ContentItemUpdateOneRequiredWithoutAiPlaylistItemsNestedInput
  }

  export type AIPlaylistItemUncheckedUpdateWithoutPlaylistInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentItemId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type AIPlaylistItemUncheckedUpdateManyWithoutPlaylistInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentItemId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type AIModuleLearningPathItemCreateManyAiModuleInput = {
    id?: string
    order: number
    learningPathId: string
    confidence?: number
  }

  export type AIModuleQuizAttemptCreateManyAiModuleInput = {
    id?: string
    userId: string
    topicId: string
    score: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    answers: JsonNullValueInput | InputJsonValue
  }

  export type AIModuleRatingCreateManyAiModuleInput = {
    id?: string
    userId: string
    topicId: string
    rating: number
    feedback?: string | null
    createdAt?: Date | string
  }

  export type PracticeAttemptCreateManyAiModuleInput = {
    id?: string
    userId: string
    questions: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    score?: number | null
    averageEase?: number | null
    completedAt?: Date | string | null
  }

  export type AIModuleLearningPathItemUpdateWithoutAiModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    confidence?: IntFieldUpdateOperationsInput | number
    learningPath?: LearningPathUpdateOneRequiredWithoutAiModuleItemsNestedInput
  }

  export type AIModuleLearningPathItemUncheckedUpdateWithoutAiModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    learningPathId?: StringFieldUpdateOperationsInput | string
    confidence?: IntFieldUpdateOperationsInput | number
  }

  export type AIModuleLearningPathItemUncheckedUpdateManyWithoutAiModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    learningPathId?: StringFieldUpdateOperationsInput | string
    confidence?: IntFieldUpdateOperationsInput | number
  }

  export type AIModuleQuizAttemptUpdateWithoutAiModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: JsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutAiModuleQuizAttemptsNestedInput
    topic?: TopicUpdateOneRequiredWithoutAiModuleQuizAttemptsNestedInput
  }

  export type AIModuleQuizAttemptUncheckedUpdateWithoutAiModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: JsonNullValueInput | InputJsonValue
  }

  export type AIModuleQuizAttemptUncheckedUpdateManyWithoutAiModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: JsonNullValueInput | InputJsonValue
  }

  export type AIModuleRatingUpdateWithoutAiModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAiModuleRatingsNestedInput
    topic?: TopicUpdateOneRequiredWithoutAiModuleRatingsNestedInput
  }

  export type AIModuleRatingUncheckedUpdateWithoutAiModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIModuleRatingUncheckedUpdateManyWithoutAiModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PracticeAttemptUpdateWithoutAiModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    questions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    averageEase?: NullableFloatFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutPracticeAttemptsNestedInput
  }

  export type PracticeAttemptUncheckedUpdateWithoutAiModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    questions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    averageEase?: NullableFloatFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PracticeAttemptUncheckedUpdateManyWithoutAiModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    questions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    averageEase?: NullableFloatFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AIChatMessageCreateManyChatInput = {
    id?: string
    display?: string | null
    role: string
    content: string
    createdAt?: Date | string
  }

  export type AIChatMessageUpdateWithoutChatInput = {
    id?: StringFieldUpdateOperationsInput | string
    display?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIChatMessageUncheckedUpdateWithoutChatInput = {
    id?: StringFieldUpdateOperationsInput | string
    display?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIChatMessageUncheckedUpdateManyWithoutChatInput = {
    id?: StringFieldUpdateOperationsInput | string
    display?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}